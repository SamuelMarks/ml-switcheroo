{
  "ABC": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ABI_INCOMPATIBILITY_WARNING": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "AGENT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ALLREDUCE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ALL_SUFFIX": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "AOTINDUCTOR_DIR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "API_BLAS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "API_C10": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "API_CAFFE2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "API_DRIVER": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "API_FFT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "API_LAST": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "API_PYTORCH": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "API_RAND": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "API_ROCMSMI": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "API_ROCTX": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "API_RTC": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "API_RUNTIME": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "API_SPECIAL": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ARCHIVE_FORMAT_PATH": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ARCHIVE_FORMAT_VALUE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ARCHIVE_ROOT_NAME": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ARCHIVE_VERSION_PATH": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ARCHIVE_VERSION_VALUE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ASGD": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "params",
      "lr",
      "lambd",
      "alpha",
      "t0",
      "weight_decay",
      "foreach",
      "maximize",
      "differentiable",
      "capturable"
    ],
    "type": "class"
  },
  "AST_Rewriter": {
    "description": "Take a FunctionType object representing a `forward` method, then",
    "std_args": [],
    "type": "class"
  },
  "ASYMMETRIC": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ASYNC": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ASYNC_JIT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "AUTO": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "AUTOGRAD_FUNCTION_COUNTER": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "AbsTransform": {
    "description": "Transform via the mapping :math:`y = |x|`.",
    "std_args": [
      "self",
      "cache_size"
    ],
    "type": "class"
  },
  "AcceleratorError": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ActionHook": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Adadelta": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "eps",
      "lr",
      "rho",
      "weight_decay"
    ],
    "type": "function"
  },
  "Adagrad": {
    "description": "Auto-discovered via Consensus (Score: 4.0)",
    "std_args": [
      "eps",
      "initial_accumulator_value",
      "lr"
    ],
    "type": "function"
  },
  "Adam": {
    "description": "Adaptive Moment Estimation.",
    "std_args": [
      "params",
      "lr",
      "beta1",
      "beta2",
      "eps",
      "weight_decay",
      "amsgrad"
    ],
    "variants": {}
  },
  "Adamax": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "eps",
      "lr",
      "weight_decay"
    ],
    "type": "function"
  },
  "AdaptiveAvgPool1d": {
    "description": "Applies a 1D adaptive average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "output_size"
    ],
    "type": "class"
  },
  "AdaptiveAvgPool2d": {
    "description": "Applies a 2D adaptive average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "output_size"
    ],
    "type": "class"
  },
  "AdaptiveAvgPool3d": {
    "description": "Applies a 3D adaptive average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "output_size"
    ],
    "type": "class"
  },
  "AdaptiveLogSoftmaxWithLoss": {
    "description": "Efficient softmax approximation.",
    "std_args": [
      "self",
      "in_features",
      "n_classes",
      "cutoffs",
      "div_value",
      "head_bias",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "AdaptiveMaxPool1d": {
    "description": "Applies a 1D adaptive max pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "output_size",
      "return_indices"
    ],
    "type": "class"
  },
  "AdaptiveMaxPool2d": {
    "description": "Applies a 2D adaptive max pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "output_size",
      "return_indices"
    ],
    "type": "class"
  },
  "AdaptiveMaxPool3d": {
    "description": "Applies a 3D adaptive max pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "output_size",
      "return_indices"
    ],
    "type": "class"
  },
  "AdditionalInputs": {
    "description": "Infers dynamic_shapes based on additional inputs.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "AffineQuantizedObserverBase": {
    "description": "Observer module for affine quantization (https://github.com/pytorch/ao/tree/main/torchao/quantization#affine-quantization)",
    "std_args": [
      "self",
      "mapping_type",
      "target_dtype",
      "granularity",
      "quant_min",
      "quant_max",
      "eps",
      "scale_dtype",
      "zero_point_dtype",
      "preserve_zero",
      "zero_point_domain",
      "kwargs"
    ],
    "type": "class"
  },
  "AffineTransform": {
    "description": "Transform via the pointwise affine mapping :math:`y = \\text{loc} + \\text{scale} \\times x`.",
    "std_args": [
      "self",
      "loc",
      "scale",
      "event_dim",
      "cache_size"
    ],
    "type": "class"
  },
  "AffinityMode": {
    "description": "See behavior description for each affinity mode",
    "std_args": [],
    "type": "class"
  },
  "AllGatherStates": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "Alphadropout": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "class"
  },
  "AmbiguityWarning": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "AnnotateTypesWithSchema": {
    "description": "Use Python function signatures to annotate types for `Nodes` within an FX graph.",
    "std_args": [
      "self",
      "module",
      "annotate_functionals",
      "annotate_modules",
      "annotate_get_attrs"
    ],
    "type": "class"
  },
  "AnnotatorType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ApplyBroadcasting": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "res1",
      "res2",
      "input1",
      "input2"
    ],
    "type": "class"
  },
  "ArgMax": {
    "description": "Returns the indices of the maximum value of all elements in the input tensor.",
    "std_args": [
      "input",
      "dim",
      "keepdim"
    ],
    "variants": {}
  },
  "ArgMin": {
    "description": "Returns the indices of the minimum value of all elements in the input tensor.",
    "std_args": [
      "input",
      "dim",
      "keepdim"
    ],
    "variants": {}
  },
  "Args": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ArgsKwargsPair": {
    "description": "Simple named tuple for wrapping args/kwargs pairs.",
    "std_args": [],
    "type": "class"
  },
  "Argument": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ArgumentSpec": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ArgumentT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "AsyncCheckpointerType": {
    "description": "Enum for async checkpointer type.",
    "std_args": [],
    "type": "class"
  },
  "AsyncSaveResponse": {
    "description": "This class contains futures for staging and upload completion.",
    "std_args": [
      "self",
      "staging_completion",
      "upload_completion"
    ],
    "type": "class"
  },
  "AsyncStager": {
    "description": "This protocol is meant to provide customization and extensibility for dcp.async_save, allowing users",
    "std_args": [],
    "type": "class"
  },
  "Attribute": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "root",
      "attr"
    ],
    "type": "class"
  },
  "AuxOutput": {
    "description": "Auxiliary outputs from flex_attention operation.",
    "std_args": [],
    "type": "class"
  },
  "AuxRequest": {
    "description": "Request which auxiliary outputs to compute from flex_attention.",
    "std_args": [],
    "type": "class"
  },
  "AvgPool1d": {
    "description": "Applies a 1D average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "kernel_size",
      "stride",
      "padding",
      "ceil_mode",
      "count_include_pad"
    ],
    "type": "class"
  },
  "AvgPool2d": {
    "description": "Applies a 2D average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "kernel_size",
      "stride",
      "padding",
      "ceil_mode",
      "count_include_pad",
      "divisor_override"
    ],
    "type": "class"
  },
  "AvgPool3d": {
    "description": "Applies a 3D average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "kernel_size",
      "stride",
      "padding",
      "ceil_mode",
      "count_include_pad",
      "divisor_override"
    ],
    "type": "class"
  },
  "B": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BACKEND": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BACKWARD_INPUT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BACKWARD_POST": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BACKWARD_PRE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BACKWARD_WEIGHT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BAD": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BATCHED_POWER_SGD": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BATCHED_POWER_SGD_RANK2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BCELoss": {
    "description": "Creates a criterion that measures the Binary Cross Entropy between the target and",
    "std_args": [
      "self",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "BCEWithLogitsLoss": {
    "description": "This loss combines a `Sigmoid` layer and the `BCELoss` in one single",
    "std_args": [
      "self",
      "weight",
      "size_average",
      "reduce",
      "reduction",
      "pos_weight"
    ],
    "type": "class"
  },
  "BENCHMARKS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BENCHMARK_MAP": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BENCHMARK_NAMES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BEST": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BF16_COMPRESS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BFloat16Storage": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "device",
      "dtype",
      "wrap_storage",
      "_internal"
    ],
    "type": "class"
  },
  "BIAS_DTYPE_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BIG": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BINARY_FUNCTIONS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BINARY_NAMES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCKS_ARE_CONTIGUOUS": {
    "description": "If True, guarantees that all blocks in the mask are contiguous.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_M": {
    "description": "Thread block size for the sequence length dimension of Q in forward pass.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_M1": {
    "description": "Thread block size for Q dimension in backward pass. Use as 'bwd_BLOCK_M1'.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_M2": {
    "description": "Thread block size for second Q dimension in backward pass. Use as 'bwd_BLOCK_M2'.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_N": {
    "description": "Thread block size for the sequence length dimension of K/V in forward pass.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_N1": {
    "description": "Thread block size for K/V dimension in backward pass. Use as 'bwd_BLOCK_N1'.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_N2": {
    "description": "Thread block size for second K/V dimension in backward pass. Use as 'bwd_BLOCK_N2'.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_SIZE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BNReLU2d": {
    "description": "A BNReLU2d module is a fused module of BatchNorm2d and ReLU",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "BNReLU3d": {
    "description": "A BNReLU3d module is a fused module of BatchNorm3d and ReLU",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "BOLD": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BUFFER": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BUFFER_MUTATION": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BUILT_FROM_SOURCE_VERSION_PATTERN": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BUNDLED_INPUT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BVar": {
    "description": "Boolean variable",
    "std_args": [
      "self",
      "c"
    ],
    "type": "class"
  },
  "BYTE_IO": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Backend": {
    "description": "An enum-like class for backends.",
    "std_args": [],
    "type": "class"
  },
  "BackendConfig": {
    "description": "Config that defines the set of patterns that can be quantized on a given backend, and how reference",
    "std_args": [
      "self",
      "name"
    ],
    "type": "class"
  },
  "BackendPatternConfig": {
    "description": "Config object that specifies quantization behavior for a given operator pattern.",
    "std_args": [
      "self",
      "pattern"
    ],
    "type": "class"
  },
  "BackendType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BackendValue": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BackwardCFunction": {
    "description": "This class is used for internal autograd work. Do not use.",
    "std_args": [],
    "type": "class"
  },
  "BackwardHook": {
    "description": "A wrapper class to implement nn.Module backward hooks.",
    "std_args": [
      "self",
      "module",
      "user_hooks",
      "user_pre_hooks"
    ],
    "type": "class"
  },
  "BackwardPrefetch": {
    "description": "This configures explicit backward prefetching, which improves throughput by",
    "std_args": [],
    "type": "class"
  },
  "BaseArgumentTypes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BasePruningMethod": {
    "description": "Abstract base class for creation of new pruning techniques.",
    "std_args": [],
    "type": "class"
  },
  "BaseScheduler": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "sparsifier",
      "last_epoch",
      "verbose"
    ],
    "type": "class"
  },
  "BaseSparsifier": {
    "description": "Base class for all sparsifiers.",
    "std_args": [
      "self",
      "defaults"
    ],
    "type": "class"
  },
  "BaseTorchFunctionMode": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "BatchNorm": {
    "description": "Batch Normalization.",
    "std_args": [
      "input",
      "eps"
    ],
    "variants": {}
  },
  "BatchNorm1d": {
    "description": "Applies Batch Normalization over a 2D or 3D input.",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "BatchNorm2d": {
    "description": "This is the quantized version of :class:`~torch.nn.BatchNorm2d`.",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "BatchNorm3d": {
    "description": "This is the quantized version of :class:`~torch.nn.BatchNorm3d`.",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "BatchNormQuantizeHandler": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "node_pattern",
      "modules",
      "root_node_getter",
      "is_custom_module",
      "is_standalone_module"
    ],
    "type": "class"
  },
  "BatchSampler": {
    "description": "Wraps another sampler to yield a mini-batch of indices.",
    "std_args": [
      "self",
      "sampler",
      "batch_size",
      "drop_last"
    ],
    "type": "class"
  },
  "BatcherIterDataPipe": {
    "description": "Creates mini-batches of data (functional name: ``batch``).",
    "std_args": [
      "self",
      "datapipe",
      "batch_size",
      "drop_last",
      "wrapper_class"
    ],
    "type": "class"
  },
  "BatcherMapDataPipe": {
    "description": "Create mini-batches of data (functional name: ``batch``).",
    "std_args": [
      "self",
      "datapipe",
      "batch_size",
      "drop_last",
      "wrapper_class"
    ],
    "type": "class"
  },
  "Benchmark": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Beta": {
    "description": "Beta distribution parameterized by :attr:`concentration1` and :attr:`concentration0`.",
    "std_args": [
      "self",
      "concentration1",
      "concentration0",
      "validate_args"
    ],
    "type": "class"
  },
  "Bidirectional": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "attribute"
  },
  "Bilinear": {
    "description": "Applies a bilinear transformation to the incoming data: :math:`y = x_1^T A x_2 + b`.",
    "std_args": [
      "self",
      "in1_features",
      "in2_features",
      "out_features",
      "bias",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "BinConstraintD": {
    "description": "Binary constraints about dimensions",
    "std_args": [
      "self",
      "lhs",
      "rhs",
      "op"
    ],
    "type": "class"
  },
  "BinConstraintT": {
    "description": "Binary constraints about tensors",
    "std_args": [
      "self",
      "lhs",
      "rhs",
      "op"
    ],
    "type": "class"
  },
  "BinaryConstraint": {
    "description": "Represents all binary operations",
    "std_args": [
      "self",
      "lhs",
      "rhs",
      "op"
    ],
    "type": "class"
  },
  "BinaryOpFuzzer": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "seed",
      "dtype",
      "cuda"
    ],
    "type": "class"
  },
  "BinaryOpQuantizeHandler": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "node_pattern",
      "modules",
      "root_node_getter",
      "is_custom_module",
      "is_standalone_module"
    ],
    "type": "class"
  },
  "BinaryOpSparseFuzzer": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "seed",
      "dtype",
      "cuda"
    ],
    "type": "class"
  },
  "Binomial": {
    "description": "Creates a Binomial distribution parameterized by :attr:`total_count` and",
    "std_args": [
      "self",
      "total_count",
      "probs",
      "logits",
      "validate_args"
    ],
    "type": "class"
  },
  "BisectValidationException": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "validation_exc",
      "expr",
      "failed_action",
      "traced_node"
    ],
    "type": "class"
  },
  "BlockMask": {
    "description": "BlockMask is our format for representing a block-sparse attention mask.",
    "std_args": [
      "self",
      "seq_lengths",
      "kv_num_blocks",
      "kv_indices",
      "full_kv_num_blocks",
      "full_kv_indices",
      "q_num_blocks",
      "q_indices",
      "full_q_num_blocks",
      "full_q_indices",
      "BLOCK_SIZE",
      "mask_mod"
    ],
    "type": "class"
  },
  "BlockingAsyncStager": {
    "description": "An implementation of AsyncStager which stages the state_dict on CPU RAM and blocks until the copy is complete.",
    "std_args": [
      "self",
      "cache_staged_state_dict",
      "type_check"
    ],
    "type": "class"
  },
  "BoolLikeType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BoolStorage": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "device",
      "dtype",
      "wrap_storage",
      "_internal"
    ],
    "type": "class"
  },
  "BroadcastingTorchSaveReader": {
    "description": "StorageReader for reading a Torch Save file. This reader will read the entire checkpoint",
    "std_args": [
      "self",
      "checkpoint_id",
      "coordinator_rank"
    ],
    "type": "class"
  },
  "Buffer": {
    "description": "A kind of Tensor that should not be considered a model",
    "std_args": [
      "self",
      "data",
      "requires_grad",
      "persistent"
    ],
    "type": "class"
  },
  "BuildExtension": {
    "description": "A custom :mod:`setuptools` build extension .",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "Builder": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "ByteStorage": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "device",
      "dtype",
      "wrap_storage",
      "_internal"
    ],
    "type": "class"
  },
  "BytesIOWriteData": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "nbytes"
    ],
    "type": "class"
  },
  "BytesStorageMetadata": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "C10_MAPPINGS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "C10dRendezvousBackend": {
    "description": "Represents a C10d-backed rendezvous backend.",
    "std_args": [
      "self",
      "store",
      "run_id"
    ],
    "type": "class"
  },
  "CAFFE2_MAP": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CAFFE2_SPECIFIC_MAPPINGS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CAFFE2_TRIE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CALLABLE_NODE_OPS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CALLGRIND_SINGLETON": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CLIB_EXT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CLIB_PREFIX": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "COLUMNWISE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "COMMON_HIPCC_FLAGS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "COMMON_HIP_FLAGS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "COMMON_MSVC_FLAGS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "COMMON_NVCC_FLAGS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "COMMON_PATTERNS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "COMPAT_CALLGRIND_BINDINGS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONDA_PATTERNS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONDA_PREFIX": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONFIGS_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONSTANTS_CONFIG_FILENAME_FORMAT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONSTANTS_DIR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONSTANT_NUMEL_LIMIT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONSTANT_TENSOR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONST_ETCD_FROZEN_TTL": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONST_ETCD_JOINABLE_EPHEMERAL_TTL": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONST_ETCD_SETUP_TTL": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONST_RUNID_SUBROOT_TTL": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONST_WORKER_KEEPALIVE_TTL": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_CACHE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_CONTEXT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_COORD_FUNC": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_D3D10": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_D3D11": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_D3D9": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_DEF": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_DEVICE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_DEVICE_FUNC": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_EGL": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_ERROR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_EVENT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_EXEC": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_GL": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_GRAPHICS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_INCLUDE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_INCLUDE_CUDA_MAIN_H": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_INIT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_JIT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_KERN": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_LAST": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_LITERAL": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_MATH_FUNC": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_MEM": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_NUMERIC_LITERAL": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_OCCUPANCY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_OTHER": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_PEER": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_SPECIAL_FUNC": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_STREAM": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_SURFACE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_TEX": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_THREAD": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_TYPE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_VDPAU": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CONV_VERSION": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CORE_COMPLEX": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CPP": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CPPTimer": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "stmt",
      "setup",
      "global_setup",
      "timer",
      "globals"
    ],
    "type": "class"
  },
  "CPUOffload": {
    "description": "This configures CPU offloading.",
    "std_args": [
      "self",
      "offload_params"
    ],
    "type": "class"
  },
  "CREATE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CSEPass": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "banned_ops"
    ],
    "type": "class"
  },
  "CTCLoss": {
    "description": "The Connectionist Temporal Classification loss.",
    "std_args": [
      "self",
      "blank",
      "reduction",
      "zero_infinity"
    ],
    "type": "class"
  },
  "CUDAExtension": {
    "description": "Create a :class:`setuptools.Extension` for CUDA/C++.",
    "std_args": [
      "name",
      "sources",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "CUDAGraph": {
    "description": "Wrapper around a CUDA graph.",
    "std_args": [],
    "type": "class"
  },
  "CUDAPluggableAllocator": {
    "description": "CUDA memory allocator loaded from a so file.",
    "std_args": [
      "self",
      "path_to_so_file",
      "alloc_fn_name",
      "free_fn_name"
    ],
    "type": "class"
  },
  "CUDA_CLANG_VERSIONS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CUDA_GCC_VERSIONS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CUDA_HOME": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CUDA_IDENTIFIER_MAP": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CUDA_INCLUDE_MAP": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CUDA_MISMATCH_MESSAGE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CUDA_MISMATCH_WARN": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CUDA_NOT_FOUND_MESSAGE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CUDA_SPECIAL_MAP": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CUDA_TO_HIP_MAPPINGS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CUDA_TYPE_NAME_MAP": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CUDNN_HOME": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CUDNN_TENSOR_DTYPES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CURRENT_DCP_VERSION": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CURRENT_DECOMPOSITION_TABLE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CURRENT_NODE_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CUSTOM_OBJ": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CUSTOM_OBJ_FILENAME_PREFIX": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CXX_FLAGS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Cache": {
    "description": "Container for mutable state (non-grad).",
    "std_args": [
      "value"
    ],
    "variants": {}
  },
  "CalcConv": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "conv_result",
      "input_var",
      "c_out",
      "kernel",
      "padding",
      "stride",
      "dilation",
      "matching_constraint_vars"
    ],
    "type": "class"
  },
  "CalcMaxPool": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "maxpool_result",
      "input_var",
      "kernel",
      "padding",
      "stride",
      "dilation",
      "matching_constraint_vars"
    ],
    "type": "class"
  },
  "CalcProduct": {
    "description": "Given correct dimensions, calculate the product for flatten accounting for Dyn",
    "std_args": [
      "self",
      "start",
      "end",
      "flattened",
      "dims_to_flatten"
    ],
    "type": "class"
  },
  "CallMethodKey": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "name"
    ],
    "type": "class"
  },
  "CallgrindStats": {
    "description": "Top level container for Callgrind results collected by Timer.",
    "std_args": [
      "self",
      "task_spec",
      "number_per_run",
      "built_with_debug_symbols",
      "baseline_inclusive_stats",
      "baseline_exclusive_stats",
      "stmt_inclusive_stats",
      "stmt_exclusive_stats",
      "stmt_callgrind_out"
    ],
    "type": "class"
  },
  "CanReshape": {
    "description": "can_reshape constraint",
    "std_args": [
      "self",
      "src",
      "target"
    ],
    "type": "class"
  },
  "CapabilityBasedPartitioner": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "graph_module",
      "operator_support",
      "allows_single_node_partition",
      "non_compute_ops",
      "allowed_single_node_partition_ops"
    ],
    "type": "class"
  },
  "Capture": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "schema_df"
    ],
    "type": "class"
  },
  "CaptureA": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "ctx",
      "kwargs"
    ],
    "type": "class"
  },
  "CaptureAdd": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "left",
      "right",
      "ctx"
    ],
    "type": "class"
  },
  "CaptureCall": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "callable",
      "ctx",
      "kwargs"
    ],
    "type": "class"
  },
  "CaptureControl": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "CaptureDataFrame": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "schema_df"
    ],
    "type": "class"
  },
  "CaptureDataFrameWithDataPipeOps": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "schema_df"
    ],
    "type": "class"
  },
  "CaptureF": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "ctx",
      "kwargs"
    ],
    "type": "class"
  },
  "CaptureGetAttr": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "src",
      "name",
      "ctx"
    ],
    "type": "class"
  },
  "CaptureGetItem": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "left",
      "key",
      "ctx"
    ],
    "type": "class"
  },
  "CaptureInitial": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "schema_df"
    ],
    "type": "class"
  },
  "CaptureLikeMock": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "name"
    ],
    "type": "class"
  },
  "CaptureMul": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "left",
      "right",
      "ctx"
    ],
    "type": "class"
  },
  "CaptureSetItem": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "left",
      "key",
      "value",
      "ctx"
    ],
    "type": "class"
  },
  "CaptureSub": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "left",
      "right",
      "ctx"
    ],
    "type": "class"
  },
  "CaptureVariable": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "value",
      "ctx"
    ],
    "type": "class"
  },
  "CaptureVariableAssign": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "ctx",
      "kwargs"
    ],
    "type": "class"
  },
  "CastBool": {
    "description": "Cast tensor to bool",
    "std_args": [],
    "variants": {}
  },
  "CastDouble": {
    "description": "Cast tensor to float64",
    "std_args": [],
    "variants": {}
  },
  "CastFloat": {
    "description": "Cast tensor to float32",
    "std_args": [],
    "variants": {}
  },
  "CastHalf": {
    "description": "Cast tensor to float16",
    "std_args": [],
    "variants": {}
  },
  "CastInt": {
    "description": "Cast tensor to int32",
    "std_args": [],
    "variants": {}
  },
  "CastLong": {
    "description": "Cast tensor to int64",
    "std_args": [],
    "variants": {}
  },
  "CatQuantizeHandler": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "node_pattern",
      "modules",
      "root_node_getter",
      "is_custom_module",
      "is_standalone_module"
    ],
    "type": "class"
  },
  "CatTransform": {
    "description": "Transform functor that applies a sequence of transforms `tseq`",
    "std_args": [
      "self",
      "tseq",
      "dim",
      "lengths",
      "cache_size"
    ],
    "type": "class"
  },
  "Categorical": {
    "description": "Creates a categorical distribution parameterized by either :attr:`probs` or",
    "std_args": [
      "self",
      "probs",
      "logits",
      "validate_args"
    ],
    "type": "class"
  },
  "Cauchy": {
    "description": "Samples from a Cauchy (Lorentz) distribution. The distribution of the ratio of",
    "std_args": [
      "self",
      "loc",
      "scale",
      "validate_args"
    ],
    "type": "class"
  },
  "CausalBias": {
    "description": "A bias representing causal attention patterns. For an overview of the bias structure, see the :class:`CausalVariant` enum.",
    "std_args": [
      "self",
      "variant",
      "seq_len_q",
      "seq_len_kv"
    ],
    "type": "class"
  },
  "CausalVariant": {
    "description": "Enum for causal variants used in attention mechanisms.",
    "std_args": [],
    "type": "class"
  },
  "Celu": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "alpha"
    ],
    "type": "function"
  },
  "CenterCrop": {
    "description": "Crops the given image at the center.",
    "std_args": [
      "size"
    ],
    "variants": {}
  },
  "ChainDataset": {
    "description": "Dataset for chaining multiple :class:`IterableDataset` s.",
    "std_args": [
      "self",
      "datasets"
    ],
    "type": "class"
  },
  "ChainedScheduler": {
    "description": "Chains a list of learning rate schedulers.",
    "std_args": [
      "self",
      "schedulers",
      "optimizer"
    ],
    "type": "class"
  },
  "ChannelShuffle": {
    "description": "Divides and rearranges the channels in a tensor.",
    "std_args": [
      "self",
      "groups"
    ],
    "type": "class"
  },
  "CharStorage": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "device",
      "dtype",
      "wrap_storage",
      "_internal"
    ],
    "type": "class"
  },
  "CheckpointError": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "CheckpointException": {
    "description": "Exception raised if failure was detected as part of a checkpoint load or save.",
    "std_args": [
      "self",
      "msg",
      "failures"
    ],
    "type": "class"
  },
  "CheckpointFunction": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "CheckpointPolicy": {
    "description": "Enum for specifying the policy for checkpointing during backpropagation.",
    "std_args": [],
    "type": "class"
  },
  "Chi2": {
    "description": "Creates a Chi-squared distribution parameterized by shape parameter :attr:`df`.",
    "std_args": [
      "self",
      "df",
      "validate_args"
    ],
    "type": "class"
  },
  "ChildFailedError": {
    "description": "Special exception type that can be raised from a function annotated with the",
    "std_args": [
      "self",
      "name",
      "failures"
    ],
    "type": "class"
  },
  "ChunkStorageMetadata": {
    "description": "Each chunk is expected to have the same properties of the TensorStorageMetadata",
    "std_args": [
      "self",
      "offsets",
      "sizes"
    ],
    "type": "class"
  },
  "CircularPad1d": {
    "description": "Pads the input tensor using circular padding of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "CircularPad2d": {
    "description": "Pads the input tensor using circular padding of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "CircularPad3d": {
    "description": "Pads the input tensor using circular padding of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "Clamp": {
    "description": "Clamp all elements in input into the range [min, max].",
    "std_args": [
      "input",
      "min",
      "max"
    ],
    "variants": {}
  },
  "ClipGradNorm": {
    "description": "Clips gradient norm of an iterable of parameters.",
    "std_args": [
      "parameters",
      "max_norm"
    ],
    "variants": {}
  },
  "CodeGen": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "CollatorIterDataPipe": {
    "description": "Collates samples from DataPipe to Tensor(s) by a custom collate function (functional name: ``collate``).",
    "std_args": [
      "self",
      "datapipe",
      "conversion",
      "collate_fn"
    ],
    "type": "class"
  },
  "Colorize": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "ColwiseParallel": {
    "description": "Partition a compatible nn.Module in a column-wise fashion. Currently supports nn.Linear and nn.Embedding.",
    "std_args": [
      "self",
      "input_layouts",
      "output_layouts",
      "use_local_output"
    ],
    "type": "class"
  },
  "Compare": {
    "description": "Helper class for displaying the results of many measurements in a",
    "std_args": [
      "self",
      "results"
    ],
    "type": "class"
  },
  "Compile": {
    "description": "Alias for JIT compilation.",
    "std_args": [
      "func"
    ],
    "variants": {}
  },
  "CompletedProcessType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ComplexDoubleStorage": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "device",
      "dtype",
      "wrap_storage",
      "_internal"
    ],
    "type": "class"
  },
  "ComplexFloatStorage": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "device",
      "dtype",
      "wrap_storage",
      "_internal"
    ],
    "type": "class"
  },
  "Component": {
    "description": "A component serves as a container for a subgraph we want to create afterwards.",
    "std_args": [
      "self",
      "graph",
      "order",
      "name",
      "input_placeholders",
      "orig_inputs",
      "orig_outputs",
      "getattr_maps",
      "constructor_args",
      "gm"
    ],
    "type": "class"
  },
  "ComposableQuantizer": {
    "description": "ComposableQuantizer allows users to combine more than one quantizer into a single quantizer.",
    "std_args": [
      "self",
      "quantizers"
    ],
    "type": "class"
  },
  "ComposeTransform": {
    "description": "Composes multiple transforms in a chain.",
    "std_args": [
      "self",
      "parts",
      "cache_size"
    ],
    "type": "class"
  },
  "ConcatDataFramesPipe": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "source_datapipe",
      "batch"
    ],
    "type": "class"
  },
  "ConcatDataset": {
    "description": "Dataset as a concatenation of multiple datasets.",
    "std_args": [
      "self",
      "datasets"
    ],
    "type": "class"
  },
  "ConcaterIterDataPipe": {
    "description": "Concatenates multiple Iterable DataPipes (functional name: ``concat``).",
    "std_args": [
      "self",
      "datapipes"
    ],
    "type": "class"
  },
  "ConcaterMapDataPipe": {
    "description": "Concatenate multiple Map DataPipes (functional name: ``concat``).",
    "std_args": [
      "self",
      "datapipes"
    ],
    "type": "class"
  },
  "ConnectionWrapper": {
    "description": "Proxy class for _multiprocessing.Connection which uses ForkingPickler for object serialization.",
    "std_args": [
      "self",
      "conn"
    ],
    "type": "class"
  },
  "ConsoleMetricHandler": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "ConstantArgument": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "name",
      "value"
    ],
    "type": "class"
  },
  "ConstantLR": {
    "description": "Multiply the learning rate of each parameter group by a small constant factor.",
    "std_args": [
      "self",
      "optimizer",
      "factor",
      "total_iters",
      "last_epoch"
    ],
    "type": "class"
  },
  "ConstantPad1d": {
    "description": "Pads the input tensor boundaries with a constant value.",
    "std_args": [
      "self",
      "padding",
      "value"
    ],
    "type": "class"
  },
  "ConstantPad2d": {
    "description": "Pads the input tensor boundaries with a constant value.",
    "std_args": [
      "self",
      "padding",
      "value"
    ],
    "type": "class"
  },
  "ConstantPad3d": {
    "description": "Pads the input tensor boundaries with a constant value.",
    "std_args": [
      "self",
      "padding",
      "value"
    ],
    "type": "class"
  },
  "Constraint": {
    "description": "Abstract base class for constraints.",
    "std_args": [],
    "type": "class"
  },
  "ConstraintGenerator": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "traced",
      "graph"
    ],
    "type": "class"
  },
  "ConstraintRegistry": {
    "description": "Registry to link constraints to transforms.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "ConstraintViolationError": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Container": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "kwargs"
    ],
    "type": "class"
  },
  "ContextProp": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "getter",
      "setter"
    ],
    "type": "class"
  },
  "ContinuousBernoulli": {
    "description": "Creates a continuous Bernoulli distribution parameterized by :attr:`probs`",
    "std_args": [
      "self",
      "probs",
      "logits",
      "lims",
      "validate_args"
    ],
    "type": "class"
  },
  "Conv": {
    "description": "Auto-discovered via Consensus (Score: 3.0)",
    "std_args": [
      "dtype",
      "groups",
      "kernel_size",
      "out_channels",
      "padding",
      "strides",
      "use_bias"
    ],
    "type": "attribute"
  },
  "Conv1d": {
    "description": "A Conv1d module attached with FakeQuantize modules for weight,",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "qconfig",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "Conv3d": {
    "description": "A Conv3d module attached with FakeQuantize modules for weight,",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "qconfig",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "ConvAdd2d": {
    "description": "A ConvAdd2d module is a fused module of Conv2d and Add",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "ConvAddReLU2d": {
    "description": "A ConvAddReLU2d module is a fused module of Conv2d, Add and Relu",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "ConvBn1d": {
    "description": "A ConvBn1d module is a module fused from Conv1d and BatchNorm1d,",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "eps",
      "momentum",
      "freeze_bn",
      "qconfig"
    ],
    "type": "class"
  },
  "ConvBn2d": {
    "description": "A ConvBn2d module is a module fused from Conv2d and BatchNorm2d,",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "eps",
      "momentum",
      "freeze_bn",
      "qconfig"
    ],
    "type": "class"
  },
  "ConvBn3d": {
    "description": "A ConvBn3d module is a module fused from Conv3d and BatchNorm3d,",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "eps",
      "momentum",
      "freeze_bn",
      "qconfig"
    ],
    "type": "class"
  },
  "ConvBnReLU1d": {
    "description": "A ConvBnReLU1d module is a module fused from Conv1d, BatchNorm1d and ReLU,",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "eps",
      "momentum",
      "freeze_bn",
      "qconfig"
    ],
    "type": "class"
  },
  "ConvBnReLU2d": {
    "description": "A ConvBnReLU2d module is a module fused from Conv2d, BatchNorm2d and ReLU,",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "eps",
      "momentum",
      "freeze_bn",
      "qconfig"
    ],
    "type": "class"
  },
  "ConvBnReLU3d": {
    "description": "A ConvBnReLU3d module is a module fused from Conv3d, BatchNorm3d and ReLU,",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "eps",
      "momentum",
      "freeze_bn",
      "qconfig"
    ],
    "type": "class"
  },
  "ConvReLU1d": {
    "description": "A ConvReLU1d module is a fused module of Conv1d and ReLU, attached with",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "qconfig"
    ],
    "type": "class"
  },
  "ConvReLU2d": {
    "description": "A ConvReLU2d module is a fused module of Conv2d and ReLU, attached with",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "qconfig"
    ],
    "type": "class"
  },
  "ConvReLU3d": {
    "description": "A ConvReLU3d module is a fused module of Conv3d and ReLU, attached with",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "qconfig"
    ],
    "type": "class"
  },
  "ConvReluQuantizeHandler": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "node_pattern",
      "modules",
      "root_node_getter",
      "is_custom_module",
      "is_standalone_module"
    ],
    "type": "class"
  },
  "ConvT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ConvTranspose1d": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "output_padding",
      "groups",
      "bias",
      "dilation",
      "padding_mode",
      "device",
      "dtype",
      "weight_qparams"
    ],
    "type": "class"
  },
  "ConvTranspose2d": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "output_padding",
      "groups",
      "bias",
      "dilation",
      "padding_mode",
      "device",
      "dtype",
      "weight_qparams"
    ],
    "type": "class"
  },
  "ConvTranspose3d": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "output_padding",
      "groups",
      "bias",
      "dilation",
      "padding_mode",
      "device",
      "dtype",
      "weight_qparams"
    ],
    "type": "class"
  },
  "ConvertCustomConfig": {
    "description": "Custom configuration for :func:`~torch.ao.quantization.quantize_fx.convert_fx`.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "ConvertIntKey": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "CopyIfCallgrind": {
    "description": "Signal that a global may be replaced with a deserialized copy.",
    "std_args": [
      "self",
      "value",
      "setup"
    ],
    "type": "class"
  },
  "CopyNodeQuantizeHandler": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "node_pattern",
      "modules",
      "root_node_getter",
      "is_custom_module",
      "is_standalone_module"
    ],
    "type": "class"
  },
  "CorrCholeskyTransform": {
    "description": "Transforms an unconstrained real vector :math:`x` with length :math:`D*(D-1)/2` into the",
    "std_args": [
      "self",
      "cache_size"
    ],
    "type": "class"
  },
  "CosineAnnealingLR": {
    "description": "Set the learning rate of each parameter group using a cosine annealing schedule.",
    "std_args": [
      "optimizer",
      "T_max"
    ],
    "variants": {}
  },
  "CosineAnnealingWarmRestarts": {
    "description": "Set the learning rate of each parameter group using a cosine annealing schedule.",
    "std_args": [
      "self",
      "optimizer",
      "T_0",
      "T_mult",
      "eta_min",
      "last_epoch"
    ],
    "type": "class"
  },
  "CosineEmbeddingLoss": {
    "description": "Creates a criterion that measures the loss given input tensors",
    "std_args": [
      "self",
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "CosineSimilarity": {
    "description": "Returns cosine similarity between :math:`x_1` and :math:`x_2`, computed along `dim`.",
    "std_args": [
      "self",
      "dim",
      "eps"
    ],
    "type": "class"
  },
  "CppExtension": {
    "description": "Create a :class:`setuptools.Extension` for C++.",
    "std_args": [
      "name",
      "sources",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "CrossEntropyLoss": {
    "description": "Cross Entropy Loss.",
    "std_args": [
      "input",
      "target",
      "weight"
    ],
    "variants": {}
  },
  "CrossMapLRN2d": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "size",
      "alpha",
      "beta",
      "k"
    ],
    "type": "class"
  },
  "CubicSL": {
    "description": "Sets the sparsity level of each parameter group to the final sl",
    "std_args": [
      "self",
      "sparsifier",
      "init_sl",
      "init_t",
      "delta_t",
      "total_t",
      "initially_zero",
      "last_epoch",
      "verbose"
    ],
    "type": "class"
  },
  "CudaError": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "code"
    ],
    "type": "class"
  },
  "CudaGraphsSupport": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "support_dict"
    ],
    "type": "class"
  },
  "CumulativeDistributionTransform": {
    "description": "Transform via the cumulative distribution function of a probability distribution.",
    "std_args": [
      "self",
      "distribution",
      "cache_size"
    ],
    "type": "class"
  },
  "CurrentState": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "CustomDecompTable": {
    "description": "This is a custom dictionary that is specifically used for handling decomp_table in export.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "CustomFromMask": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "mask"
    ],
    "type": "class"
  },
  "CustomObjArgument": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "name",
      "class_fqn",
      "fake_val"
    ],
    "type": "class"
  },
  "CustomPolicy": {
    "description": "This policy takes in a lambda function that maps a given ``nn.Module`` to",
    "std_args": [
      "self",
      "lambda_fn"
    ],
    "type": "class"
  },
  "CyclicLR": {
    "description": "Sets the learning rate of each parameter group according to cyclical learning rate policy (CLR).",
    "std_args": [
      "self",
      "optimizer",
      "base_lr",
      "max_lr",
      "step_size_up",
      "step_size_down",
      "mode",
      "gamma",
      "scale_fn",
      "scale_mode",
      "cycle_momentum",
      "base_momentum",
      "max_momentum",
      "last_epoch"
    ],
    "type": "class"
  },
  "CyclingIterator": {
    "description": "An iterator decorator that cycles through the",
    "std_args": [
      "self",
      "n",
      "generator_fn",
      "start_epoch"
    ],
    "type": "class"
  },
  "D": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DAG": {
    "description": "DAG class contains all the DAG nodes",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "DAGNode": {
    "description": "DAGNode class maintains useful information for a partition (submodule),",
    "std_args": [
      "self",
      "submodule_node",
      "input_nodes",
      "output_nodes",
      "logical_device_ids",
      "size_bytes"
    ],
    "type": "class"
  },
  "DATAPIPES_OPS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DCP_LOGGER_NAME": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DCP_TO_TORCH": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DDPCommHookType": {
    "description": "Enumerate ``ddp_comm_hooks`` and ``ddp_comm_hook_wrapper`` communucation hook types.",
    "std_args": [],
    "type": "class"
  },
  "DEFAULT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT_ALLOW_NON_TENSOR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT_CACHE_DIR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT_CHUNK_DIM": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT_DYNAMIC_QUANT_MODULE_MAPPINGS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT_DYNAMIC_SPARSE_QUANT_MODULE_MAPPINGS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT_EXTRA_FILE_SIZE_LIMIT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT_FLAGS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT_FLOAT_TO_QUANTIZED_OPERATOR_MAPPINGS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT_INIT_METHOD": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT_MIN_ACC_MODULE_SIZE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT_MODULE_TO_ACT_POST_PROCESS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT_NUM_WORKER_THREADS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT_PICKLE_PROTOCOL": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT_PORT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT_PROCESS_GROUP_TIMEOUT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT_PROTOCOL": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT_QAT_MODULE_MAPPINGS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT_REFERENCE_STATIC_QUANT_MODULE_MAPPINGS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT_ROLE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT_RPC_TIMEOUT_SEC": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT_SHUTDOWN_TIMEOUT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT_SKIP_FUSION": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT_STATIC_QUANT_MODULE_MAPPINGS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT_STATIC_SPARSE_QUANT_MODULE_MAPPINGS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT_SUFFIX": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DENIED": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEPENDENCY_RESOLUTION_FAILED": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEPRECATION_WARNING": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEVICE_NAMES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DFIterDataPipe": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "DGreatestUpperBound": {
    "description": "Greatest Upper bound for dimensions",
    "std_args": [
      "self",
      "res",
      "rhs1",
      "rhs2"
    ],
    "type": "class"
  },
  "DILL_AVAILABLE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DISTRIBUTED": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DLDeviceType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "DONE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DTYPE_CONFIGS_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DTensorExtensions": {
    "description": "DTensorExtension is the TensorFlattener extension needed for 2D FSDP + TP.",
    "std_args": [
      "self",
      "device_handle"
    ],
    "type": "class"
  },
  "DTypeConfig": {
    "description": "Config object that specifies the supported data types passed as arguments to",
    "std_args": [
      "self",
      "input_dtype",
      "output_dtype",
      "weight_dtype",
      "bias_dtype",
      "is_dynamic"
    ],
    "type": "class"
  },
  "DTypeWithConstraints": {
    "description": "Config for specifying additional constraints for a given dtype, such as quantization",
    "std_args": [
      "self",
      "dtype",
      "quant_min_lower_bound",
      "quant_max_upper_bound",
      "scale_min_lower_bound",
      "scale_max_upper_bound",
      "scale_exact_match",
      "zero_point_exact_match"
    ],
    "type": "class"
  },
  "DUCK": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DUMP_PREFIX": {
    "description": "Different modes of the event tracker for local debugging:",
    "std_args": [],
    "type": "attribute"
  },
  "DVar": {
    "description": "Dimension variable",
    "std_args": [
      "self",
      "c"
    ],
    "type": "class"
  },
  "DYNAMIC": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DYNAMIC_OPS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DataChunk": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "items"
    ],
    "type": "class"
  },
  "DataChunkDF": {
    "description": "DataChunkDF iterating over individual items inside of DataFrame containers, to access DataFrames user `raw_iterator`.",
    "std_args": [
      "self",
      "items"
    ],
    "type": "class"
  },
  "DataFrameTracedOps": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "source_datapipe",
      "output_var"
    ],
    "type": "class"
  },
  "DataFrameTracer": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "source_datapipe",
      "schema_df"
    ],
    "type": "class"
  },
  "DataFramesAsTuplesPipe": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "source_datapipe"
    ],
    "type": "class"
  },
  "DataLoader": {
    "description": "Data loading utility.",
    "std_args": [
      "dataset"
    ],
    "variants": {}
  },
  "DataParallel": {
    "description": "Implements data parallelism at the module level.",
    "std_args": [
      "self",
      "module",
      "device_ids",
      "output_device",
      "dim"
    ],
    "type": "class"
  },
  "DataPipe": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DataPipeGraph": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Dataset": {
    "description": "An abstract class representing a :class:`Dataset`.",
    "std_args": [],
    "type": "class"
  },
  "DeQuantStub": {
    "description": "Dequantize stub module, before calibration, this is same as identity,",
    "std_args": [
      "self",
      "qconfig"
    ],
    "type": "class"
  },
  "DeQuantize": {
    "description": "Dequantizes an incoming tensor",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "Decoder": {
    "description": "Decode key/data sets using a list of handlers.",
    "std_args": [
      "self",
      "handler",
      "key_fn"
    ],
    "type": "class"
  },
  "DecompositionInterpreter": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "module",
      "new_graph",
      "decomposition_table",
      "kwargs"
    ],
    "type": "class"
  },
  "DefaultDeviceType": {
    "description": "A class that manages the default device type for checkpointing.",
    "std_args": [],
    "type": "class"
  },
  "DefaultFuseHandler": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "node"
    ],
    "type": "class"
  },
  "DefaultLoadPlanner": {
    "description": "DefaultLoadPlanner that adds multiple features on top of LoadPlanner.",
    "std_args": [
      "self",
      "flatten_state_dict",
      "flatten_sharded_tensors",
      "allow_partial_load"
    ],
    "type": "class"
  },
  "DefaultLogsSpecs": {
    "description": "Default LogsSpecs implementation:",
    "std_args": [
      "self",
      "log_dir",
      "redirects",
      "tee",
      "local_ranks_filter"
    ],
    "type": "class"
  },
  "DefaultNodeQuantizeHandler": {
    "description": "Common quantized op, first input and first output will be quantized",
    "std_args": [
      "self",
      "node_pattern",
      "modules",
      "root_node_getter",
      "is_custom_module",
      "is_standalone_module"
    ],
    "type": "class"
  },
  "DefaultSavePlanner": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "flatten_state_dict",
      "flatten_sharded_tensors",
      "dedup_replicated_tensors",
      "dedup_save_to_lowest_rank",
      "enable_plan_caching"
    ],
    "type": "class"
  },
  "DefaultStager": {
    "description": "DefaultStager provides a full-featured staging implementation that combines",
    "std_args": [
      "self",
      "config"
    ],
    "type": "class"
  },
  "DeferredCudaCallError": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "DeferredMtiaCallError": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "DemultiplexerIterDataPipe": {
    "description": "Splits the input DataPipe into multiple child DataPipes, using the given classification function (functional name: ``demux``).",
    "std_args": [],
    "type": "class"
  },
  "DerivedQuantizationSpec": {
    "description": "Quantization spec for the Tensors whose quantization parameters are derived from other Tensors",
    "std_args": [
      "self",
      "derived_from",
      "derive_qparams_fn",
      "dtype",
      "quant_min",
      "quant_max",
      "qscheme",
      "ch_axis",
      "is_dynamic"
    ],
    "type": "class"
  },
  "Device": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "DeviceDict": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DeviceDtypeDict": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DeviceMesh": {
    "description": "DeviceMesh represents a mesh of devices, where layout of devices could be",
    "std_args": [
      "self",
      "device_type",
      "mesh",
      "mesh_dim_names",
      "backend_override",
      "_init_backend"
    ],
    "type": "class"
  },
  "DeviceType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DictValueType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Dim": {
    "description": "The ``Dim`` class allows users to specify dynamism in their exported",
    "std_args": [
      "self",
      "name",
      "min",
      "max"
    ],
    "type": "class"
  },
  "DimConstraint": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DimConstraints": {
    "description": "Custom solver for a system of constraints on symbolic dimensions.",
    "std_args": [
      "self",
      "symbol_to_source",
      "var_to_val",
      "marked_dynamic",
      "source_name_to_debug_name"
    ],
    "type": "class"
  },
  "DimDynamic": {
    "description": "Controls how to perform symbol allocation for a dimension.  It is always",
    "std_args": [],
    "type": "class"
  },
  "DimList": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DimOrDims": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Directory": {
    "description": "A file structure representation. Organized as Directory nodes that have lists of",
    "std_args": [
      "self",
      "name",
      "is_dir"
    ],
    "type": "class"
  },
  "Dirichlet": {
    "description": "Creates a Dirichlet distribution parameterized by concentration :attr:`concentration`.",
    "std_args": [
      "self",
      "concentration",
      "validate_args"
    ],
    "type": "class"
  },
  "Disj": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "disjuncts"
    ],
    "type": "class"
  },
  "Dispatcher": {
    "description": "Dispatch methods based on type signature",
    "std_args": [
      "self",
      "name",
      "doc"
    ],
    "type": "class"
  },
  "DistBackendError": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DistError": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DistNetworkError": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DistStoreError": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DistributedDataParallel": {
    "description": "Implement distributed data parallelism based on ``torch.distributed`` at module level.",
    "std_args": [
      "self",
      "module",
      "device_ids",
      "output_device",
      "dim",
      "broadcast_buffers",
      "init_sync",
      "process_group",
      "bucket_cap_mb",
      "find_unused_parameters",
      "check_reduction",
      "gradient_as_bucket_view",
      "static_graph",
      "delay_all_reduce_named_params",
      "param_to_hook_all_reduce",
      "mixed_precision",
      "device_mesh",
      "skip_all_reduce_unused_params"
    ],
    "type": "class"
  },
  "DistributedDataParallelCPU": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "module",
      "device_ids",
      "output_device",
      "dim",
      "broadcast_buffers",
      "init_sync",
      "process_group",
      "bucket_cap_mb",
      "find_unused_parameters",
      "check_reduction",
      "gradient_as_bucket_view",
      "static_graph",
      "delay_all_reduce_named_params",
      "param_to_hook_all_reduce",
      "mixed_precision",
      "device_mesh",
      "skip_all_reduce_unused_params"
    ],
    "type": "class"
  },
  "DistributedOptimizer": {
    "description": "DistributedOptimizer takes remote references to parameters scattered",
    "std_args": [
      "self",
      "optimizer_class",
      "params_rref",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "DistributedSampler": {
    "description": "Sampler that restricts data loading to a subset of the dataset.",
    "std_args": [
      "self",
      "dataset",
      "num_replicas",
      "rank",
      "shuffle",
      "seed",
      "drop_last"
    ],
    "type": "class"
  },
  "Distribution": {
    "description": "Distribution is the abstract base class for probability distributions.",
    "std_args": [
      "self",
      "batch_shape",
      "event_shape",
      "validate_args"
    ],
    "type": "class"
  },
  "DivideByKey": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "divisor"
    ],
    "type": "class"
  },
  "DoubleStorage": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "device",
      "dtype",
      "wrap_storage",
      "_internal"
    ],
    "type": "class"
  },
  "Dropout": {
    "description": "Auto-discovered via Consensus (Score: 3.0)",
    "std_args": [
      "lr"
    ],
    "type": "attribute"
  },
  "Dropout1d": {
    "description": "Randomly zero out entire channels.",
    "std_args": [
      "self",
      "p",
      "inplace"
    ],
    "type": "class"
  },
  "Dropout2d": {
    "description": "Randomly zero out entire channels.",
    "std_args": [
      "self",
      "p",
      "inplace"
    ],
    "type": "class"
  },
  "Dropout3d": {
    "description": "Randomly zero out entire channels.",
    "std_args": [
      "self",
      "p",
      "inplace"
    ],
    "type": "class"
  },
  "DumpUnpickler": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "file",
      "catch_invalid_utf8",
      "kwargs"
    ],
    "type": "class"
  },
  "DuplicateDQPass": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Dyn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DynamicDimConstraintPrinter": {
    "description": "Printer for dynamic dim constraints.",
    "std_args": [
      "self",
      "symbol_to_source",
      "source_name_to_debug_name"
    ],
    "type": "class"
  },
  "DynamicMetaLoadPlanner": {
    "description": "Extension of DefaultLoadPlanner, which creates a new Metadata object based on the passed in state dict,",
    "std_args": [
      "self",
      "flatten_state_dict",
      "flatten_sharded_tensors",
      "allow_partial_load"
    ],
    "type": "class"
  },
  "DynamicRendezvousHandler": {
    "description": "Represent a handler that sets up a rendezvous among a set of nodes.",
    "std_args": [
      "self",
      "node",
      "settings",
      "backend_name",
      "store",
      "state_holder"
    ],
    "type": "class"
  },
  "EMPTY_ARG_DICT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ENABLE_PROFILE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ENDC": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ENV_FX_NET_ACC_SPLITTER_TRACKER_DUMP_PATH": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ENV_FX_NET_ACC_SPLITTER_TRACKER_MODE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ENV_FX_NET_ACC_SPLITTER_TRACKER_TRACKED_NODES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ENV_GITHUB_TOKEN": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ENV_TORCH_HOME": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ENV_VAR_PARALLEL_START": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ENV_XDG_CACHE_HOME": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "EPOCH_DEPRECATION_WARNING": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "EQUAL_BUT_UKNOWN": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ERR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ERROR_NOT_READY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "EXCLUSIVE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "EXEC_EXT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "EXTERN_IMPORT_COMPAT_NAME_MAPPING": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "EXTRA_DIR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "EXTRA_INCLUDE_PATHS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "EXTRA_INPUTS_GETTER_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "EdgeOrNode": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Einsum": {
    "description": "Sums the product of the elements of the input operands along dimensions specified using a notation based on the Einstein summation convention.",
    "std_args": [
      "equation",
      "operands"
    ],
    "variants": {}
  },
  "ElasticAgent": {
    "description": "An agent process responsible for managing one or more worker processes.",
    "std_args": [],
    "type": "class"
  },
  "ElasticDistributedSampler": {
    "description": "Sampler that restricts data loading to a subset of",
    "std_args": [
      "self",
      "dataset",
      "num_replicas",
      "rank",
      "start_index"
    ],
    "type": "class"
  },
  "Elu": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "alpha"
    ],
    "type": "class"
  },
  "Embedding": {
    "description": "Lookup table for storing embeddings of a fixed dictionary and size.",
    "std_args": [
      "num_embeddings",
      "embedding_dim",
      "padding_idx",
      "max_norm",
      "norm_type",
      "scale_grad_by_freq",
      "sparse"
    ],
    "variants": {}
  },
  "EmbeddingBag": {
    "description": "An embedding bag module attached with FakeQuantize modules for weight,",
    "std_args": [
      "self",
      "num_embeddings",
      "embedding_dim",
      "max_norm",
      "norm_type",
      "scale_grad_by_freq",
      "mode",
      "sparse",
      "_weight",
      "include_last_offset",
      "padding_idx",
      "qconfig",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "EmbeddingPackedParams": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "num_embeddings",
      "embedding_dim",
      "dtype"
    ],
    "type": "class"
  },
  "EmbeddingQuantizeHandler": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "node_pattern",
      "modules",
      "root_node_getter",
      "is_custom_module",
      "is_standalone_module"
    ],
    "type": "class"
  },
  "EmbeddingQuantizer": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "EmptyMatchError": {
    "description": "This is an exception that is thrown when a mock or extern is marked as",
    "std_args": [],
    "type": "class"
  },
  "EnforceUnique": {
    "description": "Raises an error if a key is seen more than once.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "Equality": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "lhs",
      "rhs"
    ],
    "type": "class"
  },
  "EqualityConstraint": {
    "description": "Represent and decide various kinds of equality constraints between input sources.",
    "std_args": [
      "self",
      "warn_only",
      "source_pairs",
      "derived_equalities",
      "phantom_symbols",
      "relaxed_sources"
    ],
    "type": "class"
  },
  "Error": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ErrorHandler": {
    "description": "Write the provided exception object along with some other metadata about",
    "std_args": [],
    "type": "class"
  },
  "EtcdRendezvous": {
    "description": "A rendezvous implementation that uses `etcd <https://etcd.io/>`__ as the backend store.",
    "std_args": [
      "self",
      "client",
      "prefix",
      "run_id",
      "num_min_workers",
      "num_max_workers",
      "timeout",
      "last_call_timeout"
    ],
    "type": "class"
  },
  "EtcdRendezvousBackend": {
    "description": "Represents an etcd-based rendezvous backend.",
    "std_args": [
      "self",
      "client",
      "run_id",
      "key_prefix",
      "ttl"
    ],
    "type": "class"
  },
  "EtcdRendezvousHandler": {
    "description": "Implements a",
    "std_args": [
      "self",
      "rdzv_impl",
      "local_addr"
    ],
    "type": "class"
  },
  "EtcdRendezvousRetryImmediately": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "EtcdRendezvousRetryableFailure": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "EtcdServer": {
    "description": ".. note:: tested on etcd server v3.4.3.",
    "std_args": [
      "self",
      "data_dir"
    ],
    "type": "class"
  },
  "EtcdStore": {
    "description": "Implement a c10 Store interface by piggybacking on the rendezvous etcd instance.",
    "std_args": [
      "self",
      "etcd_client",
      "etcd_store_prefix",
      "timeout"
    ],
    "type": "class"
  },
  "EvalEnv": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "rcb"
    ],
    "type": "class"
  },
  "Event": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "EventList": {
    "description": "A list of Events (for pretty printing).",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "EventMetadataValue": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "EventSource": {
    "description": "Known identifiers of the event producers.",
    "std_args": [],
    "type": "class"
  },
  "ExampleAggregateAsDataFrames": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "source_datapipe",
      "dataframe_size",
      "columns"
    ],
    "type": "class"
  },
  "ExecutionStats": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "c_stats",
      "benchmark_config"
    ],
    "type": "class"
  },
  "ExecutionTraceObserver": {
    "description": "Execution Trace Observer",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "ExpRelaxedCategorical": {
    "description": "Creates a ExpRelaxedCategorical parameterized by",
    "std_args": [
      "self",
      "temperature",
      "probs",
      "logits",
      "validate_args"
    ],
    "type": "class"
  },
  "ExpTransform": {
    "description": "Transform via the mapping :math:`y = \\exp(x)`.",
    "std_args": [
      "self",
      "cache_size"
    ],
    "type": "class"
  },
  "Exponential": {
    "description": "Creates a Exponential distribution parameterized by :attr:`rate`.",
    "std_args": [
      "self",
      "rate",
      "validate_args"
    ],
    "type": "class"
  },
  "ExponentialFamily": {
    "description": "ExponentialFamily is the abstract base class for probability distributions belonging to an",
    "std_args": [
      "self",
      "batch_shape",
      "event_shape",
      "validate_args"
    ],
    "type": "class"
  },
  "ExponentialLR": {
    "description": "Decays the learning rate of each parameter group by gamma every epoch.",
    "std_args": [
      "self",
      "optimizer",
      "gamma",
      "last_epoch"
    ],
    "type": "class"
  },
  "ExportBackwardSignature": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "gradients_to_parameters",
      "gradients_to_user_inputs",
      "loss_output"
    ],
    "type": "class"
  },
  "ExportGraphSignature": {
    "description": ":class:`ExportGraphSignature` models the input/output signature of Export Graph,",
    "std_args": [
      "self",
      "input_specs",
      "output_specs"
    ],
    "type": "class"
  },
  "ExportedProgram": {
    "description": "Package of a program from :func:`export`. It contains",
    "std_args": [
      "self",
      "root",
      "graph",
      "graph_signature",
      "state_dict",
      "range_constraints",
      "module_call_graph",
      "example_inputs",
      "constants",
      "verifiers"
    ],
    "type": "class"
  },
  "ExprBuilder": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "ExternalStream": {
    "description": "Wrapper around an externally allocated CUDA stream.",
    "std_args": [],
    "type": "class"
  },
  "F": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FAIL": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FAILED": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FAILED_BATCHED_GRAD_MSG": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FAILED_BATCHED_GRAD_MSG_FWD_AD": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FAILED_NONDET_MSG": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FAST_FAIL_SLOW_OK_MSG": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FLAT_PARAM": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FLOAT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FLOAT_TO_OBSERVED_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FORCE_USE_FLEX_ATTENTION": {
    "description": "If True, forces the use of the flex attention kernel instead of potentially using",
    "std_args": [],
    "type": "attribute"
  },
  "FP16": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FP16_COMPRESS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FP32": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FP32_OR_INT8": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FQNS_T": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FULL_BACKWARD": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FULL_SHARD": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FULL_STATE_DICT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FUSED_MODULE_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FUSER_METHOD_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FXFloatFunctional": {
    "description": "module to replace FloatFunctional module before FX graph mode quantization,",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "FakeClass": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "module",
      "name"
    ],
    "type": "class"
  },
  "FakeObject": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "module",
      "name",
      "args"
    ],
    "type": "class"
  },
  "FakeQuantize": {
    "description": "Simulate the quantize and dequantize operations in training time.",
    "std_args": [
      "self",
      "observer",
      "quant_min",
      "quant_max",
      "is_dynamic",
      "observer_kwargs"
    ],
    "type": "class"
  },
  "FakeQuantizeBase": {
    "description": "Base fake quantize module.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "FakeSparsity": {
    "description": "Parametrization for the weights. Should be attached to the 'weight' or",
    "std_args": [
      "self",
      "mask"
    ],
    "type": "class"
  },
  "FakeTensorMeta": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "tensor_size",
      "tensor_stride",
      "tensor_storage_offset",
      "is_nested"
    ],
    "type": "class"
  },
  "FakeTensorProp": {
    "description": "Execute an FX graph Node-by-Node and record a fake tensor representing",
    "std_args": [
      "self",
      "module",
      "mode"
    ],
    "type": "class"
  },
  "FauxTorch": {
    "description": "Emulate different versions of pytorch.",
    "std_args": [
      "self",
      "real_torch",
      "extra_ns_per_element"
    ],
    "type": "class"
  },
  "FeatureAlphaDropout": {
    "description": "Randomly masks out entire channels.",
    "std_args": [
      "self",
      "p",
      "inplace"
    ],
    "type": "class"
  },
  "FileBaton": {
    "description": "A primitive, file-based synchronization utility.",
    "std_args": [
      "self",
      "lock_file_path",
      "wait_seconds",
      "warn_after_seconds"
    ],
    "type": "class"
  },
  "FileLike": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FileListerIterDataPipe": {
    "description": "Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.",
    "std_args": [
      "self",
      "root",
      "masks",
      "recursive",
      "abspath",
      "non_deterministic",
      "length"
    ],
    "type": "class"
  },
  "FileOpenerIterDataPipe": {
    "description": "Given pathnames, opens files and yield pathname and file stream in a tuple (functional name: ``open_files``).",
    "std_args": [
      "self",
      "datapipe",
      "mode",
      "encoding",
      "length"
    ],
    "type": "class"
  },
  "FileSystem": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "FileSystemBase": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "FileSystemReader": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "path",
      "_extension_registry"
    ],
    "type": "class"
  },
  "FileSystemWriter": {
    "description": "Basic implementation of StorageWriter using file IO.",
    "std_args": [
      "self",
      "path",
      "single_file_per_rank",
      "sync_files",
      "thread_count",
      "per_thread_copy_ahead",
      "cache_staged_state_dict",
      "overwrite",
      "_extensions",
      "serialization_format"
    ],
    "type": "class"
  },
  "FileTimerClient": {
    "description": "Client side of ``FileTimerServer``. This client is meant to be used",
    "std_args": [
      "self",
      "file_path",
      "signal"
    ],
    "type": "class"
  },
  "FileTimerRequest": {
    "description": "Data object representing a countdown timer acquisition and release",
    "std_args": [
      "self",
      "worker_pid",
      "scope_id",
      "expiration_time",
      "signal"
    ],
    "type": "class"
  },
  "FileTimerServer": {
    "description": "Server that works with ``FileTimerClient``. Clients are expected to be",
    "std_args": [
      "self",
      "file_path",
      "run_id",
      "max_interval",
      "daemon",
      "log_event"
    ],
    "type": "class"
  },
  "FileWriter": {
    "description": "Writes protocol buffers to event files to be consumed by TensorBoard.",
    "std_args": [
      "self",
      "log_dir",
      "max_queue",
      "flush_secs",
      "filename_suffix"
    ],
    "type": "class"
  },
  "FilterDataFramesPipe": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "source_datapipe",
      "filter_fn"
    ],
    "type": "class"
  },
  "FilterFn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FilterIterDataPipe": {
    "description": "Filters out elements from the source datapipe according to input ``filter_fn`` (functional name: ``filter``).",
    "std_args": [
      "self",
      "datapipe",
      "filter_fn",
      "input_col"
    ],
    "type": "class"
  },
  "FisherSnedecor": {
    "description": "Creates a Fisher-Snedecor distribution parameterized by :attr:`df1` and :attr:`df2`.",
    "std_args": [
      "self",
      "df1",
      "df2",
      "validate_args"
    ],
    "type": "class"
  },
  "FixedQParamsFakeQuantize": {
    "description": "Simulate quantize and dequantize in training time.",
    "std_args": [
      "self",
      "observer"
    ],
    "type": "class"
  },
  "FixedQParamsObserver": {
    "description": "Observer that simulates quantize and dequantize with fixed",
    "std_args": [
      "self",
      "scale",
      "zero_point",
      "dtype",
      "qscheme",
      "quant_min",
      "quant_max",
      "is_dynamic",
      "kwargs"
    ],
    "type": "class"
  },
  "FixedQParamsOpQuantizeHandler": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "node_pattern",
      "modules",
      "root_node_getter",
      "is_custom_module",
      "is_standalone_module"
    ],
    "type": "class"
  },
  "FixedQParamsQuantizationSpec": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "dtype",
      "scale",
      "zero_point",
      "quant_min",
      "quant_max",
      "qscheme",
      "is_dynamic"
    ],
    "type": "class"
  },
  "FlatArgsAdapter": {
    "description": "Adapts input arguments with ``input_spec`` to align ``target_spec``.",
    "std_args": [],
    "type": "class"
  },
  "Flatten": {
    "description": "Flattens input by reshaping it into a one-dimensional tensor.",
    "std_args": [
      "input",
      "start_dim",
      "end_dim"
    ],
    "variants": {}
  },
  "FlexKernelOptions": {
    "description": "Options for controlling the behavior of FlexAttention kernels.",
    "std_args": [],
    "type": "class"
  },
  "FloatFunctional": {
    "description": "State collector class for float operations.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "FloatLikeType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FloatStorage": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "device",
      "dtype",
      "wrap_storage",
      "_internal"
    ],
    "type": "class"
  },
  "FlopCounterMode": {
    "description": "``FlopCounterMode`` is a context manager that counts the number of flops within its context.",
    "std_args": [
      "self",
      "mods",
      "depth",
      "display",
      "custom_mapping"
    ],
    "type": "class"
  },
  "Fold": {
    "description": "Combines an array of sliding local blocks into a large containing tensor.",
    "std_args": [
      "self",
      "output_size",
      "kernel_size",
      "dilation",
      "padding",
      "stride"
    ],
    "type": "class"
  },
  "ForkerIterDataPipe": {
    "description": "Creates multiple instances of the same Iterable DataPipe (functional name: ``fork``).",
    "std_args": [],
    "type": "class"
  },
  "FormatMode": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "FormattedTimesMixin": {
    "description": "Helpers for FunctionEvent and FunctionEventAvg.",
    "std_args": [],
    "type": "class"
  },
  "FractionalMaxPool2d": {
    "description": "Applies a 2D fractional max pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "kernel_size",
      "output_size",
      "output_ratio",
      "return_indices",
      "_random_samples"
    ],
    "type": "class"
  },
  "FractionalMaxPool3d": {
    "description": "Applies a 3D fractional max pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "kernel_size",
      "output_size",
      "output_ratio",
      "return_indices",
      "_random_samples"
    ],
    "type": "class"
  },
  "FrontendError": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "source_range",
      "msg"
    ],
    "type": "class"
  },
  "FrontendTypeError": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "source_range",
      "msg"
    ],
    "type": "class"
  },
  "FullOptimStateDictConfig": {
    "description": "Attributes:",
    "std_args": [
      "self",
      "offload_to_cpu",
      "rank0_only"
    ],
    "type": "class"
  },
  "FullStateDictConfig": {
    "description": "``FullStateDictConfig`` is a config class meant to be used with",
    "std_args": [
      "self",
      "offload_to_cpu",
      "rank0_only"
    ],
    "type": "class"
  },
  "FullyShardedDataParallel": {
    "description": "A wrapper for sharding module parameters across data parallel workers.",
    "std_args": [
      "self",
      "module",
      "process_group",
      "sharding_strategy",
      "cpu_offload",
      "auto_wrap_policy",
      "backward_prefetch",
      "mixed_precision",
      "ignored_modules",
      "param_init_fn",
      "device_id",
      "sync_module_states",
      "forward_prefetch",
      "limit_all_gathers",
      "use_orig_params",
      "ignored_states",
      "device_mesh"
    ],
    "type": "class"
  },
  "FuncType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Function": {
    "description": "Base class to create custom `autograd.Function`.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "FunctionCount": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "FunctionCounts": {
    "description": "Container for manipulating Callgrind results.",
    "std_args": [
      "self",
      "_data",
      "inclusive",
      "truncate_rows",
      "_linewidth"
    ],
    "type": "class"
  },
  "FunctionCtx": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "FunctionEvent": {
    "description": "Profiling information about a single function.",
    "std_args": [
      "self",
      "id",
      "name",
      "thread",
      "start_us",
      "end_us",
      "overload_name",
      "fwd_thread",
      "input_shapes",
      "stack",
      "scope",
      "use_device",
      "cpu_memory_usage",
      "device_memory_usage",
      "is_async",
      "is_remote",
      "sequence_nr",
      "node_id",
      "device_type",
      "device_index",
      "device_resource_id",
      "is_legacy",
      "flops",
      "trace_name",
      "concrete_inputs",
      "kwinputs",
      "is_user_annotation"
    ],
    "type": "class"
  },
  "FunctionEventAvg": {
    "description": "Used to average stats over multiple FunctionEvent objects.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "FunctionMeta": {
    "description": "Function metaclass.",
    "std_args": [
      "cls",
      "name",
      "bases",
      "attrs"
    ],
    "type": "class"
  },
  "FuseCustomConfig": {
    "description": "Custom configuration for :func:`~torch.ao.quantization.quantize_fx.fuse_fx`.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "FuseHandler": {
    "description": "Base handler class for the fusion patterns",
    "std_args": [
      "self",
      "node"
    ],
    "type": "class"
  },
  "FusedMovingAvgObsFakeQuantize": {
    "description": "Define a fused module to observe the tensor.",
    "std_args": [
      "self",
      "observer",
      "quant_min",
      "quant_max",
      "observer_kwargs"
    ],
    "type": "class"
  },
  "FusionGroup": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "top_node_idx",
      "nodes",
      "inputs",
      "nodes_need_process"
    ],
    "type": "class"
  },
  "Future": {
    "description": "Wrapper around a ``torch._C.Future`` which encapsulates an asynchronous",
    "std_args": [
      "self",
      "devices"
    ],
    "type": "class"
  },
  "FuzzedParameter": {
    "description": "Specification for a parameter to be generated during fuzzing.",
    "std_args": [
      "self",
      "name",
      "minval",
      "maxval",
      "distribution",
      "strict"
    ],
    "type": "class"
  },
  "FuzzedSparseTensor": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "name",
      "size",
      "min_elements",
      "max_elements",
      "dim_parameter",
      "sparse_dim",
      "nnz",
      "density",
      "coalesced",
      "dtype",
      "cuda"
    ],
    "type": "class"
  },
  "FuzzedTensor": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "name",
      "size",
      "steps",
      "probability_contiguous",
      "min_elements",
      "max_elements",
      "max_allocation_bytes",
      "dim_parameter",
      "roll_parameter",
      "dtype",
      "cuda",
      "tensor_constructor"
    ],
    "type": "class"
  },
  "Fuzzer": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "parameters",
      "tensors",
      "constraints",
      "seed"
    ],
    "type": "class"
  },
  "FxGraphDrawer": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "graph_module",
      "name",
      "ignore_getattr",
      "ignore_parameters_and_buffers",
      "skip_node_names_in_args",
      "parse_stack_trace",
      "dot_graph_shape",
      "normalize_args"
    ],
    "type": "class"
  },
  "FxNetAccFusionsFinder": {
    "description": "Finds groups of connected ACC nodes that pass non-tensor data between each other.",
    "std_args": [
      "self",
      "module",
      "acc_nodes"
    ],
    "type": "class"
  },
  "FxNetAccNodesFinder": {
    "description": "Finds a set of nodes that can be supported on ACC, excluding nodes that have non-tensor",
    "std_args": [
      "self",
      "module",
      "operator_support",
      "allow_non_tensor"
    ],
    "type": "class"
  },
  "FxNetMinimizerResultMismatchError": {
    "description": "Raised if comparing function thinks the results are mismatching.",
    "std_args": [],
    "type": "class"
  },
  "FxNetMinimizerRunFuncError": {
    "description": "Raised if error occurs during run_a or run_b functions",
    "std_args": [],
    "type": "class"
  },
  "FxNetSplitterInternalError": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "GELU": {
    "description": "Gaussian Error Linear Unit.",
    "std_args": [
      "input"
    ],
    "variants": {}
  },
  "GLOO": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "GOOD": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "GRADIENT_TO_PARAMETER": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "GRADIENT_TO_USER_INPUT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "GRID_SAMPLE_INTERPOLATION_MODES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "GRID_SAMPLE_PADDING_MODES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Gamma": {
    "description": "Creates a Gamma distribution parameterized by shape :attr:`concentration` and :attr:`rate`.",
    "std_args": [
      "self",
      "concentration",
      "rate",
      "validate_args"
    ],
    "type": "class"
  },
  "Gather": {
    "description": "Gathers values along an axis specified by dim.",
    "std_args": [
      "input",
      "dim",
      "index"
    ],
    "variants": {}
  },
  "GaussianNLLLoss": {
    "description": "Gaussian negative log likelihood loss.",
    "std_args": [
      "self",
      "full",
      "eps",
      "reduction"
    ],
    "type": "class"
  },
  "GdsFile": {
    "description": "Wrapper around cuFile.",
    "std_args": [
      "self",
      "filename",
      "flags"
    ],
    "type": "class"
  },
  "GeneralTensorShapeOpQuantizeHandler": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "node_pattern",
      "modules",
      "root_node_getter",
      "is_custom_module",
      "is_standalone_module"
    ],
    "type": "class"
  },
  "GeneralizedPareto": {
    "description": "Creates a Generalized Pareto distribution parameterized by :attr:`loc`, :attr:`scale`, and :attr:`concentration`.",
    "std_args": [
      "self",
      "loc",
      "scale",
      "concentration",
      "validate_args"
    ],
    "type": "class"
  },
  "GeneratedFileCleaner": {
    "description": "Context Manager to clean up generated files",
    "std_args": [
      "self",
      "keep_intermediates"
    ],
    "type": "class"
  },
  "GenericWithOneTypeVar": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Geometric": {
    "description": "Creates a Geometric distribution parameterized by :attr:`probs`,",
    "std_args": [
      "self",
      "probs",
      "logits",
      "validate_args"
    ],
    "type": "class"
  },
  "GetItem": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "tensor_size",
      "index",
      "res",
      "input_var"
    ],
    "type": "class"
  },
  "GetItemTensor": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "tensor_size",
      "index_tuple",
      "res",
      "input_var"
    ],
    "type": "class"
  },
  "GlobGroup": {
    "description": "A set of patterns that candidate strings will be matched against.",
    "std_args": [
      "self",
      "include",
      "exclude",
      "separator"
    ],
    "type": "class"
  },
  "GlobPattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "GlobalOptimizerPostHook": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "GlobalOptimizerPreHook": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "GlobalRank": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "GlobalsBridge": {
    "description": "Handle the transfer of (certain) globals when collecting Callgrind statistics.",
    "std_args": [
      "self",
      "globals",
      "data_dir"
    ],
    "type": "class"
  },
  "Glu": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "dim"
    ],
    "type": "class"
  },
  "GradScaler": {
    "description": "An instance ``scaler`` of :class:`GradScaler`.",
    "std_args": [
      "self",
      "device",
      "init_scale",
      "growth_factor",
      "backoff_factor",
      "growth_interval",
      "enabled"
    ],
    "type": "class"
  },
  "GradcheckError": {
    "description": "Error raised by :func:`gradcheck` and :func:`gradgradcheck`.",
    "std_args": [],
    "type": "class"
  },
  "GradientEdge": {
    "description": "Object representing a given gradient edge within the autograd graph.",
    "std_args": [],
    "type": "class"
  },
  "Granularity": {
    "description": "Base class for representing the granularity of quantization.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "Graph": {
    "description": "``Graph`` is the main data structure used in the FX Intermediate Representation.",
    "std_args": [
      "self",
      "owning_module",
      "tracer_cls",
      "tracer_extras"
    ],
    "type": "class"
  },
  "GraphAppendingTracer": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "graph"
    ],
    "type": "class"
  },
  "GraphMatchingException": {
    "description": "Exception raised when two graphs cannot be matched.",
    "std_args": [],
    "type": "class"
  },
  "GraphTransformObserver": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "gm",
      "passname",
      "subsystem",
      "log_url"
    ],
    "type": "class"
  },
  "GraphTypeChecker": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "env",
      "traced"
    ],
    "type": "class"
  },
  "Grayscale": {
    "description": "Convert image to grayscale.",
    "std_args": [
      "num_output_channels"
    ],
    "variants": {}
  },
  "GroupMember": {
    "description": "Group member class.",
    "std_args": [],
    "type": "class"
  },
  "GrouperIterDataPipe": {
    "description": "Groups data from IterDataPipe by keys from ``group_key_fn``, yielding a ``DataChunk`` with batch size up to ``group_size``.",
    "std_args": [
      "self",
      "datapipe",
      "group_key_fn",
      "keep_key",
      "buffer_size",
      "group_size",
      "guaranteed_group_size",
      "drop_remaining"
    ],
    "type": "class"
  },
  "Groupnorm": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "dtype",
      "eps",
      "num_groups"
    ],
    "type": "class"
  },
  "Grucell": {
    "description": "Auto-discovered via Consensus (Score: 3.0)",
    "std_args": [
      "dtype"
    ],
    "type": "class"
  },
  "GuardOnDataDependentSymNode": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "cond",
      "args"
    ],
    "type": "class"
  },
  "Gumbel": {
    "description": "Samples from a Gumbel Distribution.",
    "std_args": [
      "self",
      "loc",
      "scale",
      "validate_args"
    ],
    "type": "class"
  },
  "HANDLED_TYPES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "HASH_REGEX": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "HAS_DILL": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "HAS_NUMPY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "HAS_PYDOT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "HAS_TABULATE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "HAS_Z3": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "HEADER": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "HEALTHY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "HIPIFY_C_BREADCRUMB": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "HIPIFY_FINAL_RESULT": {
    "description": "This dictionary provides the mapping from PyTorch kernel template types",
    "std_args": [],
    "type": "attribute"
  },
  "HIP_HOME": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "HIP_UNSUPPORTED": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "HYBRID_SHARD": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "HalfCauchy": {
    "description": "Creates a half-Cauchy distribution parameterized by `scale` where::",
    "std_args": [
      "self",
      "scale",
      "validate_args"
    ],
    "type": "class"
  },
  "HalfNormal": {
    "description": "Creates a half-normal distribution parameterized by `scale` where::",
    "std_args": [
      "self",
      "scale",
      "validate_args"
    ],
    "type": "class"
  },
  "HalfStorage": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "device",
      "dtype",
      "wrap_storage",
      "_internal"
    ],
    "type": "class"
  },
  "Hardshrink": {
    "description": "Applies the Hard Shrinkage (Hardshrink) function element-wise.",
    "std_args": [
      "self",
      "lambd"
    ],
    "type": "class"
  },
  "Hardtanh": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "function"
  },
  "HealthCheckServer": {
    "description": "Interface for health check monitoring server, which can be extended",
    "std_args": [
      "self",
      "alive_callback",
      "port",
      "timeout"
    ],
    "type": "class"
  },
  "HierarchicalModelAverager": {
    "description": "Runs hierarchical model averaging (`hierarchical SGD <https://arxiv.org/pdf/2010.12998.pdf>`_).",
    "std_args": [
      "self",
      "period_group_size_dict",
      "warmup_steps",
      "process_group"
    ],
    "type": "class"
  },
  "HingeEmbeddingLoss": {
    "description": "Measures the loss given an input tensor :math:`x` and a labels tensor :math:`y`",
    "std_args": [
      "self",
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "HipifyFinalResult": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "HipifyResult": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "current_state",
      "hipified_path"
    ],
    "type": "class"
  },
  "HistogramObserver": {
    "description": "The module records the running histogram of tensor values along with",
    "std_args": [
      "self",
      "bins",
      "dtype",
      "qscheme",
      "reduce_range",
      "quant_min",
      "quant_max",
      "factory_kwargs",
      "eps",
      "is_dynamic",
      "kwargs"
    ],
    "type": "class"
  },
  "HuberLoss": {
    "description": "Creates a criterion that uses a squared term if the absolute",
    "std_args": [
      "self",
      "reduction",
      "delta"
    ],
    "type": "class"
  },
  "HuggingFaceStorageReader": {
    "description": "A reader that reads a checkpoint in the huggingface safetensors format.",
    "std_args": [
      "self",
      "path",
      "thread_count"
    ],
    "type": "class"
  },
  "HuggingFaceStorageWriter": {
    "description": "A writer that writes to storage in the huggingface safetensors format.",
    "std_args": [
      "self",
      "path",
      "fqn_to_index_mapping",
      "thread_count",
      "save_distributed",
      "enable_consolidation",
      "thread_count_consolidation"
    ],
    "type": "class"
  },
  "I": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "IMPLICIT_IMPORT_ALLOWLIST": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "INFER_STRIDE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "INIT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "INITIALIZED": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "INPLACE_BINARY_NAMES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "INPLACE_UNARY_NAMES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "INPUT_DTYPE_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "INPUT_OUTPUT_NOT_OBSERVED": {
    "description": "this means the input and output are never observed",
    "std_args": [],
    "type": "attribute"
  },
  "INPUT_QUANTIZED_INDEXES_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "INPUT_TYPE_TO_INDEX_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "INSTANTIATED_TEMPLATE_DIR_PATH": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "INT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "INT1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "INT2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "INT3": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "INT4": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "INT5": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "INT6": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "INT7": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "INT8": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "INT_SIZE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "IS_DYNAMIC_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "IS_HIP_EXTENSION": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "IS_LINUX": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "IS_MACOS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "IS_WINDOWS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Identity": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "kwargs"
    ],
    "type": "class"
  },
  "ImageHandler": {
    "description": "Decode image data using the given `imagespec`.",
    "std_args": [
      "self",
      "imagespec"
    ],
    "type": "class"
  },
  "Importer": {
    "description": "Represents an environment to import modules from.",
    "std_args": [],
    "type": "class"
  },
  "Independent": {
    "description": "Reinterprets some of the batch dims of a distribution as event dims.",
    "std_args": [
      "self",
      "base_distribution",
      "reinterpreted_batch_ndims",
      "validate_args"
    ],
    "type": "class"
  },
  "IndependentTransform": {
    "description": "Wrapper around another transform to treat",
    "std_args": [
      "self",
      "base_transform",
      "reinterpreted_batch_ndims",
      "cache_size"
    ],
    "type": "class"
  },
  "IndexSelect": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "tensor_size",
      "input_var",
      "dim_replace",
      "index",
      "output"
    ],
    "type": "class"
  },
  "IndicatorTypes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "InflatableArg": {
    "description": "Helper type for bundled inputs.",
    "std_args": [],
    "type": "class"
  },
  "InnerTensorKey": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "inner_name"
    ],
    "type": "class"
  },
  "InplaceFunction": {
    "description": "This class is here only for backward compatibility reasons.",
    "std_args": [
      "self",
      "inplace"
    ],
    "type": "class"
  },
  "InputError": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "message"
    ],
    "type": "class"
  },
  "InputInfo": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "InputKind": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "InputList": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "InputSpec": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "kind",
      "arg",
      "target",
      "persistent"
    ],
    "type": "class"
  },
  "InstanceNorm1d": {
    "description": "This is the quantized version of :class:`~torch.nn.InstanceNorm1d`.",
    "std_args": [
      "self",
      "num_features",
      "weight",
      "bias",
      "scale",
      "zero_point",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "InstanceNorm2d": {
    "description": "This is the quantized version of :class:`~torch.nn.InstanceNorm2d`.",
    "std_args": [
      "self",
      "num_features",
      "weight",
      "bias",
      "scale",
      "zero_point",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "InstanceNorm3d": {
    "description": "This is the quantized version of :class:`~torch.nn.InstanceNorm3d`.",
    "std_args": [
      "self",
      "num_features",
      "weight",
      "bias",
      "scale",
      "zero_point",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "Int": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "IntLikeType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "IntStorage": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "device",
      "dtype",
      "wrap_storage",
      "_internal"
    ],
    "type": "class"
  },
  "InternalMatch": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "anchors",
      "nodes_map",
      "placeholder_nodes",
      "returning_nodes",
      "name_node_map"
    ],
    "type": "class"
  },
  "Interpreter": {
    "description": "An Interpreter executes an FX graph Node-by-Node. This pattern",
    "std_args": [
      "self",
      "module",
      "garbage_collect_values",
      "graph"
    ],
    "type": "class"
  },
  "Interval": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "start",
      "end"
    ],
    "type": "class"
  },
  "InverseGamma": {
    "description": "Creates an inverse gamma distribution parameterized by :attr:`concentration` and :attr:`rate`",
    "std_args": [
      "self",
      "concentration",
      "rate",
      "validate_args"
    ],
    "type": "class"
  },
  "IsNodeSupported": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "IterDataPipe": {
    "description": "Iterable-style DataPipe.",
    "std_args": [],
    "type": "class"
  },
  "IterableDataset": {
    "description": "An iterable Dataset.",
    "std_args": [],
    "type": "class"
  },
  "IterableWrapperIterDataPipe": {
    "description": "Wraps an iterable object to create an IterDataPipe.",
    "std_args": [
      "self",
      "iterable",
      "deepcopy"
    ],
    "type": "class"
  },
  "IterateExprs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "IterateExprsAtom": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "JIT_EXTENSION_VERSIONER": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "JSON": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Join": {
    "description": "This class defines the generic join context manager, which allows custom hooks to be called after a process joins.",
    "std_args": [
      "self",
      "joinables",
      "enable",
      "throw_on_early_termination",
      "kwargs"
    ],
    "type": "class"
  },
  "JoinHook": {
    "description": "This defines a join hook, which provides two entry points in the join context manager.",
    "std_args": [],
    "type": "class"
  },
  "Joinable": {
    "description": "This defines an abstract base class for joinable classes.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "K": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "KEYS_NOT_IN_STATE_DICT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "KLDivLoss": {
    "description": "The Kullback-Leibler divergence loss.",
    "std_args": [
      "self",
      "size_average",
      "reduce",
      "reduction",
      "log_target"
    ],
    "type": "class"
  },
  "Kernel": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "KinetoStepTracker": {
    "description": "Provides an abstraction for incrementing the step count globally.",
    "std_args": [],
    "type": "class"
  },
  "Kumaraswamy": {
    "description": "Samples from a Kumaraswamy distribution.",
    "std_args": [
      "self",
      "concentration1",
      "concentration0",
      "validate_args"
    ],
    "type": "class"
  },
  "Kwargs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "L": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "L1Loss": {
    "description": "Creates a criterion that measures the mean absolute error (MAE) between each element in",
    "std_args": [
      "self",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "L1Unstructured": {
    "description": "Prune (currently unpruned) units in a tensor by zeroing out the ones with the lowest L1-norm.",
    "std_args": [
      "self",
      "amount"
    ],
    "type": "class"
  },
  "LIB_EXT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "LITTLE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "LKJCholesky": {
    "description": "LKJ distribution for lower Cholesky factor of correlation matrices.",
    "std_args": [
      "self",
      "dim",
      "concentration",
      "validate_args"
    ],
    "type": "class"
  },
  "LOCAL_STATE_DICT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "LOCK": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "LONG_SIZE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "LOSS_OUTPUT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "LOWER_RIGHT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "LPPool1d": {
    "description": "Applies a 1D power-average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "norm_type",
      "kernel_size",
      "stride",
      "ceil_mode"
    ],
    "type": "class"
  },
  "LPPool2d": {
    "description": "Applies a 2D power-average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "norm_type",
      "kernel_size",
      "stride",
      "ceil_mode"
    ],
    "type": "class"
  },
  "LPPool3d": {
    "description": "Applies a 3D power-average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "norm_type",
      "kernel_size",
      "stride",
      "ceil_mode"
    ],
    "type": "class"
  },
  "LRScheduler": {
    "description": "Adjusts the learning rate during optimization.",
    "std_args": [
      "self",
      "optimizer",
      "last_epoch"
    ],
    "type": "class"
  },
  "LambdaLR": {
    "description": "Sets the initial learning rate.",
    "std_args": [
      "self",
      "optimizer",
      "lr_lambda",
      "last_epoch"
    ],
    "type": "class"
  },
  "LambdaSL": {
    "description": "Sets the sparsity level of each parameter group to the final sl",
    "std_args": [
      "self",
      "sparsifier",
      "sl_lambda",
      "last_epoch",
      "verbose"
    ],
    "type": "class"
  },
  "Language": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Laplace": {
    "description": "Creates a Laplace distribution parameterized by :attr:`loc` and :attr:`scale`.",
    "std_args": [
      "self",
      "loc",
      "scale",
      "validate_args"
    ],
    "type": "class"
  },
  "LaunchConfig": {
    "description": "Creates a rendezvous config.",
    "std_args": [
      "self",
      "min_nodes",
      "max_nodes",
      "nproc_per_node",
      "logs_specs",
      "run_id",
      "role",
      "rdzv_endpoint",
      "rdzv_backend",
      "rdzv_configs",
      "rdzv_timeout",
      "max_restarts",
      "monitor_interval",
      "start_method",
      "log_line_prefix_template",
      "metrics_cfg",
      "local_addr",
      "event_log_handler",
      "numa_options"
    ],
    "type": "class"
  },
  "LayerNorm": {
    "description": "Applies Layer Normalization over a mini-batch of inputs.",
    "std_args": [
      "normalized_shape",
      "eps",
      "elementwise_affine",
      "bias"
    ],
    "variants": {}
  },
  "LazyBatchNorm1d": {
    "description": "A :class:`torch.nn.BatchNorm1d` module with lazy initialization.",
    "std_args": [
      "self",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyBatchNorm2d": {
    "description": "A :class:`torch.nn.BatchNorm2d` module with lazy initialization.",
    "std_args": [
      "self",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyBatchNorm3d": {
    "description": "A :class:`torch.nn.BatchNorm3d` module with lazy initialization.",
    "std_args": [
      "self",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyConv1d": {
    "description": "A :class:`torch.nn.Conv1d` module with lazy initialization of the ``in_channels`` argument.",
    "std_args": [
      "self",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyConv2d": {
    "description": "A :class:`torch.nn.Conv2d` module with lazy initialization of the ``in_channels`` argument.",
    "std_args": [
      "self",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyConv3d": {
    "description": "A :class:`torch.nn.Conv3d` module with lazy initialization of the ``in_channels`` argument.",
    "std_args": [
      "self",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyConvTranspose1d": {
    "description": "A :class:`torch.nn.ConvTranspose1d` module with lazy initialization of the ``in_channels`` argument.",
    "std_args": [
      "self",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "output_padding",
      "groups",
      "bias",
      "dilation",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyConvTranspose2d": {
    "description": "A :class:`torch.nn.ConvTranspose2d` module with lazy initialization of the ``in_channels`` argument.",
    "std_args": [
      "self",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "output_padding",
      "groups",
      "bias",
      "dilation",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyConvTranspose3d": {
    "description": "A :class:`torch.nn.ConvTranspose3d` module with lazy initialization of the ``in_channels`` argument.",
    "std_args": [
      "self",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "output_padding",
      "groups",
      "bias",
      "dilation",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyInstanceNorm1d": {
    "description": "A :class:`torch.nn.InstanceNorm1d` module with lazy initialization of the ``num_features`` argument.",
    "std_args": [
      "self",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyInstanceNorm2d": {
    "description": "A :class:`torch.nn.InstanceNorm2d` module with lazy initialization of the ``num_features`` argument.",
    "std_args": [
      "self",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyInstanceNorm3d": {
    "description": "A :class:`torch.nn.InstanceNorm3d` module with lazy initialization of the ``num_features`` argument.",
    "std_args": [
      "self",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyLinear": {
    "description": "A :class:`torch.nn.Linear` module where `in_features` is inferred.",
    "std_args": [
      "self",
      "out_features",
      "bias",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "Library": {
    "description": "A class to create libraries that can be used to register new operators or",
    "std_args": [
      "self",
      "ns",
      "kind",
      "dispatch_key"
    ],
    "type": "class"
  },
  "Linear": {
    "description": "Applies a linear transformation to the incoming data",
    "std_args": [
      "in_features",
      "out_features",
      "bias"
    ],
    "variants": {}
  },
  "LinearBlockSparsePattern": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "row_block_size",
      "col_block_size"
    ],
    "type": "class"
  },
  "LinearBn1d": {
    "description": "A LinearBn1d module is a module fused from Linear and BatchNorm1d, attached",
    "std_args": [
      "self",
      "in_features",
      "out_features",
      "bias",
      "eps",
      "momentum",
      "freeze_bn",
      "qconfig"
    ],
    "type": "class"
  },
  "LinearLR": {
    "description": "Decays the learning rate of each parameter group by linearly changing small multiplicative factor.",
    "std_args": [
      "self",
      "optimizer",
      "start_factor",
      "end_factor",
      "total_iters",
      "last_epoch"
    ],
    "type": "class"
  },
  "LinearLeakyReLU": {
    "description": "For onednn backend only",
    "std_args": [
      "self",
      "in_features",
      "out_features",
      "negative_slope",
      "bias",
      "dtype"
    ],
    "type": "class"
  },
  "LinearPackedParams": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "row_block_size",
      "col_block_size",
      "dtype"
    ],
    "type": "class"
  },
  "LinearReLU": {
    "description": "A LinearReLU module fused from Linear and ReLU modules, attached with",
    "std_args": [
      "self",
      "in_features",
      "out_features",
      "bias",
      "qconfig"
    ],
    "type": "class"
  },
  "LinearReLUQuantizeHandler": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "node_pattern",
      "modules",
      "root_node_getter",
      "is_custom_module",
      "is_standalone_module"
    ],
    "type": "class"
  },
  "LinearT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "LinearTanh": {
    "description": "A LinearTanh module fused from Linear and Tanh modules",
    "std_args": [
      "self",
      "in_features",
      "out_features",
      "bias",
      "dtype"
    ],
    "type": "class"
  },
  "LintCode": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "ListDictValueType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "LnStructured": {
    "description": "Prune entire (currently unpruned) channels in a tensor based on their L\\ ``n``-norm.",
    "std_args": [
      "self",
      "amount",
      "n",
      "dim"
    ],
    "type": "class"
  },
  "LoadEndianness": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "LoadItemType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "LoadPlan": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "items",
      "storage_data",
      "planner_data"
    ],
    "type": "class"
  },
  "LoadPlanner": {
    "description": "Abstract class defining the protocol used by load_state_dict to plan the load process.",
    "std_args": [],
    "type": "class"
  },
  "LoadStateDict": {
    "description": "Loading state utility for mappings.",
    "std_args": [],
    "variants": {}
  },
  "LocalElasticAgent": {
    "description": "An implementation of :py:class:`torchelastic.agent.server.ElasticAgent` that handles host-local workers.",
    "std_args": [
      "self",
      "spec",
      "logs_specs",
      "start_method",
      "exit_barrier_timeout",
      "log_line_prefix_template"
    ],
    "type": "class"
  },
  "LocalOptimStateDictConfig": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "offload_to_cpu"
    ],
    "type": "class"
  },
  "LocalResponseNorm": {
    "description": "Applies local response normalization over an input signal.",
    "std_args": [
      "self",
      "size",
      "alpha",
      "beta",
      "k"
    ],
    "type": "class"
  },
  "LocalStateDictConfig": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "offload_to_cpu"
    ],
    "type": "class"
  },
  "LocalTimerClient": {
    "description": "Client side of ``LocalTimerServer``. This client is meant to be used",
    "std_args": [
      "self",
      "mp_queue"
    ],
    "type": "class"
  },
  "LocalTimerServer": {
    "description": "Server that works with ``LocalTimerClient``. Clients are expected to be",
    "std_args": [
      "self",
      "mp_queue",
      "max_interval",
      "daemon"
    ],
    "type": "class"
  },
  "LogNormal": {
    "description": "Creates a log-normal distribution parameterized by",
    "std_args": [
      "self",
      "loc",
      "scale",
      "validate_args"
    ],
    "type": "class"
  },
  "LogSigmoid": {
    "description": "Applies the Logsigmoid function element-wise.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "LoggingShapeGuardPrinter": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "var_to_sources"
    ],
    "type": "class"
  },
  "LogisticNormal": {
    "description": "Creates a logistic-normal distribution parameterized by :attr:`loc` and :attr:`scale`",
    "std_args": [
      "self",
      "loc",
      "scale",
      "validate_args"
    ],
    "type": "class"
  },
  "LogitRelaxedBernoulli": {
    "description": "Creates a LogitRelaxedBernoulli distribution parameterized by :attr:`probs`",
    "std_args": [
      "self",
      "temperature",
      "probs",
      "logits",
      "validate_args"
    ],
    "type": "class"
  },
  "LogsDest": {
    "description": "For each log type, holds mapping of local rank ids to file paths.",
    "std_args": [
      "self",
      "stdouts",
      "stderrs",
      "tee_stdouts",
      "tee_stderrs",
      "error_files"
    ],
    "type": "class"
  },
  "LogsSpecs": {
    "description": "Defines logs processing and redirection for each worker process.",
    "std_args": [
      "self",
      "log_dir",
      "redirects",
      "tee",
      "local_ranks_filter"
    ],
    "type": "class"
  },
  "Logsumexp": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "b",
      "dim",
      "keepdim",
      "return_sign",
      "where",
      "x"
    ],
    "type": "attribute"
  },
  "LongStorage": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "device",
      "dtype",
      "wrap_storage",
      "_internal"
    ],
    "type": "class"
  },
  "LowRankMultivariateNormal": {
    "description": "Creates a multivariate normal distribution with covariance matrix having a low-rank form",
    "std_args": [
      "self",
      "loc",
      "cov_factor",
      "cov_diag",
      "validate_args"
    ],
    "type": "class"
  },
  "LowerCholeskyTransform": {
    "description": "Transform from unconstrained matrices to lower-triangular matrices with",
    "std_args": [
      "self",
      "cache_size"
    ],
    "type": "class"
  },
  "Lstmcell": {
    "description": "Auto-discovered via Consensus (Score: 3.0)",
    "std_args": [
      "dtype"
    ],
    "type": "class"
  },
  "MAGIC_NUMBER": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MAP_LOCATION": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MASTER_ADDR_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MASTER_PORT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MATH_TRANSPILATIONS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MAXBIT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MAXDIM": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MAX_DIM_SIZE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MAX_RAW_TENSOR_SIZE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MAX_TENSOR_RANK": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MDNotImplementedError": {
    "description": "A NotImplementedError for multiple dispatch",
    "std_args": [],
    "type": "class"
  },
  "MEMORY_EVENT_NAME": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "METHOD_TO_OPERATOR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MINIMUM_CLANG_VERSION": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MINIMUM_GCC_VERSION": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MINIMUM_MSVC_VERSION": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MIN_DIM_SIZE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MOCKED_BUT_STILL_USED": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MODELS_DIR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MODELS_FILENAME_FORMAT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MODULE_HUBCONF": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MODULE_INFO_PATH": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MPI": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MSELoss": {
    "description": "Mean Squared Error.",
    "std_args": [
      "input",
      "target"
    ],
    "variants": {}
  },
  "MSVC_IGNORE_CUDAFE_WARNINGS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MTIA_DIR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MULTIPROCESSING": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MUST_RECOMPUTE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MUST_SAVE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MapDataPipe": {
    "description": "Map-style DataPipe.",
    "std_args": [],
    "type": "class"
  },
  "MapperIterDataPipe": {
    "description": "Applies a function over each item from the source DataPipe (functional name: ``map``).",
    "std_args": [
      "self",
      "datapipe",
      "fn",
      "input_col",
      "output_col"
    ],
    "type": "class"
  },
  "MapperMapDataPipe": {
    "description": "Apply the input function over each item from the source DataPipe (functional name: ``map``).",
    "std_args": [
      "self",
      "datapipe",
      "fn"
    ],
    "type": "class"
  },
  "MappingType": {
    "description": "How floating point number is mapped to integer number",
    "std_args": [],
    "type": "class"
  },
  "MarginRankingLoss": {
    "description": "Creates a criterion that measures the loss given",
    "std_args": [
      "self",
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "MaskedTensor": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "data",
      "mask",
      "requires_grad"
    ],
    "type": "class"
  },
  "MatHandler": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "loadmat_kwargs"
    ],
    "type": "class"
  },
  "Match": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "MatchAllNode": {
    "description": "A node pattern that matches all nodes, used in defining",
    "std_args": [],
    "type": "class"
  },
  "MaxPool1d": {
    "description": "Applies a 1D max pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "return_indices",
      "ceil_mode"
    ],
    "type": "class"
  },
  "MaxPool3d": {
    "description": "Applies a 3D max pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "return_indices",
      "ceil_mode"
    ],
    "type": "class"
  },
  "MaxUnpool1d": {
    "description": "Computes a partial inverse of :class:`MaxPool1d`.",
    "std_args": [
      "self",
      "kernel_size",
      "stride",
      "padding"
    ],
    "type": "class"
  },
  "MaxUnpool2d": {
    "description": "Computes a partial inverse of :class:`MaxPool2d`.",
    "std_args": [
      "self",
      "kernel_size",
      "stride",
      "padding"
    ],
    "type": "class"
  },
  "MaxUnpool3d": {
    "description": "Computes a partial inverse of :class:`MaxPool3d`.",
    "std_args": [
      "self",
      "kernel_size",
      "stride",
      "padding"
    ],
    "type": "class"
  },
  "Measurement": {
    "description": "The result of a Timer measurement.",
    "std_args": [
      "self",
      "number_per_run",
      "raw_times",
      "task_spec",
      "metadata"
    ],
    "type": "class"
  },
  "MemPool": {
    "description": "MemPool represents a pool of memory in a caching allocator. Currently,",
    "std_args": [
      "self",
      "allocator",
      "use_on_oom"
    ],
    "type": "class"
  },
  "MemRecordsAcc": {
    "description": "Acceleration structure for accessing mem_records in interval.",
    "std_args": [
      "self",
      "mem_records"
    ],
    "type": "class"
  },
  "MetaAttribute": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "root",
      "attr"
    ],
    "type": "class"
  },
  "MetaDeviceAttribute": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "root",
      "attr"
    ],
    "type": "class"
  },
  "MetaProxy": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "node",
      "tracer"
    ],
    "type": "class"
  },
  "MetaTracer": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "autowrap_modules",
      "autowrap_functions",
      "param_shapes_constant"
    ],
    "type": "class"
  },
  "Metadata": {
    "description": "This class represents the metadata of the checkpoint.",
    "std_args": [
      "self",
      "state_dict_metadata",
      "planner_data",
      "storage_data",
      "storage_meta",
      "version"
    ],
    "type": "class"
  },
  "MetadataIndex": {
    "description": "This class represents a lookup key for items in a state dict or Metadata.",
    "std_args": [
      "self",
      "fqn",
      "offset",
      "index"
    ],
    "type": "class"
  },
  "MethodDispatcher": {
    "description": "Dispatch methods based on type signature",
    "std_args": [
      "self",
      "name",
      "doc"
    ],
    "type": "class"
  },
  "MetricData": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MetricHandler": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "MetricStream": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "group_name",
      "handler"
    ],
    "type": "class"
  },
  "MetricsConfig": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "params"
    ],
    "type": "class"
  },
  "MinMaxObserver": {
    "description": "Observer module for computing the quantization parameters based on the",
    "std_args": [
      "self",
      "dtype",
      "qscheme",
      "reduce_range",
      "quant_min",
      "quant_max",
      "factory_kwargs",
      "eps",
      "is_dynamic",
      "kwargs"
    ],
    "type": "class"
  },
  "Mish": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "x"
    ],
    "type": "class"
  },
  "MixedPrecision": {
    "description": "This configures FSDP-native mixed precision training.",
    "std_args": [
      "self",
      "param_dtype",
      "reduce_dtype",
      "buffer_dtype",
      "keep_low_precision_grads",
      "cast_forward_inputs",
      "cast_root_forward_inputs",
      "_module_classes_to_ignore"
    ],
    "type": "class"
  },
  "MixtureSameFamily": {
    "description": "The `MixtureSameFamily` distribution implements a (batch of) mixture",
    "std_args": [
      "self",
      "mixture_distribution",
      "component_distribution",
      "validate_args"
    ],
    "type": "class"
  },
  "MixtureSameFamilyConstraint": {
    "description": "Constraint for the :class:`~torch.distribution.MixtureSameFamily`",
    "std_args": [
      "self",
      "base_constraint"
    ],
    "type": "class"
  },
  "MklSubgraph": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "fx_graph"
    ],
    "type": "class"
  },
  "MkldnnBatchNorm": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "dense_module"
    ],
    "type": "class"
  },
  "MkldnnConv1d": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "dense_module",
      "dtype"
    ],
    "type": "class"
  },
  "MkldnnConv2d": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "dense_module",
      "dtype"
    ],
    "type": "class"
  },
  "MkldnnConv3d": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "dense_module",
      "dtype"
    ],
    "type": "class"
  },
  "MkldnnLinear": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "dense_module",
      "dtype"
    ],
    "type": "class"
  },
  "MkldnnPrelu": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "dense_module",
      "dtype"
    ],
    "type": "class"
  },
  "ModelAverager": {
    "description": "Base class for all model averagers.",
    "std_args": [
      "self",
      "process_group"
    ],
    "type": "class"
  },
  "MovingAverageMinMaxObserver": {
    "description": "Observer module for computing the quantization parameters based on the",
    "std_args": [
      "self",
      "averaging_constant",
      "dtype",
      "qscheme",
      "reduce_range",
      "quant_min",
      "quant_max",
      "eps",
      "is_dynamic",
      "kwargs"
    ],
    "type": "class"
  },
  "MovingAveragePerChannelMinMaxObserver": {
    "description": "Observer module for computing the quantization parameters based on the",
    "std_args": [
      "self",
      "averaging_constant",
      "ch_axis",
      "dtype",
      "qscheme",
      "reduce_range",
      "quant_min",
      "quant_max",
      "eps",
      "is_dynamic",
      "kwargs"
    ],
    "type": "class"
  },
  "MultiLabelMarginLoss": {
    "description": "Creates a criterion that optimizes a multi-class multi-classification",
    "std_args": [
      "self",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "MultiLabelSoftMarginLoss": {
    "description": "Creates a criterion that optimizes a multi-label one-versus-all",
    "std_args": [
      "self",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "MultiMarginLoss": {
    "description": "Creates a criterion that optimizes a multi-class classification hinge",
    "std_args": [
      "self",
      "p",
      "margin",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "MultiStepLR": {
    "description": "Decays the learning rate of each parameter group by gamma once the number of epoch reaches one of the milestones.",
    "std_args": [
      "self",
      "optimizer",
      "milestones",
      "gamma",
      "last_epoch"
    ],
    "type": "class"
  },
  "MultiheadAttention": {
    "description": "Multi-head attention mechanism. Supports repacking query/key/value via plugins.",
    "std_args": [
      "embed_dim",
      "num_heads",
      "dropout",
      "bias",
      "add_bias_kv",
      "add_zero_attn",
      "kdim",
      "vdim",
      "batch_first"
    ],
    "variants": {}
  },
  "MultiplexerIterDataPipe": {
    "description": "Yields one element at a time from each of the input Iterable DataPipes (functional name: ``mux``).",
    "std_args": [
      "self",
      "datapipes"
    ],
    "type": "class"
  },
  "MultiplicativeLR": {
    "description": "Multiply the learning rate of each parameter group by the factor given in the specified function.",
    "std_args": [
      "self",
      "optimizer",
      "lr_lambda",
      "last_epoch"
    ],
    "type": "class"
  },
  "MultiprocessContext": {
    "description": "``PContext`` holding worker processes invoked as a function.",
    "std_args": [
      "self",
      "name",
      "entrypoint",
      "args",
      "envs",
      "start_method",
      "logs_specs",
      "log_line_prefixes",
      "numa_options"
    ],
    "type": "class"
  },
  "MultiprocessingRequestQueue": {
    "description": "A ``RequestQueue`` backed by python ``multiprocessing.Queue``",
    "std_args": [
      "self",
      "mp_queue"
    ],
    "type": "class"
  },
  "MultivariateNormal": {
    "description": "Creates a multivariate normal (also called Gaussian) distribution",
    "std_args": [
      "self",
      "loc",
      "covariance_matrix",
      "precision_matrix",
      "scale_tril",
      "validate_args"
    ],
    "type": "class"
  },
  "NAMELESS_SCHEMA": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NAME_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NATIVE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NATIVE_BINARY_FNS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NATIVE_BINARY_MAP": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NATIVE_INPLACE_BINARY_FNS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NATIVE_INPLACE_BINARY_MAP": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NATIVE_INPLACE_UNARY_FNS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NATIVE_INPLACE_UNARY_MAP": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NATIVE_REDUCE_FNS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NATIVE_REDUCE_MAP": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NATIVE_UNARY_FNS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NATIVE_UNARY_MAP": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NCCL": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NEST": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NLLLoss": {
    "description": "The negative log likelihood loss. It is useful to train a classification",
    "std_args": [
      "self",
      "weight",
      "size_average",
      "ignore_index",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "NLLLoss2d": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "weight",
      "size_average",
      "ignore_index",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "NODE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NODES_SUFFIX": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NODE_INPUT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NODE_OUTPUT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NONE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NON_GROUP_MEMBER": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NON_OBSERVABLE_ARG_DICT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NON_QUANTIZABLE_WEIGHT_OPS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NON_TRACEABLE_MODULE_CLASS_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NON_TRACEABLE_MODULE_NAME_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NOOP": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NOT_RELATED": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NO_ACTION": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NO_DUNDER_FILE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NO_SHARD": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NSFusionElType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NSFusionType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NSNodeTargetType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NSResultsType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NSSingleResultType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NSSingleResultValuesType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "NSSubgraph": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "NUM_TENSOR_ARGS_TO_OBSERVATION_TYPE_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NVIDIA_PATTERNS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Nadam": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "eps",
      "lr",
      "weight_decay"
    ],
    "type": "function"
  },
  "NamedShape": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Names": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NearlyDiagonalSparsifier": {
    "description": "Nearly Diagonal Sparsifier",
    "std_args": [
      "self",
      "nearliness"
    ],
    "type": "class"
  },
  "NegativeBinomial": {
    "description": "Creates a Negative Binomial distribution, i.e. distribution",
    "std_args": [
      "self",
      "total_count",
      "probs",
      "logits",
      "validate_args"
    ],
    "type": "class"
  },
  "NestedIOFunction": {
    "description": "This class is here only for backward compatibility reasons.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "Node": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "NodeEvent": {
    "description": "An event in graph split that happened on a node.",
    "std_args": [
      "self",
      "source",
      "desc",
      "dep"
    ],
    "type": "class"
  },
  "NodeEventTracker": {
    "description": "Tracks node events during the splitter execution.",
    "std_args": [
      "self",
      "tracker_mode",
      "dump_prefix"
    ],
    "type": "class"
  },
  "NodeInfo": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NodeInputOrOutputType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "NodeLatency": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "NodeList": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NodePattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NodeSet": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NodeSource": {
    "description": "NodeSource is a data structure that contains the provenance information of a node.",
    "std_args": [
      "self",
      "node",
      "pass_name",
      "action"
    ],
    "type": "class"
  },
  "NodeSourceAction": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "NodeState": {
    "description": "The states that a node can be in rendezvous.",
    "std_args": [],
    "type": "class"
  },
  "NonDynamicallyQuantizableLinear": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "in_features",
      "out_features",
      "bias",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "NoopObserver": {
    "description": "Observer that doesn't do anything and just passes its configuration to the",
    "std_args": [
      "self",
      "dtype",
      "custom_op_name"
    ],
    "type": "class"
  },
  "Normal": {
    "description": "Creates a normal (also called Gaussian) distribution parameterized by",
    "std_args": [
      "self",
      "loc",
      "scale",
      "validate_args"
    ],
    "type": "class"
  },
  "Normalize": {
    "description": "Normalize a tensor image with mean and standard deviation.",
    "std_args": [
      "mean",
      "std",
      "inplace"
    ],
    "variants": {}
  },
  "NormalizeArgs": {
    "description": "Normalize arguments to Python targets. This means that",
    "std_args": [
      "self",
      "module",
      "normalize_to_only_use_kwargs"
    ],
    "type": "class"
  },
  "NormalizeOperators": {
    "description": "Normalize callsites that are different ways of \"spelling\" the same",
    "std_args": [
      "self",
      "module",
      "annotate_functionals",
      "annotate_modules",
      "annotate_get_attrs"
    ],
    "type": "class"
  },
  "NotEqualError": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "msg",
      "mismatched"
    ],
    "type": "class"
  },
  "NotSupportedError": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "source_range",
      "msg"
    ],
    "type": "class"
  },
  "NullMetricHandler": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "NumaOptions": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "affinity_mode",
      "should_fall_back_if_binding_fails"
    ],
    "type": "class"
  },
  "Number": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "OBLIVIOUS_SIZE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "OBSERVATION_TYPE_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "OBSERVED_TO_QUANTIZED_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "OKBLUE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "OKGREEN": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ONEAPI_PATTERNS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "OPERATOR_HANDLES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "OP_TO_ANNOTATOR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ORIGINAL_ATEN": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "OUT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "OUTPUT_DTYPE_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "OUTPUT_QUANTIZED_INDEXES_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "OUTPUT_SHARE_OBSERVER_WITH_INPUT": {
    "description": "this means the output will use the same observer instance as input, based",
    "std_args": [],
    "type": "attribute"
  },
  "OUTPUT_USE_DIFFERENT_OBSERVER_AS_INPUT": {
    "description": "this means input and output are observed with different observers, based",
    "std_args": [],
    "type": "attribute"
  },
  "OUT_OF_MEMORY_EVENT_NAME": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "OVERLAP_F_B": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ObjMismatchError": {
    "description": "Raised when an importer found a different object with the same name as the user-provided one.",
    "std_args": [],
    "type": "class"
  },
  "ObjNotFoundError": {
    "description": "Raised when an importer cannot find an object by searching for its name.",
    "std_args": [],
    "type": "class"
  },
  "ObservationType": {
    "description": "An enum that represents different ways of how an operator/operator pattern",
    "std_args": [],
    "type": "class"
  },
  "ObserverBase": {
    "description": "Base observer Module.",
    "std_args": [
      "self",
      "dtype",
      "is_dynamic"
    ],
    "type": "class"
  },
  "ObserverOrFakeQuantize": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "OneCycleLR": {
    "description": "Sets the learning rate of each parameter group according to the 1cycle learning rate policy.",
    "std_args": [
      "self",
      "optimizer",
      "max_lr",
      "total_steps",
      "epochs",
      "steps_per_epoch",
      "pct_start",
      "anneal_strategy",
      "cycle_momentum",
      "base_momentum",
      "max_momentum",
      "div_factor",
      "final_div_factor",
      "three_phase",
      "last_epoch"
    ],
    "type": "class"
  },
  "OneHot": {
    "description": "One-hot encoding.",
    "std_args": [
      "input",
      "num_classes"
    ],
    "variants": {}
  },
  "OneHotCategorical": {
    "description": "Creates a one-hot categorical distribution parameterized by :attr:`probs` or",
    "std_args": [
      "self",
      "probs",
      "logits",
      "validate_args"
    ],
    "type": "class"
  },
  "OneHotCategoricalStraightThrough": {
    "description": "Creates a reparameterizable :class:`OneHotCategorical` distribution based on the straight-",
    "std_args": [
      "self",
      "probs",
      "logits",
      "validate_args"
    ],
    "type": "class"
  },
  "OnnxExporterError": {
    "description": "Errors raised by the ONNX exporter. This is the base class for all exporter errors.",
    "std_args": [],
    "type": "class"
  },
  "OnnxExporterWarning": {
    "description": "Warnings in the ONNX exporter.",
    "std_args": [],
    "type": "class"
  },
  "OpSupports": {
    "description": "A set of atomic `OperatorSupportBase` instances that can be combined together",
    "std_args": [],
    "type": "class"
  },
  "OperatorConfig": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "OperatorPatternType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "OperatorSupport": {
    "description": "`_support_dict` maps node.target typename to supported inputs dtypes.",
    "std_args": [
      "self",
      "support_dict"
    ],
    "type": "class"
  },
  "OperatorSupportBase": {
    "description": "Interface for determining if a fx.Node is supported by a backend",
    "std_args": [],
    "type": "class"
  },
  "OptState": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "OptimStateDictConfig": {
    "description": "``OptimStateDictConfig`` is the base class for all ``optim_state_dict``",
    "std_args": [
      "self",
      "offload_to_cpu"
    ],
    "type": "class"
  },
  "OptimStateKeyType": {
    "description": "Represents the type of key in an optimizer state-dict.",
    "std_args": [],
    "type": "class"
  },
  "Optimizer": {
    "description": "Base class for all optimizers.",
    "std_args": [
      "self",
      "params",
      "defaults"
    ],
    "type": "class"
  },
  "OptimizerPostHook": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "OptimizerPreHook": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "OptimizerStateType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "OrderedDictWrapper": {
    "description": "A wrapper around a C++ OrderedDict.",
    "std_args": [
      "self",
      "cpp_module",
      "attr"
    ],
    "type": "class"
  },
  "OrderedImporter": {
    "description": "A compound importer that takes a list of importers and tries them one at a time.",
    "std_args": [
      "self",
      "args"
    ],
    "type": "class"
  },
  "OutOfMemoryError": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "OutputKind": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "OutputProp": {
    "description": "Output propagation (modeled from shape propagation).",
    "std_args": [
      "self",
      "mod"
    ],
    "type": "class"
  },
  "OutputSpec": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "kind",
      "arg",
      "target"
    ],
    "type": "class"
  },
  "P": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "P2POp": {
    "description": "A class to build point-to-point operations for ``batch_isend_irecv``.",
    "std_args": [
      "self",
      "op",
      "tensor",
      "peer",
      "group",
      "tag",
      "group_peer"
    ],
    "type": "class"
  },
  "PARAMETER": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PARAMETER_MUTATION": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PARAM_ID": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PARAM_LIST": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PARAM_NAME": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PASSTHROUGH_FNS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PATTERN_COMPLEX_FORMAT_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PATTERN_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PContext": {
    "description": "The base class that standardizes operations over a set of processes that are launched via different mechanisms.",
    "std_args": [
      "self",
      "name",
      "entrypoint",
      "args",
      "envs",
      "logs_specs",
      "log_line_prefixes"
    ],
    "type": "class"
  },
  "PG_WRAPPER_STORE_PREFIX": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PICKLE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PIP_PATTERNS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PLAT_TO_VCVARS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "POWER_SGD": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "POWER_SGD_RANK2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PREFER_RECOMPUTE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PREFER_SAVE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PRESCALE_QK": {
    "description": "Whether to pre-scale QK by 1/sqrt(d) and change of base. This is slightly faster but",
    "std_args": [],
    "type": "attribute"
  },
  "PRESERVED_ATEN_CIA_OPS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PRESERVED_ATTRIBUTES_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PRIVATE_OPS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PROCESS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PROFILER_STEP_NAME": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PROTOCOL_VERSION": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PRUNING_TYPE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PYTHON": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PYTORCH_MAP": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PYTORCH_SPECIAL_MAP": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PYTORCH_SPECIFIC_MAPPINGS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PYTORCH_TEMPLATE_MAP": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PYTORCH_TRIE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PackageExporter": {
    "description": "Exporters allow you to write packages of code, pickled Python data, and",
    "std_args": [
      "self",
      "f",
      "importer",
      "debug"
    ],
    "type": "class"
  },
  "PackageImporter": {
    "description": "Importers allow you to load code written to packages by :class:`PackageExporter`.",
    "std_args": [
      "self",
      "file_or_buffer",
      "module_allowed"
    ],
    "type": "class"
  },
  "PackagingError": {
    "description": "This exception is raised when there is an issue with exporting a package.",
    "std_args": [
      "self",
      "dependency_graph",
      "debug"
    ],
    "type": "class"
  },
  "PackagingErrorReason": {
    "description": "Listing of different reasons a dependency may fail to package.",
    "std_args": [],
    "type": "class"
  },
  "PackedParameter": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "param"
    ],
    "type": "class"
  },
  "PackedSequence": {
    "description": "Holds the data and list of :attr:`batch_sizes` of a packed sequence.",
    "std_args": [],
    "type": "class"
  },
  "PackedSequence_": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Pad": {
    "description": "Pads tensor.",
    "std_args": [
      "input",
      "pad",
      "mode",
      "value"
    ],
    "variants": {}
  },
  "PairwiseDistance": {
    "description": "Computes the pairwise distance between input vectors, or between columns of input matrices.",
    "std_args": [
      "self",
      "p",
      "eps",
      "keepdim"
    ],
    "type": "class"
  },
  "PandasWrapper": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "ParallelStyle": {
    "description": "The parallel style contract defines how the module or submodule should be parallelized.",
    "std_args": [],
    "type": "class"
  },
  "Param": {
    "description": "Container for trainable parameter.",
    "std_args": [
      "value"
    ],
    "variants": {}
  },
  "Parameter": {
    "description": "A kind of Tensor that is to be considered a module parameter.",
    "std_args": [
      "self",
      "data",
      "requires_grad"
    ],
    "type": "class"
  },
  "ParameterAlias": {
    "description": "Indicates that a parameter should alias the value of another parameter.",
    "std_args": [
      "self",
      "alias_to"
    ],
    "type": "class"
  },
  "ParameterDict": {
    "description": "Holds parameters in a dictionary.",
    "std_args": [
      "self",
      "parameters"
    ],
    "type": "class"
  },
  "ParameterList": {
    "description": "Holds parameters in a list.",
    "std_args": [
      "self",
      "values"
    ],
    "type": "class"
  },
  "ParameterProxy": {
    "description": "A special proxy which lets \"shape\", \"size\", \"dim\", and a few other",
    "std_args": [
      "self",
      "tracer",
      "node",
      "name",
      "param"
    ],
    "type": "class"
  },
  "ParametrizationList": {
    "description": "A sequential container that holds and manages the original parameters or buffers of a parametrized :class:`torch.nn.Module`.",
    "std_args": [
      "self",
      "modules",
      "original",
      "unsafe"
    ],
    "type": "class"
  },
  "ParamsT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Pareto": {
    "description": "Samples from a Pareto Type 1 distribution.",
    "std_args": [
      "self",
      "scale",
      "alpha",
      "validate_args"
    ],
    "type": "class"
  },
  "Partial": {
    "description": "The ``Partial(reduce_op)`` placement describes the DTensor that is pending",
    "std_args": [
      "self",
      "reduce_op"
    ],
    "type": "class"
  },
  "Partition": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "id",
      "nodes",
      "node_orders"
    ],
    "type": "class"
  },
  "PartitionLatency": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "PartitionMode": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "PartitionResult": {
    "description": "NameTuple used for returning DAG and a new fx module",
    "std_args": [],
    "type": "class"
  },
  "Partitioner": {
    "description": "A fx module may not fit into one device.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "PartitionerConfig": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "PassBase": {
    "description": "Base interface for implementing passes.",
    "std_args": [],
    "type": "class"
  },
  "PassManager": {
    "description": "Construct a PassManager.",
    "std_args": [
      "self",
      "passes",
      "constraints",
      "steps",
      "run_checks_after_each_pass",
      "suppress_check_failures"
    ],
    "type": "class"
  },
  "PassResult": {
    "description": "Result of a pass:",
    "std_args": [],
    "type": "class"
  },
  "PassType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Pattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PendingUnbackedSymbolNotFound": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "PerAxis": {
    "description": "Represents per-axis granularity in quantization.",
    "std_args": [
      "self",
      "axis"
    ],
    "type": "class"
  },
  "PerBlock": {
    "description": "Represents per-block granularity in quantization. See",
    "std_args": [
      "self",
      "block_size"
    ],
    "type": "class"
  },
  "PerChannelMinMaxObserver": {
    "description": "Observer module for computing the quantization parameters based on the",
    "std_args": [
      "self",
      "ch_axis",
      "dtype",
      "qscheme",
      "reduce_range",
      "quant_min",
      "quant_max",
      "factory_kwargs",
      "eps",
      "is_dynamic",
      "kwargs"
    ],
    "type": "class"
  },
  "PerGroup": {
    "description": "Represents per-channel group granularity in quantization.",
    "std_args": [
      "self",
      "group_size"
    ],
    "type": "class"
  },
  "PerRow": {
    "description": "Represents row-wise granularity in quantization.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "PerRowDataFramesPipe": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "source_datapipe"
    ],
    "type": "class"
  },
  "PerTensor": {
    "description": "Represents per-tensor granularity in quantization.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "PerToken": {
    "description": "Represents per-token granularity in quantization.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "PeriodicModelAverager": {
    "description": "Averages parameters periodically after the warm-up stage.",
    "std_args": [
      "self",
      "period",
      "warmup_steps",
      "process_group"
    ],
    "type": "class"
  },
  "PipelineScheduleMulti": {
    "description": "Base class for multi-stage schedules.",
    "std_args": [
      "self",
      "stages",
      "n_microbatches",
      "loss_fn",
      "args_chunk_spec",
      "kwargs_chunk_spec",
      "output_merge_spec",
      "use_full_backward",
      "scale_grads"
    ],
    "type": "class"
  },
  "PipelineScheduleSingle": {
    "description": "Base class for single-stage schedules.",
    "std_args": [
      "self",
      "stage",
      "n_microbatches",
      "loss_fn",
      "args_chunk_spec",
      "kwargs_chunk_spec",
      "output_merge_spec",
      "scale_grads"
    ],
    "type": "class"
  },
  "PipelineStage": {
    "description": "A class representing a pipeline stage in a pipeline parallelism setup.",
    "std_args": [
      "self",
      "submodule",
      "stage_index",
      "num_stages",
      "device",
      "input_args",
      "output_args",
      "group",
      "dw_builder"
    ],
    "type": "class"
  },
  "PixelShuffle": {
    "description": "Rearrange elements in a tensor according to an upscaling factor.",
    "std_args": [
      "self",
      "upscale_factor"
    ],
    "type": "class"
  },
  "PixelUnshuffle": {
    "description": "Reverse the PixelShuffle operation.",
    "std_args": [
      "self",
      "downscale_factor"
    ],
    "type": "class"
  },
  "PlaceholderObserver": {
    "description": "Observer that doesn't do anything and just passes its configuration to the",
    "std_args": [
      "self",
      "dtype",
      "custom_op_name",
      "compute_dtype",
      "quant_min",
      "quant_max",
      "qscheme",
      "eps",
      "is_dynamic"
    ],
    "type": "class"
  },
  "Placement": {
    "description": "The base class for the Placement type, where it describes how a DTensor is placed onto the",
    "std_args": [],
    "type": "class"
  },
  "Poisson": {
    "description": "Creates a Poisson distribution parameterized by :attr:`rate`, the rate parameter.",
    "std_args": [
      "self",
      "rate",
      "validate_args"
    ],
    "type": "class"
  },
  "PoissonNLLLoss": {
    "description": "Negative log likelihood loss with Poisson distribution of target.",
    "std_args": [
      "self",
      "log_input",
      "full",
      "size_average",
      "eps",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "PolynomialLR": {
    "description": "Decays the learning rate of each parameter group using a polynomial function in the given total_iters.",
    "std_args": [
      "self",
      "optimizer",
      "total_iters",
      "power",
      "last_epoch"
    ],
    "type": "class"
  },
  "Pool": {
    "description": "Pool implementation which uses our version of SimpleQueue.",
    "std_args": [],
    "type": "class"
  },
  "PopulateValidator": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "graph",
      "validator"
    ],
    "type": "class"
  },
  "PortNodeMetaForQDQ": {
    "description": "Port metadata for nodes added by quantization flow.",
    "std_args": [],
    "type": "class"
  },
  "PositiveDefiniteTransform": {
    "description": "Transform from unconstrained matrices to positive-definite matrices.",
    "std_args": [
      "self",
      "cache_size"
    ],
    "type": "class"
  },
  "PostLocalSGDOptimizer": {
    "description": "Wraps an arbitrary :class:`torch.optim.Optimizer` and runs `post-local SGD <https://arxiv.org/abs/1808.07217>`_,",
    "std_args": [
      "self",
      "optim",
      "averager"
    ],
    "type": "class"
  },
  "PostLocalSGDState": {
    "description": "Store state for all-reducing gradients globally until given step, then locally after.",
    "std_args": [
      "self",
      "process_group",
      "subgroup",
      "start_localSGD_iter",
      "post_local_gradient_allreduce"
    ],
    "type": "class"
  },
  "PowerSGDState": {
    "description": "Store both the algorithm's hyperparameters and internal state for all gradients during training.",
    "std_args": [
      "self",
      "process_group",
      "matrix_approximation_rank",
      "start_powerSGD_iter",
      "min_compression_rate",
      "use_error_feedback",
      "warm_start",
      "orthogonalization_epsilon",
      "random_seed",
      "compression_stats_logging_frequency",
      "batch_tensors_with_same_shape"
    ],
    "type": "class"
  },
  "PowerTransform": {
    "description": "Transform via the mapping :math:`y = x^{\\text{exponent}}`.",
    "std_args": [
      "self",
      "exponent",
      "cache_size"
    ],
    "type": "class"
  },
  "PreDispatchTorchFunctionMode": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "tracer"
    ],
    "type": "class"
  },
  "PrepareCustomConfig": {
    "description": "Custom configuration for :func:`~torch.ao.quantization.quantize_fx.prepare_fx` and",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "PrimitiveType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ProcessContext": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "processes",
      "error_files"
    ],
    "type": "class"
  },
  "ProcessException": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "msg",
      "error_index",
      "pid"
    ],
    "type": "class"
  },
  "ProcessExitedException": {
    "description": "Exception raised when a process failed due to signal or exited with a specific code.",
    "std_args": [
      "self",
      "msg",
      "error_index",
      "error_pid",
      "exit_code",
      "signal_name"
    ],
    "type": "class"
  },
  "ProcessFailure": {
    "description": "Represent the failed process result. When the worker process fails, it may record failure root cause into the file.",
    "std_args": [
      "self",
      "local_rank",
      "pid",
      "exitcode",
      "error_file"
    ],
    "type": "class"
  },
  "ProcessRaisedException": {
    "description": "Exception raised when a process failed due to an exception raised by the code.",
    "std_args": [
      "self",
      "msg",
      "error_index",
      "error_pid"
    ],
    "type": "class"
  },
  "ProfilerAction": {
    "description": "Profiler actions that can be taken at the specified intervals",
    "std_args": [],
    "type": "class"
  },
  "PropagateUnbackedSymInts": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "module",
      "garbage_collect_values",
      "graph"
    ],
    "type": "class"
  },
  "Proxy": {
    "description": "``Proxy`` objects are ``Node`` wrappers that flow through the",
    "std_args": [
      "self",
      "node",
      "tracer"
    ],
    "type": "class"
  },
  "ProxyTorchDispatchMode": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "tracer",
      "tracing_mode",
      "pre_dispatch",
      "_allow_fake_constant",
      "_error_on_data_dependent_ops"
    ],
    "type": "class"
  },
  "PruningContainer": {
    "description": "Container holding a sequence of pruning methods for iterative pruning.",
    "std_args": [
      "self",
      "args"
    ],
    "type": "class"
  },
  "PySymType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PythonCode": {
    "description": "Represents all the information necessary to exec or save a graph as Python code.",
    "std_args": [
      "self",
      "src",
      "globals",
      "_lineno_map"
    ],
    "type": "class"
  },
  "PythonKeyTracer": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "PythonUDF": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Q": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "QAT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "QAT_MODULE_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "QConfig": {
    "description": "Describes how to quantize a layer or a part of the network by providing",
    "std_args": [],
    "type": "class"
  },
  "QConfigAny": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "QConfigDynamic": {
    "description": "Describes how to dynamically quantize a layer or a part of the network by providing",
    "std_args": [],
    "type": "class"
  },
  "QConfigMapping": {
    "description": "Mapping from model ops to :class:`torch.ao.quantization.QConfig` s.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "QConfigMultiMapping": {
    "description": "This class, used with the prepare_n_shadows_model API, stores a list of :class:`torch.ao.quantization.QConfigMapping`s",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "QFunctional": {
    "description": "Wrapper class for quantized operations.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "QInt32Storage": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "device",
      "dtype",
      "wrap_storage",
      "_internal"
    ],
    "type": "class"
  },
  "QInt8Storage": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "device",
      "dtype",
      "wrap_storage",
      "_internal"
    ],
    "type": "class"
  },
  "QUANTIZE_PER_CHANNEL": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "QUANTIZE_PER_TENSOR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "QUANT_ANNOTATION_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "QUInt2x4Storage": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "device",
      "dtype",
      "wrap_storage",
      "_internal"
    ],
    "type": "class"
  },
  "QUInt4x2Storage": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "device",
      "dtype",
      "wrap_storage",
      "_internal"
    ],
    "type": "class"
  },
  "QUInt8Storage": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "device",
      "dtype",
      "wrap_storage",
      "_internal"
    ],
    "type": "class"
  },
  "QuantStub": {
    "description": "Quantize stub module, before calibration, this is same as an observer,",
    "std_args": [
      "self",
      "qconfig"
    ],
    "type": "class"
  },
  "QuantType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "QuantWrapper": {
    "description": "A wrapper class that wraps the input module, adds QuantStub and",
    "std_args": [
      "self",
      "module"
    ],
    "type": "class"
  },
  "QuantizationAnnotation": {
    "description": "How are input argument or output should be quantized,",
    "std_args": [
      "self",
      "input_qspec_map",
      "output_qspec",
      "allow_implicit_sharing",
      "_annotated"
    ],
    "type": "class"
  },
  "QuantizationConfig": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "input_activation",
      "output_activation",
      "weight",
      "bias",
      "is_qat"
    ],
    "type": "class"
  },
  "QuantizationSpec": {
    "description": "Quantization spec for common operators that allows user to specify how to",
    "std_args": [
      "self",
      "dtype",
      "observer_or_fake_quant_ctr",
      "quant_min",
      "quant_max",
      "qscheme",
      "ch_axis",
      "is_dynamic"
    ],
    "type": "class"
  },
  "QuantizationSpecBase": {
    "description": "Base class for different types of quantization specs that allows users to",
    "std_args": [],
    "type": "class"
  },
  "QuantizationTracer": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "skipped_module_names",
      "skipped_module_classes"
    ],
    "type": "class"
  },
  "Quantize": {
    "description": "Quantizes an incoming tensor",
    "std_args": [
      "self",
      "scale",
      "zero_point",
      "dtype",
      "factory_kwargs"
    ],
    "type": "class"
  },
  "QuantizeHandler": {
    "description": "Base handler class for the quantizer patterns",
    "std_args": [
      "self",
      "node_pattern",
      "modules",
      "root_node_getter",
      "is_custom_module",
      "is_standalone_module"
    ],
    "type": "class"
  },
  "QuantizedEngine": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "m",
      "name"
    ],
    "type": "class"
  },
  "QuantizedGRU": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "QuantizedGRUCell": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "class"
  },
  "QuantizedHuggingFaceStorageReader": {
    "description": "Extension of HuggingFaceStorageReader that handles quantized tensors.",
    "std_args": [
      "self",
      "path",
      "thread_count",
      "target_dtype",
      "block_size"
    ],
    "type": "class"
  },
  "QuantizedLSTM": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "other",
      "dtype"
    ],
    "type": "class"
  },
  "QuantizedLSTMCell": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "class"
  },
  "QuantizedLinearFP16": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "class"
  },
  "QuantizedRNNBase": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "other",
      "dtype"
    ],
    "type": "class"
  },
  "QuantizedRNNCell": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "class"
  },
  "QuantizedRNNCellBase": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "class"
  },
  "Quantizer": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "QuantizerCls": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Queue": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "QueueEmptyError": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "R": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RAdam": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "params",
      "lr",
      "betas",
      "eps",
      "weight_decay",
      "decoupled_weight_decay",
      "foreach",
      "maximize",
      "capturable",
      "differentiable"
    ],
    "type": "class"
  },
  "READY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "READ_DATA_CHUNK": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RECORD": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RECORD_AND_SAVE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RECV_B": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RECV_F": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "REDUCE_NAMES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "REFERENCE_QUANTIZED_MODULE_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "REGULAR_SIZES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RELATED_BUT_NOT_EQUAL": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "REMOTE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "REPLACE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "REPO_ROOT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "REQUIRES_GRAD": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RESHARD": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RE_ANGLE_HEADER": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RE_ASSERT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RE_CAFFE2_PREPROCESSOR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RE_CU_SUFFIX": {
    "description": "Returns a HipifyResult object with the following details:",
    "std_args": [],
    "type": "attribute"
  },
  "RE_EXTERN_SHARED": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RE_INCLUDE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RE_KERNEL_LAUNCH": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RE_PYTORCH_PREPROCESSOR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RE_QUOTE_HEADER": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RE_SYNCTHREADS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RE_THC_GENERIC_FILE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RMSprop": {
    "description": "Root Mean Square Propagation.",
    "std_args": [
      "params",
      "lr",
      "rho",
      "eps",
      "weight_decay",
      "momentum",
      "centered"
    ],
    "variants": {}
  },
  "RNNBase": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "mode",
      "input_size",
      "hidden_size",
      "num_layers",
      "bias",
      "batch_first",
      "dropout",
      "bidirectional",
      "proj_size",
      "device",
      "dtype",
      "weight_qparams_dict"
    ],
    "type": "class"
  },
  "RNNCell": {
    "description": "We'll store weight_qparams for all the weights (weight_ih and weight_hh),",
    "std_args": [
      "self",
      "input_size",
      "hidden_size",
      "bias",
      "nonlinearity",
      "device",
      "dtype",
      "weight_qparams_dict"
    ],
    "type": "class"
  },
  "RNNDynamicQuantizeHandler": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "node_pattern",
      "modules",
      "root_node_getter",
      "is_custom_module",
      "is_standalone_module"
    ],
    "type": "class"
  },
  "ROCM_HOME": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ROCM_VERSION": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ROOT_MODULE_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ROOT_NODE_GETTER_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ROWS_GUARANTEED_SAFE": {
    "description": "If True, guarantees that at least one value in each row is not masked out.",
    "std_args": [],
    "type": "attribute"
  },
  "ROWWISE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RPCExecMode": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "RPC_AVAILABLE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RReLU": {
    "description": "Applies the randomized leaky rectified linear unit function, element-wise.",
    "std_args": [
      "self",
      "lower",
      "upper",
      "inplace"
    ],
    "type": "class"
  },
  "RRef": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "value",
      "type_hint"
    ],
    "type": "class"
  },
  "RRefMeta": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "RRefProxy": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "rref",
      "rpc_api",
      "timeout"
    ],
    "type": "class"
  },
  "RUNNING": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RUN_WITH_INTERPRETER": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RandomCrop": {
    "description": "Crop the given image at a random location.",
    "std_args": [
      "size",
      "padding",
      "pad_if_needed",
      "fill",
      "padding_mode"
    ],
    "variants": {}
  },
  "RandomHorizontalFlip": {
    "description": "Horizontally flip the image randomly with a given probability.",
    "std_args": [
      "p"
    ],
    "variants": {}
  },
  "RandomSampler": {
    "description": "Samples elements randomly. If without replacement, then sample from a shuffled dataset.",
    "std_args": [
      "self",
      "data_source",
      "replacement",
      "num_samples",
      "generator"
    ],
    "type": "class"
  },
  "RandomStructured": {
    "description": "Prune entire (currently unpruned) channels in a tensor at random.",
    "std_args": [
      "self",
      "amount",
      "dim"
    ],
    "type": "class"
  },
  "RandomUnstructured": {
    "description": "Prune (currently unpruned) units in a tensor at random.",
    "std_args": [
      "self",
      "amount"
    ],
    "type": "class"
  },
  "RandomVerticalFlip": {
    "description": "Vertically flip the image randomly with a given probability.",
    "std_args": [
      "p"
    ],
    "variants": {}
  },
  "RdzvEvent": {
    "description": "Dataclass to represent any rendezvous event.",
    "std_args": [
      "self",
      "name",
      "run_id",
      "message",
      "hostname",
      "pid",
      "node_state",
      "master_endpoint",
      "rank",
      "local_id",
      "error_trace"
    ],
    "type": "class"
  },
  "ReadItem": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "type",
      "dest_index",
      "dest_offsets",
      "storage_index",
      "storage_offsets",
      "lengths"
    ],
    "type": "class"
  },
  "RecordingObserver": {
    "description": "The module is mainly for debug and records the tensor values during runtime.",
    "std_args": [
      "self",
      "dtype"
    ],
    "type": "class"
  },
  "ReduceLROnPlateau": {
    "description": "Reduce learning rate when a metric has stopped improving.",
    "std_args": [
      "self",
      "optimizer",
      "mode",
      "factor",
      "patience",
      "threshold",
      "threshold_mode",
      "cooldown",
      "min_lr",
      "eps"
    ],
    "type": "class"
  },
  "Refine": {
    "description": "Symbolic shape inference.",
    "std_args": [
      "self",
      "traced"
    ],
    "type": "class"
  },
  "ReflectionPad1d": {
    "description": "Pads the input tensor using the reflection of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ReflectionPad2d": {
    "description": "Pads the input tensor using the reflection of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ReflectionPad3d": {
    "description": "Pads the input tensor using the reflection of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "RelaxedBernoulli": {
    "description": "Creates a RelaxedBernoulli distribution, parametrized by",
    "std_args": [
      "self",
      "temperature",
      "probs",
      "logits",
      "validate_args"
    ],
    "type": "class"
  },
  "RelaxedOneHotCategorical": {
    "description": "Creates a RelaxedOneHotCategorical distribution parametrized by",
    "std_args": [
      "self",
      "temperature",
      "probs",
      "logits",
      "validate_args"
    ],
    "type": "class"
  },
  "RelaxedUnspecConstraint": {
    "description": "For clients: no explicit constraint; constraint is whatever is implicitly",
    "std_args": [
      "self",
      "warn_only"
    ],
    "type": "class"
  },
  "Relu6": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "class"
  },
  "RemoteException": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RemovableHandle": {
    "description": "A handle which provides the capability to remove a hook.",
    "std_args": [
      "self",
      "hooks_dict",
      "extra_dict"
    ],
    "type": "class"
  },
  "RendezvousBackend": {
    "description": "Represent a backend that holds the rendezvous state.",
    "std_args": [],
    "type": "class"
  },
  "RendezvousClosedError": {
    "description": "Raised when a rendezvous is closed.",
    "std_args": [],
    "type": "class"
  },
  "RendezvousConnectionError": {
    "description": "Raised when the connection to a rendezvous backend has failed.",
    "std_args": [],
    "type": "class"
  },
  "RendezvousError": {
    "description": "Represents the base type for rendezvous errors.",
    "std_args": [],
    "type": "class"
  },
  "RendezvousGracefulExitError": {
    "description": "Raised when node wasn't not included in rendezvous and gracefully exits.",
    "std_args": [],
    "type": "class"
  },
  "RendezvousHandler": {
    "description": "Main rendezvous interface.",
    "std_args": [],
    "type": "class"
  },
  "RendezvousHandlerCreator": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RendezvousHandlerRegistry": {
    "description": "Represent a registry of :py:class:`RendezvousHandler` backends.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "RendezvousInfo": {
    "description": "Holds the information about the rendezvous.",
    "std_args": [
      "self",
      "store",
      "rank",
      "world_size",
      "bootstrap_store_info"
    ],
    "type": "class"
  },
  "RendezvousParameters": {
    "description": "Hold the parameters to construct a :py:class:`RendezvousHandler`.",
    "std_args": [
      "self",
      "backend",
      "endpoint",
      "run_id",
      "min_nodes",
      "max_nodes",
      "local_addr",
      "kwargs"
    ],
    "type": "class"
  },
  "RendezvousSettings": {
    "description": "Hold the settings of the rendezvous.",
    "std_args": [
      "self",
      "run_id",
      "min_nodes",
      "max_nodes",
      "timeout",
      "keep_alive_interval",
      "keep_alive_max_attempt"
    ],
    "type": "class"
  },
  "RendezvousStateError": {
    "description": "Raised when the state of a rendezvous is corrupt.",
    "std_args": [],
    "type": "class"
  },
  "RendezvousStoreInfo": {
    "description": "Store address and port that can be used to bootstrap trainer distributed comms",
    "std_args": [
      "self",
      "master_addr",
      "master_port"
    ],
    "type": "class"
  },
  "RendezvousTimeout": {
    "description": "Hold the timeout configuration of a rendezvous.",
    "std_args": [
      "self",
      "join",
      "last_call",
      "close",
      "heartbeat"
    ],
    "type": "class"
  },
  "RendezvousTimeoutError": {
    "description": "Raised when a rendezvous did not complete on time.",
    "std_args": [],
    "type": "class"
  },
  "ReplacedPatterns": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "anchor",
      "nodes_map",
      "replacements"
    ],
    "type": "class"
  },
  "Replicate": {
    "description": "The ``Replicate()`` placement describes the DTensor replicating on a corresponding",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "ReplicationPad1d": {
    "description": "Pads the input tensor using replication of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ReplicationPad2d": {
    "description": "Pads the input tensor using replication of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ReplicationPad3d": {
    "description": "Pads the input tensor using replication of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "RequestQueue": {
    "description": "Consumer queue holding timer acquisition/release requests",
    "std_args": [],
    "type": "class"
  },
  "Reshape": {
    "description": "Returns a tensor with the same data and number of elements as input, but with the specified shape.",
    "std_args": [
      "x",
      "shape"
    ],
    "variants": {}
  },
  "ReshapeTransform": {
    "description": "Unit Jacobian transform to reshape the rightmost part of a tensor.",
    "std_args": [
      "self",
      "in_shape",
      "out_shape",
      "cache_size"
    ],
    "type": "class"
  },
  "Resize": {
    "description": "Resize the input image to the given size.",
    "std_args": [
      "size",
      "interpolation",
      "antialias"
    ],
    "variants": {}
  },
  "Result": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ReuseInputObserver": {
    "description": "This observer is used when we want to reuse the observer from the operator",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "RewritingTracer": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "autowrap_modules",
      "autowrap_functions",
      "param_shapes_constant"
    ],
    "type": "class"
  },
  "Rmsnorm": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "dtype",
      "eps"
    ],
    "type": "class"
  },
  "Rnncellbase": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "class"
  },
  "RoutedDecoderIterDataPipe": {
    "description": "Decodes binary streams from input DataPipe, yields pathname and decoded data in a tuple.",
    "std_args": [
      "self",
      "datapipe",
      "handlers",
      "key_fn"
    ],
    "type": "class"
  },
  "RowwiseParallel": {
    "description": "Partition a compatible nn.Module in a row-wise fashion. Currently supports nn.Linear and nn.Embedding.",
    "std_args": [
      "self",
      "input_layouts",
      "output_layouts",
      "use_local_output"
    ],
    "type": "class"
  },
  "Rprop": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "params",
      "lr",
      "etas",
      "step_sizes",
      "capturable",
      "foreach",
      "maximize",
      "differentiable"
    ],
    "type": "class"
  },
  "RunProcsResult": {
    "description": "Results of a completed run of processes started with ``start_processes()``. Returned by ``PContext``.",
    "std_args": [
      "self",
      "return_values",
      "failures",
      "stdouts",
      "stderrs"
    ],
    "type": "class"
  },
  "RunResult": {
    "description": "Return results of the worker executions.",
    "std_args": [
      "self",
      "state",
      "return_values",
      "failures"
    ],
    "type": "class"
  },
  "RuntimeAssert": {
    "description": "This is pretty similar to ShapeGuard but it also comes with a message,",
    "std_args": [
      "self",
      "expr",
      "msg",
      "stack"
    ],
    "type": "class"
  },
  "S": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SAC_IGNORED_OPS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SAFETENSORS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SAMPLE_INPUTS_DIR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SAMPLE_INPUTS_FILENAME_FORMAT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SDPBackend": {
    "description": "An enum-like class that contains the different backends for scaled dot product attention.",
    "std_args": [],
    "type": "attribute"
  },
  "SEND_B": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SEND_F": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SGD": {
    "description": "Stochastic Gradient Descent.",
    "std_args": [
      "params",
      "lr",
      "momentum",
      "dampening",
      "weight_decay",
      "nesterov"
    ],
    "variants": {}
  },
  "SHADOW_NODE_NAME_PREFIX": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SHADOW_WRAPPER_NODE_NAME_PREFIX": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SHAPEENV_EVENT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SHARD": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SHARDED_STATE_DICT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SHARDING_PRIORITIES": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "SHARD_GRAD_OP": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SHARED_FLAG": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SHORT_SIZE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SIZE_LIKE_UNBACKED": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SOCKET": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SOURCE_FILE_NOT_FOUND": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SOURCE_ROOT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SPARSE_DISPATCH": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "STANDALONE_MODULE_CLASS_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "STANDALONE_MODULE_NAME_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "STATE_DICT_2D_LAYOUT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "STATE_DICT_TYPE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "STATIC": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "STATIC_OPS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "STATIC_QAT_ONLY_OPS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "STAT_EVENT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "STEPPED": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "STOPPED": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "STORAGE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "STORAGE_KEY_SEPARATOR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "STORAGE_TYPES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "STORE_BASED_BARRIER_PREFIX": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SUBPROCESS_DECODE_ARGS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SUCCEEDED": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SUCCESS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SUPPORTED_MODULES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SUPPORTED_QDTYPES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SWALR": {
    "description": "Anneals the learning rate in each parameter group to a fixed value.",
    "std_args": [
      "self",
      "optimizer",
      "swa_lr",
      "anneal_epochs",
      "anneal_strategy",
      "last_epoch"
    ],
    "type": "class"
  },
  "SYCL_HOME": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SYMMETRIC": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SYMMETRIC_NO_CLIPPING_ERR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SYMPY_INTERP": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SYNC": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Sampler": {
    "description": "Base class for all Samplers.",
    "std_args": [
      "self",
      "data_source"
    ],
    "type": "class"
  },
  "SamplerIterDataPipe": {
    "description": "Generate sample elements using the provided ``Sampler`` (defaults to :class:`SequentialSampler`).",
    "std_args": [
      "self",
      "datapipe",
      "sampler",
      "sampler_args",
      "sampler_kwargs"
    ],
    "type": "class"
  },
  "SavePlan": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "items",
      "storage_data",
      "planner_data",
      "usable"
    ],
    "type": "class"
  },
  "SavePlanner": {
    "description": "Abstract class defining the protocol used by save_state_dict to plan the save process.",
    "std_args": [],
    "type": "class"
  },
  "Scalar": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Scatter": {
    "description": "Writes all values from the tensor src into self at the indices specified in index.",
    "std_args": [
      "input",
      "dim",
      "index",
      "src"
    ],
    "variants": {}
  },
  "Schedule1F1B": {
    "description": "The 1F1B schedule.",
    "std_args": [
      "self",
      "stage",
      "n_microbatches",
      "loss_fn",
      "args_chunk_spec",
      "kwargs_chunk_spec",
      "output_merge_spec",
      "scale_grads"
    ],
    "type": "class"
  },
  "ScheduleDualPipeV": {
    "description": "The DualPipeV schedule. A more efficient schedule variant based on the",
    "std_args": [
      "self",
      "stages",
      "n_microbatches",
      "loss_fn",
      "args_chunk_spec",
      "kwargs_chunk_spec",
      "output_merge_spec",
      "scale_grads"
    ],
    "type": "class"
  },
  "ScheduleGPipe": {
    "description": "The GPipe schedule.",
    "std_args": [
      "self",
      "stage",
      "n_microbatches",
      "loss_fn",
      "args_chunk_spec",
      "kwargs_chunk_spec",
      "output_merge_spec",
      "scale_grads"
    ],
    "type": "class"
  },
  "ScheduleInterleaved1F1B": {
    "description": "The Interleaved 1F1B schedule.",
    "std_args": [
      "self",
      "stages",
      "n_microbatches",
      "loss_fn",
      "args_chunk_spec",
      "kwargs_chunk_spec",
      "output_merge_spec",
      "scale_grads"
    ],
    "type": "class"
  },
  "ScheduleInterleavedZeroBubble": {
    "description": "The Interleaved Zero Bubble schedule.",
    "std_args": [
      "self",
      "stages",
      "n_microbatches",
      "loss_fn",
      "args_chunk_spec",
      "kwargs_chunk_spec",
      "output_merge_spec",
      "scale_grads"
    ],
    "type": "class"
  },
  "ScheduleLoopedBFS": {
    "description": "Breadth-First Pipeline Parallelism.",
    "std_args": [
      "self",
      "stages",
      "n_microbatches",
      "loss_fn",
      "output_merge_spec",
      "scale_grads"
    ],
    "type": "class"
  },
  "ScheduleZBVZeroBubble": {
    "description": "The Zero Bubble schedule (ZBV variant).",
    "std_args": [
      "self",
      "stages",
      "n_microbatches",
      "loss_fn",
      "args_chunk_spec",
      "kwargs_chunk_spec",
      "output_merge_spec",
      "scale_grads"
    ],
    "type": "class"
  },
  "Scope": {
    "description": "Scope object that records the module path and the module type",
    "std_args": [
      "self",
      "module_path",
      "module_type"
    ],
    "type": "class"
  },
  "ScopeContextManager": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "scope",
      "current_module",
      "current_module_path"
    ],
    "type": "class"
  },
  "ScriptObjectMeta": {
    "description": "Metadata which is stored on nodes representing ScriptObjects.",
    "std_args": [
      "self",
      "constant_name",
      "class_fqn"
    ],
    "type": "class"
  },
  "SelectiveCheckpointContext": {
    "description": "Context passed to policy function during selective checkpointing.",
    "std_args": [
      "self",
      "is_recompute"
    ],
    "type": "class"
  },
  "Selu": {
    "description": "Auto-discovered via Consensus (Score: 3.0)",
    "std_args": [],
    "type": "class"
  },
  "SequenceParallel": {
    "description": "SequenceParallel replicates a compatible ``nn.Module`` parameters and runs the sharded computation with",
    "std_args": [
      "self",
      "sequence_dim",
      "use_local_output"
    ],
    "type": "class"
  },
  "SequenceWrapperMapDataPipe": {
    "description": "Wraps a sequence object into a MapDataPipe.",
    "std_args": [
      "self",
      "sequence",
      "deepcopy"
    ],
    "type": "class"
  },
  "Sequential": {
    "description": "A sequential container.",
    "std_args": [
      "layers"
    ],
    "variants": {}
  },
  "SequentialLR": {
    "description": "Contains a list of schedulers expected to be called sequentially during the optimization process.",
    "std_args": [
      "self",
      "optimizer",
      "schedulers",
      "milestones",
      "last_epoch"
    ],
    "type": "class"
  },
  "SequentialSampler": {
    "description": "Samples elements sequentially, always in the same order.",
    "std_args": [
      "self",
      "data_source"
    ],
    "type": "class"
  },
  "Serialization": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "SerializationFormat": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "ShapeEnv": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "should_record_events",
      "tracked_fakes",
      "kwargs"
    ],
    "type": "class"
  },
  "ShapeEnvEvent": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "f",
      "args",
      "kwargs",
      "tracked_fakes",
      "name"
    ],
    "type": "class"
  },
  "ShapeEnvSettings": {
    "description": "Encapsulates all shape env settings that could potentially affect",
    "std_args": [
      "self",
      "allow_scalar_outputs",
      "allow_dynamic_output_shape_ops",
      "assume_static_by_default",
      "specialize_zero_one",
      "duck_shape",
      "prefer_deferred_runtime_asserts_over_guards",
      "trace_asserts"
    ],
    "type": "class"
  },
  "ShapeGuardPrinter": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args"
    ],
    "type": "class"
  },
  "ShapeGuardPythonPrinter": {
    "description": "Python printer for shape guards that extends the base ShapeGuardPrinter.",
    "std_args": [
      "self",
      "args"
    ],
    "type": "class"
  },
  "ShapeProp": {
    "description": "Execute an FX graph Node-by-Node and",
    "std_args": [
      "self",
      "gm",
      "fake_mode"
    ],
    "type": "class"
  },
  "ShapesCollection": {
    "description": "Builder for dynamic_shapes.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "Shard": {
    "description": "The ``Shard(dim)`` placement describes the DTensor sharding on tensor dimension",
    "std_args": [
      "self",
      "dim"
    ],
    "type": "class"
  },
  "ShardedGradScaler": {
    "description": "ShardedGradScaler helps perform gradient scaling in a shard aware manner. It extends",
    "std_args": [
      "self",
      "device",
      "init_scale",
      "backoff_factor",
      "growth_factor",
      "growth_interval",
      "enabled",
      "process_group"
    ],
    "type": "class"
  },
  "ShardedOptimStateDictConfig": {
    "description": "``ShardedOptimStateDictConfig`` is a config class meant to be used with",
    "std_args": [
      "self",
      "offload_to_cpu",
      "_use_dtensor"
    ],
    "type": "class"
  },
  "ShardedStateDictConfig": {
    "description": "``ShardedStateDictConfig`` is a config class meant to be used with",
    "std_args": [
      "self",
      "offload_to_cpu",
      "_use_dtensor"
    ],
    "type": "class"
  },
  "ShardingFilterIterDataPipe": {
    "description": "Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).",
    "std_args": [
      "self",
      "source_datapipe",
      "sharding_group_filter"
    ],
    "type": "class"
  },
  "ShardingStrategy": {
    "description": "This specifies the sharding strategy to be used for distributed training by",
    "std_args": [],
    "type": "class"
  },
  "SharedCache": {
    "description": "Dictionary from multiprocessing handles to StorageWeakRef.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "SharedQuantizationSpec": {
    "description": "Quantization spec for the Tensors whose quantization parameters are shared with other Tensors",
    "std_args": [
      "self",
      "edge_or_node"
    ],
    "type": "class"
  },
  "ShortStorage": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "device",
      "dtype",
      "wrap_storage",
      "_internal"
    ],
    "type": "class"
  },
  "ShuffleDataFramesPipe": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "source_datapipe"
    ],
    "type": "class"
  },
  "ShufflerIterDataPipe": {
    "description": "Shuffle the input MapDataPipe via its indices (functional name: ``shuffle``).",
    "std_args": [
      "self",
      "datapipe",
      "indices"
    ],
    "type": "class"
  },
  "Sigmoid": {
    "description": "Auto-discovered via Consensus (Score: 3.0)",
    "std_args": [
      "x"
    ],
    "type": "class"
  },
  "SigmoidTransform": {
    "description": "Transform via the mapping :math:`y = \\frac{1}{1 + \\exp(-x)}` and :math:`x = \\text{logit}(y)`.",
    "std_args": [
      "self",
      "cache_size"
    ],
    "type": "class"
  },
  "SignalException": {
    "description": "Exception is raised inside the torchelastic agent process by the termination handler",
    "std_args": [
      "self",
      "msg",
      "sigval"
    ],
    "type": "class"
  },
  "Silu": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "x"
    ],
    "type": "class"
  },
  "SimpleElasticAgent": {
    "description": "An ``ElasticAgent`` that manages one particular type of worker role.",
    "std_args": [
      "self",
      "spec",
      "exit_barrier_timeout"
    ],
    "type": "class"
  },
  "SimpleQueue": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "SmoothL1Loss": {
    "description": "Creates a criterion that uses a squared term if the absolute",
    "std_args": [
      "self",
      "size_average",
      "reduce",
      "reduction",
      "beta"
    ],
    "type": "class"
  },
  "SobolEngine": {
    "description": "The :class:`torch.quasirandom.SobolEngine` is an engine for generating",
    "std_args": [
      "self",
      "dimension",
      "scramble",
      "seed"
    ],
    "type": "class"
  },
  "SoftMarginLoss": {
    "description": "Creates a criterion that optimizes a two-class classification",
    "std_args": [
      "self",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "Softmax2d": {
    "description": "Applies SoftMax over features to each spatial location.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "SoftmaxTransform": {
    "description": "Transform from unconstrained space to the simplex via :math:`y = \\exp(x)` then",
    "std_args": [
      "self",
      "cache_size"
    ],
    "type": "class"
  },
  "Softmin": {
    "description": "Applies the Softmin function to an n-dimensional input Tensor.",
    "std_args": [
      "self",
      "dim"
    ],
    "type": "class"
  },
  "Softplus": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "class"
  },
  "SoftplusTransform": {
    "description": "Transform via the mapping :math:`\\text{Softplus}(x) = \\log(1 + \\exp(x))`.",
    "std_args": [
      "self",
      "cache_size"
    ],
    "type": "class"
  },
  "Softshrink": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "class"
  },
  "Softsign": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "class"
  },
  "SourceChangeWarning": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "SourcePartition": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "nodes",
      "source",
      "input_nodes",
      "output_nodes",
      "params"
    ],
    "type": "class"
  },
  "SparseAdam": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "params",
      "lr",
      "betas",
      "eps",
      "maximize"
    ],
    "type": "class"
  },
  "SparseSemiStructuredTensor": {
    "description": "This class implements semi-structured sparsity as a Tensor subclass.",
    "std_args": [],
    "type": "class"
  },
  "SparseSemiStructuredTensorCUSPARSELT": {
    "description": "The cuSPARSELt backend expects the specified elements and the metadata to be stored in a single tensor:",
    "std_args": [],
    "type": "class"
  },
  "SparseSemiStructuredTensorCUTLASS": {
    "description": "This class implements semi-structured sparsity for the CUTLASS backend.",
    "std_args": [],
    "type": "class"
  },
  "SpawnContext": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "processes",
      "error_files"
    ],
    "type": "class"
  },
  "Specialization": {
    "description": "This class is used in multi-graph compilation contexts where we generate",
    "std_args": [
      "self",
      "source",
      "check_fn"
    ],
    "type": "class"
  },
  "SpectralNorm": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "name",
      "n_power_iterations",
      "dim",
      "eps"
    ],
    "type": "class"
  },
  "SpectralNormLoadStateDictPreHook": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "fn"
    ],
    "type": "class"
  },
  "SpectralNormStateDictHook": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "fn"
    ],
    "type": "class"
  },
  "SpectralOpFuzzer": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "seed",
      "dtype",
      "cuda",
      "probability_regular"
    ],
    "type": "class"
  },
  "SplitResult": {
    "description": "Stores the results of the splitter.",
    "std_args": [],
    "type": "class"
  },
  "Squeeze": {
    "description": "Returns a tensor with all the dimensions of input of size 1 removed.",
    "std_args": [
      "input",
      "dim"
    ],
    "variants": {}
  },
  "StackDataset": {
    "description": "Dataset as a stacking of multiple datasets.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "StackTransform": {
    "description": "Transform functor that applies a sequence of transforms `tseq`",
    "std_args": [
      "self",
      "tseq",
      "dim",
      "cache_size"
    ],
    "type": "class"
  },
  "StagingOptions": {
    "description": "Configuration options for checkpoint staging behavior.",
    "std_args": [
      "self",
      "use_pinned_memory",
      "use_shared_memory",
      "use_async_staging",
      "use_non_blocking_copy"
    ],
    "type": "class"
  },
  "StateDict": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "StateDictConfig": {
    "description": "``StateDictConfig`` is the base class for all ``state_dict`` configuration",
    "std_args": [
      "self",
      "offload_to_cpu"
    ],
    "type": "class"
  },
  "StateDictOptions": {
    "description": "This dataclass specifies how get_state_dict/set_state_dict will work.",
    "std_args": [
      "self",
      "full_state_dict",
      "cpu_offload",
      "ignore_frozen_params",
      "keep_submodule_prefixes",
      "strict",
      "broadcast_from_rank0",
      "flatten_optimizer_state_dict",
      "dsd_fqn_modifiers"
    ],
    "type": "class"
  },
  "StateDictSettings": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "state_dict_type",
      "state_dict_config",
      "optim_state_dict_config"
    ],
    "type": "class"
  },
  "StateDictType": {
    "description": "This enum indicates that which type of ``state_dict`` the FSDP module is",
    "std_args": [],
    "type": "class"
  },
  "Stateful": {
    "description": "Stateful protocol for objects that can be checkpointed and restored.",
    "std_args": [],
    "type": "class"
  },
  "StatefulSymbolicContext": {
    "description": "Create symbols in ``create_symbolic_sizes_strides_storage_offset`` via",
    "std_args": [
      "self",
      "dynamic_sizes",
      "dynamic_strides",
      "constraint_sizes",
      "constraint_strides",
      "specialize_on",
      "view_base_context",
      "tensor_source",
      "shape_env_to_source_to_symbol_cache"
    ],
    "type": "class"
  },
  "StatefulT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "StatelessSymbolicContext": {
    "description": "Create symbols in ``create_symbolic_sizes_strides_storage_offset`` via",
    "std_args": [
      "self",
      "dynamic_sizes",
      "dynamic_strides",
      "constraint_sizes",
      "constraint_strides",
      "specialize_on",
      "view_base_context"
    ],
    "type": "class"
  },
  "StaticTCPRendezvous": {
    "description": "Static rendezvous that is a wrapper around the TCPStore.",
    "std_args": [
      "self",
      "master_addr",
      "master_port",
      "rank",
      "world_size",
      "run_id",
      "timeout"
    ],
    "type": "class"
  },
  "StepLR": {
    "description": "Decays the learning rate of each parameter group by gamma every step_size epochs.",
    "std_args": [
      "optimizer",
      "step_size",
      "gamma"
    ],
    "variants": {}
  },
  "StickBreakingTransform": {
    "description": "Transform from unconstrained space to the simplex of one additional",
    "std_args": [
      "self",
      "cache_size"
    ],
    "type": "class"
  },
  "StmtBuilder": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Storage": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "StorageMeta": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "checkpoint_id",
      "save_id",
      "load_id",
      "modules"
    ],
    "type": "class"
  },
  "StorageReader": {
    "description": "Interface used by ``load_state_dict`` to read from storage.",
    "std_args": [],
    "type": "class"
  },
  "StorageType": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "name"
    ],
    "type": "class"
  },
  "StorageWeakRef": {
    "description": "A weak reference to a Storage.",
    "std_args": [
      "self",
      "storage"
    ],
    "type": "class"
  },
  "StorageWriter": {
    "description": "Interface used by ``save_state_dict`` to write to storage.",
    "std_args": [],
    "type": "class"
  },
  "Stream": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "StreamContext": {
    "description": "Context-manager that selects a given stream.",
    "std_args": [
      "self",
      "stream"
    ],
    "type": "class"
  },
  "StreamReaderIterDataPipe": {
    "description": "Given IO streams and their label names, yield bytes with label name as tuple.",
    "std_args": [
      "self",
      "datapipe",
      "chunk"
    ],
    "type": "class"
  },
  "StreamWrapper": {
    "description": "StreamWrapper is introduced to wrap file handler generated by DataPipe operation like `FileOpener`.",
    "std_args": [
      "self",
      "file_obj",
      "parent_stream",
      "name"
    ],
    "type": "class"
  },
  "StrictMinMaxConstraint": {
    "description": "For clients: the size at this dimension must be within 'vr' (which",
    "std_args": [
      "self",
      "warn_only",
      "vr"
    ],
    "type": "class"
  },
  "StringTable": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "StudentT": {
    "description": "Creates a Student's t-distribution parameterized by degree of",
    "std_args": [
      "self",
      "df",
      "loc",
      "scale",
      "validate_args"
    ],
    "type": "class"
  },
  "SubclassSymbolicContext": {
    "description": "The correct symbolic context for a given inner tensor of a traceable tensor subclass",
    "std_args": [
      "self",
      "dynamic_sizes",
      "dynamic_strides",
      "constraint_sizes",
      "constraint_strides",
      "specialize_on",
      "view_base_context",
      "tensor_source",
      "shape_env_to_source_to_symbol_cache",
      "inner_contexts"
    ],
    "type": "class"
  },
  "Subgraph": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "is_acc",
      "nodes",
      "device_ordinal"
    ],
    "type": "class"
  },
  "SubgraphMatcher": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "pattern",
      "match_output",
      "match_placeholder",
      "remove_overlapping_matches",
      "ignore_literals"
    ],
    "type": "class"
  },
  "SubgraphMatcherWithNameNodeMap": {
    "description": "Extends SubgraphMatcher to support querying the matched subgraph nodes through node name,",
    "std_args": [
      "self",
      "pattern_gm",
      "match_output",
      "match_placeholder",
      "remove_overlapping_matches",
      "ignore_literals"
    ],
    "type": "class"
  },
  "SubgraphTypeRelationship": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "SubprocessContext": {
    "description": "``PContext`` holding worker processes invoked as a binary.",
    "std_args": [
      "self",
      "name",
      "entrypoint",
      "args",
      "envs",
      "logs_specs",
      "log_line_prefixes",
      "numa_options"
    ],
    "type": "class"
  },
  "SubprocessHandler": {
    "description": "Convenience wrapper around python's ``subprocess.Popen``. Keeps track of",
    "std_args": [
      "self",
      "entrypoint",
      "args",
      "env",
      "stdout",
      "stderr",
      "local_rank_id",
      "numa_options"
    ],
    "type": "class"
  },
  "Subset": {
    "description": "Subset of a dataset at specified indices.",
    "std_args": [
      "self",
      "dataset",
      "indices"
    ],
    "type": "class"
  },
  "SubsetRandomSampler": {
    "description": "Samples elements randomly from a given list of indices, without replacement.",
    "std_args": [
      "self",
      "indices",
      "generator"
    ],
    "type": "class"
  },
  "SummaryWriter": {
    "description": "Writes entries directly to event files in the log_dir to be consumed by TensorBoard.",
    "std_args": [
      "self",
      "log_dir",
      "comment",
      "purge_step",
      "max_queue",
      "flush_secs",
      "filename_suffix"
    ],
    "type": "class"
  },
  "SupportDict": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SupportedArgumentDTypes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SyclExtension": {
    "description": "Creates a :class:`setuptools.Extension` for SYCL/C++.",
    "std_args": [
      "name",
      "sources",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "SymBool": {
    "description": "Like a bool (including magic methods), but redirects all operations on the",
    "std_args": [
      "self",
      "node"
    ],
    "type": "class"
  },
  "SymBoolArgument": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "name"
    ],
    "type": "class"
  },
  "SymExprPrinter": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "SymFloat": {
    "description": "Like a float (including magic methods), but redirects all operations on the",
    "std_args": [
      "self",
      "node"
    ],
    "type": "class"
  },
  "SymFloatArgument": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "name"
    ],
    "type": "class"
  },
  "SymInt": {
    "description": "Like an int (including magic methods), but redirects all operations on the",
    "std_args": [
      "self",
      "node"
    ],
    "type": "class"
  },
  "SymIntArgument": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "name"
    ],
    "type": "class"
  },
  "SymIntEqByExpr": {
    "description": "This is a wrapper around SymInt which has alternative semantics for",
    "std_args": [
      "self",
      "val"
    ],
    "type": "class"
  },
  "SymIntSymbolicContext": {
    "description": "Data structure specifying any constraints on a SymInt input",
    "std_args": [
      "self",
      "constraint"
    ],
    "type": "class"
  },
  "SymNode": {
    "description": "This is a type erased SymInt/SymFloat which we use to do actual operations.",
    "std_args": [
      "self",
      "expr",
      "shape_env",
      "pytype",
      "hint",
      "constant",
      "fx_node",
      "optimized_summation"
    ],
    "type": "class"
  },
  "SymbolicContext": {
    "description": "Data structure specifying how we should create symbols in",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "SymbolicValueError": {
    "description": "Errors around TorchScript values and nodes.",
    "std_args": [
      "self",
      "msg",
      "value"
    ],
    "type": "class"
  },
  "SympyBoolean": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SympyToZ3": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "validator"
    ],
    "type": "class"
  },
  "SyncBatchNorm": {
    "description": "Applies Batch Normalization over a N-Dimensional input.",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "process_group",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "SyncPayload": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "stage_name",
      "success",
      "payload",
      "exception"
    ],
    "type": "class"
  },
  "Synchronize": {
    "description": "Blocks until computation is finished (Barrier).",
    "std_args": [],
    "variants": {}
  },
  "SystemEnv": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "T": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TENSOR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TENSOR_CONSTANT_FILENAME_PREFIX": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TENSOR_REDUCE_FNS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TENSOR_REDUCE_MAP": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TERMINATE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TGreatestUpperBound": {
    "description": "Greatest Upper bound for tensors with dynamic type",
    "std_args": [
      "self",
      "res",
      "rhs1",
      "rhs2"
    ],
    "type": "class"
  },
  "THREAD": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TLS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TOKEN": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TORCH": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TORCHELASTIC_ENABLE_FILE_TIMER": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TORCHELASTIC_HEALTH_CHECK_PORT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TORCHELASTIC_TIMER_FILE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TORCH_AVAILABLE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TORCH_JIT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TORCH_LIB_PATH": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TORCH_REDUCE_FNS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TORCH_REDUCE_MAP": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TORCH_SAVE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TORCH_TO_DCP": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TORCH_WORKER_SERVER_SOCKET": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TRACKER_DUMP_PATH": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TRACKER_MODE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TVar": {
    "description": "Tensor variable with no tensor constructor",
    "std_args": [
      "self",
      "tvar"
    ],
    "type": "class"
  },
  "T_0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "T_cur": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "T_destination": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "T_i": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "T_max": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "T_mult": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Table": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "results",
      "colorize",
      "trim_significant_figures",
      "highlight_warnings"
    ],
    "type": "class"
  },
  "TailLog": {
    "description": "Tail the given log files.",
    "std_args": [
      "self",
      "name",
      "log_files",
      "dst",
      "log_line_prefixes",
      "interval_sec"
    ],
    "type": "class"
  },
  "TanhTransform": {
    "description": "Transform via the mapping :math:`y = \\tanh(x)`.",
    "std_args": [
      "self",
      "cache_size"
    ],
    "type": "class"
  },
  "Tanhshrink": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "class"
  },
  "Target": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TargetTypeName": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TaskSpec": {
    "description": "Container for information used to define a Timer. (except globals)",
    "std_args": [
      "self",
      "stmt",
      "setup",
      "global_setup",
      "label",
      "sub_label",
      "description",
      "env",
      "num_threads"
    ],
    "type": "class"
  },
  "Tensor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TensorArgument": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "name"
    ],
    "type": "class"
  },
  "TensorChunkSpec": {
    "description": "Class used to specify chunking of inputs",
    "std_args": [
      "self",
      "split_dim"
    ],
    "type": "class"
  },
  "TensorDataset": {
    "description": "Dataset wrapping tensors.",
    "std_args": [
      "self",
      "tensors"
    ],
    "type": "class"
  },
  "TensorMetadata": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TensorOrTensors": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TensorPipeRpcBackendOptions": {
    "description": "The backend options for",
    "std_args": [
      "self",
      "num_worker_threads",
      "rpc_timeout",
      "init_method",
      "device_maps",
      "devices",
      "_transports",
      "_channels"
    ],
    "type": "class"
  },
  "TensorProperties": {
    "description": "Properties used to create :class:`Tensor`",
    "std_args": [
      "self",
      "dtype",
      "layout",
      "requires_grad",
      "memory_format",
      "pin_memory"
    ],
    "type": "class"
  },
  "TensorStorageMetadata": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "properties",
      "size",
      "chunks"
    ],
    "type": "class"
  },
  "TensorType": {
    "description": "TensorType defines a type for tensors, which consists of a list of dimensions.",
    "std_args": [
      "self",
      "dim"
    ],
    "type": "class"
  },
  "TensorWeakRef": {
    "description": "Wrapper around a weak ref of a Tensor that handles the _fix_weakref() call required when unwrapping a Tensor weakref.",
    "std_args": [
      "self",
      "tensor"
    ],
    "type": "class"
  },
  "TensorWriteData": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "chunk",
      "properties",
      "size"
    ],
    "type": "class"
  },
  "TensorboardEventHandler": {
    "description": "TensorboardEventHandler is an event handler that will write known events to",
    "std_args": [
      "self",
      "writer"
    ],
    "type": "class"
  },
  "Tensors": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TestPassManager": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Threshold": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "threshold"
    ],
    "type": "function"
  },
  "ThroughputBenchmark": {
    "description": "This class is a wrapper around a c++ component throughput_benchmark::ThroughputBenchmark.",
    "std_args": [
      "self",
      "module"
    ],
    "type": "class"
  },
  "Timer": {
    "description": "Helper class for measuring execution time of PyTorch statements.",
    "std_args": [
      "self",
      "stmt",
      "setup",
      "global_setup",
      "timer",
      "globals",
      "label",
      "sub_label",
      "description",
      "env",
      "num_threads",
      "language"
    ],
    "type": "class"
  },
  "TimerClient": {
    "description": "Client library to acquire and release countdown timers by communicating",
    "std_args": [],
    "type": "class"
  },
  "TimerRequest": {
    "description": "Data object representing a countdown timer acquisition and release",
    "std_args": [
      "self",
      "worker_id",
      "scope_id",
      "expiration_time"
    ],
    "type": "class"
  },
  "TimerServer": {
    "description": "Entity that monitors active timers and expires them",
    "std_args": [
      "self",
      "request_queue",
      "max_interval",
      "daemon"
    ],
    "type": "class"
  },
  "ToTensor": {
    "description": "Convert a PIL Image or numpy.ndarray to tensor.",
    "std_args": [],
    "variants": {}
  },
  "Token": {
    "description": "Represent an opaque fencing token used by the rendezvous backend.",
    "std_args": [],
    "type": "attribute"
  },
  "TokenArgument": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "name"
    ],
    "type": "class"
  },
  "TopK": {
    "description": "Returns the k largest elements of the given input tensor along a given dimension.",
    "std_args": [
      "input",
      "k",
      "dim"
    ],
    "variants": {}
  },
  "TorchAODType": {
    "description": "Placeholder for dtypes that do not exist in PyTorch core yet.",
    "std_args": [],
    "type": "class"
  },
  "TorchFunctionMetadataMode": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "tracer"
    ],
    "type": "class"
  },
  "TorchFunctionMode": {
    "description": "A ``TorchFunctionMode`` allows you to override the meaning of all",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "TorchFunctional": {
    "description": "Torch Functional Namespace",
    "std_args": [],
    "variants": {}
  },
  "TorchVersion": {
    "description": "A string with magic powers to compare to both Version and iterables!",
    "std_args": [],
    "type": "class"
  },
  "TraceError": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TracerBase": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TrackedFake": {
    "description": "Tracks the sources of all fake tensors we wrap in Dynamo.",
    "std_args": [
      "self",
      "fake",
      "source",
      "symbolic_context"
    ],
    "type": "class"
  },
  "Transform": {
    "description": "Abstract class for invertable transformations with computable log",
    "std_args": [
      "self",
      "cache_size"
    ],
    "type": "class"
  },
  "TransformCodeFunc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TransformedDistribution": {
    "description": "Extension of the Distribution class, which applies a sequence of Transforms",
    "std_args": [
      "self",
      "base_distribution",
      "transforms",
      "validate_args"
    ],
    "type": "class"
  },
  "Transformer": {
    "description": "``Transformer`` is a special type of interpreter that produces a",
    "std_args": [
      "self",
      "module"
    ],
    "type": "class"
  },
  "TransformerDecoder": {
    "description": "TransformerDecoder is a stack of N decoder layers.",
    "std_args": [
      "self",
      "decoder_layer",
      "num_layers",
      "norm"
    ],
    "type": "class"
  },
  "TransformerEncoder": {
    "description": "TransformerEncoder is a stack of N encoder layers.",
    "std_args": [
      "self",
      "encoder_layer",
      "num_layers",
      "norm",
      "enable_nested_tensor",
      "mask_check"
    ],
    "type": "class"
  },
  "TranslationValidator": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "Trie": {
    "description": "Creates a Trie out of a list of words. The trie can be exported to a Regex pattern.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "TrieNode": {
    "description": "A Trie node whose children are represented as a directory of char: TrieNode.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "TripletMarginLoss": {
    "description": "Creates a criterion that measures the triplet loss given an input",
    "std_args": [
      "self",
      "margin",
      "p",
      "eps",
      "swap",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "TripletMarginWithDistanceLoss": {
    "description": "Creates a criterion that measures the triplet loss given input",
    "std_args": [
      "self",
      "distance_function",
      "margin",
      "swap",
      "reduction"
    ],
    "type": "class"
  },
  "TypedStorage": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "device",
      "dtype",
      "wrap_storage",
      "_internal"
    ],
    "type": "class"
  },
  "U": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "UCC": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "UNARY_NAMES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "UNARY_NAMES_UNSUPPORTED": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "UNDEFINED": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "UNDERLINE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "UNHEALTHY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "UNIMPLEMENTED_ATTR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "UNKNOWN": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "UNSAFE_MESSAGE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "UNSCALED": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "UNSET_RPC_TIMEOUT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "UNSHARD": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "UNTRACABLE_DATAFRAME_PIPES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "UPPER_LEFT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "USER_INPUT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "USER_INPUT_MUTATION": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "USER_OUTPUT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "USE_TMA": {
    "description": "Whether to use Tensor Memory Accelerator (TMA) on supported hardware.",
    "std_args": [],
    "type": "attribute"
  },
  "UnBatcherIterDataPipe": {
    "description": "Undos batching of data (functional name: ``unbatch``).",
    "std_args": [
      "self",
      "datapipe",
      "unbatch_level"
    ],
    "type": "class"
  },
  "UnaryOpFuzzer": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "seed",
      "dtype",
      "cuda"
    ],
    "type": "class"
  },
  "UnaryOpSparseFuzzer": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "seed",
      "dtype",
      "cuda"
    ],
    "type": "class"
  },
  "Unflatten": {
    "description": "Unflattens a tensor dim expanding it to a desired shape. For use with :class:`~nn.Sequential`.",
    "std_args": [
      "self",
      "dim",
      "unflattened_size"
    ],
    "type": "class"
  },
  "Unfold": {
    "description": "Extracts sliding local blocks from a batched input tensor.",
    "std_args": [
      "self",
      "kernel_size",
      "dilation",
      "padding",
      "stride"
    ],
    "type": "class"
  },
  "Uniform": {
    "description": "Generates uniformly distributed random samples from the half-open interval",
    "std_args": [
      "self",
      "low",
      "high",
      "validate_args"
    ],
    "type": "class"
  },
  "UniformQuantizationObserverBase": {
    "description": "Common base for all observers using uniform quantization to calculate",
    "std_args": [
      "self",
      "dtype",
      "qscheme",
      "reduce_range",
      "quant_min",
      "quant_max",
      "factory_kwargs",
      "eps",
      "is_dynamic",
      "kwargs"
    ],
    "type": "class"
  },
  "UninitializedBuffer": {
    "description": "A buffer that is not initialized.",
    "std_args": [
      "self",
      "data",
      "requires_grad",
      "persistent"
    ],
    "type": "class"
  },
  "UninitializedParameter": {
    "description": "A parameter that is not initialized.",
    "std_args": [
      "self",
      "data",
      "requires_grad"
    ],
    "type": "class"
  },
  "UninitializedTensorMixin": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "UnionFind": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "n"
    ],
    "type": "class"
  },
  "UnpackedDualTensor": {
    "description": "Namedtuple returned by :func:`unpack_dual` containing the primal and tangent components of the dual tensor.",
    "std_args": [],
    "type": "class"
  },
  "Unpickler": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Unserializable": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "inner"
    ],
    "type": "class"
  },
  "Unsqueeze": {
    "description": "Returns a new tensor with a dimension of size one inserted at the specified position.",
    "std_args": [
      "input",
      "dim"
    ],
    "variants": {}
  },
  "UnsupportedNodeError": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "ctx",
      "offending_node",
      "reason"
    ],
    "type": "class"
  },
  "UnsupportedOperatorError": {
    "description": "Raised when an operator is unsupported by the exporter.",
    "std_args": [
      "self",
      "name",
      "version",
      "supported_version"
    ],
    "type": "class"
  },
  "UntypedStorage": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "UpsamplingBilinear2d": {
    "description": "Applies a 2D bilinear upsampling to an input signal composed of several input channels.",
    "std_args": [
      "self",
      "size",
      "scale_factor"
    ],
    "type": "class"
  },
  "UpsamplingNearest2d": {
    "description": "Applies a 2D nearest neighbor upsampling to an input signal composed of several input channels.",
    "std_args": [
      "self",
      "size",
      "scale_factor"
    ],
    "type": "class"
  },
  "V": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "VAR_DEPENDENCY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "VERBOSE_OFF": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "VERBOSE_ON": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "VERBOSE_ON_CREATION": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "VERY_BAD": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ValidationException": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "model",
      "assertions",
      "target_exprs",
      "failed_source_exprs"
    ],
    "type": "class"
  },
  "ValueRangesSLoc": {
    "description": "Locations of the guards that triggered lower and upper bound.",
    "std_args": [
      "self",
      "lower",
      "upper"
    ],
    "type": "class"
  },
  "ValueType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "VarDispatcher": {
    "description": "A dispatcher that calls functions with variable names",
    "std_args": [
      "self",
      "name"
    ],
    "type": "class"
  },
  "Variable": {
    "description": "Generic state container (Trainable or Non-Trainable).",
    "std_args": [
      "value"
    ],
    "variants": {}
  },
  "VariableMeta": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Variadic": {
    "description": "A class whose getitem method can be used to generate a new type",
    "std_args": [],
    "type": "class"
  },
  "VariadicSignatureMeta": {
    "description": "A metaclass that overrides ``__getitem__`` on the class. This is used to",
    "std_args": [],
    "type": "class"
  },
  "VariadicSignatureType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "VersionMap": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "VersionRange": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "View": {
    "description": "Returns a new tensor with the same data as the self tensor but of a different shape.",
    "std_args": [
      "input",
      "shape"
    ],
    "variants": {}
  },
  "VonMises": {
    "description": "A circular von Mises distribution.",
    "std_args": [
      "self",
      "loc",
      "concentration",
      "validate_args"
    ],
    "type": "class"
  },
  "W": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "WARMUP": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "WARNING": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "WARN_FOR_UNFUSED_KERNELS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "WEIGHT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "WEIGHTS_CONFIG_FILENAME_FORMAT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "WEIGHTS_DIR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "WEIGHT_DTYPE_DICT_KEY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "WEIGHT_FILENAME_PREFIX": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "WEIGHT_ONLY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "WORKER": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "WRAPPED_EXCEPTION": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "WRITE_DQ": {
    "description": "Controls whether gradient scatters are done in the DQ iteration loop of the backward pass.",
    "std_args": [],
    "type": "attribute"
  },
  "WRONG_COMPILER_WARNING": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Warning": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "setter",
      "getter"
    ],
    "type": "class"
  },
  "WeakIdKeyDictionary": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "dict",
      "ref_type"
    ],
    "type": "class"
  },
  "WeakIdRef": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "key",
      "callback"
    ],
    "type": "class"
  },
  "WeakRef": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "WeakTensorKeyDictionary": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Weibull": {
    "description": "Samples from a two-parameter Weibull distribution.",
    "std_args": [
      "self",
      "scale",
      "concentration",
      "validate_args"
    ],
    "type": "class"
  },
  "WeightNorm": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "name",
      "dim"
    ],
    "type": "class"
  },
  "WeightNormSparsifier": {
    "description": "Weight-Norm Sparsifier",
    "std_args": [
      "self",
      "sparsity_level",
      "sparse_block_shape",
      "zeros_per_block",
      "norm"
    ],
    "type": "class"
  },
  "WeightedRandomSampler": {
    "description": "Samples elements from ``[0,..,len(weights)-1]`` with given probabilities (weights).",
    "std_args": [
      "self",
      "weights",
      "num_samples",
      "replacement",
      "generator"
    ],
    "type": "class"
  },
  "Wishart": {
    "description": "Creates a Wishart distribution parameterized by a symmetric positive definite matrix :math:`\\Sigma`,",
    "std_args": [
      "self",
      "df",
      "covariance_matrix",
      "precision_matrix",
      "scale_tril",
      "validate_args"
    ],
    "type": "class"
  },
  "WithItemBuilder": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Worker": {
    "description": "A worker instance.",
    "std_args": [
      "self",
      "local_rank",
      "global_rank",
      "role_rank",
      "world_size",
      "role_world_size"
    ],
    "type": "class"
  },
  "WorkerGroup": {
    "description": "A set of ``Worker`` instances.",
    "std_args": [
      "self",
      "spec"
    ],
    "type": "class"
  },
  "WorkerSpec": {
    "description": "Blueprint information about a particular type of worker.",
    "std_args": [
      "self",
      "role",
      "local_world_size",
      "rdzv_handler",
      "fn",
      "entrypoint",
      "args",
      "max_restarts",
      "monitor_interval",
      "master_port",
      "master_addr",
      "local_addr",
      "event_log_handler",
      "numa_options"
    ],
    "type": "class"
  },
  "WorkerState": {
    "description": "A state of the ``WorkerGroup``.",
    "std_args": [],
    "type": "class"
  },
  "WriteItem": {
    "description": "Dataclass which holds information about what needs to be written to storage.",
    "std_args": [
      "self",
      "index",
      "type",
      "bytes_io_data",
      "tensor_data"
    ],
    "type": "class"
  },
  "WriteItemType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "WriteResult": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "index",
      "size_in_bytes",
      "storage_data"
    ],
    "type": "class"
  },
  "X86InductorQuantizer": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "XCCL": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "XL_MODEL_WEIGHTS_DIR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "XL_MODEL_WEIGHTS_PARAM_CONFIG_PATH": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "XNNPACKEngine": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "m",
      "name"
    ],
    "type": "class"
  },
  "XNNPACKQuantizer": {
    "description": "!!! DEPRECATED !!!",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "XPUInductorQuantizer": {
    "description": "XPUInductorQuantizer is a class designed to facilitate",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "ZeroPad1d": {
    "description": "Pads the input tensor boundaries with zero.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ZeroPad2d": {
    "description": "Pads the input tensor boundaries with zero.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ZeroPad3d": {
    "description": "Pads the input tensor boundaries with zero.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ZeroPointDomain": {
    "description": "Enum that indicate whether zero_point is in integer domain or floating point domain",
    "std_args": [],
    "type": "class"
  },
  "ZeroRedundancyOptimizer": {
    "description": "Wrap an arbitrary :class:`optim.Optimizer <torch.optim.Optimizer>` and shards its states across ranks in the group.",
    "std_args": [
      "self",
      "params",
      "optimizer_class",
      "process_group",
      "parameters_as_bucket_view",
      "overlap_with_ddp",
      "defaults"
    ],
    "type": "class"
  },
  "ZipperIterDataPipe": {
    "description": "Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).",
    "std_args": [
      "self",
      "datapipes"
    ],
    "type": "class"
  },
  "ZipperMapDataPipe": {
    "description": "Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).",
    "std_args": [
      "self",
      "datapipes"
    ],
    "type": "class"
  },
  "__imports__": {},
  "a": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "abspath": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "acc_events": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "acc_nodes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "acquire": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "scope_id",
      "expiration_time"
    ],
    "type": "function"
  },
  "action": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "action_map": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "activation": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "activation_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "qconfig"
    ],
    "type": "function"
  },
  "activation_is_dynamically_quantized": {
    "description": "Given a qconfig, decide if the activation needs to be",
    "std_args": [
      "qconfig"
    ],
    "type": "function"
  },
  "activation_is_int32_quantized": {
    "description": "Given a qconfig, decide if the activation needs to be",
    "std_args": [
      "qconfig"
    ],
    "type": "function"
  },
  "activation_is_int8_quantized": {
    "description": "Given a qconfig, decide if the activation needs to be",
    "std_args": [
      "qconfig"
    ],
    "type": "function"
  },
  "activation_is_statically_quantized": {
    "description": "Given a qconfig, decide if the activation needs to be",
    "std_args": [
      "qconfig"
    ],
    "type": "function"
  },
  "activation_post_process": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "activation_relu_or_gelu": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "active": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "adapt": {
    "description": "NOTE: This adapter may mutate given ``input_args_with_path``.",
    "std_args": [
      "self",
      "target_spec",
      "input_spec",
      "input_args",
      "metadata",
      "obj"
    ],
    "type": "function"
  },
  "adapted": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "adaptive_autorange": {
    "description": "Similar to `blocked_autorange` but also checks for variablility in measurements",
    "std_args": [
      "self",
      "threshold",
      "min_run_time",
      "max_run_time",
      "callback"
    ],
    "type": "function"
  },
  "adaptive_avg_pool1d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "adaptive_avg_pool2d": {
    "description": "Applies a 2D adaptive average pooling over a quantized input signal composed",
    "std_args": [
      "input",
      "output_size"
    ],
    "type": "function"
  },
  "adaptive_avg_pool3d": {
    "description": "Applies a 3D adaptive average pooling over a quantized input signal composed",
    "std_args": [
      "input",
      "output_size"
    ],
    "type": "function"
  },
  "adaptive_inference_rule": {
    "description": "The class representing a Python function.",
    "std_args": [
      "n",
      "module_instance",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "adaptive_max_pool1d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "adaptive_max_pool1d_with_indices": {
    "description": "adaptive_max_pool1d(input, output_size, return_indices=False)",
    "std_args": [
      "input",
      "output_size",
      "return_indices"
    ],
    "type": "function"
  },
  "adaptive_max_pool2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "adaptive_max_pool2d_with_indices": {
    "description": "adaptive_max_pool2d(input, output_size, return_indices=False)",
    "std_args": [
      "input",
      "output_size",
      "return_indices"
    ],
    "type": "function"
  },
  "adaptive_max_pool3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "adaptive_max_pool3d_with_indices": {
    "description": "adaptive_max_pool3d(input, output_size, return_indices=False)",
    "std_args": [
      "input",
      "output_size",
      "return_indices"
    ],
    "type": "function"
  },
  "adaptiveavgpool2d_check": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tensor_type",
      "module_instance"
    ],
    "type": "function"
  },
  "adaptiveavgpool2d_inference_rule": {
    "description": "The input and output sizes should be the same except for the last",
    "std_args": [
      "n",
      "module_instance"
    ],
    "type": "function"
  },
  "add_assertion": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "e"
    ],
    "type": "function"
  },
  "add_audio": {
    "description": "Add audio data to summary.",
    "std_args": [
      "self",
      "tag",
      "snd_tensor",
      "global_step",
      "sample_rate",
      "walltime"
    ],
    "type": "function"
  },
  "add_checks": {
    "description": "Adds a function which takes runs various checks on a given graph module.",
    "std_args": [
      "self",
      "check"
    ],
    "type": "function"
  },
  "add_constraint": {
    "description": "Adds a constraint into the current list of constraints.",
    "std_args": [
      "self",
      "constraint"
    ],
    "type": "function"
  },
  "add_custom_scalars": {
    "description": "Create special chart by collecting charts tags in 'scalars'.",
    "std_args": [
      "self",
      "layout"
    ],
    "type": "function"
  },
  "add_custom_scalars_marginchart": {
    "description": "Shorthand for creating marginchart.",
    "std_args": [
      "self",
      "tags",
      "category",
      "title"
    ],
    "type": "function"
  },
  "add_custom_scalars_multilinechart": {
    "description": "Shorthand for creating multilinechart. Similar to ``add_custom_scalars()``, but the only necessary argument is *tags*.",
    "std_args": [
      "self",
      "tags",
      "category",
      "title"
    ],
    "type": "function"
  },
  "add_dependency": {
    "description": "Given a module, add it to the dependency graph according to patterns",
    "std_args": [
      "self",
      "module_name",
      "dependencies"
    ],
    "type": "function"
  },
  "add_dim3": {
    "description": "adds dim3() to the second and third arguments in the kernel launch",
    "std_args": [
      "kernel_string",
      "cuda_kernel"
    ],
    "type": "function"
  },
  "add_done_callback": {
    "description": "Append the given callback function to this ``Future``, which will be run",
    "std_args": [
      "self",
      "callback"
    ],
    "type": "function"
  },
  "add_dtype_config": {
    "description": "Add a set of supported data types passed as arguments to quantize ops in the",
    "std_args": [
      "self",
      "dtype_config"
    ],
    "type": "function"
  },
  "add_embedding": {
    "description": "Add embedding projector data to summary.",
    "std_args": [
      "self",
      "mat",
      "metadata",
      "label_img",
      "global_step",
      "tag",
      "metadata_header"
    ],
    "type": "function"
  },
  "add_equality": {
    "description": "Add an equality constraint",
    "std_args": [
      "self",
      "source",
      "expr"
    ],
    "type": "function"
  },
  "add_event": {
    "description": "Add an event to the event file.",
    "std_args": [
      "self",
      "event",
      "step",
      "walltime"
    ],
    "type": "function"
  },
  "add_figure": {
    "description": "Render matplotlib figure into an image and add it to summary.",
    "std_args": [
      "self",
      "tag",
      "figure",
      "global_step",
      "close",
      "walltime"
    ],
    "type": "function"
  },
  "add_graph": {
    "description": "Add graph data to summary.",
    "std_args": [
      "self",
      "model",
      "input_to_model",
      "verbose",
      "use_strict_trace"
    ],
    "type": "function"
  },
  "add_handler": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "handler"
    ],
    "type": "function"
  },
  "add_histogram": {
    "description": "Add histogram to summary.",
    "std_args": [
      "self",
      "tag",
      "values",
      "global_step",
      "bins",
      "walltime",
      "max_bins"
    ],
    "type": "function"
  },
  "add_histogram_raw": {
    "description": "Add histogram with raw data.",
    "std_args": [
      "self",
      "tag",
      "min",
      "max",
      "num",
      "sum",
      "sum_squares",
      "bucket_limits",
      "bucket_counts",
      "global_step",
      "walltime"
    ],
    "type": "function"
  },
  "add_hparams": {
    "description": "Add a set of hyperparameters to be compared in TensorBoard.",
    "std_args": [
      "self",
      "hparam_dict",
      "metric_dict",
      "hparam_domain_discrete",
      "run_name",
      "global_step"
    ],
    "type": "function"
  },
  "add_image": {
    "description": "Add image data to summary.",
    "std_args": [
      "self",
      "tag",
      "img_tensor",
      "global_step",
      "walltime",
      "dataformats"
    ],
    "type": "function"
  },
  "add_image_with_boxes": {
    "description": "Add image and draw bounding boxes on the image.",
    "std_args": [
      "self",
      "tag",
      "img_tensor",
      "box_tensor",
      "global_step",
      "walltime",
      "rescale",
      "dataformats",
      "labels"
    ],
    "type": "function"
  },
  "add_images": {
    "description": "Add batched image data to summary.",
    "std_args": [
      "self",
      "tag",
      "img_tensor",
      "global_step",
      "walltime",
      "dataformats"
    ],
    "type": "function"
  },
  "add_inference_rule": {
    "description": "Apply the addition inference rule. This includes:",
    "std_args": [
      "n"
    ],
    "type": "function"
  },
  "add_input": {
    "description": "Store a single input to a module into the benchmark memory and keep it there.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "add_layer_norm_constraints": {
    "description": "The constraints say that the type has te form: [*, 1024, 1024]",
    "std_args": [
      "input_dim",
      "normalized_dim"
    ],
    "type": "function"
  },
  "add_linear_constraints": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dims1",
      "dims2",
      "in_features",
      "out_features"
    ],
    "type": "function"
  },
  "add_mesh": {
    "description": "Add meshes or 3D point clouds to TensorBoard.",
    "std_args": [
      "self",
      "tag",
      "vertices",
      "colors",
      "faces",
      "config_dict",
      "global_step",
      "walltime"
    ],
    "type": "function"
  },
  "add_node": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "node",
      "node_order"
    ],
    "type": "function"
  },
  "add_onnx_graph": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "prototxt"
    ],
    "type": "function"
  },
  "add_op_to_sets_of_related_ops": {
    "description": "The class representing a Python function.",
    "std_args": [
      "base_name_to_sets_of_related_ops",
      "op",
      "related_op"
    ],
    "type": "function"
  },
  "add_param_group": {
    "description": "Add a param group to the :class:`Optimizer` s `param_groups`.",
    "std_args": [
      "self",
      "param_group"
    ],
    "type": "function"
  },
  "add_pass": {
    "description": "Adds a pass into the current list of passes.",
    "std_args": [
      "self",
      "_pass"
    ],
    "type": "function"
  },
  "add_pr_curve": {
    "description": "Add precision recall curve.",
    "std_args": [
      "self",
      "tag",
      "labels",
      "predictions",
      "global_step",
      "num_thresholds",
      "weights",
      "walltime"
    ],
    "type": "function"
  },
  "add_pr_curve_raw": {
    "description": "Add precision recall curve with raw data.",
    "std_args": [
      "self",
      "tag",
      "true_positive_counts",
      "false_positive_counts",
      "true_negative_counts",
      "false_negative_counts",
      "precision",
      "recall",
      "global_step",
      "num_thresholds",
      "weights",
      "walltime"
    ],
    "type": "function"
  },
  "add_pruning_method": {
    "description": "Add a child pruning ``method`` to the container.",
    "std_args": [
      "self",
      "method"
    ],
    "type": "function"
  },
  "add_quant_dequant": {
    "description": "Wrap the leaf child module in QuantWrapper if it has a valid qconfig",
    "std_args": [
      "module"
    ],
    "type": "function"
  },
  "add_relu": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "x",
      "y"
    ],
    "type": "function"
  },
  "add_safe_globals": {
    "description": "Marks the given globals as safe for ``weights_only`` load. For example, functions",
    "std_args": [
      "safe_globals"
    ],
    "type": "function"
  },
  "add_scalar": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "x",
      "y"
    ],
    "type": "function"
  },
  "add_scalars": {
    "description": "Add many scalar data to summary.",
    "std_args": [
      "self",
      "main_tag",
      "tag_scalar_dict",
      "global_step",
      "walltime"
    ],
    "type": "function"
  },
  "add_source_expr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "e"
    ],
    "type": "function"
  },
  "add_summary": {
    "description": "Add a `Summary` protocol buffer to the event file.",
    "std_args": [
      "self",
      "summary",
      "global_step",
      "walltime"
    ],
    "type": "function"
  },
  "add_target_expr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "e"
    ],
    "type": "function"
  },
  "add_tensor": {
    "description": "Add tensor data to summary.",
    "std_args": [
      "self",
      "tag",
      "tensor",
      "global_step",
      "walltime"
    ],
    "type": "function"
  },
  "add_text": {
    "description": "Add text data to summary.",
    "std_args": [
      "self",
      "tag",
      "text_string",
      "global_step",
      "walltime"
    ],
    "type": "function"
  },
  "add_value": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "metric_name",
      "metric_value"
    ],
    "type": "function"
  },
  "add_var": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "symbol",
      "type"
    ],
    "type": "function"
  },
  "add_var_to_val": {
    "description": "Adds a new symbol to the symbolic environment.",
    "std_args": [
      "self",
      "expr",
      "val"
    ],
    "type": "function"
  },
  "add_video": {
    "description": "Add video data to summary.",
    "std_args": [
      "self",
      "tag",
      "vid_tensor",
      "global_step",
      "fps",
      "walltime"
    ],
    "type": "function"
  },
  "add_zero_attn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "additional_globals": {
    "description": "If your codegen uses extra global values, add tuples of (identifier,reference to the value) here.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "addmm": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "addmm_flop": {
    "description": "Count flops for addmm.",
    "std_args": [
      "self_shape",
      "a_shape",
      "b_shape",
      "out_shape",
      "kwargs"
    ],
    "type": "function"
  },
  "affine": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "affine_grid": {
    "description": "Generate 2D or 3D flow field (sampling grid), given a batch of affine matrices :attr:`theta`.",
    "std_args": [
      "theta",
      "size",
      "align_corners"
    ],
    "type": "function"
  },
  "affinity_mode": {
    "description": "If true, we will fall back to using the original command/entrypoint if we fail to compute",
    "std_args": [],
    "type": "attribute"
  },
  "airy_ai": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "alg_id_cusparselt": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "alias_to": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "align_corners": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "align_tensors": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tensors"
    ],
    "type": "function"
  },
  "all_eq": {
    "description": "For operations where the input shape is equal to the output shape",
    "std_args": [
      "n"
    ],
    "type": "function"
  },
  "all_gather": {
    "description": "The class representing a Python function.",
    "std_args": [
      "inputs",
      "outputs",
      "streams",
      "comms"
    ],
    "type": "function"
  },
  "all_gather_coalesced": {
    "description": "Gathers input tensors from the whole group in a list in a coalesced manner.",
    "std_args": [
      "output_tensor_lists",
      "input_tensor_list",
      "group",
      "async_op"
    ],
    "type": "function"
  },
  "all_gather_dtensor": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tensor",
      "parent_mesh"
    ],
    "type": "function"
  },
  "all_gather_into_tensor": {
    "description": "Gather tensors from all ranks and put them in a single output tensor.",
    "std_args": [
      "output_tensor",
      "input_tensor",
      "group",
      "async_op"
    ],
    "type": "function"
  },
  "all_gather_object": {
    "description": "Gathers picklable objects from the whole group into a list.",
    "std_args": [
      "object_list",
      "obj",
      "group"
    ],
    "type": "function"
  },
  "all_gather_object_enforce_type": {
    "description": "Similar to plain all_gather_object but with additional type checking",
    "std_args": [
      "pg",
      "object_list",
      "obj",
      "type_checker"
    ],
    "type": "function"
  },
  "all_input_nodes": {
    "description": "Return all Nodes that are inputs to this Node. This is equivalent to",
    "std_args": [],
    "type": "attribute"
  },
  "all_node_args_except_first": {
    "description": "Returns all node arg indices after first",
    "std_args": [
      "node"
    ],
    "type": "function"
  },
  "all_node_args_have_no_tensors": {
    "description": "If we know for sure that all of this node's args have no",
    "std_args": [
      "node",
      "modules",
      "cache"
    ],
    "type": "function"
  },
  "all_paths": {
    "description": "Return a dot representation of the subgraph",
    "std_args": [
      "self",
      "src",
      "dst"
    ],
    "type": "function"
  },
  "all_reduce": {
    "description": "The class representing a Python function.",
    "std_args": [
      "inputs",
      "outputs",
      "op",
      "streams",
      "comms"
    ],
    "type": "function"
  },
  "all_reduce_coalesced": {
    "description": "WARNING: at this time individual shape checking is not implemented across nodes.",
    "std_args": [
      "tensors",
      "op",
      "group",
      "async_op"
    ],
    "type": "function"
  },
  "all_return_types": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "all_to_all": {
    "description": "Each process scatters list of input tensors to all processes in a group and return gathered list of tensors in output list.",
    "std_args": [
      "output_tensor_list",
      "input_tensor_list",
      "group"
    ],
    "type": "function"
  },
  "all_to_all_single": {
    "description": "Each process splits input tensor and then scatters the split list to all processes in a group.",
    "std_args": [
      "output",
      "input",
      "output_split_sizes",
      "input_split_sizes",
      "group"
    ],
    "type": "function"
  },
  "all_weights": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "all_writers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "allocator": {
    "description": "Returns the allocator this MemPool routes allocations to.",
    "std_args": [],
    "type": "attribute"
  },
  "allow_dynamic_output_shape_ops": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "allow_fp16_bf16_reduction_math_sdp": {
    "description": ".. warning:: This flag is beta and subject to change.",
    "std_args": [
      "enabled"
    ],
    "type": "function"
  },
  "allow_implicit_sharing": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "allow_in_graph": {
    "description": "Tells the compiler frontend (Dynamo) to skip symbolic introspection of the function",
    "std_args": [
      "fn"
    ],
    "type": "function"
  },
  "allow_insert_stateless_mods": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "allow_mutation_on_saved_tensors": {
    "description": "Context manager under which mutating tensors saved for backward is allowed.",
    "std_args": [],
    "type": "function"
  },
  "allow_non_tensor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "allow_partial_load": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "allow_scalar_outputs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "allow_tf32": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "allowed_single_node_partition_ops": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "allows_single_node_partition": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "allreduce_hook": {
    "description": "Call ``allreduce`` using ``GradBucket`` tensors.",
    "std_args": [
      "process_group",
      "bucket"
    ],
    "type": "function"
  },
  "alpha": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "alpha_dropout": {
    "description": "Apply alpha dropout to the input.",
    "std_args": [
      "input",
      "p",
      "training",
      "inplace"
    ],
    "type": "function"
  },
  "also_bool_magic_methods": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "always_bool_magic_methods": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "always_float_magic_methods": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "always_int_magic_methods": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "always_wrap_policy": {
    "description": "A simple recursive wrap policy that always returns ``True``. This means",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "ambiguities": {
    "description": "All signature pairs such that A is ambiguous with B",
    "std_args": [
      "signatures"
    ],
    "type": "function"
  },
  "ambiguity_warn": {
    "description": "Raise warning when ambiguity is detected",
    "std_args": [
      "dispatcher",
      "ambiguities"
    ],
    "type": "function"
  },
  "ambiguous": {
    "description": "A is consistent with B but neither is strictly more specific",
    "std_args": [
      "a",
      "b"
    ],
    "type": "function"
  },
  "aminmax": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "amount": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "amp_definitely_not_available": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "anchor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "anchors": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "and_": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "function"
  },
  "and_masks": {
    "description": "Returns a mask_mod that's the intersection of provided mask_mods",
    "std_args": [
      "mask_mods"
    ],
    "type": "function"
  },
  "ann_to_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ann",
      "loc",
      "rcb"
    ],
    "type": "function"
  },
  "anneal_epochs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "anneal_func": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "annotate": {
    "description": "Use to give type of `the_value` in TorchScript compiler.",
    "std_args": [
      "the_type",
      "the_value"
    ],
    "type": "function"
  },
  "annotate_functionals": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "annotate_get_attrs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "annotate_getitem_nodes": {
    "description": "Annotate the type of getitem nodes, inferred from the type of sequence node.",
    "std_args": [
      "graph"
    ],
    "type": "function"
  },
  "annotate_modules": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "announce_self_waiting": {
    "description": "Announce this worker is waiting (via num_workers_waiting counter) to join next",
    "std_args": [
      "self",
      "expected_version"
    ],
    "type": "function"
  },
  "any_chain": {
    "description": "Combines a sequence of `OperatorSupportBase` instances to form a single `OperatorSupportBase`",
    "std_args": [
      "op_support"
    ],
    "type": "function"
  },
  "aot_based": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "aot_based_partition": {
    "description": "This function helps to rebuild the partitions given the nodes and its",
    "std_args": [
      "self",
      "node_to_partition_mapping",
      "partition_to_logical_device_mapping"
    ],
    "type": "function"
  },
  "append": {
    "description": "Insert ``x`` after this node in the list of nodes in the graph.",
    "std_args": [
      "self",
      "x"
    ],
    "type": "function"
  },
  "append_cpu_child": {
    "description": "Append a CPU child of type FunctionEvent.",
    "std_args": [
      "self",
      "child"
    ],
    "type": "function"
  },
  "append_kernel": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "name",
      "device",
      "duration"
    ],
    "type": "function"
  },
  "apply": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "apply_gm_pass": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "pass_fn"
    ],
    "type": "function"
  },
  "apply_graph_pass": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "pass_fn"
    ],
    "type": "function"
  },
  "apply_jvp": {
    "description": "Apply method used when executing forward mode AD during the forward",
    "std_args": [
      "self",
      "args"
    ],
    "type": "function"
  },
  "apply_mask": {
    "description": "Simply handles the multiplication between the parameter being pruned and the generated mask.",
    "std_args": [
      "self",
      "module"
    ],
    "type": "function"
  },
  "apply_ops": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dataframe"
    ],
    "type": "function"
  },
  "apply_ops_2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dataframe"
    ],
    "type": "function"
  },
  "apply_padding": {
    "description": "We are considering the possibility where one input has less dimensions than",
    "std_args": [
      "e1_var",
      "e11",
      "e2",
      "e12",
      "d2",
      "d11",
      "d12",
      "counter"
    ],
    "type": "function"
  },
  "apply_permutation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tensor",
      "permutation",
      "dim"
    ],
    "type": "function"
  },
  "apply_random_seed": {
    "description": "Traverse the graph of ``DataPipes`` to find random ``DataPipe`` with an API of ``set_seed``.",
    "std_args": [
      "datapipe",
      "rng"
    ],
    "type": "function"
  },
  "apply_sharding": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "num_of_instances",
      "instance_id",
      "sharding_group"
    ],
    "type": "function"
  },
  "apply_shuffle_seed": {
    "description": "The class representing a Python function.",
    "std_args": [
      "datapipe",
      "rng"
    ],
    "type": "function"
  },
  "apply_shuffle_settings": {
    "description": "Traverse the graph of ``DataPipes`` to find and set shuffle attribute.",
    "std_args": [
      "datapipe",
      "shuffle"
    ],
    "type": "function"
  },
  "approximate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "arange_inference_rule": {
    "description": "The class representing a Python function.",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "are_deterministic_algorithms_enabled": {
    "description": "Returns True if the global deterministic flag is turned on. Refer to",
    "std_args": [],
    "type": "function"
  },
  "are_nodes_independent": {
    "description": "Check if all of the given nodes are pairwise-data independent.",
    "std_args": [
      "nodes"
    ],
    "type": "function"
  },
  "arg": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "arg_constraints": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "args": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "as_datapipe": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "as_functional_optim": {
    "description": "The class representing a Python function.",
    "std_args": [
      "optim_cls",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "as_integer_ratio": {
    "description": "Represent this float as an exact integer ratio",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "as_masked_tensor": {
    "description": "The class representing a Python function.",
    "std_args": [
      "data",
      "mask"
    ],
    "type": "function"
  },
  "as_nested_tensor": {
    "description": "Constructs a nested tensor preserving autograd history from a tensor or a list / tuple of",
    "std_args": [
      "ts",
      "dtype",
      "device",
      "layout"
    ],
    "type": "function"
  },
  "as_row_name": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "as_sparse_gradcheck": {
    "description": "Decorate function, to extend gradcheck for sparse tensors.",
    "std_args": [
      "gradcheck"
    ],
    "type": "function"
  },
  "as_standardized": {
    "description": "Strip library names and some prefixes from function strings.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "as_str": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "indent"
    ],
    "type": "function"
  },
  "as_tuple": {
    "description": "Returns a tuple of the attributes of the BlockMask.",
    "std_args": [
      "self",
      "flatten"
    ],
    "type": "function"
  },
  "asgd": {
    "description": "Functional API that performs asgd algorithm computation.",
    "std_args": [
      "params",
      "grads",
      "axs",
      "mus",
      "etas",
      "state_steps",
      "foreach",
      "maximize",
      "differentiable",
      "capturable",
      "has_complex",
      "lambd",
      "lr",
      "t0",
      "alpha",
      "weight_decay"
    ],
    "type": "function"
  },
  "assert_and_get_unique_device": {
    "description": "Returns the unique device for a module, or None if no device is found.",
    "std_args": [
      "module"
    ],
    "type": "function"
  },
  "assert_dicts_equal": {
    "description": "Builtin dict comparison will not compare numpy arrays.",
    "std_args": [
      "dict_0",
      "dict_1"
    ],
    "type": "function"
  },
  "assert_fn": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "assert_inference_rule": {
    "description": "The class representing a Python function.",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "assert_int_or_pair": {
    "description": "The class representing a Python function.",
    "std_args": [
      "arg",
      "arg_name",
      "message"
    ],
    "type": "function"
  },
  "assertion_dep_token": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "assoc": {
    "description": "Return a new dict with new key value pair",
    "std_args": [
      "d",
      "key",
      "value",
      "factory"
    ],
    "type": "function"
  },
  "assoc_in": {
    "description": "Return a new dict with new, potentially nested, key value pair",
    "std_args": [
      "d",
      "keys",
      "value",
      "factory"
    ],
    "type": "function"
  },
  "assume_constant_result": {
    "description": "This function is used to mark a function `fn` as having a constant result.",
    "std_args": [
      "fn"
    ],
    "type": "function"
  },
  "assume_static_by_default": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "async_execution": {
    "description": "A decorator for a function indicating that the return value of the function",
    "std_args": [
      "fn"
    ],
    "type": "function"
  },
  "async_save": {
    "description": "Asynchronous version of ``save``. This code first de-stages the state_dict on to the",
    "std_args": [
      "state_dict",
      "checkpoint_id",
      "storage_writer",
      "planner",
      "process_group",
      "async_checkpointer_type",
      "async_stager",
      "no_dist",
      "use_collectives"
    ],
    "type": "function"
  },
  "aten": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "aten_decompositions": {
    "description": "Return the ONNX to ATen decomp table.",
    "std_args": [],
    "type": "function"
  },
  "atleast_1d": {
    "description": "Returns a 1-dimensional view of each input tensor with zero dimensions.",
    "std_args": [
      "tensors"
    ],
    "type": "function"
  },
  "atleast_2d": {
    "description": "Returns a 2-dimensional view of each input tensor with zero dimensions.",
    "std_args": [
      "tensors"
    ],
    "type": "function"
  },
  "atleast_3d": {
    "description": "Returns a 3-dimensional view of each input tensor with zero dimensions.",
    "std_args": [
      "tensors"
    ],
    "type": "function"
  },
  "attach_out_of_memory_observer": {
    "description": "Attach an out-of-memory observer to MTIA memory allocator",
    "std_args": [
      "observer"
    ],
    "type": "function"
  },
  "attr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "attribute": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "audio": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tag",
      "tensor",
      "sample_rate"
    ],
    "type": "function"
  },
  "audiohandler": {
    "description": "The class representing a Python function.",
    "std_args": [
      "extension",
      "data"
    ],
    "type": "function"
  },
  "augassign_map": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "augment_many_model_functions_with_bundled_inputs": {
    "description": "Add bundled sample inputs to a model for an arbitrary list of public functions.",
    "std_args": [
      "model",
      "inputs",
      "_receive_inflate_expr",
      "info",
      "skip_size_check"
    ],
    "type": "function"
  },
  "augment_model_with_bundled_inputs": {
    "description": "Add bundled sample inputs to a model for the forward function.",
    "std_args": [
      "model",
      "inputs",
      "_receive_inflate_expr",
      "info",
      "skip_size_check"
    ],
    "type": "function"
  },
  "autocast": {
    "description": "Instances of :class:`autocast` serve as context managers or decorators that",
    "std_args": [
      "self",
      "device_type",
      "dtype",
      "enabled",
      "cache_enabled"
    ],
    "type": "class"
  },
  "autocast_decorator": {
    "description": "The class representing a Python function.",
    "std_args": [
      "autocast_instance",
      "func"
    ],
    "type": "function"
  },
  "autoclose": {
    "description": "Automatically close stream when all child streams are closed or if there are none.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "autorange": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "callback"
    ],
    "type": "function"
  },
  "available_mem_bytes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "average_parameters": {
    "description": "Averages all the given parameters.",
    "std_args": [
      "params",
      "process_group"
    ],
    "type": "function"
  },
  "average_parameters_or_parameter_groups": {
    "description": "Averages parameters of a model or parameter groups of an optimizer.",
    "std_args": [
      "params",
      "process_group"
    ],
    "type": "function"
  },
  "averager": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "averaging_constant": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "avg_fn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "avg_pool1d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "avg_pool2d": {
    "description": "Applies 2D average-pooling operation in :math:`kH \\times kW` regions by step size",
    "std_args": [
      "input",
      "kernel_size",
      "stride",
      "padding",
      "ceil_mode",
      "count_include_pad",
      "divisor_override"
    ],
    "type": "function"
  },
  "avg_pool3d": {
    "description": "Applies 3D average-pooling operation in :math:`kD \\ times kH \\times kW` regions by step size",
    "std_args": [
      "input",
      "kernel_size",
      "stride",
      "padding",
      "ceil_mode",
      "count_include_pad",
      "divisor_override"
    ],
    "type": "function"
  },
  "axis": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "backend": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "backend_capability": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "backend_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "backend_list": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "backend_registered": {
    "description": "Checks if backend_name is registered as an RPC backend.",
    "std_args": [
      "backend_name"
    ],
    "type": "function"
  },
  "backend_type_map": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "backward": {
    "description": "Shared backward utility.",
    "std_args": [
      "self",
      "gradients"
    ],
    "type": "function"
  },
  "backward_extended": {
    "description": "User defined backward.",
    "std_args": [
      "self",
      "grad_output"
    ],
    "type": "function"
  },
  "backward_signature": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "baddbmm_flop": {
    "description": "Count flops for the baddbmm operation.",
    "std_args": [
      "self_shape",
      "a_shape",
      "b_shape",
      "out_shape",
      "kwargs"
    ],
    "type": "function"
  },
  "banned_ops": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "barrier": {
    "description": "A global lock between agents. This will pause all workers until at least",
    "std_args": [
      "store",
      "world_size",
      "key_prefix",
      "barrier_timeout",
      "rank",
      "rank_tracing_decoder",
      "trace_timeout"
    ],
    "type": "function"
  },
  "bartlett": {
    "description": "The class representing a Python function.",
    "std_args": [
      "M",
      "sym",
      "dtype",
      "layout",
      "device",
      "requires_grad"
    ],
    "type": "function"
  },
  "base_constraint": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "base_dist": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "base_lrs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "base_momentums": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "base_op_node": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "base_sl": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "base_transform": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "base_types": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "baseline_exclusive_stats": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "baseline_inclusive_stats": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "basichandlers": {
    "description": "Transforms raw data (byte stream) into python objects.",
    "std_args": [
      "extension",
      "data"
    ],
    "type": "function"
  },
  "batch": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "batch_size",
      "drop_last",
      "wrapper_class"
    ],
    "type": "function"
  },
  "batch_first": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "batch_isend_irecv": {
    "description": "Send or Receive a batch of tensors asynchronously and return a list of requests.",
    "std_args": [
      "p2p_op_list"
    ],
    "type": "function"
  },
  "batch_norm": {
    "description": "Apply Batch Normalization for each channel across a batch of data.",
    "std_args": [
      "input",
      "running_mean",
      "running_var",
      "weight",
      "bias",
      "training",
      "momentum",
      "eps"
    ],
    "type": "function"
  },
  "batch_sampler": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "batch_shape": {
    "description": "Returns the shape over which parameters are batched.",
    "std_args": [],
    "type": "attribute"
  },
  "batch_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "batch_sizes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "batch_tensors_with_same_shape": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "batched_powerSGD_hook": {
    "description": "Implement simplified PowerSGD algorithm.",
    "std_args": [
      "state",
      "bucket"
    ],
    "type": "function"
  },
  "batchnorm_inference_rule": {
    "description": "The class representing a Python function.",
    "std_args": [
      "n",
      "module_instance",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "bcolors": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "bench_all": {
    "description": "This is a simple utility that can be used to benchmark torch.compile",
    "std_args": [
      "model",
      "sample_input",
      "num_iters",
      "optimizer",
      "loss_fn"
    ],
    "type": "function"
  },
  "bench_loop": {
    "description": "The class representing a Python function.",
    "std_args": [
      "model",
      "sample_input",
      "num_iters",
      "optimizer",
      "loss_fn"
    ],
    "type": "function"
  },
  "benchmark": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "benchmark_compile": {
    "description": "Use this utility to benchmark torch.compile",
    "std_args": [
      "model",
      "sample_input",
      "num_iters",
      "backend",
      "mode",
      "optimizer",
      "loss_fn"
    ],
    "type": "function"
  },
  "benchmark_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "benchmark_limit": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bessel_j0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bessel_j1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bessel_y0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bessel_y1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "beta": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bf16_compress_hook": {
    "description": "Warning: This API is experimental, and it requires NCCL version later than 2.9.6.",
    "std_args": [
      "process_group",
      "bucket"
    ],
    "type": "function"
  },
  "bf16_compress_wrapper": {
    "description": "Warning: This API is experimental, and it requires NCCL version later than 2.9.6.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "bfloat16": {
    "description": "Casts all floating point parameters and buffers to ``bfloat16`` datatype.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "bfs_level": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bfs_trace_with_node_process": {
    "description": "Traverse the graph module and apply node_op to each node.",
    "std_args": [
      "model",
      "node_op"
    ],
    "type": "function"
  },
  "bias": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bias_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bias_hh": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bias_ih": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bias_k": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bias_v": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "biject_to": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bijective": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bilinear": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bin_edges": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "binary_cross_entropy": {
    "description": "Compute Binary Cross Entropy between the target and input probabilities.",
    "std_args": [
      "input",
      "target",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "binary_cross_entropy_with_logits": {
    "description": "Compute Binary Cross Entropy between target and input logits.",
    "std_args": [
      "input",
      "target",
      "weight",
      "size_average",
      "reduce",
      "reduction",
      "pos_weight"
    ],
    "type": "function"
  },
  "binary_magic_method_remap": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "binary_op_dtype_configs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bind": {
    "description": "The class representing a Python function.",
    "std_args": [
      "optional",
      "fn"
    ],
    "type": "function"
  },
  "bind_symbols": {
    "description": "Given a paired list of placeholders (fake tensors with",
    "std_args": [
      "self",
      "placeholders",
      "args"
    ],
    "type": "function"
  },
  "binop_map": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bins": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bisect": {
    "description": "The class representing a Python function.",
    "std_args": [
      "shape_env"
    ],
    "type": "function"
  },
  "bit_length": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "bitwise_ops": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "blackman": {
    "description": "The class representing a Python function.",
    "std_args": [
      "M",
      "sym",
      "dtype",
      "layout",
      "device",
      "requires_grad"
    ],
    "type": "function"
  },
  "blank": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "block_diag": {
    "description": "Create a block diagonal matrix from provided tensors.",
    "std_args": [
      "tensors"
    ],
    "type": "function"
  },
  "block_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "blocked_autorange": {
    "description": "Measure many replicates while keeping timer overhead to a minimum.",
    "std_args": [
      "self",
      "callback",
      "min_run_time"
    ],
    "type": "function"
  },
  "bmm_flop": {
    "description": "Count flops for the bmm operation.",
    "std_args": [
      "a_shape",
      "b_shape",
      "out_shape",
      "kwargs"
    ],
    "type": "function"
  },
  "bmm_inference_rule": {
    "description": "Constraints that match the input to a size 3 tensor",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "bn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bn2d_inference_rule": {
    "description": "Given a BatchNorm2D instance and a node check the following conditions:",
    "std_args": [
      "n",
      "module_instance"
    ],
    "type": "function"
  },
  "bool": {
    "description": "Casts this storage to bool type.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "bool_": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "bool_becomes_int_magic_methods": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bool_magic_methods": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "boolean": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "boolop_map": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bootstrap_store_info": {
    "description": "Store information that can used by trainer code to bootstrap distributed comms.",
    "std_args": [],
    "type": "attribute"
  },
  "bound_sympy": {
    "description": "Given a sympy expression, computes a ValueRanges bound for what values it can be",
    "std_args": [
      "self",
      "expr",
      "size_oblivious"
    ],
    "type": "function"
  },
  "boxed_run": {
    "description": "Run `module` via interpretation and return the result.  This uses the \"boxed\"",
    "std_args": [
      "self",
      "args_list"
    ],
    "type": "function"
  },
  "breakpoint": {
    "description": "Set a breakpoint, but only on a single rank.  All other ranks will wait for you to be",
    "std_args": [
      "rank",
      "skip",
      "timeout_s"
    ],
    "type": "function"
  },
  "broadcast": {
    "description": "The class representing a Python function.",
    "std_args": [
      "inputs",
      "root",
      "streams",
      "comms"
    ],
    "type": "function"
  },
  "broadcast_all": {
    "description": "Given a list of values (possibly containing numbers), returns a list where each",
    "std_args": [
      "values"
    ],
    "type": "function"
  },
  "broadcast_bucket_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "broadcast_buffers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "broadcast_coalesced": {
    "description": "Broadcast a sequence of tensors to the specified GPUs.",
    "std_args": [
      "tensors",
      "devices",
      "buffer_size"
    ],
    "type": "function"
  },
  "broadcast_dim": {
    "description": "Apply broadcasting to the 'index' dimension of tensor_input1.",
    "std_args": [
      "tensor_input1",
      "tensor_input2",
      "res1",
      "res2",
      "index",
      "padding"
    ],
    "type": "function"
  },
  "broadcast_from_rank0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "broadcast_object_list": {
    "description": "Broadcasts picklable objects in ``object_list`` to the whole group.",
    "std_args": [
      "object_list",
      "src",
      "group",
      "device",
      "group_src"
    ],
    "type": "function"
  },
  "broadcast_shapes": {
    "description": "broadcast_shapes(*shapes) -> Size",
    "std_args": [
      "shapes"
    ],
    "type": "function"
  },
  "broadcast_tensors": {
    "description": "broadcast_tensors(*tensors) -> List of Tensors",
    "std_args": [
      "tensors"
    ],
    "type": "function"
  },
  "broadcast_types": {
    "description": "Applies broadcasting to both given types such that they",
    "std_args": [
      "t1",
      "t2"
    ],
    "type": "function"
  },
  "broadcast_warning": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "broadcasting_inference_rule": {
    "description": "The class representing a Python function.",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "bucket_bytes_cap": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bucket_bytes_cap_default": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "buffer": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "buffer_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "buffer_elements": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "buffer_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "buffers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "buffers_to_mutate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "build": {
    "description": "Factory method, finds unused new port on rank0 host and addr/port info with all ranks.",
    "std_args": [
      "rank",
      "store",
      "local_addr",
      "server_port"
    ],
    "type": "function"
  },
  "build_AnnAssign": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "stmt"
    ],
    "type": "function"
  },
  "build_Assert": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "stmt"
    ],
    "type": "function"
  },
  "build_Assign": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "stmt"
    ],
    "type": "function"
  },
  "build_Attribute": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "expr"
    ],
    "type": "function"
  },
  "build_AugAssign": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "stmt"
    ],
    "type": "function"
  },
  "build_BinOp": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "expr"
    ],
    "type": "function"
  },
  "build_BoolOp": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "expr"
    ],
    "type": "function"
  },
  "build_Break": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "stmt"
    ],
    "type": "function"
  },
  "build_Call": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "expr"
    ],
    "type": "function"
  },
  "build_Compare": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "expr"
    ],
    "type": "function"
  },
  "build_Constant": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "expr"
    ],
    "type": "function"
  },
  "build_Continue": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "stmt"
    ],
    "type": "function"
  },
  "build_Delete": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "stmt"
    ],
    "type": "function"
  },
  "build_Dict": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "expr"
    ],
    "type": "function"
  },
  "build_DictComp": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "stmt"
    ],
    "type": "function"
  },
  "build_Ellipsis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "expr"
    ],
    "type": "function"
  },
  "build_Expr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "stmt"
    ],
    "type": "function"
  },
  "build_For": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "stmt"
    ],
    "type": "function"
  },
  "build_GeneratorExp": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "stmt"
    ],
    "type": "function"
  },
  "build_If": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "stmt"
    ],
    "type": "function"
  },
  "build_IfExp": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "expr"
    ],
    "type": "function"
  },
  "build_JoinedStr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "expr"
    ],
    "type": "function"
  },
  "build_List": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "expr"
    ],
    "type": "function"
  },
  "build_ListComp": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "stmt"
    ],
    "type": "function"
  },
  "build_Name": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "expr"
    ],
    "type": "function"
  },
  "build_NameConstant": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "expr"
    ],
    "type": "function"
  },
  "build_Num": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "expr"
    ],
    "type": "function"
  },
  "build_Pass": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "stmt"
    ],
    "type": "function"
  },
  "build_Print": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "stmt"
    ],
    "type": "function"
  },
  "build_Raise": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "stmt"
    ],
    "type": "function"
  },
  "build_Return": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "stmt"
    ],
    "type": "function"
  },
  "build_Starred": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "expr"
    ],
    "type": "function"
  },
  "build_Str": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "expr"
    ],
    "type": "function"
  },
  "build_Subscript": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "expr"
    ],
    "type": "function"
  },
  "build_Tuple": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "expr"
    ],
    "type": "function"
  },
  "build_UnaryOp": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "expr"
    ],
    "type": "function"
  },
  "build_While": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "stmt"
    ],
    "type": "function"
  },
  "build_With": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "stmt"
    ],
    "type": "function"
  },
  "build_class_def": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "py_def",
      "methods",
      "properties",
      "self_name",
      "assigns"
    ],
    "type": "function"
  },
  "build_def": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "py_def",
      "type_line",
      "def_name",
      "self_name",
      "pdt_arg_types"
    ],
    "type": "function"
  },
  "build_execution_trace_obs_from_env": {
    "description": "Returns an ExecutionTraceObserver instance if the environment variable",
    "std_args": [],
    "type": "function"
  },
  "build_expr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "build_extensions": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "build_from_passlist": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "passes"
    ],
    "type": "function"
  },
  "build_ignore_context_manager": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "stmt"
    ],
    "type": "function"
  },
  "build_param": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "py_arg",
      "self_name",
      "kwarg_only",
      "pdt_arg_type"
    ],
    "type": "function"
  },
  "build_param_list": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "py_args",
      "self_name",
      "pdt_arg_types"
    ],
    "type": "function"
  },
  "build_stage": {
    "description": "Create a pipeline stage given a stage_module to be wrapped by this stage",
    "std_args": [
      "stage_module",
      "stage_index",
      "pipe_info",
      "device",
      "group"
    ],
    "type": "function"
  },
  "build_stmt": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "build_stmts": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "stmts"
    ],
    "type": "function"
  },
  "build_withitem": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "build_withitems": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "items"
    ],
    "type": "function"
  },
  "built_with_debug_symbols": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bundle_inputs": {
    "description": "Create and return a copy of the specified model with inputs attached.",
    "std_args": [
      "model",
      "inputs",
      "info",
      "_receive_inflate_expr"
    ],
    "type": "function"
  },
  "bundle_large_tensor": {
    "description": "Wrap a tensor to allow bundling regardless of size.",
    "std_args": [
      "t"
    ],
    "type": "function"
  },
  "bundle_randn": {
    "description": "Generate a tensor that will be inflated with torch.randn.",
    "std_args": [
      "size",
      "dtype"
    ],
    "type": "function"
  },
  "burn_in_info": {
    "description": "Burn model info into the HTML skeleton.",
    "std_args": [
      "skeleton",
      "info"
    ],
    "type": "function"
  },
  "byte": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "bytes_io_data": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "c": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "c_out": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cache_key_tag": {
    "description": "Tag to be included in the cache key generation for all torch compile caching.",
    "std_args": [],
    "type": "attribute"
  },
  "cache_staged_state_dict": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cached": {
    "description": "Context manager that enables the caching system within parametrizations registered with :func:`register_parametrization`.",
    "std_args": [],
    "type": "function"
  },
  "caches": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "caching_allocator_alloc": {
    "description": "Perform a memory allocation using the CUDA memory allocator.",
    "std_args": [
      "size",
      "device",
      "stream"
    ],
    "type": "function"
  },
  "caching_allocator_delete": {
    "description": "Delete memory allocated using the CUDA memory allocator.",
    "std_args": [
      "mem_ptr"
    ],
    "type": "function"
  },
  "caching_allocator_enable": {
    "description": "Enable or disable the CUDA memory allocator. On by default.",
    "std_args": [
      "value"
    ],
    "type": "function"
  },
  "calc_last_two_dims": {
    "description": "Generates constraints for the last two dimensions of a convolution or a maxpool output",
    "std_args": [
      "constraint",
      "d"
    ],
    "type": "function"
  },
  "calculate_gain": {
    "description": "Return the recommended gain value for the given nonlinearity function.",
    "std_args": [
      "nonlinearity",
      "param"
    ],
    "type": "function"
  },
  "calculate_out_dimension": {
    "description": "For calculating h_in and w_out according to the conv2D documentation",
    "std_args": [
      "d_in",
      "module_instance",
      "index"
    ],
    "type": "function"
  },
  "calculate_qmin_qmax": {
    "description": "Calculates actual qmin and qmax based on the quantization range,",
    "std_args": [
      "quant_min",
      "quant_max",
      "has_customized_qrange",
      "dtype",
      "reduce_range"
    ],
    "type": "function"
  },
  "calculate_qparams": {
    "description": "Calculate quantization parameter based on the stats attached to the observer module",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "calculate_storage_offsets": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "call": {
    "description": "Auto-generated from flax_nnx_dynamic_wiring",
    "std_args": [],
    "type": "function"
  },
  "call_function": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "target",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "call_method": {
    "description": "Execute a ``call_method`` node and return the result.",
    "std_args": [
      "self",
      "target",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "call_modules": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "call_spec": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "call_super_init": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "callable": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "can_device_access_peer": {
    "description": "Check if peer access between two devices is possible.",
    "std_args": [
      "device",
      "peer_device"
    ],
    "type": "function"
  },
  "can_use_cudnn_attention": {
    "description": "Check if cudnn_attention can be utilized in scaled_dot_product_attention.",
    "std_args": [
      "params",
      "debug"
    ],
    "type": "function"
  },
  "can_use_efficient_attention": {
    "description": "Check if efficient_attention can be utilized in scaled_dot_product_attention.",
    "std_args": [
      "params",
      "debug"
    ],
    "type": "function"
  },
  "can_use_flash_attention": {
    "description": "Check if FlashAttention can be utilized in scaled_dot_product_attention.",
    "std_args": [
      "params",
      "debug"
    ],
    "type": "function"
  },
  "canonicalize_bool_expr": {
    "description": "Canonicalize a boolean expression by transforming it into a lt / le",
    "std_args": [
      "expr"
    ],
    "type": "function"
  },
  "capture_begin": {
    "description": "Begin capturing CUDA work on the current stream.",
    "std_args": [
      "self",
      "pool",
      "capture_error_mode"
    ],
    "type": "function"
  },
  "capture_end": {
    "description": "End CUDA graph capture on the current stream.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "capture_error_mode": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "capture_stream": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cartesian_prod": {
    "description": "Do cartesian product of the given sequence of tensors. The behavior is similar to",
    "std_args": [
      "tensors"
    ],
    "type": "function"
  },
  "cas_delay": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "cast_forward_inputs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cast_root_forward_inputs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cast_symbool_to_symint_guardless": {
    "description": "Converts a SymBool or bool to a SymInt or int without introducing guards.",
    "std_args": [
      "symbool"
    ],
    "type": "function"
  },
  "cat": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "x",
      "dim"
    ],
    "type": "function"
  },
  "catch_invalid_utf8": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "causal_lower_right": {
    "description": "Creates a lower-right triangular causal bias.",
    "std_args": [
      "size"
    ],
    "type": "function"
  },
  "causal_upper_left": {
    "description": "Creates an upper-left triangular causal bias.",
    "std_args": [
      "size"
    ],
    "type": "function"
  },
  "cdata": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cdf": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "value"
    ],
    "type": "function"
  },
  "cdist": {
    "description": "Computes batched the p-norm distance between each pair of the two collections of row vectors.",
    "std_args": [
      "x1",
      "x2",
      "p",
      "compute_mode"
    ],
    "type": "function"
  },
  "ceil_mode": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ceil_to_int": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "x",
      "dtype"
    ],
    "type": "function"
  },
  "cell_gate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cell_state_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "celu_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ch_axis": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chain": {
    "description": "Combines a sequence of `OperatorSupportBase` instances to form a single `OperatorSupportBase`",
    "std_args": [
      "op_support"
    ],
    "type": "function"
  },
  "chain_matmul": {
    "description": "Returns the matrix product of the :math:`N` 2-D tensors. This product is efficiently computed",
    "std_args": [
      "matrices",
      "out"
    ],
    "type": "function"
  },
  "change_current_allocator": {
    "description": "Change the currently used memory allocator to be the one provided.",
    "std_args": [
      "allocator"
    ],
    "type": "function"
  },
  "channel_shuffle": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "char": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "chebyshev_polynomial_t": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebyshev_polynomial_u": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebyshev_polynomial_v": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebyshev_polynomial_w": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "check": {
    "description": "Check validity of ``value`` as a possible outcome of sampling",
    "std_args": [
      "self",
      "value"
    ],
    "type": "function"
  },
  "check_backward_validity": {
    "description": "The class representing a Python function.",
    "std_args": [
      "inputs"
    ],
    "type": "function"
  },
  "check_compiler_is_gcc": {
    "description": "The class representing a Python function.",
    "std_args": [
      "compiler"
    ],
    "type": "function"
  },
  "check_compiler_ok_for_platform": {
    "description": "Verify that the compiler is the expected one for the current platform.",
    "std_args": [
      "compiler"
    ],
    "type": "function"
  },
  "check_consistent": {
    "description": "Test that two \"meta\" values (typically either Tensor or SymInt) have",
    "std_args": [
      "new",
      "old"
    ],
    "type": "function"
  },
  "check_dependency": {
    "description": "Given a partition,check if there is a circular dependency on",
    "std_args": [
      "partition"
    ],
    "type": "function"
  },
  "check_env": {
    "description": "Check whether the env var ``PET_{dest}`` exists before defaulting to the given ``default`` value.",
    "std_args": [
      "self",
      "dest",
      "default",
      "kwargs"
    ],
    "type": "class"
  },
  "check_equal": {
    "description": "Compare another ShapeEnv for equivalence",
    "std_args": [
      "self",
      "other"
    ],
    "type": "function"
  },
  "check_error": {
    "description": "The class representing a Python function.",
    "std_args": [
      "res"
    ],
    "type": "function"
  },
  "check_fn": {
    "description": "The class representing a Python function.",
    "std_args": [
      "fn",
      "loc"
    ],
    "type": "function"
  },
  "check_for_mutable_operation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "target",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "check_for_type_equality": {
    "description": "A check equality to be used in fixed points.",
    "std_args": [
      "g1",
      "g2"
    ],
    "type": "function"
  },
  "check_forward_args": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "input",
      "hidden",
      "batch_sizes"
    ],
    "type": "function"
  },
  "check_forward_hidden": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "input",
      "hx",
      "hidden_label"
    ],
    "type": "function"
  },
  "check_forward_input": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "input"
    ],
    "type": "function"
  },
  "check_hidden_size": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "hx",
      "expected_hidden_size",
      "msg"
    ],
    "type": "function"
  },
  "check_input": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "input",
      "batch_sizes"
    ],
    "type": "function"
  },
  "check_input_constraints": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "check_is_root": {
    "description": "Check if this instance is a root FSDP module.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "check_min_max_valid": {
    "description": "Checks if the given minimum and maximum values are valid, meaning that",
    "std_args": [
      "min_val",
      "max_val"
    ],
    "type": "function"
  },
  "check_module_version_greater_or_equal": {
    "description": "Check if a module's version satisfies requirements",
    "std_args": [
      "module",
      "req_version_tuple",
      "error_if_malformed"
    ],
    "type": "function"
  },
  "check_mutable_operations": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "check_nan": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "check_node": {
    "description": "The class representing a Python function.",
    "std_args": [
      "node",
      "modules"
    ],
    "type": "function"
  },
  "check_recorded_events": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "check_release_file": {
    "description": "The class representing a Python function.",
    "std_args": [
      "run_lambda"
    ],
    "type": "function"
  },
  "check_sparse_tensor_invariants": {
    "description": "A tool to control checking sparse tensor invariants.",
    "std_args": [
      "self",
      "enable"
    ],
    "type": "class"
  },
  "check_subgraphs_connected": {
    "description": "Given two subgraphs A and B (in the form of a list of nodes), checks if",
    "std_args": [
      "subgraph1",
      "subgraph2"
    ],
    "type": "function"
  },
  "check_worker_number_rationality": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "checkpoint": {
    "description": "Checkpoint a model or part of the model.",
    "std_args": [
      "function",
      "args",
      "use_reentrant",
      "context_fn",
      "determinism_check",
      "debug",
      "early_stop",
      "kwargs"
    ],
    "type": "function"
  },
  "checkpoint_id": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "checkpoint_missing_warning": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "checkpoint_sequential": {
    "description": "Checkpoint a sequential model to save memory.",
    "std_args": [
      "functions",
      "segments",
      "input",
      "use_reentrant",
      "kwargs"
    ],
    "type": "function"
  },
  "child_counter": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "children": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cholesky_ex": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chunk": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chunk_dtensor": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tensor",
      "rank",
      "device_mesh"
    ],
    "type": "function"
  },
  "chunk_tensor": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tensor",
      "rank",
      "world_size",
      "num_devices_per_node",
      "pg",
      "device"
    ],
    "type": "function"
  },
  "chunks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "clamp_probs": {
    "description": "Clamps the probabilities to be in the open interval `(0, 1)`.",
    "std_args": [
      "probs"
    ],
    "type": "function"
  },
  "class_fqn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "clean_worker": {
    "description": "The class representing a Python function.",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "cleanup": {
    "description": "Break reference cycles.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "clear": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "clear_safe_globals": {
    "description": "Clears the list of globals that are safe for ``weights_only`` load.",
    "std_args": [],
    "type": "function"
  },
  "clear_timers": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "worker_pids"
    ],
    "type": "function"
  },
  "client": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "clip_grad_norm": {
    "description": "Clip the gradient norm of an iterable of parameters.",
    "std_args": [
      "parameters",
      "max_norm",
      "norm_type",
      "error_if_nonfinite",
      "foreach"
    ],
    "type": "function"
  },
  "clip_grad_norm_": {
    "description": "Clip the gradient norm of all parameters.",
    "std_args": [
      "self",
      "max_norm",
      "norm_type"
    ],
    "type": "function"
  },
  "clip_grad_value_": {
    "description": "Clip the gradients of an iterable of parameters at specified value.",
    "std_args": [
      "parameters",
      "clip_value",
      "foreach"
    ],
    "type": "function"
  },
  "clock_rate": {
    "description": "Return the clock speed of the GPU SM in MHz (megahertz) over the past sample period as given by `nvidia-smi`.",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "clone": {
    "description": "Create a copy of this class",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "cloned_coefficient": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "close": {
    "description": "Write the package to the filesystem. Any calls after :meth:`close` are now invalid.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "close_on_last_child": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "close_streams": {
    "description": "Traverse structure and attempts to close all found StreamWrappers on best effort basis.",
    "std_args": [
      "cls",
      "v",
      "depth"
    ],
    "type": "function"
  },
  "closed": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cls_to_become": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cmake_prefix_path": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cmpop_map": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "code": {
    "description": "Return the Python code generated from the ``Graph`` underlying this",
    "std_args": [],
    "type": "attribute"
  },
  "codomain": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "col_block_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "col_fn": {
    "description": "The class representing a Python function.",
    "std_args": [
      "m"
    ],
    "type": "function"
  },
  "collate": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "collate_fn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "collect_all": {
    "description": "Collects the provided :class:`~torch.futures.Future` objects into a single",
    "std_args": [
      "futures"
    ],
    "type": "function"
  },
  "collect_callgrind": {
    "description": "Collect instruction counts using Callgrind.",
    "std_args": [
      "self",
      "number",
      "repeats",
      "collect_baseline",
      "retain_out_file"
    ],
    "type": "function"
  },
  "collect_producer_nodes": {
    "description": "Starting from a target node, trace back until we hit input or",
    "std_args": [
      "node"
    ],
    "type": "function"
  },
  "colorize": {
    "description": "Colorize formatted table.",
    "std_args": [
      "self",
      "rowwise"
    ],
    "type": "function"
  },
  "column_keys": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "columns": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "combine_two_partitions": {
    "description": "Given a list of partitions and its two partitions,",
    "std_args": [
      "partition_0",
      "partition_1",
      "partitions"
    ],
    "type": "function"
  },
  "commit_tensor": {
    "description": "Call once the StorageReader finished loading data into ``tensor``.",
    "std_args": [
      "self",
      "read_item",
      "tensor"
    ],
    "type": "function"
  },
  "common_notes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "compare": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "compare_graphs": {
    "description": "Return True if two graphs are identical, i.e they",
    "std_args": [
      "left",
      "right"
    ],
    "type": "function"
  },
  "compile_callgrind_template": {
    "description": "The class representing a Python function.",
    "std_args": [
      "stmt",
      "setup",
      "global_setup"
    ],
    "type": "function"
  },
  "compile_shader": {
    "description": "Compiles compute shader from source and allows one to invoke kernels",
    "std_args": [
      "source"
    ],
    "type": "function"
  },
  "compile_timeit_template": {
    "description": "The class representing a Python function.",
    "std_args": [
      "stmt",
      "setup",
      "global_setup"
    ],
    "type": "function"
  },
  "compiled_with_cxx11_abi": {
    "description": "Returns whether PyTorch was built with _GLIBCXX_USE_CXX11_ABI=1",
    "std_args": [],
    "type": "function"
  },
  "complex_double": {
    "description": "Casts this storage to complex double type.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "complex_float": {
    "description": "Casts this storage to complex float type.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "component_distribution": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "compressed_swizzled_bitmask": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "compression_stats": {
    "description": "Return latest compression statistics as tuple.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "compression_stats_logging_frequency": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "compute_cosine_similarity": {
    "description": "Computes the cosine similarity between `x` and `y`.",
    "std_args": [
      "x",
      "y"
    ],
    "type": "function"
  },
  "compute_crc32": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "compute_curve": {
    "description": "The class representing a Python function.",
    "std_args": [
      "labels",
      "predictions",
      "num_thresholds",
      "weights"
    ],
    "type": "function"
  },
  "compute_mask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "t",
      "default_mask"
    ],
    "type": "function"
  },
  "compute_normalized_l2_error": {
    "description": "Computes the normalized L2 error between `x` and `y`.",
    "std_args": [
      "x",
      "y"
    ],
    "type": "function"
  },
  "compute_sqnr": {
    "description": "Computes the SQNR between `x` and `y`.",
    "std_args": [
      "x",
      "y"
    ],
    "type": "function"
  },
  "compute_stats": {
    "description": "The class representing a Python function.",
    "std_args": [
      "stats"
    ],
    "type": "function"
  },
  "compute_stream": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "compute_unbacked_bindings": {
    "description": "After having run fake tensor propagation and producing example_value",
    "std_args": [
      "shape_env",
      "example_value",
      "old_example_value",
      "peek"
    ],
    "type": "function"
  },
  "compute_weight": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "module"
    ],
    "type": "function"
  },
  "computer_latency_sec": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "concat_path": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "path",
      "suffix"
    ],
    "type": "function"
  },
  "concentration": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "concentration0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "concentration1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "concentration_reciprocal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "concrete_inputs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cond": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "config": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "create_trace_id"
    ],
    "type": "function"
  },
  "config_from_args": {
    "description": "The class representing a Python function.",
    "std_args": [
      "args"
    ],
    "type": "function"
  },
  "configs": {
    "description": "Return a copy of the list of configs set in this `BackendConfig`.",
    "std_args": [],
    "type": "attribute"
  },
  "configure": {
    "description": "Configures a timer client. Must be called before using ``expires``.",
    "std_args": [
      "timer_client"
    ],
    "type": "function"
  },
  "confirm_membership": {
    "description": "Helper method for the confirm phase.",
    "std_args": [
      "self",
      "expected_version",
      "this_rank"
    ],
    "type": "function"
  },
  "confirm_phase": {
    "description": "Once the rendezvous state transitions from 'joinable' to 'frozen',",
    "std_args": [
      "self",
      "expected_version",
      "this_rank"
    ],
    "type": "function"
  },
  "conjucts": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "conjugate": {
    "description": "Returns the complex conjugate of the float.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "conn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "consistent": {
    "description": "It is possible for an argument list to satisfy both A and B",
    "std_args": [
      "a",
      "b"
    ],
    "type": "function"
  },
  "consolidate_state_dict": {
    "description": "Consolidate a list of ``state_dict`` s (one per rank) on the target rank.",
    "std_args": [
      "self",
      "to"
    ],
    "type": "function"
  },
  "consolidated_output_path": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "constant_": {
    "description": "Fill the input Tensor with the value :math:`\\text{val}`.",
    "std_args": [
      "tensor",
      "val"
    ],
    "type": "function"
  },
  "constant_name": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "constants": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "constrain_range": {
    "description": "Applies a constraint that the passed in SymInt must lie between min-max",
    "std_args": [
      "a",
      "min",
      "max"
    ],
    "type": "function"
  },
  "constrain_symbol_range": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "s",
      "compiler_min",
      "compiler_max"
    ],
    "type": "function"
  },
  "constrain_unify": {
    "description": "Given two SymInts, constrain them so that they must be equal.  NB:",
    "std_args": [
      "a",
      "b"
    ],
    "type": "function"
  },
  "constraint": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "constraint_sizes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "constraint_strides": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "constraints": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "construct": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "construct_and_record_rdzv_event": {
    "description": "Initialize rendezvous event object and record its operations.",
    "std_args": [
      "run_id",
      "message",
      "node_state",
      "name",
      "hostname",
      "pid",
      "master_endpoint",
      "local_id",
      "rank"
    ],
    "type": "function"
  },
  "construct_rpc_backend_options": {
    "description": "The class representing a Python function.",
    "std_args": [
      "backend",
      "rpc_timeout",
      "init_method",
      "kwargs"
    ],
    "type": "function"
  },
  "constructor_args": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "consume_prefix_in_state_dict_if_present": {
    "description": "Strip the prefix in state_dict in place, if any.",
    "std_args": [
      "state_dict",
      "prefix"
    ],
    "type": "function"
  },
  "context": {
    "description": "Context object to wrap forward and backward passes when using",
    "std_args": [],
    "type": "class"
  },
  "conv1d": {
    "description": "Applies a 1D convolution over a quantized 1D input composed of several input",
    "std_args": [
      "input",
      "weight",
      "bias",
      "stride",
      "padding",
      "dilation",
      "groups",
      "padding_mode",
      "scale",
      "zero_point",
      "dtype"
    ],
    "type": "function"
  },
  "conv1d_input": {
    "description": "Compute the gradient of conv1d with respect to the input of the convolution.",
    "std_args": [
      "input_size",
      "weight",
      "grad_output",
      "stride",
      "padding",
      "dilation",
      "groups"
    ],
    "type": "function"
  },
  "conv1d_weight": {
    "description": "Compute the gradient of conv1d with respect to the weight of the convolution.",
    "std_args": [
      "input",
      "weight_size",
      "grad_output",
      "stride",
      "padding",
      "dilation",
      "groups"
    ],
    "type": "function"
  },
  "conv2d_inference_rule": {
    "description": "The class representing a Python function.",
    "std_args": [
      "n",
      "module_instance",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "conv2d_input": {
    "description": "Compute the gradient of conv2d with respect to the input of the convolution.",
    "std_args": [
      "input_size",
      "weight",
      "grad_output",
      "stride",
      "padding",
      "dilation",
      "groups"
    ],
    "type": "function"
  },
  "conv2d_weight": {
    "description": "Compute the gradient of conv2d with respect to the weight of the convolution.",
    "std_args": [
      "input",
      "weight_size",
      "grad_output",
      "stride",
      "padding",
      "dilation",
      "groups"
    ],
    "type": "function"
  },
  "conv3d": {
    "description": "Applies a 3D convolution over a quantized 3D input composed of several input",
    "std_args": [
      "input",
      "weight",
      "bias",
      "stride",
      "padding",
      "dilation",
      "groups",
      "padding_mode",
      "scale",
      "zero_point",
      "dtype"
    ],
    "type": "function"
  },
  "conv3d_input": {
    "description": "Compute the gradient of conv3d with respect to the input of the convolution.",
    "std_args": [
      "input_size",
      "weight",
      "grad_output",
      "stride",
      "padding",
      "dilation",
      "groups"
    ],
    "type": "function"
  },
  "conv3d_weight": {
    "description": "Compute the gradient of conv3d with respect to the weight of the convolution.",
    "std_args": [
      "input",
      "weight_size",
      "grad_output",
      "stride",
      "padding",
      "dilation",
      "groups"
    ],
    "type": "function"
  },
  "conv_add_left_optioins": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "conv_add_optioins": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "conv_add_relu_left_optioins": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "conv_backward_flop": {
    "description": "The class representing a Python function.",
    "std_args": [
      "grad_out_shape",
      "x_shape",
      "w_shape",
      "_bias",
      "_stride",
      "_padding",
      "_dilation",
      "transposed",
      "_output_padding",
      "_groups",
      "output_mask",
      "out_shape"
    ],
    "type": "function"
  },
  "conv_configs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "conv_dtype_configs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "conv_flop": {
    "description": "Count flops for convolution.",
    "std_args": [
      "x_shape",
      "w_shape",
      "_bias",
      "_stride",
      "_padding",
      "_dilation",
      "transposed",
      "args",
      "out_shape",
      "kwargs"
    ],
    "type": "function"
  },
  "conv_flop_count": {
    "description": "Count flops for convolution.",
    "std_args": [
      "x_shape",
      "w_shape",
      "out_shape",
      "transposed"
    ],
    "type": "function"
  },
  "conv_refinement_rule": {
    "description": "The equality constraints are between the first dimension of",
    "std_args": [
      "n"
    ],
    "type": "function"
  },
  "conv_result": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "conv_rule": {
    "description": "Represents the output in terms of an algrbraic expression w.r.t",
    "std_args": [
      "n",
      "module_instance"
    ],
    "type": "function"
  },
  "conv_tbc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "conv_transpose1d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "conv_transpose2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "conv_transpose3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "convert": {
    "description": "Converts submodules in input module to a different module according to `mapping`",
    "std_args": [
      "self",
      "module",
      "mapping",
      "inplace",
      "parameterization"
    ],
    "type": "function"
  },
  "convert_conv2d_weight_memory_format": {
    "description": "Convert ``memory_format`` of ``nn.Conv2d.weight`` to ``memory_format``.",
    "std_args": [
      "module",
      "memory_format"
    ],
    "type": "function"
  },
  "convert_conv3d_weight_memory_format": {
    "description": "Convert ``memory_format`` of ``nn.Conv3d.weight`` to ``memory_format``",
    "std_args": [
      "module",
      "memory_format"
    ],
    "type": "function"
  },
  "convert_dynamic_jit": {
    "description": "The class representing a Python function.",
    "std_args": [
      "model",
      "inplace",
      "debug",
      "preserved_attrs"
    ],
    "type": "function"
  },
  "convert_eq": {
    "description": "Convert equality constraints in the right format",
    "std_args": [
      "list_of_eq"
    ],
    "type": "function"
  },
  "convert_fx": {
    "description": "Convert a calibrated or trained model to a quantized model",
    "std_args": [
      "graph_module",
      "convert_custom_config",
      "_remove_qconfig",
      "qconfig_mapping",
      "backend_config",
      "keep_original_weights"
    ],
    "type": "function"
  },
  "convert_jit": {
    "description": "The class representing a Python function.",
    "std_args": [
      "model",
      "inplace",
      "debug",
      "preserved_attrs"
    ],
    "type": "function"
  },
  "convert_num_with_suffix": {
    "description": "The class representing a Python function.",
    "std_args": [
      "number",
      "suffix"
    ],
    "type": "function"
  },
  "convert_pt2e": {
    "description": "Convert a calibrated/trained model to a quantized model",
    "std_args": [
      "model",
      "use_reference_representation",
      "fold_quantize"
    ],
    "type": "function"
  },
  "convert_sync_batchnorm": {
    "description": "Converts all :attr:`BatchNorm*D` layers in the model to :class:`torch.nn.SyncBatchNorm` layers.",
    "std_args": [
      "cls",
      "module",
      "process_group"
    ],
    "type": "function"
  },
  "convert_to_percent_str": {
    "description": "The class representing a Python function.",
    "std_args": [
      "num",
      "denom"
    ],
    "type": "function"
  },
  "convert_to_reference_fx": {
    "description": "Convert a calibrated or trained model to a reference quantized model,",
    "std_args": [
      "graph_module",
      "convert_custom_config",
      "_remove_qconfig",
      "qconfig_mapping",
      "backend_config"
    ],
    "type": "function"
  },
  "convert_to_sympy_symbols": {
    "description": "Replace all unknown types with fresh type variables.",
    "std_args": [
      "self",
      "typ"
    ],
    "type": "function"
  },
  "convolution_notes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cooldown": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "coordinator_rank": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "copied_gms": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "copy": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "copy_": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "source",
      "non_blocking"
    ],
    "type": "function"
  },
  "corr_cholesky": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cosine": {
    "description": "The class representing a Python function.",
    "std_args": [
      "M",
      "sym",
      "dtype",
      "layout",
      "device",
      "requires_grad"
    ],
    "type": "function"
  },
  "cosine_embedding_loss": {
    "description": "Compute the cosine embedding loss.",
    "std_args": [
      "input1",
      "input2",
      "target",
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "cosine_similarity": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cost_aware": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cost_aware_partition": {
    "description": "This method is to partition the fx module based on the cost.",
    "std_args": [
      "self",
      "transfer_rate_bytes_per_sec",
      "node_to_latency_mapping"
    ],
    "type": "function"
  },
  "count": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "count_include_pad": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "counts": {
    "description": "Returns the total number of instructions executed.",
    "std_args": [
      "self",
      "denoise"
    ],
    "type": "function"
  },
  "cov_diag": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "covariance_matrix": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "cpp_dict": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cpu": {
    "description": "Move all model parameters and buffers to the CPU.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "cpu_children": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cpu_memory_usage": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cpu_offload": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cpu_parent": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cpu_time": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cpu_time_str": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cpu_time_total": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cpu_time_total_str": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "create_a_shadows_b": {
    "description": "Creates a new GraphModule consisting of the graph of C, with the meaningful",
    "std_args": [
      "name_a",
      "gm_a",
      "name_b",
      "gm_b",
      "matched_subgraph_pairs",
      "logger_cls",
      "should_log_inputs",
      "node_type_to_io_type_map"
    ],
    "type": "function"
  },
  "create_add_loggers_graph": {
    "description": "Given a model, a model graph partition (currently a set of matched",
    "std_args": [
      "model",
      "subgraphs_dedup",
      "qconfig_mapping",
      "node_name_to_qconfig"
    ],
    "type": "function"
  },
  "create_arg": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "a"
    ],
    "type": "function"
  },
  "create_args": {
    "description": "Parse the command line options.",
    "std_args": [
      "parser"
    ],
    "type": "function"
  },
  "create_backend": {
    "description": "Create a new :py:class:`EtcdRendezvousBackend` from the specified parameters.",
    "std_args": [
      "params"
    ],
    "type": "function"
  },
  "create_block_mask": {
    "description": "This function creates a block mask tuple from a mask_mod function.",
    "std_args": [
      "mask_mod",
      "B",
      "H",
      "Q_LEN",
      "KV_LEN",
      "device",
      "BLOCK_SIZE",
      "_compile"
    ],
    "type": "function"
  },
  "create_c10d_store": {
    "description": "The class representing a Python function.",
    "std_args": [
      "is_server",
      "server_addr",
      "server_port",
      "world_size",
      "timeout",
      "wait_for_workers",
      "retries",
      "use_libuv"
    ],
    "type": "function"
  },
  "create_contiguous": {
    "description": "The class representing a Python function.",
    "std_args": [
      "shape"
    ],
    "type": "function"
  },
  "create_dataframe": {
    "description": "The class representing a Python function.",
    "std_args": [
      "data",
      "columns"
    ],
    "type": "function"
  },
  "create_default_global_load_plan": {
    "description": "Create global load plan used by DefaultLoadPlanner.",
    "std_args": [
      "all_plans"
    ],
    "type": "function"
  },
  "create_default_global_save_plan": {
    "description": "Create the global plan and metadata used by DefaultSavePlanner.",
    "std_args": [
      "all_plans",
      "rewrite_index_hints"
    ],
    "type": "function"
  },
  "create_default_local_load_plan": {
    "description": "The class representing a Python function.",
    "std_args": [
      "state_dict",
      "metadata",
      "strict"
    ],
    "type": "function"
  },
  "create_default_local_save_plan": {
    "description": "Create the ``SavePlan`` used by DefaultSavePlanner.",
    "std_args": [
      "state_dict",
      "is_coordinator"
    ],
    "type": "function"
  },
  "create_equality_constraints_for_broadcasting": {
    "description": "Create equality constraints for when no broadcasting occurs",
    "std_args": [
      "e1",
      "e2",
      "e11",
      "e12",
      "d1",
      "d2",
      "d11",
      "d12"
    ],
    "type": "function"
  },
  "create_from_tensor": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tensor"
    ],
    "type": "function"
  },
  "create_getattr_from_value": {
    "description": "Given a value of any type, creates a getattr node corresponding to the value and",
    "std_args": [
      "module",
      "graph",
      "prefix",
      "value",
      "device"
    ],
    "type": "function"
  },
  "create_global_plan": {
    "description": "Compute the global load plan and return plans for each rank.",
    "std_args": [
      "self",
      "global_plan"
    ],
    "type": "function"
  },
  "create_handler": {
    "description": "Create a new :py:class:`DynamicRendezvousHandler` from the specified parameters.",
    "std_args": [
      "store",
      "backend",
      "params"
    ],
    "type": "function"
  },
  "create_healthcheck_server": {
    "description": "creates health check server object",
    "std_args": [
      "alive_callback",
      "port",
      "timeout"
    ],
    "type": "function"
  },
  "create_local_plan": {
    "description": "Create a LoadPlan based on state_dict and metadata provided by set_up_planner.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "create_mask": {
    "description": "This function creates a mask tensor from a mod_fn function.",
    "std_args": [
      "mod_fn",
      "B",
      "H",
      "Q_LEN",
      "KV_LEN",
      "device"
    ],
    "type": "function"
  },
  "create_n_transformed_and_logged_copies_of_subgraph": {
    "description": "Given a model `mt` and a subgraph_idx, creates the needed copies",
    "std_args": [
      "mt",
      "subgraph_idx",
      "match_name",
      "nodes_in_this_subgraph",
      "qconfig_mappings",
      "list_of_node_name_to_qconfig",
      "custom_prepare_fn",
      "custom_prepare_kwargs"
    ],
    "type": "function"
  },
  "create_nested_block_mask": {
    "description": "This function creates a nested tensor compatible block mask tuple from a mask_mod",
    "std_args": [
      "mask_mod",
      "B",
      "H",
      "q_nt",
      "kv_nt",
      "BLOCK_SIZE",
      "_compile"
    ],
    "type": "function"
  },
  "create_node": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "submodule_node",
      "input_nodes",
      "output_nodes",
      "logical_devices",
      "size_bytes"
    ],
    "type": "function"
  },
  "create_node_from_old_node_preserve_meta": {
    "description": "Creates `new_node` and copies the necessary metadata to it from `old_node`.",
    "std_args": [
      "quantized_graph",
      "create_node_args",
      "old_node"
    ],
    "type": "function"
  },
  "create_one_transformed_and_logged_copy_of_subgraph": {
    "description": "Given a subgraph in `mt` and a subgraph candidate idx, inserts the",
    "std_args": [
      "mt",
      "subgraph_idx",
      "subgraph_candidate_idx",
      "first_node",
      "last_node",
      "fqn",
      "list_of_node_name_to_qconfig",
      "example_inputs",
      "last_added_shadow_node_list",
      "custom_prepare_fn",
      "custom_prepare_kwargs"
    ],
    "type": "function"
  },
  "create_op_support": {
    "description": "Wraps a `IsNodeSupported` function into an `OperatorSupportBase` instance",
    "std_args": [
      "is_node_supported"
    ],
    "type": "function"
  },
  "create_partition": {
    "description": "Create a partition and append it to self.partitions.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "create_path_if_not_exists": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "full_path",
      "ttl"
    ],
    "type": "function"
  },
  "create_proxy": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "kind",
      "target",
      "args",
      "kwargs",
      "name",
      "type_expr",
      "proxy_factory_fn"
    ],
    "type": "function"
  },
  "create_rdzv_handler": {
    "description": "Usage:",
    "std_args": [
      "params"
    ],
    "type": "function"
  },
  "create_read_items_for_chunk_list": {
    "description": "Create a list of ``ReadItem`` based on the checkpoint and local chunks.",
    "std_args": [
      "fqn",
      "checkpoint_md",
      "local_chunks"
    ],
    "type": "function"
  },
  "create_results_comparison": {
    "description": "Input:",
    "std_args": [
      "results_grouped"
    ],
    "type": "function"
  },
  "create_selective_checkpoint_contexts": {
    "description": "Helper to avoid recomputing certain ops during activation checkpointing.",
    "std_args": [
      "policy_fn_or_list",
      "allow_cache_entry_mutation"
    ],
    "type": "function"
  },
  "create_single_node_partition": {
    "description": "Create a partition for a single node",
    "std_args": [
      "self",
      "node"
    ],
    "type": "function"
  },
  "create_stream": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "path",
      "mode"
    ],
    "type": "function"
  },
  "create_submodule_from_subgraph": {
    "description": "Input: a model, and a linear subgraph within the model from first_node to",
    "std_args": [
      "model",
      "first_node",
      "last_node"
    ],
    "type": "function"
  },
  "create_symbol": {
    "description": "Create a new symbol which is tracked by this ShapeEnv",
    "std_args": [
      "self",
      "val",
      "source",
      "dynamic_dim",
      "constraint_dim",
      "positive",
      "do_not_specialize_zero_one",
      "symbolic_context"
    ],
    "type": "function"
  },
  "create_symbolic_sizes_strides_storage_offset": {
    "description": "Returns a list of symbolic sizes and strides for the given tensor.",
    "std_args": [
      "self",
      "ex",
      "source",
      "symbolic_context"
    ],
    "type": "function"
  },
  "create_symboolnode": {
    "description": "Create a SymBool object from a sympy boolean expression",
    "std_args": [
      "self",
      "sym"
    ],
    "type": "function"
  },
  "create_symfloatnode": {
    "description": "Create a SymFloat value from a symbolic expression",
    "std_args": [
      "self",
      "sym",
      "hint",
      "source"
    ],
    "type": "function"
  },
  "create_symintnode": {
    "description": "Create a SymInt value from a symbolic expression",
    "std_args": [
      "self",
      "sym",
      "hint",
      "source"
    ],
    "type": "function"
  },
  "create_trace_id": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "create_type_hint": {
    "description": "Produces a type hint for the given argument.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "create_unbacked_symbool": {
    "description": "Create a symbolic boolean without a hint value",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "create_unbacked_symfloat": {
    "description": "Create a symbolic float without a hint value",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "create_unbacked_symint": {
    "description": "Create a symbolic integer without a hint value",
    "std_args": [
      "self",
      "source"
    ],
    "type": "function"
  },
  "create_unspecified_symbol": {
    "description": "Create a symbol with an unspecified value",
    "std_args": [
      "self",
      "val",
      "source",
      "dynamic_dim",
      "constraint_dim",
      "symbolic_context"
    ],
    "type": "function"
  },
  "create_unspecified_symint_and_symbol": {
    "description": "Create a SymInt wrapping a new unspecified symbol",
    "std_args": [
      "self",
      "value",
      "source",
      "dynamic_dim"
    ],
    "type": "function"
  },
  "created_nodes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cross_entropy": {
    "description": "Compute the cross entropy loss between input logits and target.",
    "std_args": [
      "input",
      "target",
      "weight",
      "size_average",
      "ignore_index",
      "reduce",
      "reduction",
      "label_smoothing"
    ],
    "type": "function"
  },
  "ctc_loss": {
    "description": "Compute the Connectionist Temporal Classification loss.",
    "std_args": [
      "log_probs",
      "targets",
      "input_lengths",
      "target_lengths",
      "blank",
      "reduction",
      "zero_infinity"
    ],
    "type": "function"
  },
  "ctx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cuFFTPlanCache": {
    "description": "Represent a specific plan cache for a specific `device_index`.",
    "std_args": [
      "self",
      "device_index"
    ],
    "type": "class"
  },
  "cuFFTPlanCacheAttrContextProp": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "getter",
      "setter"
    ],
    "type": "class"
  },
  "cuFFTPlanCacheManager": {
    "description": "Represent all cuFFT plan caches, return the cuFFTPlanCache for a given device when indexed.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "cuda": {
    "description": "Move all model parameters and buffers to the GPU.",
    "std_args": [
      "self",
      "device"
    ],
    "type": "function"
  },
  "cudaStatus": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "cuda_graph": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cuda_time": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cuda_time_total": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cudagraph_mark_step_begin": {
    "description": "Indicates that a new iteration of inference or training is about to begin.",
    "std_args": [],
    "type": "function"
  },
  "cudart": {
    "description": "Retrieves the CUDA runtime API module.",
    "std_args": [],
    "type": "function"
  },
  "cudnn_sdp_enabled": {
    "description": ".. warning:: This flag is beta and subject to change.",
    "std_args": [],
    "type": "function"
  },
  "cufft_plan_cache": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cummax": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "cummin": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "cummulative_sizes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cumsum_inference_rule": {
    "description": "Input and output shapes should be equal",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "cumulative_sizes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cur_stream": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "curr_buffer_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "current_accelerator": {
    "description": "Return the device of the accelerator available at compilation time.",
    "std_args": [
      "check_available"
    ],
    "type": "function"
  },
  "current_action": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "current_allocated_memory": {
    "description": "Returns the current GPU memory occupied by tensors in bytes.",
    "std_args": [],
    "type": "function"
  },
  "current_blas_handle": {
    "description": "Return cublasHandle_t pointer to current cuBLAS handle",
    "std_args": [],
    "type": "function"
  },
  "current_device": {
    "description": "Return the index of a currently selected device.",
    "std_args": [],
    "type": "function"
  },
  "current_device_idx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "current_device_index": {
    "description": "Return the index of a currently selected device for the current :ref:`accelerator<accelerators>`.",
    "std_args": [],
    "type": "function"
  },
  "current_meta": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "current_state": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "current_step": {
    "description": "Get the latest step for any requester",
    "std_args": [
      "cls"
    ],
    "type": "function"
  },
  "current_stream": {
    "description": "Return the currently selected :class:`Stream` for a given device.",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "custom_backend_name": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "custom_bwd": {
    "description": "Create a helper decorator for backward methods of custom autograd functions.",
    "std_args": [
      "bwd",
      "device_type"
    ],
    "type": "function"
  },
  "custom_device_mod": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "custom_from_mask": {
    "description": "Prune tensor corresponding to parameter called ``name`` in ``module`` by applying the pre-computed mask in ``mask``.",
    "std_args": [
      "module",
      "name",
      "mask"
    ],
    "type": "function"
  },
  "custom_fwd": {
    "description": "Create a helper decorator for ``forward`` methods of custom autograd functions.",
    "std_args": [
      "fwd",
      "device_type",
      "cast_inputs"
    ],
    "type": "function"
  },
  "custom_op": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "custom_scalars": {
    "description": "The class representing a Python function.",
    "std_args": [
      "layout"
    ],
    "type": "function"
  },
  "custom_trace_id_callback": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "customized_loss_ops": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cutoffs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cycle_momentum": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dag": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "data": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "data_parallel": {
    "description": "Evaluate module(input) in parallel across the GPUs given in device_ids.",
    "std_args": [
      "module",
      "inputs",
      "device_ids",
      "output_device",
      "dim",
      "module_kwargs"
    ],
    "type": "function"
  },
  "data_ptr": {
    "description": "Auto-generated from jax_dynamic_wiring",
    "std_args": [],
    "type": "function"
  },
  "data_source": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dataframe_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "datapipe": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "datapipes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dataset": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "datasets": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dcp_to_torch_save": {
    "description": "Given a directory containing a DCP checkpoint, this function will convert it into a",
    "std_args": [
      "dcp_checkpoint_dir",
      "torch_save_path"
    ],
    "type": "function"
  },
  "debug": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "debug_dump": {
    "description": "Arguments:",
    "std_args": [
      "self",
      "debug_path"
    ],
    "type": "function"
  },
  "debug_unclosed_streams": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "decline_if_input_dtype": {
    "description": "Report a node as non-supported, if any of its arguments is of dtype",
    "std_args": [
      "cls",
      "dtype"
    ],
    "type": "function"
  },
  "decline_if_node_in_names": {
    "description": "If a node has a name that is in the disallow set, reported it as non-supported.",
    "std_args": [
      "cls",
      "disallow_set"
    ],
    "type": "function"
  },
  "decode": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "data"
    ],
    "type": "function"
  },
  "decode1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "key",
      "data"
    ],
    "type": "function"
  },
  "decoder": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "decomp_layers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "decomp_table": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "decompose": {
    "description": "The class representing a Python function.",
    "std_args": [
      "decomposition_table"
    ],
    "type": "function"
  },
  "decomposition_table": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dedup_save_to_lowest_rank": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "deepcopy": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_activation_only_qconfig": {
    "description": "Default qconfig for quantizing activations only.",
    "std_args": [],
    "type": "attribute"
  },
  "default_affine_fixed_qparams_fake_quant": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_affine_fixed_qparams_observer": {
    "description": "Default observers for fixed qparams operations.",
    "std_args": [],
    "type": "attribute"
  },
  "default_bins": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_capture_stream": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_collate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_convert": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_debug_observer": {
    "description": "Default debug-only observer.",
    "std_args": [],
    "type": "attribute"
  },
  "default_debug_qconfig": {
    "description": "Default qconfig configuration for debugging.",
    "std_args": [],
    "type": "attribute"
  },
  "default_decompositions": {
    "description": "This is the default decomposition table which contains decomposition of",
    "std_args": [],
    "type": "function"
  },
  "default_device_backend_map": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_dynamic_fake_quant": {
    "description": "Default dynamic fake_quant for activations.",
    "std_args": [],
    "type": "attribute"
  },
  "default_dynamic_float16_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_dynamic_int8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_dynamic_qat_qconfig": {
    "description": "Default qconfig for dynamic QAT.",
    "std_args": [],
    "type": "attribute"
  },
  "default_dynamic_qconfig": {
    "description": "Default dynamic qconfig.",
    "std_args": [],
    "type": "attribute"
  },
  "default_dynamic_quant_observer": {
    "description": "Default observer for dynamic quantization.",
    "std_args": [],
    "type": "attribute"
  },
  "default_embedding_fake_quant": {
    "description": "Default fake_quant for embeddings.",
    "std_args": [],
    "type": "attribute"
  },
  "default_embedding_fake_quant_4bit": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_embedding_qat_qconfig": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_embedding_qat_qconfig_4bit": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_eval_fn": {
    "description": "Define the default evaluation function.",
    "std_args": [
      "model",
      "calib_data"
    ],
    "type": "function"
  },
  "default_fake_quant": {
    "description": "Default fake_quant for activations.",
    "std_args": [],
    "type": "attribute"
  },
  "default_fixed_qparams_range_0to1_fake_quant": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_fixed_qparams_range_0to1_observer": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_fixed_qparams_range_neg1to1_fake_quant": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_fixed_qparams_range_neg1to1_observer": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_float_qparams_observer": {
    "description": "Default observer for a floating point zero-point.",
    "std_args": [],
    "type": "attribute"
  },
  "default_float_qparams_observer_4bit": {
    "description": "Default observer for a floating point zero-point and 4 bit activations.",
    "std_args": [],
    "type": "attribute"
  },
  "default_fn": {
    "description": "The class representing a Python function.",
    "std_args": [
      "data"
    ],
    "type": "function"
  },
  "default_fused_act_fake_quant": {
    "description": "Fused version of `default_fake_quant`, with improved performance.",
    "std_args": [],
    "type": "attribute"
  },
  "default_fused_per_channel_wt_fake_quant": {
    "description": "Fused version of `default_per_channel_weight_fake_quant`, with improved performance.",
    "std_args": [],
    "type": "attribute"
  },
  "default_fused_wt_fake_quant": {
    "description": "Fused version of `default_weight_fake_quant`, with improved performance.",
    "std_args": [],
    "type": "attribute"
  },
  "default_generators": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_histogram_fake_quant": {
    "description": "Fake_quant for activations using a histogram..",
    "std_args": [],
    "type": "attribute"
  },
  "default_histogram_observer": {
    "description": "Default histogram observer, usually used for PTQ.",
    "std_args": [],
    "type": "attribute"
  },
  "default_matching": {
    "description": "Default matching method",
    "std_args": [
      "name",
      "target_version"
    ],
    "type": "function"
  },
  "default_min_lr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_observer": {
    "description": "Default observer for static quantization, usually used for debugging.",
    "std_args": [],
    "type": "attribute"
  },
  "default_op_dtype_configs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_op_fp16_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_op_quint8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_per_channel_qconfig": {
    "description": "Default qconfig configuration for per channel weight quantization.",
    "std_args": [],
    "type": "attribute"
  },
  "default_per_channel_symmetric_qnnpack_qat_qconfig": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_per_channel_symmetric_qnnpack_qconfig": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_per_channel_weight_fake_quant": {
    "description": "Default fake_quant for per-channel weights.",
    "std_args": [],
    "type": "attribute"
  },
  "default_per_channel_weight_observer": {
    "description": "Default per-channel weight observer, usually used on backends where per-channel",
    "std_args": [],
    "type": "attribute"
  },
  "default_pg_nccl_timeout": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_pg_timeout": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_placeholder_observer": {
    "description": "Default placeholder observer, usually used for quantization to torch.float16.",
    "std_args": [],
    "type": "attribute"
  },
  "default_qat_qconfig": {
    "description": "Default qconfig for QAT.",
    "std_args": [],
    "type": "attribute"
  },
  "default_qat_qconfig_v2": {
    "description": "Fused version of `default_qat_config`, has performance benefits.",
    "std_args": [],
    "type": "attribute"
  },
  "default_qconfig": {
    "description": "Default qconfig configuration.",
    "std_args": [],
    "type": "attribute"
  },
  "default_quantizable_ops": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_quint8_weight_qconfig": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_restore_location": {
    "description": "Restores `storage` using a deserializer function registered for the `location`.",
    "std_args": [
      "storage",
      "location"
    ],
    "type": "function"
  },
  "default_reuse_input_observer": {
    "description": "Default observer for operators like reshape that reuses the observer of input to",
    "std_args": [],
    "type": "attribute"
  },
  "default_reuse_input_qconfig": {
    "description": "Default qconfig for operators that reuse the observers from input Tensor, e.g. reshape",
    "std_args": [],
    "type": "attribute"
  },
  "default_stream": {
    "description": "Return the default :class:`Stream` for a given device.",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "default_symmetric_fixed_qparams_fake_quant": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_symmetric_fixed_qparams_observer": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_symmetric_qnnpack_qat_qconfig": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_symmetric_qnnpack_qconfig": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_tensor_constructor": {
    "description": "The class representing a Python function.",
    "std_args": [
      "size",
      "dtype",
      "kwargs"
    ],
    "type": "function"
  },
  "default_trace_id": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "default_weight_fake_quant": {
    "description": "Default fake_quant for weights.",
    "std_args": [],
    "type": "attribute"
  },
  "default_weight_observer": {
    "description": "Default weight observer.",
    "std_args": [],
    "type": "attribute"
  },
  "default_weight_only_qconfig": {
    "description": "Default qconfig for quantizing weights only.",
    "std_args": [],
    "type": "attribute"
  },
  "default_wrapper": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "defaults": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "define": {
    "description": "Defines a new operator.",
    "std_args": [
      "qualname",
      "schema",
      "lib",
      "tags"
    ],
    "type": "function"
  },
  "delete_all_unused_submodules": {
    "description": "Deletes all unused submodules from ``self``.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "deleted_custom_ops": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "delta": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "delta_t": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "demux": {
    "description": "Splits the input DataPipe into multiple child DataPipes, using the given classification function (functional name: ``demux``).",
    "std_args": [
      "self",
      "num_instances",
      "classifier_fn",
      "drop_none",
      "buffer_size"
    ],
    "type": "function"
  },
  "denied_modules": {
    "description": "Return all modules that are currently denied.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "denoise": {
    "description": "Remove known noisy instructions.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "deny": {
    "description": "Blocklist modules who names match the given glob patterns from the list of modules the package can import.",
    "std_args": [
      "self",
      "include",
      "exclude"
    ],
    "type": "function"
  },
  "dep": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dependencies": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dependency_graph": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dependency_graph_string": {
    "description": "Returns digraph string representation of dependencies in package.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "dependency_viewer": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dependent": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dependent_property": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dependents": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "depth": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dequant": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dequant_k": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dequant_q": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dequant_v": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dequantize": {
    "description": "Utility to convert the quantized MHA back to float.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "deregister_handle": {
    "description": "Deregisters file descriptor from cuFile Driver.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "derive_qparams_fn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "derived_equalities": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "derived_from": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "desc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "description": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "deserialize": {
    "description": "The class representing a Python function.",
    "std_args": [
      "data"
    ],
    "type": "function"
  },
  "deserialize_symexpr": {
    "description": "To be used by compile_fx to deserialize symexprs",
    "std_args": [
      "self",
      "code"
    ],
    "type": "function"
  },
  "desired_input_kwarg_layouts": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "desired_input_layouts": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "desired_output_layouts": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dest_index": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dest_offsets": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "destroy_process_group": {
    "description": "Destroy a given process group, and deinitialize the distributed package.",
    "std_args": [
      "group"
    ],
    "type": "function"
  },
  "detach_variable": {
    "description": "The class representing a Python function.",
    "std_args": [
      "inputs"
    ],
    "type": "function"
  },
  "details": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "detect_anomaly": {
    "description": "Context-manager that enable anomaly detection for the autograd engine.",
    "std_args": [
      "self",
      "check_nan"
    ],
    "type": "class"
  },
  "determine_local_world_size": {
    "description": "The class representing a Python function.",
    "std_args": [
      "nproc_per_node"
    ],
    "type": "function"
  },
  "determine_qparams": {
    "description": "Calculates the quantization parameters, given min and max",
    "std_args": [
      "min_val",
      "max_val",
      "quant_min",
      "quant_max",
      "dtype",
      "eps",
      "has_customized_qrange",
      "qscheme"
    ],
    "type": "function"
  },
  "deterministic": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "device": {
    "description": "Context-manager that changes the selected device.",
    "std_args": [
      "self",
      "device"
    ],
    "type": "class"
  },
  "device_backend_map": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "device_count": {
    "description": "Return the number of MTIA devices available.",
    "std_args": [],
    "type": "function"
  },
  "device_for_folded_attrs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "device_handle": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "device_ids": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "device_index": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "device_memory_usage": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "device_memory_used": {
    "description": "Return used global (device) memory in bytes as given by `nvidia-smi` or `amd-smi`.",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "device_mesh": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "device_of": {
    "description": "Context-manager that changes the current device to that of given object.",
    "std_args": [
      "self",
      "obj"
    ],
    "type": "class"
  },
  "device_ordinal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "device_resource_id": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "device_time": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "device_time_str": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "device_time_total": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "device_time_total_str": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "device_type": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "df": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dialect": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "digamma": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dilation": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dill": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dim_replace": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dimension": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dims": {
    "description": "Util to create multiple :func:`Dim` types.",
    "std_args": [
      "names",
      "min",
      "max"
    ],
    "type": "function"
  },
  "dims_to_flatten": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dirac": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dirac_": {
    "description": "Fill the {3, 4, 5}-dimensional input `Tensor` with the Dirac delta function.",
    "std_args": [
      "tensor",
      "groups"
    ],
    "type": "function"
  },
  "dirs_to_clean": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "disable": {
    "description": "Disable sparse tensor invariants checking in sparse tensor constructors.",
    "std_args": [],
    "type": "function"
  },
  "disable_autocast_cache": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "disable_capture": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "disable_fake_quant": {
    "description": "Disable fake quantization for the module.",
    "std_args": [
      "mod"
    ],
    "type": "function"
  },
  "disable_global_flags": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "disable_observer": {
    "description": "Disable observation for this module.",
    "std_args": [
      "mod"
    ],
    "type": "function"
  },
  "disable_progress": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "disable_proxy_modes_tracing": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "disable_saved_tensors_hooks": {
    "description": "Context-manager that disables the saved tensors default hooks feature.",
    "std_args": [
      "error_message"
    ],
    "type": "function"
  },
  "disabled": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "disjuncts": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dispatch": {
    "description": "Determine appropriate implementation for this type signature",
    "std_args": [
      "self",
      "types"
    ],
    "type": "function"
  },
  "dispatch_iter": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "types"
    ],
    "type": "function"
  },
  "dispatch_key": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dispatch_trace": {
    "description": "The class representing a Python function.",
    "std_args": [
      "root",
      "tracer",
      "concrete_args"
    ],
    "type": "function"
  },
  "display": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dissoc": {
    "description": "Return a new dict with the given key(s) removed.",
    "std_args": [
      "d",
      "keys",
      "kwargs"
    ],
    "type": "function"
  },
  "distance_function": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "distribution": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "div_value": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "divisor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "divisor_override": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "do_partition": {
    "description": "Return a new fx module with submodule nodes (partitions).",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "doc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "docstring": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "domain": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "done": {
    "description": "Return ``True`` if this ``Future`` is done. A ``Future`` is done if it",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "doprint": {
    "description": "Convert a sympy expression to its Python string representation with caching.",
    "std_args": [
      "self",
      "expr"
    ],
    "type": "function"
  },
  "double": {
    "description": "Casts all floating point parameters and buffers to ``double`` datatype.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "download_url_to_file": {
    "description": "Download object at the given URL to a local path.",
    "std_args": [
      "url",
      "dst",
      "hash_prefix",
      "progress"
    ],
    "type": "function"
  },
  "downscale_factor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "draft_export": {
    "description": "A version of torch.export.export which is designed to consistently produce",
    "std_args": [
      "mod",
      "args",
      "kwargs",
      "dynamic_shapes",
      "preserve_module_call_signature",
      "strict",
      "prefer_deferred_runtime_asserts_over_guards"
    ],
    "type": "function"
  },
  "draw": {
    "description": "Function to draw a sequence of :attr:`n` points from a Sobol sequence.",
    "std_args": [
      "self",
      "n",
      "out",
      "dtype"
    ],
    "type": "function"
  },
  "draw_base2": {
    "description": "Function to draw a sequence of :attr:`2**m` points from a Sobol sequence.",
    "std_args": [
      "self",
      "m",
      "out",
      "dtype"
    ],
    "type": "function"
  },
  "draw_boxes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "disp_image",
      "boxes",
      "labels"
    ],
    "type": "function"
  },
  "driver_allocated_memory": {
    "description": "Returns total GPU memory allocated by Metal driver for the process in bytes.",
    "std_args": [],
    "type": "function"
  },
  "drop_last": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "drop_remaining": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dropout1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dropout1d": {
    "description": "Randomly zero out entire channels (a channel is a 1D feature map).",
    "std_args": [
      "input",
      "p",
      "training",
      "inplace"
    ],
    "type": "function"
  },
  "dropout2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dropout2d": {
    "description": "Randomly zero out entire channels (a channel is a 2D feature map).",
    "std_args": [
      "input",
      "p",
      "training",
      "inplace"
    ],
    "type": "function"
  },
  "dropout3": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dropout3d": {
    "description": "Randomly zero out entire channels (a channel is a 3D feature map).",
    "std_args": [
      "input",
      "p",
      "training",
      "inplace"
    ],
    "type": "function"
  },
  "dsd_fqn_modifiers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dst": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dst_nbins": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dst_prev_stream": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dtype_configs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dtype_size": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dtype"
    ],
    "type": "function"
  },
  "dual_level": {
    "description": "Context-manager for forward AD, where all forward AD computation must occur within the ``dual_level`` context.",
    "std_args": [],
    "type": "class"
  },
  "duck_shape": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dump": {
    "description": "Function to be invoked at the end of the finder execution to printout tracked events specified by the mode.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "dump_dag": {
    "description": "Return the dag structure and the new fx module with submodules.",
    "std_args": [
      "self",
      "module_with_submodules"
    ],
    "type": "function"
  },
  "dump_error_file": {
    "description": "Dump parent error file from child process's root cause error and error code.",
    "std_args": [
      "self",
      "rootcause_error_file",
      "error_code"
    ],
    "type": "function"
  },
  "dump_patches": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dump_prefix": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dyn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dyn_type": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dynamic_shapes": {
    "description": "Infers a :func:`dynamic_shapes` pytree structure by merging shapes of the",
    "std_args": [
      "self",
      "m",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "dynamic_sizes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dynamic_sources": {
    "description": "Comma delimited list of sources that should be marked as dynamic. Primarily useful for large",
    "std_args": [],
    "type": "attribute"
  },
  "dynamic_strides": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "edge": {
    "description": "A should be checked before B",
    "std_args": [
      "a",
      "b",
      "tie_breaker"
    ],
    "type": "function"
  },
  "edge_or_node": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "eig": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "eigvals": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "elapsed_time": {
    "description": "Return the time elapsed.",
    "std_args": [
      "self",
      "end_event"
    ],
    "type": "function"
  },
  "elapsed_us": {
    "description": "Returns the length of the interval",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "elastic_launch": {
    "description": "Launches an torchelastic agent on the container that invoked the entrypoint.",
    "std_args": [
      "self",
      "config",
      "entrypoint"
    ],
    "type": "class"
  },
  "element_size": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "element_wise_eq": {
    "description": "For element-wise operations and handles broadcasting.",
    "std_args": [
      "n"
    ],
    "type": "function"
  },
  "elementwise_affine": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "eliminate_dead_code": {
    "description": "Remove all dead code from the graph, based on each node's number of",
    "std_args": [
      "self",
      "is_impure_node"
    ],
    "type": "function"
  },
  "elu_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "embed_dim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "embedding_bag": {
    "description": "Compute sums, means or maxes of `bags` of embeddings.",
    "std_args": [
      "input",
      "weight",
      "offsets",
      "max_norm",
      "norm_type",
      "scale_grad_by_freq",
      "mode",
      "sparse",
      "per_sample_weights",
      "include_last_offset",
      "padding_idx"
    ],
    "type": "function"
  },
  "embedding_dim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "embedding_inference_rule": {
    "description": "The output shape differs from the input shape in the last dimension",
    "std_args": [
      "n",
      "module_instance",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "embedding_inference_rule_functional": {
    "description": "The class representing a Python function.",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "embedding_op_dtype_configs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "embedding_override": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "input"
    ],
    "type": "function"
  },
  "emit": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "metric_data"
    ],
    "type": "function"
  },
  "emit_itt": {
    "description": "Context manager that makes every autograd operation emit an ITT range.",
    "std_args": [
      "self",
      "enabled",
      "record_shapes"
    ],
    "type": "class"
  },
  "emit_nvtx": {
    "description": "Context manager that makes every autograd operation emit an NVTX range.",
    "std_args": [
      "self",
      "enabled",
      "record_shapes"
    ],
    "type": "class"
  },
  "empty_cache": {
    "description": "Empty the MTIA device cache.",
    "std_args": [],
    "type": "function"
  },
  "emulate_precision_casts": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "enable": {
    "description": "Enable sparse tensor invariants checking in sparse tensor constructors.",
    "std_args": [],
    "type": "function"
  },
  "enable_consolidation": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "enable_cudnn_sdp": {
    "description": ".. warning:: This flag is beta and subject to change.",
    "std_args": [
      "enabled"
    ],
    "type": "function"
  },
  "enable_debug_mode": {
    "description": "Enable debugging mode for CUDAGraph.debug_dump.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "enable_fake_quant": {
    "description": "Enable fake quantization for the module.",
    "std_args": [
      "mod"
    ],
    "type": "function"
  },
  "enable_flash_sdp": {
    "description": ".. warning:: This flag is beta and subject to change.",
    "std_args": [
      "enabled"
    ],
    "type": "function"
  },
  "enable_grad": {
    "description": "Context-manager that enables gradient calculation.",
    "std_args": [],
    "variants": {}
  },
  "enable_mask_update": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "enable_math_sdp": {
    "description": ".. warning:: This flag is beta and subject to change.",
    "std_args": [
      "enabled"
    ],
    "type": "function"
  },
  "enable_mem_efficient_sdp": {
    "description": ".. warning:: This flag is beta and subject to change.",
    "std_args": [
      "enabled"
    ],
    "type": "function"
  },
  "enable_nested_tensor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "enable_observer": {
    "description": "Enable observation for this module.",
    "std_args": [
      "mod"
    ],
    "type": "function"
  },
  "enable_onednn_fusion": {
    "description": "Enable or disables onednn JIT fusion based on the parameter `enabled`.",
    "std_args": [
      "enabled"
    ],
    "type": "function"
  },
  "enable_reentrant_dispatch": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "enable_thunkify": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "enable_tracing": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "enable_wrap": {
    "description": "Context manager to wrap modules using a wrapper.",
    "std_args": [
      "wrapper_cls",
      "wrapper_kwargs"
    ],
    "type": "function"
  },
  "enabled": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "encoder": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "encoding": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "end": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "end_dim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "end_factor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "end_node": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "end_node_matches_reversed_fusion": {
    "description": "Returns true if a pattern ending with `end_node` matches",
    "std_args": [
      "end_node",
      "reversed_fusion",
      "gm",
      "seen_nodes"
    ],
    "type": "function"
  },
  "end_nodes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "endianness": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "endpoint": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "engine": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ensures": {
    "description": "This function will be called after the pass is run and will check that",
    "std_args": [
      "self",
      "graph_module"
    ],
    "type": "function"
  },
  "enter_autocast_nodes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "enter_dual_level": {
    "description": "Enter a new forward grad level.",
    "std_args": [],
    "type": "function"
  },
  "enter_stack": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "entered": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "entr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "entropy": {
    "description": "Method to compute the entropy using Bregman divergence of the log normalizer.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "entry_to_pretty_str": {
    "description": "Given a backend_config_dict entry, returns a string with the human readable",
    "std_args": [
      "entry"
    ],
    "type": "function"
  },
  "entrypoint": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "enumerate_support": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "expand"
    ],
    "type": "function"
  },
  "env": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "env_info_fmt": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "environment": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "envs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "epoch": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "eps": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "eq": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "function"
  },
  "eq_inference_rule": {
    "description": "The class representing a Python function.",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "equality_constraints": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "equality_inference_rule": {
    "description": "We generate the constraint: input = output",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "equalization_node_name_to_qconfig": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "erase_node": {
    "description": "Erases a ``Node`` from the ``Graph``. Throws an exception if",
    "std_args": [
      "self",
      "to_erase"
    ],
    "type": "function"
  },
  "erase_nodes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "gm",
      "nodes"
    ],
    "type": "function"
  },
  "erase_step_count": {
    "description": "Remove a given requester.",
    "std_args": [
      "cls",
      "requester"
    ],
    "type": "function"
  },
  "erased_nodes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "erfc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "erfcx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "erfinv": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "error": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "error_dict": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "error_file": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "error_file_data": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "error_files": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "error_index": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "error_report": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "error_trace": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "eta_min": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "euler_constant": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "eval": {
    "description": "Set the module in evaluation mode.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "eval_guards": {
    "description": "The class representing a Python function.",
    "std_args": [
      "gm",
      "args",
      "ignore_static"
    ],
    "type": "function"
  },
  "eval_is_non_overlapping_and_dense": {
    "description": "The class representing a Python function.",
    "std_args": [
      "sizes",
      "strides"
    ],
    "type": "function"
  },
  "evaluate": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "size_oblivious"
    ],
    "type": "function"
  },
  "evaluate_conditional_with_constraints": {
    "description": "Given an IR and a node representing a conditional, evaluate the conditional",
    "std_args": [
      "tracer_root",
      "graph",
      "node",
      "counter",
      "user_constraints"
    ],
    "type": "function"
  },
  "evaluate_expr": {
    "description": "Given an expression, evaluates it, adding guards if necessary",
    "std_args": [
      "self",
      "orig_expr",
      "hint",
      "fx_node",
      "size_oblivious",
      "fallback_value",
      "forcing_spec"
    ],
    "type": "function"
  },
  "evaluate_guards_expression": {
    "description": "Expected to be used with produce_guards_expression(). Evaluates an expression",
    "std_args": [
      "self",
      "code",
      "args"
    ],
    "type": "function"
  },
  "evaluate_guards_for_args": {
    "description": "Generate guards for a graph's placeholder values and evaluate the guards with args",
    "std_args": [
      "self",
      "placeholders",
      "args",
      "ignore_static"
    ],
    "type": "function"
  },
  "evaluate_sym_node": {
    "description": "Given a a SymNode, evaluates sym_node.expr, adding guards if necessary.",
    "std_args": [
      "self",
      "sym_node",
      "size_oblivious",
      "fallback_value"
    ],
    "type": "function"
  },
  "evaluate_symexpr": {
    "description": "To be used by compile_fx to evaluate symexprs",
    "std_args": [
      "self",
      "code"
    ],
    "type": "function"
  },
  "event_dim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "event_log_handler": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "event_shape": {
    "description": "Returns the shape of a single sample (without batching).",
    "std_args": [],
    "type": "attribute"
  },
  "event_writer": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "events": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "example_inputs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "exception": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "exclude": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "execWrapper": {
    "description": "The class representing a Python function.",
    "std_args": [
      "code",
      "glob",
      "loc"
    ],
    "type": "function"
  },
  "execute": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "executorch_act_qint8_scale_min_2_neg_12": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "executorch_default_dynamic_float16_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "executorch_default_dynamic_qint8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "executorch_default_dynamic_quint8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "executorch_default_op_quint8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "executorch_weight_only_quint8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "executorch_weight_qint8_neg_127_to_127_scale_min_2_neg_12": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "executorch_weighted_op_int8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "exists": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "path"
    ],
    "type": "function"
  },
  "exit_code": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "exit_dual_level": {
    "description": "Exit a forward grad level.",
    "std_args": [
      "level"
    ],
    "type": "function"
  },
  "exitcode": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "exp2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "expand_inference_rule": {
    "description": "We generate the exact constraints as we do for tensor additions but we constraint",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "expand_to_tensor_dim": {
    "description": "Expand a type to the desired tensor dimension if possible",
    "std_args": [
      "t",
      "n"
    ],
    "type": "function"
  },
  "expand_tuples": {
    "description": ">>> expand_tuples([1, (2, 3)])",
    "std_args": [
      "L"
    ],
    "type": "function"
  },
  "expect_size": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "file",
      "line"
    ],
    "type": "function"
  },
  "expect_true": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "file",
      "line"
    ],
    "type": "function"
  },
  "experimental_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "expiration_time": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "expired": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "expires": {
    "description": "Acquires a countdown timer that expires in ``after`` seconds from now,",
    "std_args": [
      "after",
      "scope",
      "client"
    ],
    "type": "function"
  },
  "expit": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "exponent": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "exponential": {
    "description": "The class representing a Python function.",
    "std_args": [
      "M",
      "center",
      "tau",
      "sym",
      "dtype",
      "layout",
      "device",
      "requires_grad"
    ],
    "type": "function"
  },
  "exponential_average_factor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "export": {
    "description": "Exports a model into ONNX format.",
    "std_args": [
      "model",
      "args",
      "f",
      "kwargs",
      "verbose",
      "input_names",
      "output_names",
      "opset_version",
      "dynamo",
      "external_data",
      "dynamic_shapes",
      "custom_translation_table",
      "report",
      "optimize",
      "verify",
      "profile",
      "dump_exported_program",
      "artifacts_dir",
      "fallback",
      "export_params",
      "keep_initializers_as_inputs",
      "dynamic_axes",
      "training",
      "operator_export_type",
      "do_constant_folding",
      "custom_opsets",
      "export_modules_as_functions",
      "autograd_inlining"
    ],
    "type": "function"
  },
  "export_chrome_trace": {
    "description": "Exports the collected trace in Chrome JSON format. If kineto is enabled, only",
    "std_args": [
      "self",
      "path"
    ],
    "type": "function"
  },
  "export_for_training": {
    "description": ":func:`export_for_training` takes any nn.Module along with example inputs, and produces a traced graph representing",
    "std_args": [
      "mod",
      "args",
      "kwargs",
      "dynamic_shapes",
      "strict",
      "preserve_module_call_signature",
      "prefer_deferred_runtime_asserts_over_guards"
    ],
    "type": "function"
  },
  "export_opnames": {
    "description": "Generate new bytecode for a Script module.",
    "std_args": [
      "m"
    ],
    "type": "function"
  },
  "export_stacks": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "path",
      "metric"
    ],
    "type": "function"
  },
  "export_to_regex": {
    "description": "Export the Trie to a regex pattern.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "expr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "extend": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "extend_results": {
    "description": "Append results to already stored ones.",
    "std_args": [
      "self",
      "results"
    ],
    "type": "function"
  },
  "extension_extract_fn": {
    "description": "The class representing a Python function.",
    "std_args": [
      "pathname"
    ],
    "type": "function"
  },
  "extern": {
    "description": "Include ``module`` in the list of external modules the package can import.",
    "std_args": [
      "self",
      "include",
      "exclude",
      "allow_empty"
    ],
    "type": "function"
  },
  "extern_modules": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "externed_modules": {
    "description": "Return all modules that are currently externed.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "extra_dict_ref": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "extra_overhead": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "result"
    ],
    "type": "function"
  },
  "extra_repr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "extra_resources_collection": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "extra_traceback": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "extract_arguments": {
    "description": "Return the list of arguments in the upcoming function parameter closure.",
    "std_args": [
      "start",
      "string"
    ],
    "type": "function"
  },
  "extract_attrs_for_lowering": {
    "description": "If `mod` is in `module_fetch_book`, fetch the mod's attributes that in the `module_fetch_book`",
    "std_args": [
      "mod"
    ],
    "type": "function"
  },
  "extract_class_name": {
    "description": "Extract class name from class definition in the form of \"class {CLASS_NAME}({Type}):\".",
    "std_args": [
      "line"
    ],
    "type": "function"
  },
  "extract_ir": {
    "description": "The class representing a Python function.",
    "std_args": [
      "filename"
    ],
    "type": "function"
  },
  "extract_method_name": {
    "description": "Extract method name from decorator in the form of \"@functional_datapipe({method_name})\".",
    "std_args": [
      "line"
    ],
    "type": "function"
  },
  "extract_subgraph": {
    "description": "Given lists of nodes from an existing graph that represent a subgraph, returns a submodule that executes that subgraph.",
    "std_args": [
      "orig_module",
      "nodes",
      "inputs",
      "outputs"
    ],
    "type": "function"
  },
  "extract_val": {
    "description": "The class representing a Python function.",
    "std_args": [
      "val",
      "include_real"
    ],
    "type": "function"
  },
  "extract_weight_comparison": {
    "description": "The class representing a Python function.",
    "std_args": [
      "m"
    ],
    "type": "function"
  },
  "extract_weight_from_node": {
    "description": "The class representing a Python function.",
    "std_args": [
      "node",
      "gm",
      "op_to_type_to_weight_extraction_fn"
    ],
    "type": "function"
  },
  "eye_": {
    "description": "Fill the 2-dimensional input `Tensor` with the identity matrix.",
    "std_args": [
      "tensor"
    ],
    "type": "function"
  },
  "f": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "factor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "factory_kwargs": {
    "description": "Return a canonicalized dict of factory kwargs.",
    "std_args": [
      "kwargs"
    ],
    "type": "function"
  },
  "failures": {
    "description": "Return a dictionary mapping node ranks to their associated exceptions in case of failure.",
    "std_args": [],
    "type": "attribute"
  },
  "fake": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fake_mode": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fake_new": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "args"
    ],
    "type": "function"
  },
  "fake_quant_enabled": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fake_signature": {
    "description": "FX gets confused by varargs, de-confuse it",
    "std_args": [
      "fn",
      "nargs"
    ],
    "type": "function"
  },
  "fake_tensor_cache": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fake_val": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fallback": {
    "description": "Registers the function implementation as the fallback for the given key.",
    "std_args": [
      "self",
      "fn",
      "dispatch_key",
      "with_keyset"
    ],
    "type": "function"
  },
  "fallthrough_kernel": {
    "description": "A dummy function to pass to ``Library.impl`` in order to register a fallthrough.",
    "std_args": [],
    "type": "function"
  },
  "fast_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fast_forward": {
    "description": "Function to fast-forward the state of the ``SobolEngine`` by",
    "std_args": [
      "self",
      "n"
    ],
    "type": "function"
  },
  "fbgemm_default_dynamic_float16_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fbgemm_default_dynamic_int8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fbgemm_default_op_fp16_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fbgemm_default_op_quint8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fbgemm_weight_only_quint4x2_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fbgemm_weight_only_quint8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fbgemm_weighted_op_quint8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fd": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fd_id": {
    "description": "The class representing a Python function.",
    "std_args": [
      "fd"
    ],
    "type": "function"
  },
  "feature_alpha_dropout": {
    "description": "Randomly masks out entire channels (a channel is a feature map).",
    "std_args": [
      "input",
      "p",
      "training",
      "inplace"
    ],
    "type": "function"
  },
  "fetch_args_kwargs_from_env": {
    "description": "Fetch the concrete values of ``args`` and ``kwargs`` of node ``n``",
    "std_args": [
      "self",
      "n"
    ],
    "type": "function"
  },
  "fetch_attr": {
    "description": "Fetch an attribute from the ``Module`` hierarchy of ``self.module``.",
    "std_args": [
      "self",
      "target"
    ],
    "type": "function"
  },
  "fetch_object_proxy": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tracer",
      "t"
    ],
    "type": "function"
  },
  "fetch_sym_proxy": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tracer"
    ],
    "type": "function"
  },
  "fft2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fgate_cx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fgate_cx_igate_cgate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "file_add_header": {
    "description": "The class representing a Python function.",
    "std_args": [
      "filepath",
      "header"
    ],
    "type": "function"
  },
  "file_obj": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "file_specific_replacement": {
    "description": "The class representing a Python function.",
    "std_args": [
      "filepath",
      "search_string",
      "replace_string",
      "strict"
    ],
    "type": "function"
  },
  "file_structure": {
    "description": "Returns a file structure representation of package's zipfile.",
    "std_args": [
      "self",
      "include",
      "exclude"
    ],
    "type": "function"
  },
  "file_writer": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "filename": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "filename_suffix": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "files_to_clean": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fill_": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "value"
    ],
    "type": "function"
  },
  "filter": {
    "description": "Keep only the elements where `filter_fn` applied to function name returns True.",
    "std_args": [
      "self",
      "filter_fn"
    ],
    "type": "function"
  },
  "filter_fn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "finalize": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "finalize_options": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "find": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "v"
    ],
    "type": "function"
  },
  "find_before": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "pos",
      "substr",
      "offsets"
    ],
    "type": "function"
  },
  "find_bracket_group": {
    "description": "Finds the first balanced parentheses.",
    "std_args": [
      "input_string",
      "start"
    ],
    "type": "function"
  },
  "find_class": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "module",
      "name"
    ],
    "type": "function"
  },
  "find_closure_group": {
    "description": "Generalization for finding a balancing closure group",
    "std_args": [
      "input_string",
      "start",
      "group"
    ],
    "type": "function"
  },
  "find_file_paths": {
    "description": "When given a path to a directory, returns the paths to the relevant files within it.",
    "std_args": [
      "dir_paths",
      "files_to_exclude"
    ],
    "type": "function"
  },
  "find_files_source_depends_on": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "find_first_use_of_broken_modules": {
    "description": "Find all broken modules in a PackagingError, and for each one, return the",
    "std_args": [
      "exc"
    ],
    "type": "function"
  },
  "find_free_port": {
    "description": "Find a free port and binds a temporary socket to it so that the port can be \"reserved\" until used.",
    "std_args": [],
    "type": "function"
  },
  "find_method": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "method_name"
    ],
    "type": "function"
  },
  "find_nodes": {
    "description": "Allows for fast query of nodes",
    "std_args": [
      "self",
      "op",
      "target",
      "sort"
    ],
    "type": "function"
  },
  "find_parentheses_group": {
    "description": "Finds the first balanced bracket.",
    "std_args": [
      "input_string",
      "start"
    ],
    "type": "function"
  },
  "find_sequential_partitions": {
    "description": "The class representing a Python function.",
    "std_args": [
      "gm",
      "partition_types",
      "include_functional_equivalent",
      "filter_fn"
    ],
    "type": "function"
  },
  "find_single_partition": {
    "description": "Fit the whole fx module into one device",
    "std_args": [
      "self",
      "total_size_of_graph",
      "logical_device_id"
    ],
    "type": "function"
  },
  "find_state_dict_object": {
    "description": "The class representing a Python function.",
    "std_args": [
      "state_dict",
      "index"
    ],
    "type": "function"
  },
  "find_symbol_binding_fx_nodes": {
    "description": "Find all nodes in an FX graph that bind sympy Symbols.",
    "std_args": [
      "graph"
    ],
    "type": "function"
  },
  "find_tensor_shard": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tensor",
      "index"
    ],
    "type": "function"
  },
  "find_unused_parameters": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "finish": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "metadata",
      "results"
    ],
    "type": "function"
  },
  "finish_plan": {
    "description": "Accept the plan from coordinator and return final LoadPlan.",
    "std_args": [
      "self",
      "central_plan"
    ],
    "type": "function"
  },
  "first": {
    "description": "The first element in a sequence",
    "std_args": [
      "seq"
    ],
    "type": "function"
  },
  "first_two_eq": {
    "description": "For operations where the first two dimensions of the input and output shape",
    "std_args": [
      "n"
    ],
    "type": "function"
  },
  "fix_static_global_kernels": {
    "description": "Static global kernels in HIP results in a compilation error.",
    "std_args": [
      "in_txt"
    ],
    "type": "function"
  },
  "fixed_qparams_op_dtype_configs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "flags": {
    "description": "Context manager for setting if nnpack is enabled globally",
    "std_args": [
      "enabled"
    ],
    "type": "function"
  },
  "flags_frozen": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "flash_sdp_enabled": {
    "description": ".. warning:: This flag is beta and subject to change.",
    "std_args": [],
    "type": "function"
  },
  "flat_args_adapter": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "flatten_check": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tensor_type",
      "start_dim",
      "end_dim"
    ],
    "type": "function"
  },
  "flatten_inference_rule": {
    "description": "The class representing a Python function.",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "flatten_optimizer_state_dict": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "flatten_parameters": {
    "description": "Reset parameter data pointer so that they can use faster code paths.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "flatten_refinement_rule": {
    "description": "Generates equality constraints between the dimensions of the input and output",
    "std_args": [
      "n"
    ],
    "type": "function"
  },
  "flatten_sharded_optim_state_dict": {
    "description": "Flatten a sharded optimizer state-dict.",
    "std_args": [
      "sharded_optim_state_dict",
      "model",
      "optim"
    ],
    "type": "function"
  },
  "flatten_sharded_tensors": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "flatten_state_dict": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "flattened": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "flex_attention": {
    "description": "This function implements scaled dot product attention with an arbitrary attention score modification function.",
    "std_args": [
      "query",
      "key",
      "value",
      "score_mod",
      "block_mask",
      "scale",
      "enable_gqa",
      "return_lse",
      "kernel_options",
      "return_aux"
    ],
    "type": "function"
  },
  "float": {
    "description": "Casts all floating point parameters and buffers to ``float`` datatype.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "float16_dynamic_qconfig": {
    "description": "Dynamic qconfig with weights quantized to `torch.float16`.",
    "std_args": [],
    "type": "attribute"
  },
  "float16_static_qconfig": {
    "description": "Dynamic qconfig with both activations and weights quantized to `torch.float16`.",
    "std_args": [],
    "type": "attribute"
  },
  "float8_e4m3fn": {
    "description": "Casts this storage to float8_e4m3fn type",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "float8_e4m3fnuz": {
    "description": "Casts this storage to float8_e4m3fnuz type",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "float8_e5m2": {
    "description": "Casts this storage to float8_e5m2 type",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "float8_e5m2fnuz": {
    "description": "Casts this storage to float8_e5m2fnuz type",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "float_pow": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "function"
  },
  "float_qparams_weight_only_qconfig": {
    "description": "Dynamic qconfig with weights quantized with a floating point zero_point.",
    "std_args": [],
    "type": "attribute"
  },
  "float_qparams_weight_only_qconfig_4bit": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "float_to_observed_mapping": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "float_truediv": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "function"
  },
  "floor_to_int": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "x",
      "dtype"
    ],
    "type": "function"
  },
  "floordiv": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "function"
  },
  "flop_counts": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "flop_registry": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "flops": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "flush": {
    "description": "Flushes the event file to disk.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "flush_secs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fmt": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fmt_fn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fold": {
    "description": "Combine an array of sliding local blocks into a large containing tensor.",
    "std_args": [
      "input",
      "output_size",
      "kernel_size",
      "dilation",
      "padding",
      "stride"
    ],
    "type": "function"
  },
  "fold_bn_weights_into_conv_node": {
    "description": "The class representing a Python function.",
    "std_args": [
      "conv_node",
      "conv_weight_node",
      "conv_bias_node",
      "bn_node",
      "m"
    ],
    "type": "function"
  },
  "force_cudagraph_gc": {
    "description": "If True (the backward-compatible behavior) then gc.collect() before recording",
    "std_args": [],
    "type": "attribute"
  },
  "force_disable_caches": {
    "description": "Force disables all caching -- This will take precedence over and override any other caching flag",
    "std_args": [],
    "type": "attribute"
  },
  "forced_specializations": {
    "description": "Returns a dictionary of the names of symbols to their specialized value",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "forget_gate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fork": {
    "description": "Creates multiple instances of the same Iterable DataPipe (functional name: ``fork``).",
    "std_args": [
      "self",
      "num_instances",
      "buffer_size",
      "copy"
    ],
    "type": "function"
  },
  "fork_rng": {
    "description": "Forks the RNG, so that when you return, the RNG is reset",
    "std_args": [
      "devices",
      "enabled",
      "_caller",
      "_devices_kw",
      "device_type"
    ],
    "type": "function"
  },
  "format_bytecode": {
    "description": "The class representing a Python function.",
    "std_args": [
      "table"
    ],
    "type": "function"
  },
  "format_guards": {
    "description": "Format this shape env's guard expressions with optional traceback info if verbose",
    "std_args": [
      "self",
      "verbose"
    ],
    "type": "function"
  },
  "format_msg": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "boarder_delim",
      "section_delim"
    ],
    "type": "function"
  },
  "format_node": {
    "description": "Return a descriptive string representation of ``self``.",
    "std_args": [
      "self",
      "placeholder_names",
      "maybe_return_typename",
      "include_tensor_metadata"
    ],
    "type": "function"
  },
  "format_stack": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "format_str": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "format_time": {
    "description": "Define time formatting.",
    "std_args": [
      "time_us",
      "time_ms",
      "time_s"
    ],
    "type": "function"
  },
  "forward": {
    "description": "Auto-generated from flax_nnx_dynamic_wiring",
    "std_args": [],
    "type": "function"
  },
  "forward_arg_names": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "forward_extended": {
    "description": "User defined forward.",
    "std_args": [
      "self",
      "input"
    ],
    "type": "function"
  },
  "forward_impl": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "input",
      "hx",
      "batch_sizes",
      "max_batch_size",
      "sorted_indices"
    ],
    "type": "function"
  },
  "forward_packed": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "input",
      "hx"
    ],
    "type": "function"
  },
  "forward_shape": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "shape"
    ],
    "type": "function"
  },
  "forward_tensor": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "input",
      "hx"
    ],
    "type": "function"
  },
  "fp16_bf16_reduction_math_sdp_allowed": {
    "description": ".. warning:: This flag is beta and subject to change.",
    "std_args": [],
    "type": "function"
  },
  "fp16_compress_hook": {
    "description": "Compress by casting ``GradBucket`` to ``torch.float16`` divided by process group size.",
    "std_args": [
      "process_group",
      "bucket"
    ],
    "type": "function"
  },
  "fp16_compress_wrapper": {
    "description": "Cast input tensor to ``torch.float16``, cast result of hook back to input dtype.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "fp32_precision": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fqn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fqn_to_index_mapping": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fractional_max_pool2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fractional_max_pool2d_with_indices": {
    "description": "fractional_max_pool2d(input, kernel_size, output_size=None, output_ratio=None, return_indices=False, _random_samples=None)",
    "std_args": [
      "input",
      "kernel_size",
      "output_size",
      "output_ratio",
      "return_indices",
      "_random_samples"
    ],
    "type": "function"
  },
  "fractional_max_pool3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fractional_max_pool3d_with_indices": {
    "description": "fractional_max_pool3d(input, kernel_size, output_size=None, output_ratio=None, return_indices=False, _random_samples=None)",
    "std_args": [
      "input",
      "kernel_size",
      "output_size",
      "output_ratio",
      "return_indices",
      "_random_samples"
    ],
    "type": "function"
  },
  "free_dead_references": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "free_symbols": {
    "description": "Recursively collect all free symbols from a value.",
    "std_args": [
      "val"
    ],
    "type": "function"
  },
  "free_unbacked_symbols": {
    "description": "Like free_symbols, but filtered to only report unbacked symbols",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "freeze": {
    "description": "Freeze container to hashable form",
    "std_args": [
      "d"
    ],
    "type": "function"
  },
  "freeze_bn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "freeze_bn_stats": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "freeze_runtime_asserts": {
    "description": "Freeze this ShapeEnv to stop adding deferred runtime asserts.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "frexp": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "from_backend": {
    "description": "Create a new :py:class:`DynamicRendezvousHandler`.",
    "std_args": [
      "cls",
      "run_id",
      "store",
      "backend",
      "min_nodes",
      "max_nodes",
      "local_addr",
      "timeout",
      "keep_alive_interval",
      "keep_alive_max_attempt"
    ],
    "type": "function"
  },
  "from_buffer": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "from_dense": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "original_tensor"
    ],
    "type": "function"
  },
  "from_dict": {
    "description": "Create a ``ConvertCustomConfig`` from a dictionary with the following items:",
    "std_args": [
      "cls",
      "fuse_custom_config_dict"
    ],
    "type": "function"
  },
  "from_fake": {
    "description": "The class representing a Python function.",
    "std_args": [
      "fake"
    ],
    "type": "function"
  },
  "from_file": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "filename",
      "shared",
      "nbytes"
    ],
    "type": "function"
  },
  "from_float": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "other"
    ],
    "type": "function"
  },
  "from_group": {
    "description": "Constructs a :class:`DeviceMesh` with ``device_type`` from an",
    "std_args": [
      "group",
      "device_type",
      "mesh",
      "mesh_dim_names"
    ],
    "type": "function"
  },
  "from_ipc_handle": {
    "description": "Reconstruct an event from an IPC handle on the given device.",
    "std_args": [
      "cls",
      "device",
      "handle"
    ],
    "type": "function"
  },
  "from_kv_blocks": {
    "description": "Creates a BlockMask instance from key-value block information.",
    "std_args": [
      "cls",
      "kv_num_blocks",
      "kv_indices",
      "full_kv_num_blocks",
      "full_kv_indices",
      "BLOCK_SIZE",
      "mask_mod",
      "seq_lengths",
      "compute_q_blocks"
    ],
    "type": "function"
  },
  "from_list_qconfig_mapping": {
    "description": "Creates a QConfigMultiMapping from a list of QConfigMappings",
    "std_args": [
      "cls",
      "qconfig_mapping_list"
    ],
    "type": "function"
  },
  "from_node": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "from_observed": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "other"
    ],
    "type": "function"
  },
  "from_params": {
    "description": "Uses the weights and biases to create a new LSTM cell.",
    "std_args": [
      "cls",
      "wi",
      "wh",
      "bi",
      "bh",
      "split_gates"
    ],
    "type": "function"
  },
  "from_pretrained": {
    "description": "Create EmbeddingBag instance from given 2-dimensional FloatTensor.",
    "std_args": [
      "cls",
      "embeddings",
      "freeze",
      "max_norm",
      "norm_type",
      "scale_grad_by_freq",
      "mode",
      "sparse",
      "include_last_offset",
      "padding_idx"
    ],
    "type": "function"
  },
  "from_reference": {
    "description": "Create a (fbgemm/qnnpack) dynamic quantized module from a reference quantized",
    "std_args": [
      "cls",
      "ref_qlinear"
    ],
    "type": "function"
  },
  "from_str": {
    "description": "Example:",
    "std_args": [
      "cls",
      "vm"
    ],
    "type": "function"
  },
  "from_tuple": {
    "description": "A helper for creating a tuple of `TensorChunkSpec` from a tuple of chunk",
    "std_args": [
      "chunk_dims"
    ],
    "type": "function"
  },
  "from_weakref": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "cdata"
    ],
    "type": "function"
  },
  "fromkeys": {
    "description": "Return a new ParameterDict with the keys provided.",
    "std_args": [
      "self",
      "keys",
      "default"
    ],
    "type": "function"
  },
  "fs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fsdp_modules": {
    "description": "Return all nested FSDP instances.",
    "std_args": [
      "module",
      "root_only"
    ],
    "type": "function"
  },
  "full_inference_rule": {
    "description": "The class representing a Python function.",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "full_kv_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "full_kv_num_blocks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "full_optim_state_dict": {
    "description": "Return the full optimizer state-dict.",
    "std_args": [
      "model",
      "optim",
      "optim_input",
      "rank0_only",
      "group"
    ],
    "type": "function"
  },
  "full_q_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "full_q_num_blocks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "full_state_dict": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "func_list": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "funcs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "function": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "function_events": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "functional_call": {
    "description": "Perform a functional call on the module by replacing the module parameters and buffers with the provided ones.",
    "std_args": [
      "module",
      "parameters_and_buffers",
      "args",
      "kwargs",
      "tie_weights",
      "strict"
    ],
    "type": "function"
  },
  "functional_optim_map": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "functional_relu_override": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x",
      "inplace"
    ],
    "type": "function"
  },
  "functions": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fuse": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "load_arg",
      "named_modules",
      "fused_graph",
      "root_node",
      "extra_inputs",
      "matched_node_pattern",
      "fuse_custom_config",
      "fuser_method_mapping",
      "is_qat"
    ],
    "type": "function"
  },
  "fuse_by_partitions": {
    "description": "The class representing a Python function.",
    "std_args": [
      "gm",
      "partitions",
      "prefix",
      "always_return_tuple"
    ],
    "type": "function"
  },
  "fuse_conv_bn": {
    "description": "Return the fused the conv and bn modules.",
    "std_args": [
      "is_qat",
      "conv",
      "bn"
    ],
    "type": "function"
  },
  "fuse_conv_bn_eval": {
    "description": "Fuse a convolutional module and a BatchNorm module into a single, new convolutional module.",
    "std_args": [
      "conv",
      "bn",
      "transpose"
    ],
    "type": "function"
  },
  "fuse_conv_bn_jit": {
    "description": "Fuse conv - bn module",
    "std_args": [
      "model",
      "inplace"
    ],
    "type": "function"
  },
  "fuse_conv_bn_relu": {
    "description": "Return the fused conv and bv modules.",
    "std_args": [
      "is_qat",
      "conv",
      "bn",
      "relu"
    ],
    "type": "function"
  },
  "fuse_conv_bn_weights": {
    "description": "Fuse convolutional module parameters and BatchNorm module parameters into new convolutional module parameters.",
    "std_args": [
      "conv_w",
      "conv_b",
      "bn_rm",
      "bn_rv",
      "bn_eps",
      "bn_w",
      "bn_b",
      "transpose"
    ],
    "type": "function"
  },
  "fuse_convtranspose_bn": {
    "description": "Return the fused ConvTranspose and bn modules.",
    "std_args": [
      "is_qat",
      "convt",
      "bn"
    ],
    "type": "function"
  },
  "fuse_fx": {
    "description": "Fuse modules like conv+bn, conv+bn+relu etc, model must be in eval mode.",
    "std_args": [
      "model",
      "fuse_custom_config",
      "backend_config"
    ],
    "type": "function"
  },
  "fuse_known_modules": {
    "description": "Return a list of known fuse modules.",
    "std_args": [
      "mod_list",
      "is_qat",
      "additional_fuser_method_mapping"
    ],
    "type": "function"
  },
  "fuse_linear_bn": {
    "description": "Return the fused linear and bn modules.",
    "std_args": [
      "is_qat",
      "linear",
      "bn"
    ],
    "type": "function"
  },
  "fuse_linear_bn_eval": {
    "description": "Fuse a linear module and a BatchNorm module into a single, new linear module.",
    "std_args": [
      "linear",
      "bn"
    ],
    "type": "function"
  },
  "fuse_linear_bn_weights": {
    "description": "Fuse linear module parameters and BatchNorm module parameters into new linear module parameters.",
    "std_args": [
      "linear_w",
      "linear_b",
      "bn_rm",
      "bn_rv",
      "bn_eps",
      "bn_w",
      "bn_b"
    ],
    "type": "function"
  },
  "fuse_modules": {
    "description": "Fuse a list of modules into a single module.",
    "std_args": [
      "model",
      "modules_to_fuse",
      "inplace",
      "fuser_func",
      "fuse_custom_config_dict"
    ],
    "type": "function"
  },
  "fuse_modules_qat": {
    "description": "QAT version for `fuse_modules`.",
    "std_args": [
      "model",
      "modules_to_fuse",
      "inplace",
      "fuser_func",
      "fuse_custom_config_dict"
    ],
    "type": "function"
  },
  "fuse_partitions": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "partitions",
      "prefix"
    ],
    "type": "function"
  },
  "fuse_transpose_cusparselt": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fused_per_channel_wt_fake_quant_range_neg_127_to_127": {
    "description": "Fused version of `default_per_channel_weight_fake_quant`, with the 8-bit values restricted to [-127, +127], excluding -128.",
    "std_args": [],
    "type": "attribute"
  },
  "fused_wt_fake_quant_range_neg_127_to_127": {
    "description": "Fused version of `default_weight_fake_quant`, with the 8-bit values restricted to [-127, +127], excluding -128.",
    "std_args": [],
    "type": "attribute"
  },
  "fuser_method": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fwd_thread": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fx_const_folded_attrs_name": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fx_graph": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fx_node": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fx_placeholder_targets": {
    "description": "The class representing a Python function.",
    "std_args": [
      "gm"
    ],
    "type": "function"
  },
  "fx_placeholder_vals": {
    "description": "The class representing a Python function.",
    "std_args": [
      "gm"
    ],
    "type": "function"
  },
  "gamma": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "gammainc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "gammaincc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "gammaln": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "garbage_collect_values": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "gates": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "gather_object": {
    "description": "Gathers picklable objects from the whole group in a single process.",
    "std_args": [
      "obj",
      "object_gather_list",
      "dst",
      "group",
      "group_dst"
    ],
    "type": "function"
  },
  "gathered_objects": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "gaussian": {
    "description": "The class representing a Python function.",
    "std_args": [
      "M",
      "std",
      "sym",
      "dtype",
      "layout",
      "device",
      "requires_grad"
    ],
    "type": "function"
  },
  "gaussian_nll_loss": {
    "description": "Compute the Gaussian negative log likelihood loss.",
    "std_args": [
      "input",
      "target",
      "var",
      "full",
      "eps",
      "reduction"
    ],
    "type": "function"
  },
  "gds_deregister_buffer": {
    "description": "Deregisters a previously registered storage on a CUDA device as a cufile buffer.",
    "std_args": [
      "s"
    ],
    "type": "function"
  },
  "gds_register_buffer": {
    "description": "Registers a storage on a CUDA device as a cufile buffer.",
    "std_args": [
      "s"
    ],
    "type": "function"
  },
  "ge": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "function"
  },
  "gen_all_reshape_possibilities": {
    "description": "Consider all possibilities what the input dimensions could be (number or dynamic)",
    "std_args": [
      "list_of_dims",
      "target"
    ],
    "type": "function"
  },
  "gen_broadcasting_constraints": {
    "description": "The class representing a Python function.",
    "std_args": [
      "e1",
      "e2",
      "symbols",
      "counter",
      "output_var"
    ],
    "type": "function"
  },
  "gen_bvar": {
    "description": "Generate a boolean variable",
    "std_args": [
      "curr"
    ],
    "type": "function"
  },
  "gen_consistency_constraints": {
    "description": "Args:",
    "std_args": [
      "constraint",
      "counter"
    ],
    "type": "function"
  },
  "gen_constructor_wrapper": {
    "description": "The class representing a Python function.",
    "std_args": [
      "target"
    ],
    "type": "function"
  },
  "gen_dvar": {
    "description": "Generate a dimension variable",
    "std_args": [
      "curr"
    ],
    "type": "function"
  },
  "gen_embedding_rules": {
    "description": "The class representing a Python function.",
    "std_args": [
      "n",
      "symbols",
      "embedding_dim",
      "counter"
    ],
    "type": "function"
  },
  "gen_fn_def": {
    "description": "Given the free variables and a return annotation, generates the beginning of the FX function.",
    "std_args": [
      "self",
      "free_vars",
      "maybe_return_annotation",
      "expanded_def"
    ],
    "type": "function"
  },
  "gen_from_template": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dir",
      "template_name",
      "output_name",
      "replacements"
    ],
    "type": "function"
  },
  "gen_greatest_upper_bound": {
    "description": "Args:",
    "std_args": [
      "constraint",
      "counter"
    ],
    "type": "function"
  },
  "gen_layer_norm_constraints": {
    "description": "The class representing a Python function.",
    "std_args": [
      "n",
      "normalized_shape",
      "symbols",
      "counter"
    ],
    "type": "function"
  },
  "gen_lists_of_dims": {
    "description": "Generate lists of DVar to represent tensor dimensions",
    "std_args": [
      "num_tensors",
      "dim_size",
      "counter"
    ],
    "type": "function"
  },
  "gen_mkl_autotuner": {
    "description": "This generates a heuristic that can be passed into `optimize_for_inference` that",
    "std_args": [
      "example_inputs",
      "iters",
      "warmup"
    ],
    "type": "function"
  },
  "gen_nat_constraints": {
    "description": "Generate natural number constraints for dimensions",
    "std_args": [
      "list_of_dims"
    ],
    "type": "function"
  },
  "gen_tensor_dims": {
    "description": "Generate a list of tensor dimensions",
    "std_args": [
      "n",
      "curr"
    ],
    "type": "function"
  },
  "gen_tvar": {
    "description": "Generate a tensor variable",
    "std_args": [
      "curr"
    ],
    "type": "function"
  },
  "general_cosine": {
    "description": "The class representing a Python function.",
    "std_args": [
      "M",
      "a",
      "sym",
      "dtype",
      "layout",
      "device",
      "requires_grad"
    ],
    "type": "function"
  },
  "general_hamming": {
    "description": "The class representing a Python function.",
    "std_args": [
      "M",
      "alpha",
      "sym",
      "dtype",
      "layout",
      "device",
      "requires_grad"
    ],
    "type": "function"
  },
  "generate_all_broadcasting_possibilities_no_padding": {
    "description": "Generate broadcasting constraints assuming no padding. Broadcasting can happen at any dimension.",
    "std_args": [
      "d1",
      "d2",
      "d11",
      "d12"
    ],
    "type": "function"
  },
  "generate_all_int_dyn_dim_possibilities": {
    "description": "Generate all possibilities of being equal or not equal to dyn for my_list",
    "std_args": [
      "my_list"
    ],
    "type": "function"
  },
  "generate_binconstraint_d": {
    "description": "Transform binary constraints for dimensions",
    "std_args": [
      "constraint",
      "counter"
    ],
    "type": "function"
  },
  "generate_binconstraint_t": {
    "description": "Transform binary constraints for tensors",
    "std_args": [
      "constraint",
      "counter"
    ],
    "type": "function"
  },
  "generate_broadcasting": {
    "description": "Transform broadcasting constraints",
    "std_args": [
      "constraint",
      "counter"
    ],
    "type": "function"
  },
  "generate_calc_conv": {
    "description": "The class representing a Python function.",
    "std_args": [
      "constraint",
      "counter"
    ],
    "type": "function"
  },
  "generate_calc_maxpool": {
    "description": "Transform maxpool constraints",
    "std_args": [
      "constraint",
      "counter"
    ],
    "type": "function"
  },
  "generate_calc_product": {
    "description": "Transform flatten constraints",
    "std_args": [
      "constraint",
      "counter"
    ],
    "type": "function"
  },
  "generate_conj": {
    "description": "Transform conjunctions",
    "std_args": [
      "constraint",
      "counter"
    ],
    "type": "function"
  },
  "generate_constraints": {
    "description": "Iterate through every node and generate constraints",
    "std_args": [
      "self",
      "counter"
    ],
    "type": "function"
  },
  "generate_constraints_node": {
    "description": "Generate constraints the given node:",
    "std_args": [
      "self",
      "n",
      "counter"
    ],
    "type": "function"
  },
  "generate_d_gub": {
    "description": "Transform greatest upper bound for dimensions into equality constraints",
    "std_args": [
      "constraint",
      "counter"
    ],
    "type": "function"
  },
  "generate_disj": {
    "description": "Transform disjunctions",
    "std_args": [
      "constraint",
      "counter"
    ],
    "type": "function"
  },
  "generate_flatten_constraints": {
    "description": "The class representing a Python function.",
    "std_args": [
      "start_dim",
      "end_dim",
      "input",
      "flattened",
      "n",
      "counter"
    ],
    "type": "function"
  },
  "generate_gub": {
    "description": "Transform greatest upper bound for tensors. Results in equality and Greatest Upper Bound",
    "std_args": [
      "constraint",
      "counter"
    ],
    "type": "function"
  },
  "generate_inputs_for_submodules": {
    "description": "Generate inputs for targeting submdoules in the given model. Note that if two submodules refer to the same obj, this",
    "std_args": [
      "model",
      "inputs",
      "target_submodules",
      "deepcopy"
    ],
    "type": "function"
  },
  "generate_methods_for_privateuse1_backend": {
    "description": "Automatically generate attributes and methods for the custom backend after rename privateuse1 backend.",
    "std_args": [
      "for_tensor",
      "for_module",
      "for_packed_sequence",
      "for_storage",
      "unsupported_dtype"
    ],
    "type": "function"
  },
  "generate_mobile_module_lints": {
    "description": "Generate a list of lints for a given torch script module.",
    "std_args": [
      "script_module"
    ],
    "type": "function"
  },
  "generate_output": {
    "description": "Given the output arguments, generates the return statement of the FX function.",
    "std_args": [
      "self",
      "output_args",
      "descs"
    ],
    "type": "function"
  },
  "generate_reshape": {
    "description": "Transform reshape constraints",
    "std_args": [
      "constraint",
      "counter"
    ],
    "type": "function"
  },
  "generate_square_subsequent_mask": {
    "description": "Generate a square causal mask for the sequence.",
    "std_args": [
      "sz",
      "device",
      "dtype"
    ],
    "type": "function"
  },
  "generate_upgraders_bytecode": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "generate_vmap_rule": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "generator": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "geqrf": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "get": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "getStream": {
    "description": "The class representing a Python function.",
    "std_args": [
      "group"
    ],
    "type": "function"
  },
  "get_CSE_banned_ops": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_a_var": {
    "description": "The class representing a Python function.",
    "std_args": [
      "obj"
    ],
    "type": "function"
  },
  "get_acc_ops_name": {
    "description": "The class representing a Python function.",
    "std_args": [
      "k"
    ],
    "type": "function"
  },
  "get_all": {
    "description": "Given a store and a prefix, the method goes through the array of keys",
    "std_args": [
      "store",
      "rank",
      "prefix",
      "world_size"
    ],
    "type": "function"
  },
  "get_all_graph_pipes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "graph"
    ],
    "type": "function"
  },
  "get_all_groups": {
    "description": "Returns a list of ProcessGroups for all mesh dimensions.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_all_sharing_strategies": {
    "description": "Return a set of sharing strategies supported on a current system.",
    "std_args": [],
    "type": "function"
  },
  "get_allocator_backend": {
    "description": "Return a string describing the active allocator backend as set by",
    "std_args": [],
    "type": "function"
  },
  "get_analytical_jacobian": {
    "description": "The class representing a Python function.",
    "std_args": [
      "inputs",
      "output",
      "nondet_tol",
      "grad_out"
    ],
    "type": "function"
  },
  "get_arch_list": {
    "description": "Return list CUDA architectures this library was compiled for.",
    "std_args": [],
    "type": "function"
  },
  "get_arg_indices_of_inputs_to_log": {
    "description": "Returns the indices of args of the node which we should attach",
    "std_args": [
      "node"
    ],
    "type": "function"
  },
  "get_arg_info_from_tensor_fqn": {
    "description": "Uses tensor_fqn to obtain a dict containing module_fqn, module and tensor_name",
    "std_args": [
      "model",
      "tensor_fqn"
    ],
    "type": "function"
  },
  "get_arg_return_types_from_interface": {
    "description": "The class representing a Python function.",
    "std_args": [
      "module_interface"
    ],
    "type": "function"
  },
  "get_args_parser": {
    "description": "Parse the command line options.",
    "std_args": [],
    "type": "function"
  },
  "get_as_bool": {
    "description": "Return the value for ``key`` as a ``bool``.",
    "std_args": [
      "self",
      "key",
      "default"
    ],
    "type": "function"
  },
  "get_as_int": {
    "description": "Return the value for ``key`` as an ``int``.",
    "std_args": [
      "self",
      "key",
      "default"
    ],
    "type": "function"
  },
  "get_attr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "target",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "get_attr_inference_rule": {
    "description": "If the attribute is \"device\" then the tensor shape is preserved",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "get_axioms": {
    "description": "Given the symbols in an expression, it returns all the runtime asserts that have those symbols",
    "std_args": [
      "self",
      "symbols",
      "compute_hint"
    ],
    "type": "function"
  },
  "get_backend": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_backend_config": {
    "description": "Return the backend configuration of the given process group.",
    "std_args": [
      "group"
    ],
    "type": "function"
  },
  "get_backoff_factor": {
    "description": "Return a Python float containing the scale backoff factor.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_base_name_for_op": {
    "description": "The class representing a Python function.",
    "std_args": [
      "base_name_to_sets_of_related_ops",
      "op"
    ],
    "type": "function"
  },
  "get_base_name_to_sets_of_related_ops": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_bfs_level_partition": {
    "description": "Given a list of partitions,",
    "std_args": [
      "partitions"
    ],
    "type": "function"
  },
  "get_bias": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_bias_qspec": {
    "description": "The class representing a Python function.",
    "std_args": [
      "quantization_config"
    ],
    "type": "function"
  },
  "get_block_size": {
    "description": "Get the block size based on the input shape and granularity type.",
    "std_args": [
      "input_shape",
      "granularity"
    ],
    "type": "function"
  },
  "get_buffer": {
    "description": "Return the buffer given by ``target`` if it exists, otherwise throw an error.",
    "std_args": [
      "self",
      "target"
    ],
    "type": "function"
  },
  "get_cachingallocator_config": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_clang_version": {
    "description": "The class representing a Python function.",
    "std_args": [
      "run_lambda"
    ],
    "type": "function"
  },
  "get_class_assigns": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "cls_ast"
    ],
    "type": "function"
  },
  "get_class_properties": {
    "description": "Get a list of Property objects representing the properties of a class.",
    "std_args": [
      "cls",
      "self_name"
    ],
    "type": "function"
  },
  "get_client": {
    "description": "Return an etcd client object that can be used to make requests to this server.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_cmake_version": {
    "description": "The class representing a Python function.",
    "std_args": [
      "run_lambda"
    ],
    "type": "function"
  },
  "get_columns": {
    "description": "The class representing a Python function.",
    "std_args": [
      "data"
    ],
    "type": "function"
  },
  "get_combined_dict": {
    "description": "Combines two dictionaries.",
    "std_args": [
      "default_dict",
      "additional_dict"
    ],
    "type": "function"
  },
  "get_comm_latency_between": {
    "description": "Given two partitions (parent and child),",
    "std_args": [
      "parent_partition",
      "child_partition",
      "transfer_rate_bytes_per_sec"
    ],
    "type": "function"
  },
  "get_compat_bindings": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_compiler_abi_compatibility_and_version": {
    "description": "Determine if the given compiler is ABI-compatible with PyTorch alongside its version.",
    "std_args": [
      "compiler"
    ],
    "type": "function"
  },
  "get_conda_packages": {
    "description": "The class representing a Python function.",
    "std_args": [
      "run_lambda",
      "patterns"
    ],
    "type": "function"
  },
  "get_conv_fun_weight": {
    "description": "The class representing a Python function.",
    "std_args": [
      "node",
      "gm"
    ],
    "type": "function"
  },
  "get_conv_mod_weight": {
    "description": "The class representing a Python function.",
    "std_args": [
      "mod"
    ],
    "type": "function"
  },
  "get_coordinate": {
    "description": "Return the relative indices of this rank relative to all",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_core_count": {
    "description": "Return GPU core count.",
    "std_args": [],
    "type": "function"
  },
  "get_cpp_backtrace": {
    "description": "Return a string containing the C++ stack trace of the current thread.",
    "std_args": [
      "frames_to_skip",
      "maximum_number_of_frames"
    ],
    "type": "function"
  },
  "get_cpu_capability": {
    "description": "Return cpu capability as a string value.",
    "std_args": [],
    "type": "function"
  },
  "get_cpu_info": {
    "description": "The class representing a Python function.",
    "std_args": [
      "run_lambda"
    ],
    "type": "function"
  },
  "get_crc32_options": {
    "description": "Get whether :func:`torch.save` computes and writes crc32 for each record.",
    "std_args": [],
    "type": "function"
  },
  "get_ctx": {
    "description": "get_ctx() returns the current AbstractImplCtx object.",
    "std_args": [],
    "type": "function"
  },
  "get_cuda_module_loading_config": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_cudnn_mode": {
    "description": "The class representing a Python function.",
    "std_args": [
      "mode"
    ],
    "type": "function"
  },
  "get_cudnn_version": {
    "description": "Return a list of libcudnn.so; it's hard to tell which one is being used.",
    "std_args": [
      "run_lambda"
    ],
    "type": "function"
  },
  "get_current_meta": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_current_pass_count": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls"
    ],
    "type": "function"
  },
  "get_custom_module_class_keys": {
    "description": "Get all the unique custom module keys in the custom config dict",
    "std_args": [
      "custom_module_mapping"
    ],
    "type": "function"
  },
  "get_cxx_compiler": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_data": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_deepcopy_hook": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_default_args": {
    "description": "Get a dictionary of default arguments for a function.",
    "std_args": [
      "fn"
    ],
    "type": "function"
  },
  "get_default_args_for_class": {
    "description": "Get default arguments for all methods in a class (except for static methods).",
    "std_args": [
      "cls"
    ],
    "type": "function"
  },
  "get_default_backend_for_device": {
    "description": "Return the default backend for the given device.",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "get_default_build_root": {
    "description": "Return the path to the root folder under which extensions will built.",
    "std_args": [],
    "type": "function"
  },
  "get_default_compare_output_module_list": {
    "description": "Get list of module class types that we will record output",
    "std_args": [],
    "type": "function"
  },
  "get_default_custom_config_dict": {
    "description": "Defines the default custom config dict.",
    "std_args": [],
    "type": "function"
  },
  "get_default_device": {
    "description": "Gets the default ``torch.Tensor`` to be allocated on ``device``",
    "std_args": [],
    "type": "function"
  },
  "get_default_dynamic_quant_module_mappings": {
    "description": "Get module mapping for post training dynamic quantization",
    "std_args": [],
    "type": "function"
  },
  "get_default_dynamic_sparse_quant_module_mappings": {
    "description": "Get module mapping for post training dynamic sparse quantization",
    "std_args": [],
    "type": "function"
  },
  "get_default_float_to_quantized_operator_mappings": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_default_fusion_patterns": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_default_load_endianness": {
    "description": "Get fallback byte order for loading files",
    "std_args": [],
    "type": "function"
  },
  "get_default_mmap_options": {
    "description": "Get default mmap options for :func:`torch.load` with ``mmap=True``.",
    "std_args": [],
    "type": "function"
  },
  "get_default_nowrap_functions": {
    "description": "Return public functions that do not wrap in a subclass when invoked by",
    "std_args": [],
    "type": "function"
  },
  "get_default_output_activation_post_process_map": {
    "description": "The class representing a Python function.",
    "std_args": [
      "is_training"
    ],
    "type": "function"
  },
  "get_default_qat_module_mappings": {
    "description": "Get default module mapping for quantization aware training",
    "std_args": [],
    "type": "function"
  },
  "get_default_qat_qconfig": {
    "description": "Returns the default QAT qconfig for the specified backend.",
    "std_args": [
      "backend",
      "version"
    ],
    "type": "function"
  },
  "get_default_qat_qconfig_dict": {
    "description": "The class representing a Python function.",
    "std_args": [
      "backend",
      "version"
    ],
    "type": "function"
  },
  "get_default_qat_qconfig_mapping": {
    "description": "Return the default QConfigMapping for quantization aware training.",
    "std_args": [
      "backend",
      "version"
    ],
    "type": "function"
  },
  "get_default_qconfig": {
    "description": "Returns the default PTQ qconfig for the specified backend.",
    "std_args": [
      "backend",
      "version"
    ],
    "type": "function"
  },
  "get_default_qconfig_dict": {
    "description": "The class representing a Python function.",
    "std_args": [
      "backend",
      "version"
    ],
    "type": "function"
  },
  "get_default_qconfig_mapping": {
    "description": "Return the default QConfigMapping for post training quantization.",
    "std_args": [
      "backend",
      "version"
    ],
    "type": "function"
  },
  "get_default_qconfig_propagation_list": {
    "description": "Get the default list of module types that we'll attach qconfig",
    "std_args": [],
    "type": "function"
  },
  "get_default_quant_patterns": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_default_static_quant_module_mappings": {
    "description": "Get module mapping for post training static quantization",
    "std_args": [],
    "type": "function"
  },
  "get_default_static_quant_reference_module_mappings": {
    "description": "Get reference module mapping for post training static quantization",
    "std_args": [],
    "type": "function"
  },
  "get_default_static_sparse_quant_module_mappings": {
    "description": "Get module mapping for post training static sparse quantization",
    "std_args": [],
    "type": "function"
  },
  "get_default_x86_inductor_quantization_config": {
    "description": "reduce_range is False by default. Set it to True on earlier CPUs without VNNI to avoid accuracy issue.",
    "std_args": [
      "is_qat",
      "is_dynamic",
      "reduce_range"
    ],
    "type": "function"
  },
  "get_default_xpu_inductor_quantization_config": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_deterministic_debug_mode": {
    "description": "Returns the current value of the debug mode for deterministic",
    "std_args": [],
    "type": "function"
  },
  "get_device": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_device_backend_map": {
    "description": "Return backend map of the device.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_device_capability": {
    "description": "Return capability of a given device as a tuple of (major version, minor version).",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "get_device_name": {
    "description": "Get the name of a device.",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "get_device_partition_stats": {
    "description": "Given a list of partitions and a list of devices, returns:",
    "std_args": [
      "partitions",
      "devices"
    ],
    "type": "function"
  },
  "get_device_properties": {
    "description": "Return a dictionary of MTIA device properties",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "get_device_states": {
    "description": "The class representing a Python function.",
    "std_args": [
      "args"
    ],
    "type": "function"
  },
  "get_device_to_partitions_mapping": {
    "description": "Given a list of partitions and a list of devices,",
    "std_args": [
      "partitions",
      "devices"
    ],
    "type": "function"
  },
  "get_device_type": {
    "description": "Get the current default device type for checkpointing.",
    "std_args": [],
    "type": "function"
  },
  "get_df_wrapper": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_dir": {
    "description": "Get the Torch Hub cache directory used for storing downloaded models & weights.",
    "std_args": [],
    "type": "function"
  },
  "get_dynamic_quant_module_class": {
    "description": "n Get the dynamically quantized module class corresponding to",
    "std_args": [
      "float_module_class",
      "additional_dynamic_quant_mapping"
    ],
    "type": "function"
  },
  "get_elapsed_time_ms": {
    "description": "Return the elapsed time in millis from the given start time.",
    "std_args": [
      "start_time_in_seconds"
    ],
    "type": "function"
  },
  "get_ema_avg_fn": {
    "description": "Get the function applying exponential moving average (EMA) across a single param.",
    "std_args": [
      "decay"
    ],
    "type": "function"
  },
  "get_ema_multi_avg_fn": {
    "description": "Get the function applying exponential moving average (EMA) across multiple params.",
    "std_args": [
      "decay"
    ],
    "type": "function"
  },
  "get_embedding_operators_config": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_embedding_qat_module_mappings": {
    "description": "Get module mapping for quantization aware training",
    "std_args": [],
    "type": "function"
  },
  "get_embedding_static_quant_module_mappings": {
    "description": "Get module mapping, including mapping for embedding QAT",
    "std_args": [],
    "type": "function"
  },
  "get_enabled": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_endpoint": {
    "description": "Return the etcd server endpoint (host:port).",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_entrypoint_name": {
    "description": "Get the entry point name.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_enum_value_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "e",
      "loc"
    ],
    "type": "function"
  },
  "get_env_info": {
    "description": "Collects environment information to aid in debugging.",
    "std_args": [],
    "type": "function"
  },
  "get_env_variable_or_raise": {
    "description": "Tries to retrieve environment variable. Raises ``ValueError``",
    "std_args": [
      "env_name"
    ],
    "type": "function"
  },
  "get_equivalent_types": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_error_handler": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_event_failed": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_event_succeeded": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_executorch_backend_config": {
    "description": "Return the `BackendConfig` for backends PyTorch lowers to through the Executorch stack.",
    "std_args": [],
    "type": "function"
  },
  "get_expected_cell_size": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "input",
      "batch_sizes"
    ],
    "type": "function"
  },
  "get_expected_hidden_size": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "input",
      "batch_sizes"
    ],
    "type": "function"
  },
  "get_expired_timers": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "deadline"
    ],
    "type": "function"
  },
  "get_ext_filename": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "ext_name"
    ],
    "type": "function"
  },
  "get_extra_size_of": {
    "description": "Given a node and a set of nodes,",
    "std_args": [
      "node",
      "nodes"
    ],
    "type": "function"
  },
  "get_extra_state": {
    "description": "Return any extra state to include in the module's state_dict.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_fastpath_enabled": {
    "description": "Returns whether fast path for TransformerEncoder and MultiHeadAttention",
    "std_args": [],
    "type": "function"
  },
  "get_fbgemm_backend_config": {
    "description": "Return the `BackendConfig` for PyTorch's native FBGEMM backend.",
    "std_args": [],
    "type": "function"
  },
  "get_file_binaries_from_pathnames": {
    "description": "The class representing a Python function.",
    "std_args": [
      "pathnames",
      "mode",
      "encoding"
    ],
    "type": "function"
  },
  "get_file_pathnames_from_root": {
    "description": "The class representing a Python function.",
    "std_args": [
      "root",
      "masks",
      "recursive",
      "abspath",
      "non_deterministic"
    ],
    "type": "function"
  },
  "get_filename": {
    "description": "Get the results filename.",
    "std_args": [],
    "type": "function"
  },
  "get_first_failure": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_flat_arg_paths": {
    "description": "Returns a list of paths that are used to access the flat args.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_flat_weights": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_float32_matmul_precision": {
    "description": "Returns the current value of float32 matrix multiplication precision. Refer to",
    "std_args": [],
    "type": "function"
  },
  "get_flop_counts": {
    "description": "Return the flop counts as a dictionary of dictionaries.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_fqn_to_example_inputs": {
    "description": "Given a model and its example inputs, return a dictionary from",
    "std_args": [
      "model",
      "example_inputs"
    ],
    "type": "function"
  },
  "get_free_port": {
    "description": "Returns an unused port on localhost.",
    "std_args": [],
    "type": "function"
  },
  "get_func_annotations": {
    "description": "get annotations of function positional parameters",
    "std_args": [
      "cls",
      "func"
    ],
    "type": "function"
  },
  "get_func_params": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "func"
    ],
    "type": "function"
  },
  "get_fused_module_classes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "backend_config"
    ],
    "type": "function"
  },
  "get_fuser_method": {
    "description": "Get fuser method for the given list of module types.",
    "std_args": [
      "op_list",
      "additional_fuser_method_mapping"
    ],
    "type": "function"
  },
  "get_fuser_method_mapping": {
    "description": "The class representing a Python function.",
    "std_args": [
      "backend_config"
    ],
    "type": "function"
  },
  "get_fuser_method_new": {
    "description": "Get fuser method.",
    "std_args": [
      "op_pattern",
      "fuser_method_mapping"
    ],
    "type": "function"
  },
  "get_fusion_pattern_to_extra_inputs_getter": {
    "description": "Get a map from fusion pattern to a function that returns extra input nodes",
    "std_args": [
      "backend_config"
    ],
    "type": "function"
  },
  "get_fusion_pattern_to_root_node_getter": {
    "description": "Get a map from fusion pattern to a function that returns the root node",
    "std_args": [
      "backend_config"
    ],
    "type": "function"
  },
  "get_gcc_version": {
    "description": "The class representing a Python function.",
    "std_args": [
      "run_lambda"
    ],
    "type": "function"
  },
  "get_gencode_flags": {
    "description": "Return NVCC gencode flags this library was compiled with.",
    "std_args": [],
    "type": "function"
  },
  "get_global_quantization_config": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_global_rank": {
    "description": "Translate a group rank into a global rank.",
    "std_args": [
      "group",
      "group_rank"
    ],
    "type": "function"
  },
  "get_gpu_info": {
    "description": "The class representing a Python function.",
    "std_args": [
      "run_lambda"
    ],
    "type": "function"
  },
  "get_gradient_edge": {
    "description": "Get the gradient edge for computing the gradient of the given Tensor.",
    "std_args": [
      "tensor"
    ],
    "type": "function"
  },
  "get_graph_provenance_json": {
    "description": "Given an fx.Graph, return a json that contains the provenance information of each node.",
    "std_args": [
      "graph"
    ],
    "type": "function"
  },
  "get_greatest_upper_bound": {
    "description": "Get the most precise type that's consistent with the given types",
    "std_args": [
      "type1",
      "type2"
    ],
    "type": "function"
  },
  "get_group": {
    "description": "Returns the single ProcessGroup specified by mesh_dim, or, if mesh_dim is not specified and the",
    "std_args": [
      "self",
      "mesh_dim"
    ],
    "type": "function"
  },
  "get_group_rank": {
    "description": "Translate a global rank into a group rank.",
    "std_args": [
      "group",
      "global_rank"
    ],
    "type": "function"
  },
  "get_growth_factor": {
    "description": "Return a Python float containing the scale growth factor.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_growth_interval": {
    "description": "Return a Python int containing the growth interval.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_hip_file_path": {
    "description": "Returns the new name of the hipified file",
    "std_args": [
      "rel_filepath",
      "is_pytorch_extension"
    ],
    "type": "function"
  },
  "get_host": {
    "description": "Return the host the server is running on.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_ignored_functions": {
    "description": "Return public functions that cannot be overridden by ``__torch_function__``.",
    "std_args": [],
    "type": "function"
  },
  "get_implications": {
    "description": "Given a expression, it returns a list of predicates that follow from it",
    "std_args": [
      "self",
      "e"
    ],
    "type": "function"
  },
  "get_in": {
    "description": "Returns coll[i0][i1]...[iX] where [i0, i1, ..., iX]==keys.",
    "std_args": [
      "keys",
      "coll",
      "default",
      "no_default"
    ],
    "type": "function"
  },
  "get_info_and_burn_skeleton": {
    "description": "The class representing a Python function.",
    "std_args": [
      "path_or_bytesio",
      "kwargs"
    ],
    "type": "function"
  },
  "get_inline_skeleton": {
    "description": "Get a fully-inlined skeleton of the frontend.",
    "std_args": [],
    "type": "function"
  },
  "get_innermost_proxy_mode": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_input_act_qspec": {
    "description": "The class representing a Python function.",
    "std_args": [
      "quantization_config"
    ],
    "type": "function"
  },
  "get_intel_gpu_detected": {
    "description": "The class representing a Python function.",
    "std_args": [
      "run_lambda"
    ],
    "type": "function"
  },
  "get_intel_gpu_driver_version": {
    "description": "The class representing a Python function.",
    "std_args": [
      "run_lambda"
    ],
    "type": "function"
  },
  "get_intel_gpu_onboard": {
    "description": "The class representing a Python function.",
    "std_args": [
      "run_lambda"
    ],
    "type": "function"
  },
  "get_item": {
    "description": "The class representing a Python function.",
    "std_args": [
      "data",
      "idx"
    ],
    "type": "function"
  },
  "get_jit_class_def": {
    "description": "Get definitions for each method within the current class independently.",
    "std_args": [
      "cls",
      "self_name"
    ],
    "type": "function"
  },
  "get_jit_def": {
    "description": "Build a JIT AST (TreeView) from the given function.",
    "std_args": [
      "fn",
      "def_name",
      "self_name",
      "is_classmethod"
    ],
    "type": "function"
  },
  "get_kernel": {
    "description": "Returns the computed kernel for a given operator and dispatch key.",
    "std_args": [
      "op",
      "dispatch_key"
    ],
    "type": "function"
  },
  "get_last_lr": {
    "description": "Return last computed learning rate by current scheduler.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_last_progress_time": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_last_sl": {
    "description": "Return last computed sparsity level by current scheduler.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_latency_of_one_partition": {
    "description": "Given a partition and its nodes' latency, return a PartitionLatency for this partition",
    "std_args": [
      "partition",
      "node_to_latency_mapping"
    ],
    "type": "function"
  },
  "get_latency_of_partitioned_graph": {
    "description": "Given all partitions in a graph, find the critical path among all partitions",
    "std_args": [
      "partitions",
      "partition_to_latency_mapping",
      "transfer_rate_bytes_per_sec"
    ],
    "type": "function"
  },
  "get_len": {
    "description": "The class representing a Python function.",
    "std_args": [
      "df"
    ],
    "type": "function"
  },
  "get_libc": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_libc_version": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_linear_fun_weight": {
    "description": "The class representing a Python function.",
    "std_args": [
      "node",
      "gm"
    ],
    "type": "function"
  },
  "get_linear_mod_weight": {
    "description": "The class representing a Python function.",
    "std_args": [
      "mod"
    ],
    "type": "function"
  },
  "get_linear_prepack_op_for_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dtype"
    ],
    "type": "function"
  },
  "get_linux_pkg_version": {
    "description": "The class representing a Python function.",
    "std_args": [
      "run_lambda",
      "pkg_name"
    ],
    "type": "function"
  },
  "get_local_rank": {
    "description": "Returns the local rank of the given mesh_dim of the DeviceMesh.",
    "std_args": [
      "self",
      "mesh_dim"
    ],
    "type": "function"
  },
  "get_log_level": {
    "description": "Return default log level for pytorch.",
    "std_args": [],
    "type": "function"
  },
  "get_logdir": {
    "description": "Return the directory where event files will be written.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_logger": {
    "description": "Util function to set up a simple logger that writes",
    "std_args": [
      "name"
    ],
    "type": "function"
  },
  "get_logging_handler": {
    "description": "The class representing a Python function.",
    "std_args": [
      "destination"
    ],
    "type": "function"
  },
  "get_logical_id_to_device": {
    "description": "Get a mapping from device logical ID to Device object.",
    "std_args": [
      "devices"
    ],
    "type": "function"
  },
  "get_lr": {
    "description": "Get learning rate.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_lsb_version": {
    "description": "The class representing a Python function.",
    "std_args": [
      "run_lambda"
    ],
    "type": "function"
  },
  "get_lstm_mod_weights": {
    "description": "The class representing a Python function.",
    "std_args": [
      "mod"
    ],
    "type": "function"
  },
  "get_lstm_weight": {
    "description": "The class representing a Python function.",
    "std_args": [
      "mod"
    ],
    "type": "function"
  },
  "get_mac_version": {
    "description": "The class representing a Python function.",
    "std_args": [
      "run_lambda"
    ],
    "type": "function"
  },
  "get_mask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_matching_subgraph_pairs": {
    "description": "Matches matchable subgraphs of graph_a to graph_b.",
    "std_args": [
      "gm_a",
      "gm_b",
      "base_name_to_sets_of_related_ops",
      "unmatchable_types_map"
    ],
    "type": "function"
  },
  "get_max_alg_id": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_max_tuning_duration": {
    "description": "Get max time to spend tuning a given solution.",
    "std_args": [],
    "type": "function"
  },
  "get_max_tuning_iterations": {
    "description": "Get max iterations to spend tuning a given solution.",
    "std_args": [],
    "type": "function"
  },
  "get_method_definitions": {
    "description": "#.pyi generation for functional DataPipes Process.",
    "std_args": [
      "file_path",
      "files_to_exclude",
      "deprecated_files",
      "default_output_type",
      "method_to_special_output_type",
      "root"
    ],
    "type": "function"
  },
  "get_method_name": {
    "description": "The class representing a Python function.",
    "std_args": [
      "depth"
    ],
    "type": "function"
  },
  "get_model_info": {
    "description": "Get JSON-friendly information about a model.",
    "std_args": [
      "path_or_file",
      "title",
      "extra_file_size_limit"
    ],
    "type": "function"
  },
  "get_model_state_dict": {
    "description": "Return the model state_dict of ``model``.",
    "std_args": [
      "model",
      "submodules",
      "options"
    ],
    "type": "function"
  },
  "get_name": {
    "description": "Return Metal device name",
    "std_args": [],
    "type": "function"
  },
  "get_native_backend_config": {
    "description": "Return the `BackendConfig` for PyTorch Native backend (fbgemm/qnnpack).",
    "std_args": [],
    "type": "function"
  },
  "get_native_backend_config_dict": {
    "description": "Return the `BackendConfig` for PyTorch Native backend (fbgemm/qnnpack) in dictionary form.",
    "std_args": [],
    "type": "function"
  },
  "get_new_attr_name_with_prefix": {
    "description": "The class representing a Python function.",
    "std_args": [
      "prefix"
    ],
    "type": "function"
  },
  "get_node_creation_hook": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_node_erase_hook": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_node_first_input_and_output_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "node",
      "gm",
      "logger_cls",
      "node_type_to_io_type_map"
    ],
    "type": "function"
  },
  "get_node_input_qparams": {
    "description": "Returns the qparams (scale, zero_point) of the first input to `node`,",
    "std_args": [
      "node",
      "gm",
      "node_type_to_io_type_map"
    ],
    "type": "function"
  },
  "get_node_local_rank": {
    "description": "Return the local rank of the current process relative to the node.",
    "std_args": [
      "fallback_rank"
    ],
    "type": "function"
  },
  "get_node_replace_hook": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_node_target": {
    "description": "Given a `node` returns its target typename.",
    "std_args": [
      "submodules",
      "node"
    ],
    "type": "function"
  },
  "get_node_to_partition_mapping": {
    "description": "Given a list of partitions,return node to partition mapping",
    "std_args": [
      "partitions"
    ],
    "type": "function"
  },
  "get_node_type_to_io_type_map": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_non_observable_arg_indexes_and_types": {
    "description": "Returns a dict with of non float tensor types as keys and values which correspond to a",
    "std_args": [
      "node"
    ],
    "type": "function"
  },
  "get_nontrivial_guards": {
    "description": "Returns a list of guard expressions that aren't statically known (i.e. not trivial)",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_normalized_nth_input": {
    "description": "Given a node, gets the n'th input to that node, normalizing",
    "std_args": [
      "node",
      "gm",
      "idx"
    ],
    "type": "function"
  },
  "get_number_of_non_param_args": {
    "description": "Assumes that all non-param args occur first. Returns the number of",
    "std_args": [
      "node",
      "gm"
    ],
    "type": "function"
  },
  "get_numerical_jacobian": {
    "description": "Compute the numerical Jacobian for a given fn and its inputs.",
    "std_args": [
      "fn",
      "inputs",
      "target",
      "eps",
      "grad_out"
    ],
    "type": "function"
  },
  "get_numerical_jacobian_wrt_specific_input": {
    "description": "The class representing a Python function.",
    "std_args": [
      "fn",
      "input_idx",
      "inputs",
      "outputs",
      "eps",
      "input",
      "is_forward_ad"
    ],
    "type": "function"
  },
  "get_nvidia_driver_version": {
    "description": "The class representing a Python function.",
    "std_args": [
      "run_lambda"
    ],
    "type": "function"
  },
  "get_nvidia_smi": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_observer_state_dict": {
    "description": "Returns the state dict corresponding to the observer stats.",
    "std_args": [
      "mod"
    ],
    "type": "function"
  },
  "get_onednn_backend_config": {
    "description": "Return the `BackendConfig` for PyTorch's native ONEDNN backend.",
    "std_args": [],
    "type": "function"
  },
  "get_op_to_type_to_weight_extraction_fn": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_opt_einsum": {
    "description": "Return the opt_einsum package if opt_einsum is currently available, else None.",
    "std_args": [],
    "type": "function"
  },
  "get_optimizer_state_dict": {
    "description": "Return the combined state_dict for optimizers.",
    "std_args": [
      "model",
      "optimizers",
      "submodules",
      "options"
    ],
    "type": "function"
  },
  "get_os": {
    "description": "The class representing a Python function.",
    "std_args": [
      "run_lambda"
    ],
    "type": "function"
  },
  "get_output_act_qspec": {
    "description": "The class representing a Python function.",
    "std_args": [
      "quantization_config"
    ],
    "type": "function"
  },
  "get_output_file_path": {
    "description": "Returns the output file name or None.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_overridable_functions": {
    "description": "List functions that are overridable via __torch_function__",
    "std_args": [],
    "type": "function"
  },
  "get_param_names": {
    "description": "The class representing a Python function.",
    "std_args": [
      "fn",
      "n_args"
    ],
    "type": "function"
  },
  "get_parameter": {
    "description": "Returns the parameter given by ``target`` if it exists,",
    "std_args": [
      "traced",
      "target"
    ],
    "type": "function"
  },
  "get_params_to_average": {
    "description": "Return a list of parameters that need to average.",
    "std_args": [
      "params"
    ],
    "type": "function"
  },
  "get_partition_to_latency_mapping": {
    "description": "Given all the partitions and node_to_latency_mapping dictionary,",
    "std_args": [
      "partitions",
      "node_to_latency_mapping"
    ],
    "type": "function"
  },
  "get_path": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "path"
    ],
    "type": "function"
  },
  "get_pattern_to_dtype_configs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "backend_config"
    ],
    "type": "function"
  },
  "get_pattern_to_input_type_to_index": {
    "description": "The class representing a Python function.",
    "std_args": [
      "backend_config"
    ],
    "type": "function"
  },
  "get_per_process_memory_fraction": {
    "description": "Get memory fraction for a process.",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "get_pg_count": {
    "description": "Return the number of process groups.",
    "std_args": [],
    "type": "function"
  },
  "get_pip_packages": {
    "description": "Return `pip list` output. Note: will also find conda-installed pytorch and numpy packages.",
    "std_args": [
      "run_lambda",
      "patterns"
    ],
    "type": "function"
  },
  "get_platform": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_port": {
    "description": "Return the port the server is running on.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_pretty_env_info": {
    "description": "Returns a pretty string of environment information.",
    "std_args": [],
    "type": "function"
  },
  "get_process_group_ranks": {
    "description": "Get all ranks associated with ``group``.",
    "std_args": [
      "group"
    ],
    "type": "function"
  },
  "get_proxy_mode": {
    "description": "Current the currently active proxy tracing mode, or None if",
    "std_args": [],
    "type": "function"
  },
  "get_proxy_slot": {
    "description": "The class representing a Python function.",
    "std_args": [
      "obj",
      "tracer",
      "default",
      "transform"
    ],
    "type": "function"
  },
  "get_pruned_guards": {
    "description": "Get a list of guards, but pruned so it only provides guards that",
    "std_args": [
      "self",
      "symints"
    ],
    "type": "function"
  },
  "get_python_platform": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_qat_module_classes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "backend_config"
    ],
    "type": "function"
  },
  "get_qconfig_dtypes": {
    "description": "returns the qconfig tuple for qconfig:",
    "std_args": [
      "qconfig"
    ],
    "type": "function"
  },
  "get_qconv_fun_weight": {
    "description": "The class representing a Python function.",
    "std_args": [
      "node",
      "gm"
    ],
    "type": "function"
  },
  "get_qconv_prepack_op": {
    "description": "The class representing a Python function.",
    "std_args": [
      "conv_op"
    ],
    "type": "function"
  },
  "get_qlinear_fun_weight": {
    "description": "The class representing a Python function.",
    "std_args": [
      "node",
      "gm"
    ],
    "type": "function"
  },
  "get_qlstm_weight": {
    "description": "The class representing a Python function.",
    "std_args": [
      "mod"
    ],
    "type": "function"
  },
  "get_qnnpack_backend_config": {
    "description": "Return the `BackendConfig` for PyTorch's native QNNPACK backend.",
    "std_args": [],
    "type": "function"
  },
  "get_qparam_dict": {
    "description": "The class representing a Python function.",
    "std_args": [
      "observer_or_fake_quant"
    ],
    "type": "function"
  },
  "get_quant_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "qconfig"
    ],
    "type": "function"
  },
  "get_quantized_operator": {
    "description": "Get the quantized operator corresponding to the float operator",
    "std_args": [
      "float_op"
    ],
    "type": "function"
  },
  "get_quantized_weight": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_quantized_weight_bias_dict": {
    "description": "dictionary from flat_weight_name to quantized weight or (unquantized) bias",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_quantized_weight_hh": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_quantized_weight_ih": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_rank": {
    "description": "Return the rank of the current process in the provided ``group``, default otherwise.",
    "std_args": [
      "group"
    ],
    "type": "function"
  },
  "get_rdeps": {
    "description": "Return a list of all modules which depend on the module ``module_name``.",
    "std_args": [
      "self",
      "module_name"
    ],
    "type": "function"
  },
  "get_rdzv_endpoint": {
    "description": "The class representing a Python function.",
    "std_args": [
      "args"
    ],
    "type": "function"
  },
  "get_rdzv_state": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_remote_module_template": {
    "description": "The class representing a Python function.",
    "std_args": [
      "enable_moving_cpu_tensors_to_cuda"
    ],
    "type": "function"
  },
  "get_rendezvous_handler": {
    "description": "Obtain a reference to a :py:class`RendezvousHandler`.",
    "std_args": [
      "params"
    ],
    "type": "function"
  },
  "get_replace_hook": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "replace_inputs"
    ],
    "type": "function"
  },
  "get_resource_reader": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "fullname"
    ],
    "type": "function"
  },
  "get_resources_dir": {
    "description": "Generates the resources directory for the generated kernels,",
    "std_args": [
      "self",
      "can_create"
    ],
    "type": "function"
  },
  "get_resources_dir_for_et_path": {
    "description": "The class representing a Python function.",
    "std_args": [
      "trace_path",
      "create_dir"
    ],
    "type": "function"
  },
  "get_results": {
    "description": "Return all TunableOp results.",
    "std_args": [],
    "type": "function"
  },
  "get_reversed_fusions": {
    "description": "Set of potential fusions, in reverse order.  The order is reversed",
    "std_args": [],
    "type": "function"
  },
  "get_rng_state": {
    "description": "Returns the random number generator state as a ByteTensor.",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "get_rng_state_all": {
    "description": "Return a list of ByteTensor representing the random number states of all devices.",
    "std_args": [],
    "type": "function"
  },
  "get_rotating_buffer_size": {
    "description": "Get the rotating buffer size in kilobytes.",
    "std_args": [],
    "type": "function"
  },
  "get_run_id": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_running_cuda_version": {
    "description": "The class representing a Python function.",
    "std_args": [
      "run_lambda"
    ],
    "type": "function"
  },
  "get_safe_globals": {
    "description": "Returns the list of user-added globals that are safe for ``weights_only`` load.",
    "std_args": [],
    "type": "function"
  },
  "get_scale": {
    "description": "Return a Python float containing the current scale, or 1.0 if scaling is disabled.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_schedule_class": {
    "description": "Maps a schedule name (case insensitive) to its corresponding class object.",
    "std_args": [
      "schedule_name"
    ],
    "type": "function"
  },
  "get_shape": {
    "description": "The class representing a Python function.",
    "std_args": [
      "i"
    ],
    "type": "function"
  },
  "get_sharing_strategy": {
    "description": "Return the current strategy for sharing CPU tensors.",
    "std_args": [],
    "type": "function"
  },
  "get_signature": {
    "description": "The class representing a Python function.",
    "std_args": [
      "fn",
      "rcb",
      "loc",
      "is_method"
    ],
    "type": "function"
  },
  "get_signature_for_torch_op": {
    "description": "Given an operator on the `torch` namespace, return a list of `inspect.Signature`",
    "std_args": [
      "op",
      "return_schemas"
    ],
    "type": "function"
  },
  "get_size_of_all_nodes": {
    "description": "Given a fx graph module, update each node with its total size (weights + bias + output)",
    "std_args": [
      "fx_module",
      "args"
    ],
    "type": "function"
  },
  "get_size_of_node": {
    "description": "Given a node with node.dtype and node.shape, return its total size and its output size.",
    "std_args": [
      "fx_module",
      "node"
    ],
    "type": "function"
  },
  "get_skipped_module_name_and_classes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "prepare_custom_config",
      "is_standalone_module"
    ],
    "type": "function"
  },
  "get_sl": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_socket_with_port": {
    "description": "Returns a free port on localhost that is \"reserved\" by binding a temporary",
    "std_args": [],
    "type": "function"
  },
  "get_source": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "module_name"
    ],
    "type": "function"
  },
  "get_source_partitions": {
    "description": "Args:",
    "std_args": [
      "graph",
      "wanted_sources",
      "filter_fn"
    ],
    "type": "function"
  },
  "get_state": {
    "description": "See base class.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_state_dict": {
    "description": "Return the model state_dict and optimizers state_dict.",
    "std_args": [
      "model",
      "optimizers",
      "submodules",
      "options"
    ],
    "type": "function"
  },
  "get_state_dict_type": {
    "description": "Get the state_dict_type and the corresponding configurations for the FSDP modules rooted at ``module``.",
    "std_args": [
      "module"
    ],
    "type": "function"
  },
  "get_static_quant_module_class": {
    "description": "n Get the statically quantized module class corresponding to",
    "std_args": [
      "float_module_class",
      "additional_static_quant_mapping",
      "is_reference"
    ],
    "type": "function"
  },
  "get_std_cm": {
    "description": "The class representing a Python function.",
    "std_args": [
      "std_rd",
      "redirect_fn"
    ],
    "type": "function"
  },
  "get_storage_info": {
    "description": "The class representing a Python function.",
    "std_args": [
      "storage"
    ],
    "type": "function"
  },
  "get_stream_from_external": {
    "description": "Return a :class:`Stream` from an externally allocated CUDA stream.",
    "std_args": [
      "data_ptr",
      "device"
    ],
    "type": "function"
  },
  "get_subprocess_handler": {
    "description": "The class representing a Python function.",
    "std_args": [
      "entrypoint",
      "args",
      "env",
      "stdout",
      "stderr",
      "local_rank_id",
      "numa_options"
    ],
    "type": "function"
  },
  "get_suffix_str": {
    "description": "The class representing a Python function.",
    "std_args": [
      "number"
    ],
    "type": "function"
  },
  "get_supported_operator_for_quantization_config": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "quantization_config"
    ],
    "type": "function"
  },
  "get_supported_operators": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls"
    ],
    "type": "function"
  },
  "get_supported_quantization_configs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls"
    ],
    "type": "function"
  },
  "get_swa_avg_fn": {
    "description": "Get the function applying stochastic weight average (SWA) across a single param.",
    "std_args": [],
    "type": "function"
  },
  "get_swa_multi_avg_fn": {
    "description": "Get the function applying stochastic weight average (SWA) across multiple params.",
    "std_args": [],
    "type": "function"
  },
  "get_swapped_custom_module_class": {
    "description": "Get the observed/quantized custom module class that we need",
    "std_args": [
      "custom_module",
      "custom_module_class_mapping",
      "qconfig"
    ],
    "type": "function"
  },
  "get_symmetric_quantization_config": {
    "description": "The class representing a Python function.",
    "std_args": [
      "is_per_channel",
      "is_qat",
      "is_dynamic",
      "act_qmin",
      "act_qmax",
      "weight_qmin",
      "weight_qmax"
    ],
    "type": "function"
  },
  "get_sync_debug_mode": {
    "description": "Return current value of debug mode for cuda synchronizing operations.",
    "std_args": [],
    "type": "function"
  },
  "get_table": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "depth"
    ],
    "type": "function"
  },
  "get_target": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "get_target_type_str": {
    "description": "Returns a string representation of the type of the function or module",
    "std_args": [
      "node",
      "gm"
    ],
    "type": "function"
  },
  "get_tensor_meta": {
    "description": "The class representing a Python function.",
    "std_args": [
      "node"
    ],
    "type": "function"
  },
  "get_tensor_value": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_tensorrt_backend_config": {
    "description": "Return the `BackendConfig` for the TensorRT backend.",
    "std_args": [],
    "type": "function"
  },
  "get_tensorrt_backend_config_dict": {
    "description": "Return the `BackendConfig` for the TensorRT backend in dictionary form.",
    "std_args": [],
    "type": "function"
  },
  "get_test_only_legacy_native_backend_config": {
    "description": "Return the `BackendConfig` for PyTorch Native backend (fbgemm/qnnpack) with various additional fp16 ops.",
    "std_args": [],
    "type": "function"
  },
  "get_test_only_legacy_native_backend_config_dict": {
    "description": "Return the `BackendConfig` for PyTorch Native backend (fbgemm/qnnpack) with various additional",
    "std_args": [],
    "type": "function"
  },
  "get_testing_overrides": {
    "description": "Return a dict containing dummy overrides for all overridable functions",
    "std_args": [],
    "type": "function"
  },
  "get_torch_dispatch_modes": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_total_flops": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_trace_id": {
    "description": "Returns the current trace ID.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_type_a_related_to_b": {
    "description": "The class representing a Python function.",
    "std_args": [
      "base_name_to_sets_of_related_ops"
    ],
    "type": "function"
  },
  "get_type_line": {
    "description": "Try to find the line containing a comment with the type annotation.",
    "std_args": [
      "source"
    ],
    "type": "function"
  },
  "get_unique_id": {
    "description": "Get an id. This id is guaranteed to only be handed out once for this package.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_unmatchable_types_map": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_unsafe_globals_in_checkpoint": {
    "description": "Returns a list of strings of functions/classes in a ``torch.save`` object that are not safe for ``weights_only``.",
    "std_args": [
      "f"
    ],
    "type": "function"
  },
  "get_use_env": {
    "description": "Retrieve ``use_env`` from the args.",
    "std_args": [
      "args"
    ],
    "type": "function"
  },
  "get_val": {
    "description": "The class representing a Python function.",
    "std_args": [
      "capture"
    ],
    "type": "function"
  },
  "get_validators": {
    "description": "Return the TunableOp validators.",
    "std_args": [],
    "type": "function"
  },
  "get_weight": {
    "description": "Fake quantize (quantize and dequantize) the weight with",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_weight_hh": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_weight_ih": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_weight_qspec": {
    "description": "The class representing a Python function.",
    "std_args": [
      "quantization_config"
    ],
    "type": "function"
  },
  "get_windows_version": {
    "description": "The class representing a Python function.",
    "std_args": [
      "run_lambda"
    ],
    "type": "function"
  },
  "get_worker_group": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "role"
    ],
    "type": "function"
  },
  "get_worker_info": {
    "description": "Get :class:`~torch.distributed.rpc.WorkerInfo` of a given worker name.",
    "std_args": [
      "worker_name"
    ],
    "type": "function"
  },
  "get_world_size": {
    "description": "Return the number of processes in the current process group.",
    "std_args": [
      "group"
    ],
    "type": "function"
  },
  "get_x86_backend_config": {
    "description": "Return the `BackendConfig` for PyTorch's native x86 backend.",
    "std_args": [],
    "type": "function"
  },
  "get_x86_inductor_linear_dynamic_fp16_config": {
    "description": "For linear_dynamic_fp16. The name may be confusing.",
    "std_args": [],
    "type": "function"
  },
  "getattr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "attr",
      "attr_val",
      "parameter_proxy_cache"
    ],
    "type": "function"
  },
  "getattr_from_fqn": {
    "description": "Given an obj and a fqn such as \"foo.bar.baz\", returns gm.foo.bar.baz.",
    "std_args": [
      "obj",
      "fqn"
    ],
    "type": "function"
  },
  "getattr_maps": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "getattr_recursive": {
    "description": "The class representing a Python function.",
    "std_args": [
      "obj",
      "name"
    ],
    "type": "function"
  },
  "getitem_inference_rule": {
    "description": "The class representing a Python function.",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "getstate_hook": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "getter": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "git_version": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "global_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "global_namespace": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "global_qconfig": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "global_rank": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "global_setup": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "global_unstructured": {
    "description": "Globally prunes tensors corresponding to all parameters in ``parameters`` by applying the specified ``pruning_method``.",
    "std_args": [
      "parameters",
      "pruning_method",
      "importance_scores",
      "kwargs"
    ],
    "type": "function"
  },
  "globals": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "gm": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "grad": {
    "description": "Creates a function that evaluates the gradient of 'func'.",
    "std_args": [
      "func",
      "argnums",
      "has_aux"
    ],
    "variants": {}
  },
  "grad_outputs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "gradcheck": {
    "description": "Check gradients computed via small finite differences against analytical",
    "std_args": [
      "func",
      "inputs",
      "eps",
      "atol",
      "rtol",
      "raise_exception",
      "nondet_tol",
      "check_undefined_grad",
      "check_grad_dtypes",
      "check_batched_grad",
      "check_batched_forward_grad",
      "check_forward_ad",
      "check_backward_ad",
      "fast_mode",
      "masked"
    ],
    "type": "function"
  },
  "gradgradcheck": {
    "description": "Check gradients of gradients computed via small finite differences",
    "std_args": [
      "func",
      "inputs",
      "grad_outputs",
      "eps",
      "atol",
      "rtol",
      "gen_non_contig_grad_outputs",
      "raise_exception",
      "nondet_tol",
      "check_undefined_grad",
      "check_grad_dtypes",
      "check_batched_grad",
      "check_fwd_over_rev",
      "check_rev_over_rev",
      "fast_mode",
      "masked"
    ],
    "type": "function"
  },
  "gradient_as_bucket_view": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "gradients_to_parameters": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "gradients_to_user_inputs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "granularity": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "graph": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "graph_code_log": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "graph_copy": {
    "description": "Copy all nodes from a given graph into ``self``.",
    "std_args": [
      "self",
      "g",
      "val_map",
      "return_output_node"
    ],
    "type": "function"
  },
  "graph_id": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "graph_module_from_producer_nodes": {
    "description": "Construct a graph module from extracted producer nodes",
    "std_args": [
      "root",
      "producer_nodes"
    ],
    "type": "function"
  },
  "graph_pool_handle": {
    "description": "Return an opaque token representing the id of a graph memory pool.",
    "std_args": [],
    "type": "function"
  },
  "graph_signature": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "greater_than": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "greater_than_eq": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "grid_sample": {
    "description": "Compute grid sample.",
    "std_args": [
      "input",
      "grid",
      "mode",
      "padding_mode",
      "align_corners"
    ],
    "type": "function"
  },
  "group": {
    "description": "Group class. Placeholder.",
    "std_args": [],
    "type": "class"
  },
  "group_key_fn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "group_name": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "group_norm": {
    "description": "Apply Group Normalization for last certain number of dimensions.",
    "std_args": [
      "input",
      "num_groups",
      "weight",
      "bias",
      "eps"
    ],
    "type": "function"
  },
  "group_peer": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "group_rank": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "group_results_by_subgraph": {
    "description": "Creates a comparison of results",
    "std_args": [
      "results"
    ],
    "type": "function"
  },
  "group_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "group_world_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "groupby": {
    "description": "Group a collection by a key function",
    "std_args": [
      "func",
      "seq"
    ],
    "type": "function"
  },
  "groups": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "gt": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "function"
  },
  "gt_inference_rule": {
    "description": "The class representing a Python function.",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "guaranteed_group_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "guard_bool": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "file",
      "line"
    ],
    "type": "function"
  },
  "guard_float": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "file",
      "line"
    ],
    "type": "function"
  },
  "guard_int": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "file",
      "line"
    ],
    "type": "function"
  },
  "guard_or_defer_runtime_assert": {
    "description": "Adds a guard that orig_expr is True if we can or fall back to adding an assert",
    "std_args": [
      "self",
      "orig_expr",
      "msg",
      "fx_node"
    ],
    "type": "function"
  },
  "guard_or_false": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "file",
      "line"
    ],
    "type": "function"
  },
  "guard_or_true": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "file",
      "line"
    ],
    "type": "function"
  },
  "guard_scalar": {
    "description": "Guard a scalar value, which can be a symbolic or concrete boolean, integer, or float.",
    "std_args": [
      "a"
    ],
    "type": "function"
  },
  "guard_size_oblivious": {
    "description": "Like guard_bool, but if we encounter unbacked symbols, if those symbols",
    "std_args": [
      "self",
      "file",
      "line"
    ],
    "type": "function"
  },
  "gumbel_softmax": {
    "description": "Sample from the Gumbel-Softmax distribution (`Link 1`_  `Link 2`_) and optionally discretize.",
    "std_args": [
      "logits",
      "tau",
      "hard",
      "eps",
      "dim"
    ],
    "type": "function"
  },
  "half": {
    "description": "Casts all floating point parameters and buffers to ``half`` datatype.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "half_open_interval": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "half_to_int": {
    "description": "Casts a half-precision float value into an integer.",
    "std_args": [
      "f"
    ],
    "type": "function"
  },
  "halt_ordering": {
    "description": "Deprecated interface to temporarily disable ordering.",
    "std_args": [],
    "type": "function"
  },
  "hamming": {
    "description": "The class representing a Python function.",
    "std_args": [
      "M",
      "sym",
      "dtype",
      "layout",
      "device",
      "requires_grad"
    ],
    "type": "function"
  },
  "handle": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "handle_existing_rendezvous": {
    "description": "Handle the case when there's an existing (state 'final) rendezvous already",
    "std_args": [
      "self",
      "expected_version"
    ],
    "type": "function"
  },
  "handle_extension": {
    "description": "Return a decoder handler function for the list of extensions.",
    "std_args": [
      "extensions",
      "f"
    ],
    "type": "function"
  },
  "handle_join_last_call": {
    "description": "After we reach min number of workers, one particular worker takes on the",
    "std_args": [
      "self",
      "expected_version",
      "deadline"
    ],
    "type": "function"
  },
  "handle_sym_dispatch": {
    "description": "Call into the currently active proxy tracing mode to do a",
    "std_args": [
      "func",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "handle_torch_function": {
    "description": "Implement a function with checks for ``__torch_function__`` overrides.",
    "std_args": [
      "public_api",
      "relevant_args",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "handler": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "handlers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hann": {
    "description": "The class representing a Python function.",
    "std_args": [
      "M",
      "sym",
      "dtype",
      "layout",
      "device",
      "requires_grad"
    ],
    "type": "function"
  },
  "hardshrink": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hardtanh_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "has_customized_qrange": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "has_enumerate_support": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "has_file": {
    "description": "Checks if a file is present in a :class:`Directory`.",
    "std_args": [
      "self",
      "filename"
    ],
    "type": "function"
  },
  "has_folding_been_run": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "has_free_symbols": {
    "description": "Faster version of bool(free_symbols(val))",
    "std_args": [
      "val"
    ],
    "type": "function"
  },
  "has_free_unbacked_symbols": {
    "description": "Faster version of bool(free_unbacked_symbols(val))",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "has_half": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "has_hint": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "has_magma": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "has_materialized": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "has_no_children_ignoring_parametrizations": {
    "description": "Checks if module._modules is empty or",
    "std_args": [
      "module"
    ],
    "type": "function"
  },
  "has_preserved_node_meta": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "has_proxy_slot": {
    "description": "The class representing a Python function.",
    "std_args": [
      "obj",
      "tracer"
    ],
    "type": "function"
  },
  "has_rsample": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "has_side_effect": {
    "description": "The class representing a Python function.",
    "std_args": [
      "fn"
    ],
    "type": "function"
  },
  "has_static_value": {
    "description": "User-code friendly utility to check if a value is static or dynamic.",
    "std_args": [
      "a"
    ],
    "type": "function"
  },
  "has_symbolic_sizes_strides": {
    "description": "The class representing a Python function.",
    "std_args": [
      "elem"
    ],
    "type": "function"
  },
  "has_torch_function": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "has_torch_function_unary": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "has_torch_function_variadic": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "has_uninitialized_params": {
    "description": "Check if a module has parameters that are not initialized.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "has_warnings": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hashable": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "head": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "head_bias": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "head_dim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "head_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "heartbeat": {
    "description": "Get the keep-alive heartbeat timeout.",
    "std_args": [],
    "type": "attribute"
  },
  "help": {
    "description": "Print docstring for the function corresponding to inputs",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "hermite_polynomial_h": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermite_polynomial_he": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hessian": {
    "description": "Compute the Hessian of a given scalar function.",
    "std_args": [
      "func",
      "inputs",
      "create_graph",
      "strict",
      "vectorize",
      "outer_jacobian_strategy"
    ],
    "type": "function"
  },
  "hex": {
    "description": "Returns the hexadecimal representation of the float.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "hfft2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hfftn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hgates": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hidden_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hidden_state_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hierarchical_pickle": {
    "description": "The class representing a Python function.",
    "std_args": [
      "data"
    ],
    "type": "function"
  },
  "highlight_warnings": {
    "description": "Enables warning highlighting when building formatted table.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "hinge_embedding_loss": {
    "description": "Compute the hinge embedding loss.",
    "std_args": [
      "input",
      "target",
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "hint": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hint_int": {
    "description": "Retrieve the hint for an int (based on the underlying real values as observed",
    "std_args": [
      "a",
      "fallback"
    ],
    "type": "function"
  },
  "hip": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hip_header_magic": {
    "description": "If the file makes kernel builtin calls and does not include the cuda_runtime.h header,",
    "std_args": [
      "input_string"
    ],
    "type": "function"
  },
  "hipified_path": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hipify": {
    "description": "The class representing a Python function.",
    "std_args": [
      "project_directory",
      "show_detailed",
      "extensions",
      "header_extensions",
      "output_directory",
      "header_include_dirs",
      "includes",
      "extra_files",
      "out_of_place_only",
      "ignores",
      "show_progress",
      "hip_clang_launch",
      "is_pytorch_extension",
      "hipify_extra_files_only",
      "clean_ctx"
    ],
    "type": "function"
  },
  "hist": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "histogram": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "histogram_raw": {
    "description": "Output a `Summary` protocol buffer with a histogram.",
    "std_args": [
      "name",
      "min",
      "max",
      "num",
      "sum",
      "sum_squares",
      "bucket_limits",
      "bucket_counts"
    ],
    "type": "function"
  },
  "histogramdd": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "hook_with_zero_step": {
    "description": "Modify ``hook`` to overlap :class:`ZeroRedundancyOptimizer` optimizer step with :class:`DistributedDataParallel` backward pass.",
    "std_args": [
      "hook",
      "ddp",
      "zero",
      "shard_buckets"
    ],
    "type": "function"
  },
  "hook_with_zero_step_interleaved": {
    "description": "Modify ``hook`` to overlap :class:`ZeroRedundancyOptimizer` optimizer step with :class:`DistributedDataParallel` backward pass",
    "std_args": [
      "hook",
      "ddp",
      "zero",
      "shard_buckets"
    ],
    "type": "function"
  },
  "hooks_dict_ref": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "host_memory_stats": {
    "description": "Return a dictionary of CUDA memory allocator statistics for a given device.",
    "std_args": [],
    "type": "function"
  },
  "host_memory_stats_as_nested_dict": {
    "description": "Return the result of :func:`~torch.cuda.host_memory_stats` as a nested dictionary.",
    "std_args": [],
    "type": "function"
  },
  "hostname": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "householder_product": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hparams": {
    "description": "Output three `Summary` protocol buffers needed by hparams plugin.",
    "std_args": [
      "hparam_dict",
      "metric_dict",
      "hparam_domain_discrete"
    ],
    "type": "function"
  },
  "hpu": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "device",
      "non_blocking"
    ],
    "type": "function"
  },
  "huber_loss": {
    "description": "Compute the Huber loss, with optional weighting.",
    "std_args": [
      "input",
      "target",
      "reduction",
      "delta",
      "weight"
    ],
    "type": "function"
  },
  "hvp": {
    "description": "Compute the dot product between the scalar function's Hessian and a vector ``v`` at a specified point.",
    "std_args": [
      "func",
      "inputs",
      "v",
      "create_graph",
      "strict"
    ],
    "type": "function"
  },
  "i": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "i0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "i0e": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "i1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "i1e": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "icdf": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "value"
    ],
    "type": "function"
  },
  "id": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "identity_transform": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "idx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ifft2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "igate_cgate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "igates": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ignore_fresh_unbacked_symbols": {
    "description": "Indicates that the newly allocated unbacked SymInts are being",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "ignore_frozen_params": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ignore_index": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ignore_literals": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ihfft2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ihfftn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ij": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ijk": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "image": {
    "description": "Output a `Summary` protocol buffer with images.",
    "std_args": [
      "tag",
      "tensor",
      "rescale",
      "dataformats"
    ],
    "type": "function"
  },
  "image_boxes": {
    "description": "Output a `Summary` protocol buffer with images.",
    "std_args": [
      "tag",
      "tensor_image",
      "tensor_boxes",
      "rescale",
      "dataformats",
      "labels"
    ],
    "type": "function"
  },
  "imagehandler": {
    "description": "The class representing a Python function.",
    "std_args": [
      "imagespec"
    ],
    "type": "function"
  },
  "imagespec": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "imagespecs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "immediate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "immutable_dict": {
    "description": "An immutable version of :class:`dict`.",
    "std_args": [],
    "type": "class"
  },
  "immutable_list": {
    "description": "An immutable version of :class:`list`.",
    "std_args": [],
    "type": "class"
  },
  "impl": {
    "description": "Register an implementation for a device type for this operator.",
    "std_args": [
      "qualname",
      "types",
      "func",
      "lib"
    ],
    "type": "function"
  },
  "impl_abstract": {
    "description": "This API was renamed to :func:`torch.library.register_fake` in PyTorch 2.4.",
    "std_args": [
      "qualname",
      "func",
      "lib",
      "_stacklevel"
    ],
    "type": "function"
  },
  "implicit_replication": {
    "description": "This context manager allows :class:`DTensor` to implicitly treat all non-DTensors (``torch.Tensor``)",
    "std_args": [],
    "type": "function"
  },
  "importer": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in1_features": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in2_features": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in_cooldown": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in_features": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in_interval": {
    "description": "Return all records in the given interval",
    "std_args": [
      "self",
      "start_us",
      "end_us"
    ],
    "type": "function"
  },
  "in_order": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in_proj_bias": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in_proj_weight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in_shape": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in_spec": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "include": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "include_last_offset": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "include_paths": {
    "description": "Get the include paths required to build a C++ or CUDA or SYCL extension.",
    "std_args": [
      "device_type"
    ],
    "type": "function"
  },
  "inclusive": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "increment_step": {
    "description": "Increments the step count for the requester.",
    "std_args": [
      "cls",
      "requester"
    ],
    "type": "function"
  },
  "increment_version": {
    "description": "Update autograd metadata tracking whether the given Tensor was modified in place.",
    "std_args": [
      "tensor"
    ],
    "type": "function"
  },
  "independent": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "index": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "index1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "index2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "index_select_inference_rule": {
    "description": "We constrain the second argument to a vector or Dyn.",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "index_tuple": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "infer_symbolic_relations": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "n"
    ],
    "type": "function"
  },
  "infer_symbolic_types": {
    "description": "Calls our symbolic inferencer twice.",
    "std_args": [
      "traced"
    ],
    "type": "function"
  },
  "infer_symbolic_types_single_pass": {
    "description": "Calls our symbolic inferencer once.",
    "std_args": [
      "traced"
    ],
    "type": "function"
  },
  "inference_mode": {
    "description": "Context manager that enables or disables inference mode.",
    "std_args": [
      "self",
      "mode"
    ],
    "type": "class"
  },
  "init": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "init_backend": {
    "description": "The class representing a Python function.",
    "std_args": [
      "backend",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "init_device_mesh": {
    "description": "Initializes a `DeviceMesh` based on `device_type`, `mesh_shape`, and `mesh_dim_names` parameters.",
    "std_args": [
      "device_type",
      "mesh_shape",
      "mesh_dim_names",
      "backend_override"
    ],
    "type": "function"
  },
  "init_dropout_state": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dropout",
      "train",
      "dropout_seed",
      "dropout_state"
    ],
    "type": "function"
  },
  "init_path": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "path"
    ],
    "type": "function"
  },
  "init_phase": {
    "description": "Initially, the rendezvous state is expected to be one of:",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "init_process_group": {
    "description": "Initialize the default distributed process group.",
    "std_args": [
      "backend",
      "init_method",
      "timeout",
      "world_size",
      "rank",
      "store",
      "group_name",
      "pg_options",
      "device_id"
    ],
    "type": "function"
  },
  "init_rank": {
    "description": "The class representing a Python function.",
    "std_args": [
      "num_ranks",
      "uid",
      "rank"
    ],
    "type": "function"
  },
  "init_reductions": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "init_rpc": {
    "description": "Initializes RPC primitives such as the local RPC agent",
    "std_args": [
      "name",
      "backend",
      "rank",
      "world_size",
      "rpc_backend_options"
    ],
    "type": "function"
  },
  "init_sl": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "init_step_count": {
    "description": "Initialize for a given requester.",
    "std_args": [
      "cls",
      "requester"
    ],
    "type": "function"
  },
  "init_t": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "initial_cell_state_qparams": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "initial_hidden_state_qparams": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "initial_seed": {
    "description": "Return the current random seed of the current GPU.",
    "std_args": [],
    "type": "function"
  },
  "initialize": {
    "description": "Call prior to running code that we wish to capture errors/exceptions.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "initialize_hidden": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "batch_size",
      "is_quantized"
    ],
    "type": "function"
  },
  "initialize_metrics": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cfg"
    ],
    "type": "function"
  },
  "initialize_parameters": {
    "description": "Infers ``in_features`` based on ``input`` and initializes parameters.",
    "std_args": [
      "self",
      "input"
    ],
    "type": "function"
  },
  "initialized": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "initially_zero": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "inner": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "inner_contexts": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "inner_name": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "inplace": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "inplace_methods": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "inplace_ops": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "inplace_wrapper": {
    "description": "Convenience wrapper for passes which modify an object inplace. This",
    "std_args": [
      "fn"
    ],
    "type": "function"
  },
  "input1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_activation": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_col": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_dot_graph": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_dtype_with_constraints": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_gate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_kwarg_layouts": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_layouts": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_nodes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_output_only_quint8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_placeholders": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_qspec_map": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_quantized_indexes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_reshard": {
    "description": "Register hooks to an nn.Module for input resharding, enabling sharding and restoration during backward computation.",
    "std_args": [
      "module",
      "tp_device_mesh",
      "input_reshard_dim"
    ],
    "type": "function"
  },
  "input_shapes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_specs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_tensors_index": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_tokens": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_var": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "inputs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "inputs_meta": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "inputs_to_buffers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "inputs_to_lifted_custom_objs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "inputs_to_lifted_tensor_constants": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "inputs_to_parameters": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "insert": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "insert_arg": {
    "description": "Insert an positional argument to the argument list with given index.",
    "std_args": [
      "self",
      "idx",
      "arg"
    ],
    "type": "function"
  },
  "insert_deferred_runtime_asserts": {
    "description": "During tracing, we may have discovered that some data-dependent values",
    "std_args": [
      "gm",
      "shape_env",
      "name",
      "export"
    ],
    "type": "function"
  },
  "insert_subgm": {
    "description": "The class representing a Python function.",
    "std_args": [
      "gm",
      "sub_gm",
      "orig_inputs",
      "orig_outputs"
    ],
    "type": "function"
  },
  "inserting_after": {
    "description": "Set the point at which create_node and companion methods will insert into the graph.",
    "std_args": [
      "self",
      "n"
    ],
    "type": "function"
  },
  "inserting_before": {
    "description": "Set the point at which create_node and companion methods will insert into the graph.",
    "std_args": [
      "self",
      "n"
    ],
    "type": "function"
  },
  "install_tensor_meta": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tensor_meta"
    ],
    "type": "function"
  },
  "instance_id": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "instance_norm": {
    "description": "Apply Instance Normalization independently for each channel in every data sample within a batch.",
    "std_args": [
      "input",
      "running_mean",
      "running_var",
      "weight",
      "bias",
      "use_input_stats",
      "momentum",
      "eps"
    ],
    "type": "function"
  },
  "instantiate": {
    "description": "Instantiate the CUDA graph. Will be called by",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "instantiate_non_scriptable_remote_module_template": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "instantiate_scriptable_remote_module_template": {
    "description": "The class representing a Python function.",
    "std_args": [
      "module_interface_cls",
      "enable_moving_cpu_tensors_to_cuda"
    ],
    "type": "function"
  },
  "int": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "int8_in_int8_out_ops": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "int_": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "int_floordiv": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "function"
  },
  "int_to_half": {
    "description": "Casts an integer value to a half-precision float.",
    "std_args": [
      "i"
    ],
    "type": "function"
  },
  "int_truediv": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "function"
  },
  "integer_interval": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "intern": {
    "description": "Specify modules that should be packaged. A module must match some ``intern`` pattern in order to be",
    "std_args": [
      "self",
      "include",
      "exclude",
      "allow_empty"
    ],
    "type": "function"
  },
  "interned_modules": {
    "description": "Return all modules that are currently interned.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "interpolate": {
    "description": "Down/up samples the input to either the given :attr:`size` or the given",
    "std_args": [
      "input",
      "size",
      "scale_factor",
      "mode",
      "align_corners"
    ],
    "type": "function"
  },
  "interval": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "inv_ex": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "inverse_shape": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "shape"
    ],
    "type": "function"
  },
  "invert_permutation": {
    "description": "Returns the inverse of ``permutation``.",
    "std_args": [
      "permutation"
    ],
    "type": "function"
  },
  "ipc_collect": {
    "description": "Force collects GPU memory after it has been released by CUDA IPC.",
    "std_args": [],
    "type": "function"
  },
  "ipc_handle": {
    "description": "Return an IPC handle of this event.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "ipu": {
    "description": "Move all model parameters and buffers to the IPU.",
    "std_args": [
      "self",
      "device"
    ],
    "type": "function"
  },
  "iqr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "irecv": {
    "description": "Receives a tensor asynchronously.",
    "std_args": [
      "tensor",
      "src",
      "group",
      "tag",
      "group_src"
    ],
    "type": "function"
  },
  "irfft2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_acc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_acceptable": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tensor"
    ],
    "type": "function"
  },
  "is_accessor_node": {
    "description": "Helper function to determine if a node is trying to access",
    "std_args": [
      "node"
    ],
    "type": "function"
  },
  "is_activation_post_process": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_algebraic_expression": {
    "description": "The class representing a Python function.",
    "std_args": [
      "constraint"
    ],
    "type": "function"
  },
  "is_async": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_autocast_available": {
    "description": "Return a bool indicating if autocast is available on :attr:`device_type`.",
    "std_args": [
      "device_type"
    ],
    "type": "function"
  },
  "is_available": {
    "description": "Return true if MTIA device is available",
    "std_args": [],
    "type": "function"
  },
  "is_backend_available": {
    "description": "Check backend availability.",
    "std_args": [
      "backend"
    ],
    "type": "function"
  },
  "is_bf16_supported": {
    "description": "The class representing a Python function.",
    "std_args": [
      "including_emulation"
    ],
    "type": "function"
  },
  "is_bool": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_bool_expr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "constraint"
    ],
    "type": "function"
  },
  "is_built": {
    "description": "Return whether PyTorch is built with CUDA support.",
    "std_args": [],
    "type": "function"
  },
  "is_bw": {
    "description": "A boolean marking if this is currently running during the backward pass or not",
    "std_args": [],
    "type": "attribute"
  },
  "is_caffe2_gpu_file": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rel_filepath"
    ],
    "type": "function"
  },
  "is_capturing_metal": {
    "description": "Checks if metal capture is in progress",
    "std_args": [],
    "type": "function"
  },
  "is_channels_last_contiguous_2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "sizes",
      "strides"
    ],
    "type": "function"
  },
  "is_channels_last_contiguous_3d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "sizes",
      "strides"
    ],
    "type": "function"
  },
  "is_channels_last_strides_2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "sizes",
      "strides"
    ],
    "type": "function"
  },
  "is_channels_last_strides_3d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "sizes",
      "strides"
    ],
    "type": "function"
  },
  "is_closed": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_column": {
    "description": "The class representing a Python function.",
    "std_args": [
      "data"
    ],
    "type": "function"
  },
  "is_compiling": {
    "description": "Indicates whether a graph is executed/traced as part of torch.compile() or torch.export().",
    "std_args": [],
    "type": "function"
  },
  "is_concrete_bool": {
    "description": "Utility to check if underlying object",
    "std_args": [
      "a"
    ],
    "type": "function"
  },
  "is_concrete_float": {
    "description": "Utility to check if underlying object",
    "std_args": [
      "a"
    ],
    "type": "function"
  },
  "is_concrete_int": {
    "description": "Utility to check if underlying object",
    "std_args": [
      "a"
    ],
    "type": "function"
  },
  "is_consistent": {
    "description": "A binary relation denoted by ~ that determines if t1 is consistent with t2.",
    "std_args": [
      "t1",
      "t2"
    ],
    "type": "function"
  },
  "is_constant": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_contiguous": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "sizes",
      "strides"
    ],
    "type": "function"
  },
  "is_create_fx_call_function": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_cuda": {
    "description": "Return true if `self.data` stored on a gpu.",
    "std_args": [],
    "type": "attribute"
  },
  "is_current_stream_capturing": {
    "description": "Return True if CUDA graph capture is underway on the current CUDA stream, False otherwise.",
    "std_args": [],
    "type": "function"
  },
  "is_cusparse_file": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rel_filepath"
    ],
    "type": "function"
  },
  "is_custom_module_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_dataframe": {
    "description": "The class representing a Python function.",
    "std_args": [
      "data"
    ],
    "type": "function"
  },
  "is_defer_runtime_assert": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_dependent": {
    "description": "Checks if ``constraint`` is a ``_Dependent`` object.",
    "std_args": [
      "constraint"
    ],
    "type": "function"
  },
  "is_derived": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "src",
      "symbol_src",
      "fn"
    ],
    "type": "function"
  },
  "is_deterministic_algorithms_warn_only_enabled": {
    "description": "Returns True if the global deterministic flag is set to warn only.",
    "std_args": [],
    "type": "function"
  },
  "is_dim": {
    "description": "The class representing a Python function.",
    "std_args": [
      "d"
    ],
    "type": "function"
  },
  "is_dim_div_by_target": {
    "description": "Generate constraints to check if the input dimensions is divisible by the target dimensions",
    "std_args": [
      "target",
      "dim"
    ],
    "type": "function"
  },
  "is_dir": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_discrete": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_dynamic": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_dynamo_compiling": {
    "description": "Indicates whether a graph is traced via TorchDynamo.",
    "std_args": [],
    "type": "function"
  },
  "is_enabled": {
    "description": "Return a bool indicating whether this instance is enabled.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_equal": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "source1",
      "source2"
    ],
    "type": "function"
  },
  "is_evaluate_expr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_exporting": {
    "description": "Indicated whether we're under exporting.",
    "std_args": [],
    "type": "function"
  },
  "is_failed": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_flash_attention_available": {
    "description": "Check if PyTorch was built with FlashAttention for scaled_dot_product_attention.",
    "std_args": [],
    "type": "function"
  },
  "is_float": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_from_package": {
    "description": "Return whether an object was loaded from a package.",
    "std_args": [
      "obj"
    ],
    "type": "function"
  },
  "is_function_or_method": {
    "description": "The class representing a Python function.",
    "std_args": [
      "the_callable"
    ],
    "type": "function"
  },
  "is_functional_optim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_general_tensor_value_op": {
    "description": "Returns True if the operator works for both floating point and",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_gloo_available": {
    "description": "Check if the Gloo backend is available.",
    "std_args": [],
    "type": "function"
  },
  "is_hpu": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_impure": {
    "description": "Returns whether this op is impure, i.e. if its op is a placeholder or",
    "std_args": [
      "self",
      "impure_random"
    ],
    "type": "function"
  },
  "is_in_onnx_export": {
    "description": "Returns whether it is in the middle of ONNX export.",
    "std_args": [],
    "type": "function"
  },
  "is_infra_mode": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls"
    ],
    "type": "function"
  },
  "is_initialized": {
    "description": "Return whether PyTorch's MTIA state has been initialized.",
    "std_args": [],
    "type": "function"
  },
  "is_int": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_integer": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_lazy": {
    "description": "Returns whether ``param`` is an ``UninitializedParameter`` or ``UninitializedBuffer``.",
    "std_args": [
      "param"
    ],
    "type": "function"
  },
  "is_legacy": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_macos13_or_newer": {
    "description": "Return a bool indicating whether MPS is running on MacOS 13 or newer.",
    "std_args": [
      "minor"
    ],
    "type": "function"
  },
  "is_macos_or_newer": {
    "description": "Return a bool indicating whether MPS is running on given MacOS or newer.",
    "std_args": [
      "major",
      "minor"
    ],
    "type": "function"
  },
  "is_masked_tensor": {
    "description": "Returns True if the input is a MaskedTensor, else False",
    "std_args": [
      "obj"
    ],
    "type": "function"
  },
  "is_metal_capture_enabled": {
    "description": "Checks if `metal_capture` context manager is usable",
    "std_args": [],
    "type": "function"
  },
  "is_more_precise": {
    "description": "A binary relation denoted by <= that determines if t1 is more precise than t2.",
    "std_args": [
      "t1",
      "t2"
    ],
    "type": "function"
  },
  "is_mpi_available": {
    "description": "Check if the MPI backend is available.",
    "std_args": [],
    "type": "function"
  },
  "is_multithreading_enabled": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_namedtuple": {
    "description": "The class representing a Python function.",
    "std_args": [
      "obj"
    ],
    "type": "function"
  },
  "is_nccl_available": {
    "description": "Check if the NCCL backend is available.",
    "std_args": [],
    "type": "function"
  },
  "is_nested": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_nested_int": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_ninja_available": {
    "description": "Return ``True`` if the `ninja <https://ninja-build.org/>`_ build system is available on the system, ``False`` otherwise.",
    "std_args": [],
    "type": "function"
  },
  "is_node_output_tensor": {
    "description": "Checks if the node output produces a Tensor or not.",
    "std_args": [
      "node"
    ],
    "type": "function"
  },
  "is_node_supported": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "submodules",
      "node"
    ],
    "type": "function"
  },
  "is_non_overlapping_and_dense": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "sizes",
      "strides"
    ],
    "type": "function"
  },
  "is_non_overlapping_and_dense_indicator": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "sizes",
      "strides"
    ],
    "type": "function"
  },
  "is_out_of_place": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rel_filepath"
    ],
    "type": "function"
  },
  "is_parametrized": {
    "description": "Determine if a module has a parametrization.",
    "std_args": [
      "module",
      "tensor_name"
    ],
    "type": "function"
  },
  "is_partial": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "reduce_op"
    ],
    "type": "function"
  },
  "is_per_channel": {
    "description": "The class representing a Python function.",
    "std_args": [
      "qscheme"
    ],
    "type": "function"
  },
  "is_per_tensor": {
    "description": "The class representing a Python function.",
    "std_args": [
      "qscheme"
    ],
    "type": "function"
  },
  "is_pinned": {
    "description": "Return true if `self.data` stored on in pinned memory.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_process_running": {
    "description": "function to check process is running or not",
    "std_args": [
      "pid"
    ],
    "type": "function"
  },
  "is_pruned": {
    "description": "Check if a module is pruned by looking for pruning pre-hooks.",
    "std_args": [
      "module"
    ],
    "type": "function"
  },
  "is_pytorch_file": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rel_filepath"
    ],
    "type": "function"
  },
  "is_qat": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_quantized": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_recompute": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_recording": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_registered": {
    "description": "Returns True if the execution trace observer is registered, otherwise False.",
    "std_args": [],
    "type": "attribute"
  },
  "is_remote": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_replicate": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_reserved_name": {
    "description": "The class representing a Python function.",
    "std_args": [
      "name"
    ],
    "type": "function"
  },
  "is_running": {
    "description": "Returns True if the observer is running, otherwise False.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_shard": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dim"
    ],
    "type": "function"
  },
  "is_shardable": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_shared": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_sparse": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_sparse_coo": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_sparse_csr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_special_file": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rel_filepath"
    ],
    "type": "function"
  },
  "is_standalone_module_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_storage": {
    "description": "Returns True if `obj` is a PyTorch storage object.",
    "std_args": [
      "obj"
    ],
    "type": "function"
  },
  "is_sym_node": {
    "description": "The class representing a Python function.",
    "std_args": [
      "node"
    ],
    "type": "function"
  },
  "is_symbol_binding_fx_node": {
    "description": "Check if a given FX node is a symbol binding node.",
    "std_args": [
      "node"
    ],
    "type": "function"
  },
  "is_symbolic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_symmetric_quant": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_target_div_by_dim": {
    "description": "Generate constraints to check if the target dimensions are divisible by the input dimensions",
    "std_args": [
      "target",
      "dim"
    ],
    "type": "function"
  },
  "is_tensor": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ann"
    ],
    "type": "function"
  },
  "is_tensor_like": {
    "description": "Returns ``True`` if the passed-in input is a Tensor-like.",
    "std_args": [
      "inp"
    ],
    "type": "function"
  },
  "is_tensor_method_or_property": {
    "description": "Returns True if the function passed in is a handler for a",
    "std_args": [
      "func"
    ],
    "type": "function"
  },
  "is_tf32_supported": {
    "description": "Return a bool indicating if the current CUDA/ROCm device supports dtype tf32.",
    "std_args": [],
    "type": "function"
  },
  "is_torch_jit_ignore_context_manager": {
    "description": "The class representing a Python function.",
    "std_args": [
      "stmt"
    ],
    "type": "function"
  },
  "is_torchelastic_launched": {
    "description": "Check whether this process was launched with ``torch.distributed.elastic`` (aka torchelastic).",
    "std_args": [],
    "type": "function"
  },
  "is_ucc_available": {
    "description": "Check if the UCC backend is available.",
    "std_args": [],
    "type": "function"
  },
  "is_unbacked_symint": {
    "description": "Check if a sympy symbol matches the naming convention for unbacked symbols",
    "std_args": [
      "self",
      "symbol"
    ],
    "type": "function"
  },
  "is_user_annotation": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_vararg": {
    "description": "The class representing a Python function.",
    "std_args": [
      "the_callable"
    ],
    "type": "function"
  },
  "is_view_replay_enabled": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_warn_always_enabled": {
    "description": "Returns True if the global warn_always flag is turned on. Refer to",
    "std_args": [],
    "type": "function"
  },
  "is_xccl_available": {
    "description": "Check if the XCCL backend is available.",
    "std_args": [],
    "type": "function"
  },
  "is_xnnpack_available": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "isend": {
    "description": "Send a tensor asynchronously.",
    "std_args": [
      "tensor",
      "dst",
      "group",
      "tag",
      "group_dst"
    ],
    "type": "function"
  },
  "isinstance": {
    "description": "Provide container type refinement in TorchScript.",
    "std_args": [
      "obj",
      "target_type"
    ],
    "type": "function"
  },
  "ismethod": {
    "description": "Is func a method?",
    "std_args": [
      "func"
    ],
    "type": "function"
  },
  "istft": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "isvar": {
    "description": "The class representing a Python function.",
    "std_args": [
      "o"
    ],
    "type": "function"
  },
  "isvariadic": {
    "description": "Check whether the type `obj` is variadic.",
    "std_args": [
      "obj"
    ],
    "type": "function"
  },
  "itemfilter": {
    "description": "Filter items in dictionary by item",
    "std_args": [
      "predicate",
      "d",
      "factory"
    ],
    "type": "function"
  },
  "itemmap": {
    "description": "Apply function to items of dictionary",
    "std_args": [
      "func",
      "d",
      "factory"
    ],
    "type": "function"
  },
  "items": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "iter": {
    "description": "Called when a proxy object is being iterated over, such as",
    "std_args": [
      "self",
      "obj"
    ],
    "type": "function"
  },
  "iterDP_deprecated_files": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "iterDP_file_path": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "iterDP_files_to_exclude": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "iterDP_method_to_special_output_type": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "iterable": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "iterate": {
    "description": "The class representing a Python function.",
    "std_args": [
      "data"
    ],
    "type": "function"
  },
  "iterate_till_fixed_point": {
    "description": "Transform constraints till reaching a fixed point",
    "std_args": [
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "iters_per_second": {
    "description": "Return total number of iterations per second across all calling threads.",
    "std_args": [],
    "type": "attribute"
  },
  "ivals": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "jacobian": {
    "description": "Compute the Jacobian of a given function.",
    "std_args": [
      "func",
      "inputs",
      "create_graph",
      "strict",
      "vectorize",
      "strategy"
    ],
    "type": "function"
  },
  "jit": {
    "description": "Compiles a function for efficient execution (JIT/Graph mode).",
    "std_args": [
      "func",
      "static_argnums"
    ],
    "variants": {}
  },
  "job_id": {
    "description": "Semantically, this should be an identifier that uniquely identifies, e.g., a",
    "std_args": [],
    "type": "attribute"
  },
  "join": {
    "description": "Join one or more processes within spawn context.",
    "std_args": [
      "self",
      "timeout",
      "grace_period"
    ],
    "type": "function"
  },
  "join_device": {
    "description": "Return default device.",
    "std_args": [],
    "type": "attribute"
  },
  "join_hook": {
    "description": "Return the ZeRO join hook.",
    "std_args": [
      "self",
      "kwargs"
    ],
    "type": "function"
  },
  "join_phase": {
    "description": "We observed a rendezvous state in 'joinable' state, and attempt to join this",
    "std_args": [
      "self",
      "expected_version"
    ],
    "type": "function"
  },
  "join_process_group": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "join_rendezvous": {
    "description": "Helper method for the join phase.",
    "std_args": [
      "self",
      "expected_version"
    ],
    "type": "function"
  },
  "jvp": {
    "description": "Compute the dot product between the Jacobian of the given function at the point given by the inputs and a vector ``v``.",
    "std_args": [
      "func",
      "inputs",
      "v",
      "create_graph",
      "strict"
    ],
    "type": "function"
  },
  "k": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kDLCPU": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kDLCUDA": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kDLCUDAHost": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kDLCUDAManaged": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kDLExtDev": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kDLHexagon": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kDLMAIA": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kDLMetal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kDLOneAPI": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kDLOpenCL": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kDLROCM": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kDLROCMHost": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kDLVPI": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kDLVulkan": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kDLWebGPU": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "k_proj_weight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kaiming_normal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kaiming_normal_": {
    "description": "Fill the input `Tensor` with values using a Kaiming normal distribution.",
    "std_args": [
      "tensor",
      "a",
      "mode",
      "nonlinearity",
      "generator"
    ],
    "type": "function"
  },
  "kaiming_uniform": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kaiming_uniform_": {
    "description": "Fill the input `Tensor` with values using a Kaiming uniform distribution.",
    "std_args": [
      "tensor",
      "a",
      "mode",
      "nonlinearity",
      "generator"
    ],
    "type": "function"
  },
  "kaiser": {
    "description": "The class representing a Python function.",
    "std_args": [
      "M",
      "beta",
      "sym",
      "dtype",
      "layout",
      "device",
      "requires_grad"
    ],
    "type": "function"
  },
  "kdim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "keep_alive_interval": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "keep_alive_max_attempt": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "keep_intermediates": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "keep_key": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "keep_low_precision_grads": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "keep_submodule_prefixes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "keep_tensor_guards_unsafe": {
    "description": "A common function to keep tensor guards on all tensors. This is unsafe to",
    "std_args": [
      "guard_entries",
      "keep_parameters"
    ],
    "type": "function"
  },
  "keepdim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "keepdim_warning": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kernel": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kernel_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kernels": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "key": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "key_averages": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "group_by_input_shape",
      "group_by_stack_n",
      "group_by_overload_name"
    ],
    "type": "function"
  },
  "key_fn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "keyfilter": {
    "description": "Filter items in dictionary by key",
    "std_args": [
      "predicate",
      "d",
      "factory"
    ],
    "type": "function"
  },
  "keymap": {
    "description": "Apply function to keys of dictionary",
    "std_args": [
      "func",
      "d",
      "factory"
    ],
    "type": "function"
  },
  "keyrefs": {
    "description": "Return a list of weak references to the keys.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "keys": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "kind": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kineto_activities": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kineto_results": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kl_based": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kl_based_partition": {
    "description": "This function is a cost aware partition based",
    "std_args": [
      "self",
      "transfer_rate_bytes_per_sec",
      "node_to_latency_mapping"
    ],
    "type": "function"
  },
  "kl_div": {
    "description": "Compute the KL Divergence loss.",
    "std_args": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction",
      "log_target"
    ],
    "type": "function"
  },
  "kl_divergence": {
    "description": "Compute Kullback-Leibler divergence :math:`KL(p \\| q)` between two distributions.",
    "std_args": [
      "p",
      "q"
    ],
    "type": "function"
  },
  "kpack": {
    "description": "ROCm-specific kernel packing parameter.",
    "std_args": [],
    "type": "attribute"
  },
  "kthvalue": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "kv_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kv_num_blocks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kw_only_dataclass": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kwargs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kwinputs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "l1_loss": {
    "description": "Compute the L1 loss, with optional weighting.",
    "std_args": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction",
      "weight"
    ],
    "type": "function"
  },
  "l1_unstructured": {
    "description": "Prune tensor by removing units with the lowest L1-norm.",
    "std_args": [
      "module",
      "name",
      "amount",
      "importance_scores"
    ],
    "type": "function"
  },
  "label": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "label_smoothing": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "laguerre_polynomial_l": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lambd": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lambda_auto_wrap_policy": {
    "description": "A convenient auto wrap policy to wrap submodules based on an arbitrary user",
    "std_args": [
      "module",
      "recurse",
      "nonwrapped_numel",
      "lambda_fn"
    ],
    "type": "function"
  },
  "last_call": {
    "description": "Get the last call timeout.",
    "std_args": [],
    "type": "attribute"
  },
  "last_epoch": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "last_map_location": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "latency_avg_ms": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "launch": {
    "description": "The class representing a Python function.",
    "std_args": [
      "args"
    ],
    "type": "function"
  },
  "launch_agent": {
    "description": "The class representing a Python function.",
    "std_args": [
      "config",
      "entrypoint",
      "args"
    ],
    "type": "function"
  },
  "layer_norm": {
    "description": "Apply Layer Normalization for last certain number of dimensions.",
    "std_args": [
      "input",
      "normalized_shape",
      "weight",
      "bias",
      "eps"
    ],
    "type": "function"
  },
  "layer_norm_functional": {
    "description": "We generate the constraint: input = output",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "layer_norm_inference_rule": {
    "description": "Input and output shapes should be equal.",
    "std_args": [
      "n",
      "module_instance",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "layer_norm_op_dtype_configs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "layers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "layout": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lazy_property": {
    "description": "Used as a decorator for lazy loading of class attributes. This uses a",
    "std_args": [
      "self",
      "wrapped"
    ],
    "type": "class"
  },
  "ldl_factor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ldl_factor_ex": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ldl_solve": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "le": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "function"
  },
  "leaky_relu": {
    "description": "Quantized version of the.",
    "std_args": [
      "input",
      "negative_slope",
      "inplace",
      "scale",
      "zero_point"
    ],
    "type": "function"
  },
  "leaky_relu_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "left": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legacy_contiguous_format": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legalize_graph": {
    "description": "Replace the graph of the given GraphModule with one that contains the same nodes as the",
    "std_args": [
      "gm"
    ],
    "type": "function"
  },
  "legendre_polynomial_p": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "length": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "lengths": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "less_than": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "level": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lhs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lib": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "libc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "library_paths": {
    "description": "Get the library paths required to build a C++ or CUDA extension.",
    "std_args": [
      "device_type"
    ],
    "type": "function"
  },
  "lift_lowering_attrs_to_nodes": {
    "description": "Recursively traverse all `fx_module` nodes and fetch the module's attributes if the node is a leaf module.",
    "std_args": [
      "fx_module"
    ],
    "type": "function"
  },
  "lifted_custom_objs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lifted_tensor_constants": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "limit": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "linear1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "linear2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "linear_K": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "linear_Q": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "linear_V": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "linear_check": {
    "description": "Checks that an input tensor type satisfies the conditions for linear operation",
    "std_args": [
      "tensor_type",
      "module_instance"
    ],
    "type": "function"
  },
  "linear_configs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "linear_constraints": {
    "description": "The class representing a Python function.",
    "std_args": [
      "n",
      "in_features",
      "out_features",
      "symbols",
      "counter"
    ],
    "type": "function"
  },
  "linear_dtype_configs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "linear_inference_rule": {
    "description": "Input and output sizes should be the same except for the last dimension",
    "std_args": [
      "n",
      "module_instance",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "linear_refinement_rule": {
    "description": "The equality constraints are between the first dimension of",
    "std_args": [
      "n"
    ],
    "type": "function"
  },
  "lint": {
    "description": "Runs various checks on this Graph to make sure it is well-formed. In",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "list": {
    "description": "List all callable entrypoints available in the repo specified by ``github``.",
    "std_args": [
      "github",
      "force_reload",
      "skip_validation",
      "trust_repo",
      "verbose"
    ],
    "type": "function"
  },
  "list_backends": {
    "description": "Return valid strings that can be passed to `torch.compile(..., backend=\"name\")`.",
    "std_args": [
      "exclude_tags"
    ],
    "type": "function"
  },
  "list_files": {
    "description": "Given path(s) to the root directory, yields file pathname(s) (path + filename) of files within the root directory.",
    "std_args": [
      "self",
      "masks",
      "recursive",
      "abspath",
      "non_deterministic",
      "length"
    ],
    "type": "function"
  },
  "list_gpu_processes": {
    "description": "Return a human-readable printout of the running processes and their GPU memory use for a given device.",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "ln_structured": {
    "description": "Prune tensor by removing channels with the lowest L\\ ``n``-norm along the specified dimension.",
    "std_args": [
      "module",
      "name",
      "amount",
      "n",
      "dim",
      "importance_scores"
    ],
    "type": "function"
  },
  "load": {
    "description": ".. warning::",
    "std_args": [
      "f",
      "extra_files",
      "expected_opset_version"
    ],
    "type": "function"
  },
  "load_binary": {
    "description": "Load raw bytes.",
    "std_args": [
      "self",
      "package",
      "resource"
    ],
    "type": "function"
  },
  "load_binunicode": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "load_bytes": {
    "description": "Load the item described by ``read_item``and ``value``.",
    "std_args": [
      "self",
      "read_item",
      "value"
    ],
    "type": "function"
  },
  "load_cache_artifacts": {
    "description": "Hot loads cache artifacts that were previously serialized via",
    "std_args": [
      "serialized_artifacts"
    ],
    "type": "function"
  },
  "load_compiled_function": {
    "description": "Load an aot-compiled function from a file.",
    "std_args": [
      "file"
    ],
    "type": "function"
  },
  "load_extra_data": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "rdzv_version",
      "key",
      "timeout"
    ],
    "type": "function"
  },
  "load_graph_and_inputs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ir"
    ],
    "type": "function"
  },
  "load_id": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "load_inline": {
    "description": "Load a PyTorch C++ extension just-in-time (JIT) from string sources.",
    "std_args": [
      "name",
      "cpp_sources",
      "cuda_sources",
      "sycl_sources",
      "functions",
      "extra_cflags",
      "extra_cuda_cflags",
      "extra_sycl_cflags",
      "extra_ldflags",
      "extra_include_paths",
      "build_directory",
      "verbose",
      "with_cuda",
      "with_sycl",
      "is_python_module",
      "with_pytorch_error_handling",
      "keep_intermediates",
      "use_pch",
      "no_implicit_headers"
    ],
    "type": "function"
  },
  "load_nvprof": {
    "description": "Open an nvprof trace file and parses autograd annotations.",
    "std_args": [
      "path"
    ],
    "type": "function"
  },
  "load_observer_state_dict": {
    "description": "Given input model and a state_dict containing model observer stats,",
    "std_args": [
      "mod",
      "obs_dict"
    ],
    "type": "function"
  },
  "load_pickle": {
    "description": "Unpickles the resource from the package, loading any modules that are needed to construct the objects",
    "std_args": [
      "self",
      "package",
      "resource",
      "map_location"
    ],
    "type": "function"
  },
  "load_sharded_optimizer_state_dict": {
    "description": "Load a state_dict in conjunction with FSDP sharded optimizer state.",
    "std_args": [
      "model_state_dict",
      "optimizer_key",
      "storage_reader",
      "planner"
    ],
    "type": "function"
  },
  "load_state_dict": {
    "description": "Copies parameters and buffers from state_dict into this module.",
    "std_args": [
      "state_dict",
      "strict"
    ],
    "variants": {}
  },
  "load_state_dict_from_url": {
    "description": "Loads the Torch serialized object at the given URL.",
    "std_args": [
      "url",
      "model_dir",
      "map_location",
      "progress",
      "check_hash",
      "file_name",
      "weights_only"
    ],
    "type": "function"
  },
  "load_storage": {
    "description": "Loads data from the file into the storage.",
    "std_args": [
      "self",
      "storage",
      "offset"
    ],
    "type": "function"
  },
  "load_text": {
    "description": "Load a string.",
    "std_args": [
      "self",
      "package",
      "resource",
      "encoding",
      "errors"
    ],
    "type": "function"
  },
  "loadmat_kwargs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "loc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "local_addr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "local_id": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "local_rank": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "local_rank_id": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "local_response_norm": {
    "description": "Apply local response normalization over an input signal.",
    "std_args": [
      "input",
      "size",
      "alpha",
      "beta",
      "k"
    ],
    "type": "function"
  },
  "local_world_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "location_tag": {
    "description": "The class representing a Python function.",
    "std_args": [
      "storage"
    ],
    "type": "function"
  },
  "lock_file_path": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "log_abs_det_jacobian": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "x",
      "y"
    ],
    "type": "function"
  },
  "log_cdf": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "value"
    ],
    "type": "function"
  },
  "log_debug_info_for_expired_timers": {
    "description": "The class representing a Python function.",
    "std_args": [
      "run_id",
      "expired_timers"
    ],
    "type": "function"
  },
  "log_dir": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "log_hook": {
    "description": "Logs callable output.",
    "std_args": [
      "fn",
      "level"
    ],
    "type": "function"
  },
  "log_input": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "log_line_prefix_template": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "log_lru_cache_stats": {
    "description": "The class representing a Python function.",
    "std_args": [
      "wrapped_f"
    ],
    "type": "function"
  },
  "log_ndtr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "log_prob": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "value"
    ],
    "type": "function"
  },
  "log_survival_function": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "value"
    ],
    "type": "function"
  },
  "log_target": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "log_url": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "logabsdet": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "logger": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "logical_device_ids": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "logical_id": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "logit": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "logits": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "logits_to_probs": {
    "description": "Converts a tensor of logits into probabilities. Note that for the",
    "std_args": [
      "logits",
      "is_binary"
    ],
    "type": "function"
  },
  "logs_specs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "logsigmoid": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "long": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "lookup_object": {
    "description": "Extension from the planner interface to make it easy to extend the default planner.",
    "std_args": [
      "self",
      "index"
    ],
    "type": "function"
  },
  "lookup_tensor": {
    "description": "Extension from the planner interface to make it easy to extend the default planner.",
    "std_args": [
      "self",
      "index"
    ],
    "type": "function"
  },
  "loop_pass": {
    "description": "Convenience wrapper for passes which need to be applied multiple times.",
    "std_args": [
      "base_pass",
      "n_iter",
      "predicate"
    ],
    "type": "function"
  },
  "loss_output": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "loss_parallel": {
    "description": "A context manager that enables loss parallelism, where efficient parallelized loss computation",
    "std_args": [],
    "type": "function"
  },
  "lower": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lower_cholesky": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lower_pt2e_quantized_to_x86": {
    "description": "Lower a PT2E-qantized model to x86 backend.",
    "std_args": [
      "model",
      "example_inputs"
    ],
    "type": "function"
  },
  "lower_to_fbgemm": {
    "description": "Lower a quantized reference model (with reference quantized operator patterns)",
    "std_args": [
      "model",
      "qconfig_map",
      "node_name_to_scope",
      "keep_original_weights"
    ],
    "type": "function"
  },
  "lower_to_qnnpack": {
    "description": "Lower a quantized reference model (with reference quantized operator patterns)",
    "std_args": [
      "model",
      "qconfig_map",
      "node_name_to_scope"
    ],
    "type": "function"
  },
  "lower_triangular": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lp_pool1d": {
    "description": "Apply a 1D power-average pooling over an input signal composed of several input planes.",
    "std_args": [
      "input",
      "norm_type",
      "kernel_size",
      "stride",
      "ceil_mode"
    ],
    "type": "function"
  },
  "lp_pool2d": {
    "description": "Apply a 2D power-average pooling over an input signal composed of several input planes.",
    "std_args": [
      "input",
      "norm_type",
      "kernel_size",
      "stride",
      "ceil_mode"
    ],
    "type": "function"
  },
  "lp_pool3d": {
    "description": "Apply a 3D power-average pooling over an input signal composed of several input planes.",
    "std_args": [
      "input",
      "norm_type",
      "kernel_size",
      "stride",
      "ceil_mode"
    ],
    "type": "function"
  },
  "lr_lambdas": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lru_cache": {
    "description": "The class representing a Python function.",
    "std_args": [
      "maxsize"
    ],
    "type": "function"
  },
  "ls": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "path"
    ],
    "type": "function"
  },
  "lse": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lshift": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "function"
  },
  "lstsq": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lt": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "function"
  },
  "lt_inference_rule": {
    "description": "The class representing a Python function.",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "lu": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lu_factor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lu_factor_ex": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lu_solve": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lu_unpack": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "m": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "macros": {
    "description": "Defines simple macros for caffe2.distributed.launch cmd args substitution",
    "std_args": [],
    "type": "class"
  },
  "magic_methods": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "magic_methods_on_operator_with_trailing_underscore": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "main": {
    "description": "The class representing a Python function.",
    "std_args": [
      "args"
    ],
    "type": "function"
  },
  "main_hook": {
    "description": "Call this hook while there exists a non-joined process to shadow collective communications in a training iteration.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "make_dual": {
    "description": "Associate a tensor value with its tangent to create a \"dual tensor\" for forward AD gradient computation.",
    "std_args": [
      "tensor",
      "tangent",
      "level"
    ],
    "type": "function"
  },
  "make_fx": {
    "description": "Given a function f, return a new function which when executed with valid",
    "std_args": [
      "f",
      "decomposition_table",
      "tracing_mode",
      "_allow_non_fake_inputs",
      "pre_dispatch",
      "record_module_stack",
      "_allow_fake_constant",
      "_error_on_data_dependent_ops",
      "record_stack_traces"
    ],
    "type": "function"
  },
  "make_graphed_callables": {
    "description": "Accept callables (functions or :class:`nn.Module<torch.nn.Module>`\\ s) and returns graphed versions.",
    "std_args": [
      "callables",
      "sample_args",
      "num_warmup_iters",
      "allow_unused_input",
      "pool"
    ],
    "type": "function"
  },
  "make_histogram": {
    "description": "Convert values into a histogram proto using logic from histogram.cc.",
    "std_args": [
      "values",
      "bins",
      "max_bins"
    ],
    "type": "function"
  },
  "make_image": {
    "description": "Convert a numpy representation of an image to Image protobuf.",
    "std_args": [
      "tensor",
      "rescale",
      "rois",
      "labels"
    ],
    "type": "function"
  },
  "make_set": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "v"
    ],
    "type": "function"
  },
  "make_tensor_from_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "inp_type"
    ],
    "type": "function"
  },
  "make_video": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tensor",
      "fps"
    ],
    "type": "function"
  },
  "makedirs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dn",
      "exist_ok"
    ],
    "type": "function"
  },
  "mantissa": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "manual_meta_overrides": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "manual_seed": {
    "description": "Set the seed for generating random numbers for the current GPU.",
    "std_args": [
      "seed"
    ],
    "type": "function"
  },
  "manual_seed_all": {
    "description": "Set the seed for generating random numbers on all GPUs.",
    "std_args": [
      "seed"
    ],
    "type": "function"
  },
  "map": {
    "description": "Apply the input function over each item from the source DataPipe (functional name: ``map``).",
    "std_args": [
      "self",
      "fn"
    ],
    "type": "function"
  },
  "mapDP_deprecated_files": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mapDP_file_path": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mapDP_files_to_exclude": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mapDP_method_to_special_output_type": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "map_aggregate": {
    "description": "Apply fn recursively to each object appearing in arg.",
    "std_args": [
      "a",
      "fn"
    ],
    "type": "function"
  },
  "map_arg": {
    "description": "Apply fn recursively to each Node appearing in arg.",
    "std_args": [
      "a",
      "fn"
    ],
    "type": "function"
  },
  "map_nodes_to_values": {
    "description": "Recursively descend through ``args`` and look up the concrete value",
    "std_args": [
      "self",
      "args",
      "n"
    ],
    "type": "function"
  },
  "mapping_type": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mappings": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "margin": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "margin_ranking_loss": {
    "description": "Compute the margin ranking loss.",
    "std_args": [
      "input1",
      "input2",
      "target",
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "mark": {
    "description": "Describe an instantaneous event that occurred at some point.",
    "std_args": [
      "msg"
    ],
    "type": "function"
  },
  "mark_dirty": {
    "description": "See :meth:`Function.mark_dirty`.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "mark_non_differentiable": {
    "description": "See :meth:`Function.mark_non_differentiable`.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "mark_shared_storage": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "pairs"
    ],
    "type": "function"
  },
  "mask": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mask_check": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mask_mod": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "masked_fill_inference_rule": {
    "description": "Similar to addition. For now we implement the constraints when",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "masked_select": {
    "description": "Constructs a nested tensor given a strided tensor input and a strided mask, the resulting jagged layout nested tensor",
    "std_args": [
      "tensor",
      "mask"
    ],
    "type": "function"
  },
  "masked_tensor": {
    "description": "The class representing a Python function.",
    "std_args": [
      "data",
      "mask",
      "requires_grad"
    ],
    "type": "function"
  },
  "masks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "master_addr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "master_endpoint": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "master_port": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "match": {
    "description": "Returns:",
    "std_args": [
      "self",
      "graph",
      "node_name_match"
    ],
    "type": "function"
  },
  "match_extensions": {
    "description": "Helper method to see if filename ends with certain extension",
    "std_args": [
      "filename",
      "extensions"
    ],
    "type": "function"
  },
  "match_masks": {
    "description": "The class representing a Python function.",
    "std_args": [
      "name",
      "masks"
    ],
    "type": "function"
  },
  "match_output": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "match_placeholder": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "matched_files_iter": {
    "description": "The class representing a Python function.",
    "std_args": [
      "root_path",
      "includes",
      "ignores",
      "extensions",
      "out_of_place_only",
      "is_pytorch_extension"
    ],
    "type": "function"
  },
  "matches": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "candidate"
    ],
    "type": "function"
  },
  "matches_module_pattern": {
    "description": "The class representing a Python function.",
    "std_args": [
      "pattern",
      "node",
      "modules"
    ],
    "type": "function"
  },
  "matching_constraint": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "materialize": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "materialize_fake_tensors": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "materialize_lines": {
    "description": "The class representing a Python function.",
    "std_args": [
      "lines",
      "indentation"
    ],
    "type": "function"
  },
  "math_op_names": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "math_sdp_enabled": {
    "description": ".. warning:: This flag is beta and subject to change.",
    "std_args": [],
    "type": "function"
  },
  "mathandler": {
    "description": "The class representing a Python function.",
    "std_args": [
      "loadmat_kwargs"
    ],
    "type": "function"
  },
  "matrix_approximation_rank": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "matrix_exp": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "matrix_instr_nonkdim": {
    "description": "ROCm-specific matrix instruction non-K dimension.",
    "std_args": [],
    "type": "attribute"
  },
  "max_buffer_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "max_lrs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "max_memory_allocated": {
    "description": "Return the maximum memory allocated in bytes for a given device.",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "max_memory_cached": {
    "description": "Deprecated; see :func:`~torch.cuda.max_memory_reserved`.",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "max_memory_reserved": {
    "description": "Return the maximum GPU memory managed by the caching allocator in bytes for a given device.",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "max_momentums": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "max_nodes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "max_norm": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "max_pool1d": {
    "description": "Applies a 1D max pooling over a quantized input signal composed of",
    "std_args": [
      "input",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "ceil_mode",
      "return_indices"
    ],
    "type": "function"
  },
  "max_pool1d_with_indices": {
    "description": "max_pool1d(input, kernel_size, stride=None, padding=0, dilation=1, ceil_mode=False, return_indices=False)",
    "std_args": [
      "input",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "ceil_mode",
      "return_indices"
    ],
    "type": "function"
  },
  "max_pool2d": {
    "description": "Applies a 2D max pooling over a quantized input signal composed of",
    "std_args": [
      "input",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "ceil_mode",
      "return_indices"
    ],
    "type": "function"
  },
  "max_pool2d_with_indices": {
    "description": "max_pool2d(input, kernel_size, stride=None, padding=0, dilation=1, ceil_mode=False, return_indices=False)",
    "std_args": [
      "input",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "ceil_mode",
      "return_indices"
    ],
    "type": "function"
  },
  "max_pool3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "max_pool3d_with_indices": {
    "description": "max_pool3d(input, kernel_size, stride=None, padding=0, dilation=1, ceil_mode=False, return_indices=False)",
    "std_args": [
      "input",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "ceil_mode",
      "return_indices"
    ],
    "type": "function"
  },
  "max_queue": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "max_restarts": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "max_scores": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "max_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "max_unpool1d": {
    "description": "Compute a partial inverse of :class:`MaxPool1d`.",
    "std_args": [
      "input",
      "indices",
      "kernel_size",
      "stride",
      "padding",
      "output_size"
    ],
    "type": "function"
  },
  "max_unpool2d": {
    "description": "Compute a partial inverse of :class:`MaxPool2d`.",
    "std_args": [
      "input",
      "indices",
      "kernel_size",
      "stride",
      "padding",
      "output_size"
    ],
    "type": "function"
  },
  "max_unpool3d": {
    "description": "Compute a partial inverse of :class:`MaxPool3d`.",
    "std_args": [
      "input",
      "indices",
      "kernel_size",
      "stride",
      "padding",
      "output_size"
    ],
    "type": "function"
  },
  "max_val": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "maxpool2d_check": {
    "description": "Applies the maxpool2d shape information to the input",
    "std_args": [
      "typ",
      "module_instance"
    ],
    "type": "function"
  },
  "maxpool2d_inference_rule": {
    "description": "Given a MaxPool2D instance and a node check the following conditions:",
    "std_args": [
      "n",
      "module_instance"
    ],
    "type": "function"
  },
  "maxpool_inference_rule": {
    "description": "The class representing a Python function.",
    "std_args": [
      "n",
      "module_instance",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "maxpool_result": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "may_depend_on": {
    "description": "Determine if one node depends on another in a torch.fx.Graph.",
    "std_args": [
      "a",
      "b",
      "search_depth"
    ],
    "type": "function"
  },
  "maybe_add_missing_fqns": {
    "description": "If `fqn` entries are filled in for one of the models in `results`, copies",
    "std_args": [
      "results"
    ],
    "type": "function"
  },
  "maybe_as_bool": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "maybe_as_float": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "maybe_as_int": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "maybe_dequantize_first_two_tensor_args_and_handle_tuples": {
    "description": "The class representing a Python function.",
    "std_args": [
      "f"
    ],
    "type": "function"
  },
  "maybe_disable_thunkify": {
    "description": "Within a context, disable thunkification.  See :func:`maybe_enable_thunkify`",
    "std_args": [],
    "type": "function"
  },
  "maybe_enable_thunkify": {
    "description": "Within this context manager, if you are doing make_fx tracing, we will thunkify",
    "std_args": [],
    "type": "function"
  },
  "maybe_handle_decomp": {
    "description": "The class representing a Python function.",
    "std_args": [
      "proxy_mode",
      "op",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "maybe_increase_iter": {
    "description": "Track iterations and trigger log message at start of local SGD.",
    "std_args": [
      "self",
      "bucket"
    ],
    "type": "function"
  },
  "maybe_temporarily_apply_numa_binding_to_current_thread": {
    "description": "1. Applies NUMA binding to the current thread, suitable for the thread",
    "std_args": [
      "gpu_index",
      "numa_options"
    ],
    "type": "function"
  },
  "median": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "meets_confidence": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "threshold"
    ],
    "type": "function"
  },
  "mem_efficient_sdp_enabled": {
    "description": ".. warning:: This flag is beta and subject to change.",
    "std_args": [],
    "type": "function"
  },
  "mem_get_info": {
    "description": "Return the global free and total GPU memory for a given device using cudaMemGetInfo.",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "mem_latency_sec": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "members": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "memory_allocated": {
    "description": "Return the current MTIA memory occupied by tensors in bytes for a given device.",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "memory_cached": {
    "description": "Deprecated; see :func:`~torch.cuda.memory_reserved`.",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "memory_format": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "memory_reserved": {
    "description": "Return the current GPU memory managed by the caching allocator in bytes for a given device.",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "memory_snapshot": {
    "description": "Return a snapshot of the CUDA memory allocator state across all devices.",
    "std_args": [
      "mempool_id"
    ],
    "type": "function"
  },
  "memory_stats": {
    "description": "Return a dictionary of MTIA memory allocator statistics for a given device.",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "memory_stats_as_nested_dict": {
    "description": "Return the result of :func:`~torch.cuda.memory_stats` as a nested dictionary.",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "memory_summary": {
    "description": "Return a human-readable printout of the current memory allocator statistics for a given device.",
    "std_args": [
      "device",
      "abbreviated"
    ],
    "type": "function"
  },
  "memory_usage": {
    "description": "Return the percent of time over the past sample period during which global (device)",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "merge": {
    "description": "Merge a collection of dictionaries",
    "std_args": [
      "dicts",
      "kwargs"
    ],
    "type": "function"
  },
  "merge_chunks": {
    "description": "Given a list of chunks, merge them into a single value according to",
    "std_args": [
      "chunks",
      "chunk_spec"
    ],
    "type": "function"
  },
  "merge_masks": {
    "description": "Determine mask type and combine masks if necessary.",
    "std_args": [
      "self",
      "attn_mask",
      "key_padding_mask",
      "query"
    ],
    "type": "function"
  },
  "merge_matmul": {
    "description": "A graph transformation that merges matrix multiplication operations that share the same right-hand",
    "std_args": [
      "in_mod"
    ],
    "type": "function"
  },
  "merge_with": {
    "description": "Merge dictionaries and apply function to combined values",
    "std_args": [
      "func",
      "dicts",
      "kwargs"
    ],
    "type": "function"
  },
  "mesh": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mesh_dim_names": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "message": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "meta": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "meta_data": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "meta_t": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "metadata": {
    "description": "Return the metadata.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "metadata_path": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "metal_capture": {
    "description": "Context manager that enables capturing of Metal calls into gputrace",
    "std_args": [
      "fname"
    ],
    "type": "function"
  },
  "method_factory": {
    "description": "The class representing a Python function.",
    "std_args": [
      "method_name",
      "docstring"
    ],
    "type": "function"
  },
  "method_list": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "method_to_operator": {
    "description": "The class representing a Python function.",
    "std_args": [
      "method"
    ],
    "type": "function"
  },
  "metrics_cfg": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mgpu_tune_gemm_in_file": {
    "description": "Process one or more files and distribute work over one or more GPUs.",
    "std_args": [
      "filename_pattern",
      "num_gpus"
    ],
    "type": "function"
  },
  "microbatches_per_round": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "milestones": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "min_compression_rate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "min_lrs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "min_nodes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "min_supported_cpython": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "min_val": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mixed_precision": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mixture_distribution": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mkdir": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "path"
    ],
    "type": "function"
  },
  "mkdtemp": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "mkldnn_map": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mkldnn_supported": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mkldnn_supported_unknown": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mm": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mm_flop": {
    "description": "Count flops for matmul.",
    "std_args": [
      "a_shape",
      "b_shape",
      "args",
      "out_shape",
      "kwargs"
    ],
    "type": "function"
  },
  "mmap": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mmap_flags": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mock": {
    "description": "Replace some required modules with a mock implementation.  Mocked modules will return a fake",
    "std_args": [
      "self",
      "include",
      "exclude",
      "allow_empty"
    ],
    "type": "function"
  },
  "mocked_modules": {
    "description": "Return all modules that are currently mocked.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "mod_0_weight_detach": {
    "description": "The class representing a Python function.",
    "std_args": [
      "mod"
    ],
    "type": "function"
  },
  "mod_tracker": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mod_weight_bias_0": {
    "description": "The class representing a Python function.",
    "std_args": [
      "mod"
    ],
    "type": "function"
  },
  "mod_weight_detach": {
    "description": "The class representing a Python function.",
    "std_args": [
      "mod"
    ],
    "type": "function"
  },
  "mode": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "model_is_exported": {
    "description": "Return True if the `torch.nn.Module` was exported, False otherwise",
    "std_args": [
      "m"
    ],
    "type": "function"
  },
  "modified_bessel_i0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "modified_bessel_i1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "modified_bessel_k0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "modified_bessel_k1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "module_call_graph": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "module_contains_param": {
    "description": "The class representing a Python function.",
    "std_args": [
      "module",
      "parametrization"
    ],
    "type": "function"
  },
  "module_fetch_book": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "module_function_to_aten_operator_type": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "module_name_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "module_name_object_type_order_qconfigs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "module_name_qconfig": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "module_name_qconfigs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "module_name_regex_qconfigs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "module_path": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "module_stack": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "module_to_fqn": {
    "description": "Returns the fqn for a module or None if module not a descendent of model.",
    "std_args": [
      "model",
      "module",
      "prefix"
    ],
    "type": "function"
  },
  "module_type": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "module_type_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "module_type_list": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "module_with_submodules": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "modules": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "modules_to_mkldnn": {
    "description": "For each node, if it's a module that can be preconverted into MKLDNN,",
    "std_args": [
      "nodes",
      "modules"
    ],
    "type": "function"
  },
  "monitor_interval": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "monitored_barrier": {
    "description": "Synchronize processes similar to ``torch.distributed.barrier``, but consider a configurable timeout.",
    "std_args": [
      "group",
      "timeout",
      "wait_all_ranks"
    ],
    "type": "function"
  },
  "move_to_device_pass": {
    "description": "Move the exported program to the given device.",
    "std_args": [
      "ep",
      "location"
    ],
    "type": "function"
  },
  "mse_loss": {
    "description": "Compute the element-wise mean squared error, with optional weighting.",
    "std_args": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction",
      "weight"
    ],
    "type": "function"
  },
  "msg": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mtia": {
    "description": "Move all model parameters and buffers to the MTIA.",
    "std_args": [
      "self",
      "device"
    ],
    "type": "function"
  },
  "mul_scalar": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "x",
      "y"
    ],
    "type": "function"
  },
  "multi_avg_fn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "multi_dot": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "multi_head_attention_forward": {
    "description": "Forward method for MultiHeadAttention.",
    "std_args": [
      "query",
      "key",
      "value",
      "embed_dim_to_check",
      "num_heads",
      "in_proj_weight",
      "in_proj_bias",
      "bias_k",
      "bias_v",
      "add_zero_attn",
      "dropout_p",
      "out_proj_weight",
      "out_proj_bias",
      "training",
      "key_padding_mask",
      "need_weights",
      "attn_mask",
      "use_separate_proj_weight",
      "q_proj_weight",
      "k_proj_weight",
      "v_proj_weight",
      "static_k",
      "static_v",
      "average_attn_weights",
      "is_causal"
    ],
    "type": "function"
  },
  "multi_margin_loss": {
    "description": "Compute the multi margin loss, with optional weighting.",
    "std_args": [
      "input",
      "target",
      "p",
      "margin",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "multigammaln": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "multihead_attn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "multilabel_margin_loss": {
    "description": "Compute the multilabel margin loss.",
    "std_args": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "multilabel_soft_margin_loss": {
    "description": "Compute the multilabel soft margin loss.",
    "std_args": [
      "input",
      "target",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "multiprocessing_context": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mux": {
    "description": "Yields one element at a time from each of the input Iterable DataPipes (functional name: ``mux``).",
    "std_args": [
      "self",
      "datapipes"
    ],
    "type": "function"
  },
  "n": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "n_averaged": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "n_batch": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "n_classes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "n_clusters": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "n_fields": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "n_inputs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "n_local_stages": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "n_outputs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "n_power_iterations": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "n_sequence_fields": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "n_unnamed_fields": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "name": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "name_node_map": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "name_to_node": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "named_buffers": {
    "description": "Returns an iterator over original module buffers, yielding",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "named_children": {
    "description": "Return an iterator over immediate children modules, yielding both the name of the module as well as the module itself.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "named_modules": {
    "description": "Return an iterator over all modules in the network, yielding both the name of the module as well as the module itself.",
    "std_args": [
      "self",
      "memo",
      "prefix",
      "remove_duplicate"
    ],
    "type": "function"
  },
  "named_parameters": {
    "description": "Returns an iterator over original module parameters, yielding",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "names_idx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "namespace": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nanmedian": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "narrow": {
    "description": "Constructs a nested tensor (which might be a view) from :attr:`tensor`, a strided tensor. This follows",
    "std_args": [
      "tensor",
      "dim",
      "start",
      "length",
      "layout"
    ],
    "type": "function"
  },
  "native_channel_shuffle": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nbytes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ndim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ndtr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ndtri": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ne": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "function"
  },
  "negative_slope": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nelement": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "neq_inference_rule": {
    "description": "Translates to inconsistent in gradual types.",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "nested_compile_region": {
    "description": "Tells **``torch.compile``** that the marked set of operations forms a nested",
    "std_args": [
      "fn"
    ],
    "type": "function"
  },
  "nested_int": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "nested_tensor": {
    "description": "Constructs a nested tensor with no autograd history (also known as a \"leaf tensor\", see",
    "std_args": [
      "tensor_list",
      "dtype",
      "layout",
      "device",
      "requires_grad",
      "pin_memory"
    ],
    "type": "function"
  },
  "nested_tensor_from_jagged": {
    "description": "Constructs a jagged layout nested tensor from the given jagged components. The jagged layout",
    "std_args": [
      "values",
      "offsets",
      "lengths",
      "jagged_dim",
      "min_seqlen",
      "max_seqlen"
    ],
    "type": "function"
  },
  "new_graph": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "new_group": {
    "description": "Create a new distributed group.",
    "std_args": [
      "ranks",
      "timeout",
      "backend",
      "pg_options",
      "use_local_synchronization",
      "group_desc",
      "device_id"
    ],
    "type": "function"
  },
  "new_method": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "new_subgroups": {
    "description": "Create subgroups of equal size.",
    "std_args": [
      "group_size",
      "group",
      "timeout",
      "backend",
      "pg_options",
      "group_desc"
    ],
    "type": "function"
  },
  "new_subgroups_by_enumeration": {
    "description": "Create subgroups by dividing the global world.",
    "std_args": [
      "ranks_per_subgroup_list",
      "timeout",
      "backend",
      "pg_options",
      "group_desc"
    ],
    "type": "function"
  },
  "next": {
    "description": "Returns the next ``Node`` in the linked list of Nodes.",
    "std_args": [],
    "type": "attribute"
  },
  "next_functions": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "next_id": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "next_rendezvous": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "next_stats_report": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nhead": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nll_loss": {
    "description": "Compute the negative log likelihood loss.",
    "std_args": [
      "input",
      "target",
      "weight",
      "size_average",
      "ignore_index",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "nn_layernorm_override": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "input"
    ],
    "type": "function"
  },
  "no_broadcast_dim_with_index": {
    "description": "Args:",
    "std_args": [
      "d1",
      "d2",
      "d3",
      "d4",
      "i"
    ],
    "type": "function"
  },
  "no_default": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "no_fuser": {
    "description": "The class representing a Python function.",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "no_grad": {
    "description": "Context-manager that disabled gradient calculation.",
    "std_args": [],
    "variants": {}
  },
  "no_observer_set": {
    "description": "These modules cannot have observers inserted by default.",
    "std_args": [],
    "type": "function"
  },
  "no_python_abi_suffix": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "no_sync": {
    "description": "Disable gradient synchronizations across FSDP instances.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "node": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "node_arg_is_bias": {
    "description": "Returns if node arg is bias",
    "std_args": [
      "node",
      "arg"
    ],
    "type": "function"
  },
  "node_arg_is_weight": {
    "description": "Returns if node arg is weight",
    "std_args": [
      "node",
      "arg"
    ],
    "type": "function"
  },
  "node_copy": {
    "description": "Copy a node from one graph into another. ``arg_transform`` needs to transform arguments from",
    "std_args": [
      "self",
      "node",
      "arg_transform"
    ],
    "type": "function"
  },
  "node_events": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "node_id": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "node_info": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "node_map": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "node_name_to_qconfig": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "node_name_to_scope": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "node_names": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "node_pattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "node_start_tokens": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "node_state": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "node_to_latency_mapping": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "node_to_partition": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "node_to_partition_mapping": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nodes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nodes_map": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nodes_need_process": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "non_acc_submodule_prefix": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "non_compute_ops": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "non_deterministic": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "non_persistent_buffers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "non_traceable_module_classes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "non_traceable_module_names": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nonlinearity": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nonnegative": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nonnegative_integer": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "noop_context_fn": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "noop_hook": {
    "description": "Return a future that wraps the input, so it is a no-op that does not incur any communication overheads.",
    "std_args": [
      "_",
      "bucket"
    ],
    "type": "function"
  },
  "noop_mask": {
    "description": "Returns a noop mask_mod",
    "std_args": [
      "batch",
      "head",
      "token_q",
      "token_kv"
    ],
    "type": "function"
  },
  "norm": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "norm1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "norm2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "norm3": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "norm_first": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "norm_fn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "norm_type": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "normal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "normal_": {
    "description": "Fill the input Tensor with values drawn from the normal distribution.",
    "std_args": [
      "tensor",
      "mean",
      "std",
      "generator"
    ],
    "type": "function"
  },
  "normalize_function": {
    "description": "Returns normalized arguments to PyTorch functions. This means that",
    "std_args": [
      "target",
      "args",
      "kwargs",
      "arg_types",
      "kwarg_types",
      "normalize_to_only_use_kwargs"
    ],
    "type": "function"
  },
  "normalize_storage_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "storage_type"
    ],
    "type": "function"
  },
  "normalize_to_only_use_kwargs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "normalize_tuple": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "normalized_arguments": {
    "description": "Returns normalized arguments to Python targets. This means that",
    "std_args": [
      "self",
      "root",
      "arg_types",
      "kwarg_types",
      "normalize_to_only_use_kwargs"
    ],
    "type": "function"
  },
  "normalized_shape": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "not_implemented_log": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "notify_join_context": {
    "description": "Notifies the join context manager that the calling process has not yet joined.",
    "std_args": [
      "joinable"
    ],
    "type": "function"
  },
  "nproc_per_node": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nprocs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ns": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ntensors": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "null_ctx_type": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_benchmarks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_channels": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_embeddings": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_generated": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_groups": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_heads": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_iters": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_layers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_nodes_waiting": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "num_of_instances": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_parameters": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_replicas": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_samples": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_stages": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_tensor_args": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_threads": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_warps": {
    "description": "Number of warps to use in the CUDA kernel. Higher values may improve performance",
    "std_args": [],
    "type": "attribute"
  },
  "num_workers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "numa_options": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "number_of_rounds": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "number_per_run": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "numel": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "nuttall": {
    "description": "The class representing a Python function.",
    "std_args": [
      "M",
      "sym",
      "dtype",
      "layout",
      "device",
      "requires_grad"
    ],
    "type": "function"
  },
  "object_type_qconfigs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "observation_type": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "observed_node_names": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "observed_to_quantized_mapping": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "observer_enabled": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "observer_or_fake_quant_ctr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "offload_params": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "offload_to_cpu": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "offset": {
    "description": "If the object is a tensor, offset into the tensor we're looking for",
    "std_args": [],
    "type": "attribute"
  },
  "offsets": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ogate_cy": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "old_flags": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "on_generate_code": {
    "description": "Register a transformer function when python code is generated",
    "std_args": [
      "self",
      "make_transformer"
    ],
    "type": "function"
  },
  "on_trace_ready": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "once_differentiable": {
    "description": "The class representing a Python function.",
    "std_args": [
      "fn"
    ],
    "type": "function"
  },
  "one_hot": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "onednn_dynamic_int8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "onednn_fusion_enabled": {
    "description": "Return whether onednn JIT fusion is enabled.",
    "std_args": [],
    "type": "function"
  },
  "onednn_input_output_only_quint8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "onednn_op_quint8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "onednn_weight_only_qint8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "onednn_weighted_op_int8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ones_": {
    "description": "Fill the input Tensor with the scalar value `1`.",
    "std_args": [
      "tensor"
    ],
    "type": "function"
  },
  "only_bool_magic_methods": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "only_float_magic_methods": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "op": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "op_add": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "op_consistency": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "op_div": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "op_eq": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "op_gt": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "op_imp": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "op_is_int8_dynamically_quantized": {
    "description": "Given a qconfig, returns True if this op is using int8 dynamic",
    "std_args": [
      "qconfig"
    ],
    "type": "function"
  },
  "op_leq": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "op_lt": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "op_matching": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "op_mod": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "op_mul": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "op_neq": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "op_precision": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "op_sub": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "op_type_supports_shadowing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "node"
    ],
    "type": "function"
  },
  "opcheck": {
    "description": "Given an operator and some sample arguments, tests if the operator is",
    "std_args": [
      "op",
      "args",
      "kwargs",
      "test_utils",
      "raise_exception",
      "atol",
      "rtol"
    ],
    "type": "function"
  },
  "open": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "fn",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "open_files": {
    "description": "Given pathnames, opens files and yield pathname and file stream in a tuple (functional name: ``open_files``).",
    "std_args": [
      "self",
      "mode",
      "encoding",
      "length"
    ],
    "type": "function"
  },
  "openf": {
    "description": "The class representing a Python function.",
    "std_args": [
      "filename",
      "mode"
    ],
    "type": "function"
  },
  "operator_support": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "operator_type_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "operator_type_qconfig": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "operators": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "optim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "optim_state_dict": {
    "description": "Transform the state-dict of an optimizer corresponding to a sharded model.",
    "std_args": [
      "model",
      "optim",
      "optim_state_dict",
      "group"
    ],
    "type": "function"
  },
  "optim_state_dict_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "optim_state_dict_to_load": {
    "description": "Convert an optimizer state-dict so that it can be loaded into the optimizer associated with the FSDP model.",
    "std_args": [
      "model",
      "optim",
      "optim_state_dict",
      "is_named_optimizer",
      "load_directly",
      "group"
    ],
    "type": "function"
  },
  "optimize_for_inference": {
    "description": "Performs a set of optimization passes to optimize a model for the",
    "std_args": [
      "model",
      "pass_config",
      "tracer"
    ],
    "type": "function"
  },
  "optimize_for_mobile": {
    "description": "Optimize a torch script module for mobile deployment.",
    "std_args": [
      "script_module",
      "optimization_blocklist",
      "preserved_methods",
      "backend"
    ],
    "type": "function"
  },
  "optimizer": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "optional_min": {
    "description": "The class representing a Python function.",
    "std_args": [
      "seq"
    ],
    "type": "function"
  },
  "or_": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "function"
  },
  "or_masks": {
    "description": "Returns a mask_mod that's the union of provided mask_mods",
    "std_args": [
      "mask_mods"
    ],
    "type": "function"
  },
  "order": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ordered_unique": {
    "description": "The class representing a Python function.",
    "std_args": [
      "elements"
    ],
    "type": "function"
  },
  "ordering": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "orig_inputs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "orig_outputs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "original": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "original_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "original_state_dict": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "orthogonal": {
    "description": "Apply an orthogonal or unitary parametrization to a matrix or a batch of matrices.",
    "std_args": [
      "module",
      "name",
      "orthogonal_map",
      "use_trivialization"
    ],
    "type": "function"
  },
  "orthogonal_": {
    "description": "Fill the input `Tensor` with a (semi) orthogonal matrix.",
    "std_args": [
      "tensor",
      "gain",
      "generator"
    ],
    "type": "function"
  },
  "orthogonalization_epsilon": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "out_channels": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "out_features": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "out_proj": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "out_shape": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "out_spec": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_activation": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_col": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_device": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_dtype_with_constraints": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_file_path": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_file_path_observer": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_gate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_layouts": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_node": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "output_nodes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_nr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_qspec": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_quantized_indexes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_ratio": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_scale": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_specs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_tensors_index": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_tokens": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_var": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_zero_point": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "outputs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "outputs_grad": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "overall_latency_sec": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "overload_name": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "override_error_code_in_rootcause_data": {
    "description": "Modify the rootcause_error read from the file, to correctly set the exit code.",
    "std_args": [
      "self",
      "rootcause_error_file",
      "rootcause_error",
      "error_code"
    ],
    "type": "function"
  },
  "ownership_token": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "p": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "p_memory_dict": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pack_hook": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pack_padded_sequence": {
    "description": "Packs a Tensor containing padded sequences of variable length.",
    "std_args": [
      "input",
      "lengths",
      "batch_first",
      "enforce_sorted"
    ],
    "type": "function"
  },
  "pack_sequence": {
    "description": "Packs a list of variable length Tensors.",
    "std_args": [
      "sequences",
      "enforce_sorted"
    ],
    "type": "function"
  },
  "pack_weight_bias": {
    "description": "The class representing a Python function.",
    "std_args": [
      "qweight",
      "bias",
      "dtype"
    ],
    "type": "function"
  },
  "packed": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "packed_t": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pad_packed_sequence": {
    "description": "Pad a packed batch of variable length sequences.",
    "std_args": [
      "sequence",
      "batch_first",
      "padding_value",
      "total_length"
    ],
    "type": "function"
  },
  "pad_sequence": {
    "description": "Pad a list of variable length Tensors with :attr:`padding_value`.",
    "std_args": [
      "sequences",
      "batch_first",
      "padding_value",
      "padding_side"
    ],
    "type": "function"
  },
  "padding": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "padding_idx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pairwise_distance": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "parallel_apply": {
    "description": "Apply each `module` in :attr:`modules` in parallel on each of :attr:`devices`.",
    "std_args": [
      "modules",
      "inputs",
      "kwargs_tup",
      "devices"
    ],
    "type": "function"
  },
  "param_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "param_groups": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "param_shape": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "param_to_acc_grad_map": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "param_to_optim_hook_handle_map": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "parameters": {
    "description": "Returns an iterator over module parameters.",
    "std_args": [
      "recurse"
    ],
    "variants": {}
  },
  "parameters_as_bucket_view": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "parameters_to_ignore": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "parameters_to_mutate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "parameters_to_vector": {
    "description": "Flatten an iterable of parameters into a single vector.",
    "std_args": [
      "parameters"
    ],
    "type": "function"
  },
  "params": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "parent": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "parent_stream": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "parents": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "parse_args": {
    "description": "The class representing a Python function.",
    "std_args": [
      "args"
    ],
    "type": "function"
  },
  "parse_datapipe_file": {
    "description": "Given a path to file, parses the file and returns a dictionary of method names to function signatures.",
    "std_args": [
      "file_path"
    ],
    "type": "function"
  },
  "parse_datapipe_files": {
    "description": "The class representing a Python function.",
    "std_args": [
      "file_paths"
    ],
    "type": "function"
  },
  "parse_min_max_nnodes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "nnodes"
    ],
    "type": "function"
  },
  "parse_nvprof_trace": {
    "description": "The class representing a Python function.",
    "std_args": [
      "path"
    ],
    "type": "function"
  },
  "parse_rendezvous_endpoint": {
    "description": "Extract the hostname and the port number from a rendezvous endpoint.",
    "std_args": [
      "endpoint",
      "default_port"
    ],
    "type": "function"
  },
  "parse_type_line": {
    "description": "Parse a type annotation specified as a comment.",
    "std_args": [
      "type_line",
      "rcb",
      "loc"
    ],
    "type": "function"
  },
  "parser": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "partition_and_fuse": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "prefix"
    ],
    "type": "function"
  },
  "partition_cudagraphs": {
    "description": "Partition an FX graph into sub-GraphModules that can be validly run under",
    "std_args": [
      "gm",
      "inputs"
    ],
    "type": "function"
  },
  "partition_graph": {
    "description": "Given the fx module, torch module and partitioner_config,",
    "std_args": [
      "self",
      "fx_module",
      "torch_module",
      "partitioner_config"
    ],
    "type": "function"
  },
  "partition_id": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "partition_to_logical_device_mapping": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "partitions": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "parts": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pass_name": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pass_result_wrapper": {
    "description": "Wrapper for passes which currently do not return a PassResult.",
    "std_args": [
      "fn"
    ],
    "type": "function"
  },
  "passes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "passname": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "patch_source_specialization": {
    "description": "Temporarily add symbol-level axioms to the ShapeEnv. This is useful when you want to \"fork\"",
    "std_args": [
      "self",
      "source",
      "check_fn"
    ],
    "type": "function"
  },
  "patched_builtins": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "path": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "patience": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pattern_anchors": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pattern_placeholder_nodes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pattern_returning_nodes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pattern_to_human_readable": {
    "description": "The class representing a Python function.",
    "std_args": [
      "p"
    ],
    "type": "function"
  },
  "patterns": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "payload": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pdist": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "peer": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "per_channel_dynamic_qconfig": {
    "description": "Dynamic qconfig with weights quantized per channel.",
    "std_args": [],
    "type": "attribute"
  },
  "per_channel_weight_observer_range_neg_127_to_127": {
    "description": "Per-channel, symmetric weight observer with the 8-bit values restricted to [-127, +127], excluding -128.",
    "std_args": [],
    "type": "attribute"
  },
  "period": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "period_process_group_dict": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "permute_dims": {
    "description": "Permutes the dimensions of the input.",
    "std_args": [
      "x",
      "axes"
    ],
    "variants": {}
  },
  "permute_hidden": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "hx",
      "permutation"
    ],
    "type": "function"
  },
  "perplexity": {
    "description": "Returns perplexity of distribution, batched over batch_shape.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "persistent": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "persistent_load": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "pid"
    ],
    "type": "function"
  },
  "persistent_workers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pgo_extra_read_key": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pgo_extra_write_key": {
    "description": "Additional read/write keys for PGO.",
    "std_args": [],
    "type": "attribute"
  },
  "phantom_symbols": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pickle_storage_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "pid": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pids": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "pin_memory": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pin_memory_device": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pipeline_order": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pixel_shuffle": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pixel_unshuffle": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "placeholder": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "target",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "placeholder_nodes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "planner_data": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "poisson_nll_loss": {
    "description": "Compute the Poisson negative log likelihood loss.",
    "std_args": [
      "input",
      "target",
      "log_input",
      "full",
      "size_average",
      "eps",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "polygamma": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pool": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pop": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "popitem": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "populate_rows_and_columns": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "pos": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "pos_weight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "positive_definite": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "positive_integer": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "positive_semidefinite": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "post_hook": {
    "description": "Call hook after all processes have joined.",
    "std_args": [
      "self",
      "is_last_joiner"
    ],
    "type": "function"
  },
  "post_localSGD_hook": {
    "description": "Run post-localSGD algorithm.",
    "std_args": [
      "state",
      "bucket"
    ],
    "type": "function"
  },
  "post_local_gradient_allreduce": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "post_unflatten_transform": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tensor",
      "param_extension"
    ],
    "type": "function"
  },
  "pow_by_natural": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "function"
  },
  "power": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "powerSGD_hook": {
    "description": "Implement PowerSGD algorithm.",
    "std_args": [
      "state",
      "bucket"
    ],
    "type": "function"
  },
  "power_draw": {
    "description": "Return the average power draw of the GPU sensor in mW (MilliWatts)",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "power_range": {
    "description": "The class representing a Python function.",
    "std_args": [
      "upper_bound",
      "base"
    ],
    "type": "function"
  },
  "pp_format": {
    "description": "The class representing a Python function.",
    "std_args": [
      "printer",
      "obj",
      "stream",
      "indent",
      "allowance",
      "context",
      "level"
    ],
    "type": "function"
  },
  "pp_group_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pr_curve": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tag",
      "labels",
      "predictions",
      "num_thresholds",
      "weights"
    ],
    "type": "function"
  },
  "pr_curve_raw": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tag",
      "tp",
      "fp",
      "tn",
      "fn",
      "precision",
      "recall",
      "num_thresholds",
      "weights"
    ],
    "type": "function"
  },
  "pre_dispatch": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pre_flatten_transform": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tensor"
    ],
    "type": "function"
  },
  "pre_load_state_dict_transform": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tensor"
    ],
    "type": "function"
  },
  "precision_matrix": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "predict": {
    "description": "Return the class with the highest probability for each example in the input minibatch.",
    "std_args": [
      "self",
      "input"
    ],
    "type": "function"
  },
  "prefer_deferred_runtime_asserts_over_guards": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "preferred_blas_library": {
    "description": "Override the library PyTorch uses for BLAS operations. Choose between cuBLAS, cuBLASLt, and CK [ROCm-only].",
    "std_args": [
      "backend"
    ],
    "type": "function"
  },
  "preferred_linalg_library": {
    "description": "Override the heuristic PyTorch uses to choose between cuSOLVER and MAGMA for CUDA linear algebra operations.",
    "std_args": [
      "backend"
    ],
    "type": "function"
  },
  "preferred_rocm_fa_library": {
    "description": "[ROCm-only]",
    "std_args": [
      "backend"
    ],
    "type": "function"
  },
  "prefetch_factor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "prefix": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "prepare": {
    "description": "Prepares a model, by adding the parametrizations.",
    "std_args": [
      "self",
      "model",
      "config"
    ],
    "type": "function"
  },
  "prepare_custom_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "prepare_dynamic_jit": {
    "description": "The class representing a Python function.",
    "std_args": [
      "model",
      "qconfig_dict",
      "inplace"
    ],
    "type": "function"
  },
  "prepare_fx": {
    "description": "Prepare a model for post training quantization",
    "std_args": [
      "model",
      "qconfig_mapping",
      "example_inputs",
      "prepare_custom_config",
      "_equalization_config",
      "backend_config"
    ],
    "type": "function"
  },
  "prepare_global_plan": {
    "description": "Implementation of the StorageReader method",
    "std_args": [
      "self",
      "global_plan"
    ],
    "type": "function"
  },
  "prepare_jit": {
    "description": "The class representing a Python function.",
    "std_args": [
      "model",
      "qconfig_dict",
      "inplace"
    ],
    "type": "function"
  },
  "prepare_local_plan": {
    "description": "Implementation of the StorageReader method",
    "std_args": [
      "self",
      "plan"
    ],
    "type": "function"
  },
  "prepare_module_input": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "prepare_module_output": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "prepare_obs_or_fq_callback": {
    "description": "A callback that will be called after the observers or fake quants are created",
    "std_args": [
      "self",
      "model",
      "edge_or_node_to_obs_or_fq"
    ],
    "type": "function"
  },
  "prepare_pt2e": {
    "description": "Prepare a model for post training quantization",
    "std_args": [
      "model",
      "quantizer"
    ],
    "type": "function"
  },
  "prepare_qat": {
    "description": "Prepares a copy of the model for quantization calibration or",
    "std_args": [
      "model",
      "mapping",
      "inplace"
    ],
    "type": "function"
  },
  "prepare_qat_fx": {
    "description": "Prepare a model for quantization aware training",
    "std_args": [
      "model",
      "qconfig_mapping",
      "example_inputs",
      "prepare_custom_config",
      "backend_config"
    ],
    "type": "function"
  },
  "prepare_qat_pt2e": {
    "description": "Prepare a model for quantization aware training",
    "std_args": [
      "model",
      "quantizer"
    ],
    "type": "function"
  },
  "prepend": {
    "description": "Insert x before this node in the list of nodes in the graph. Example::",
    "std_args": [
      "self",
      "x"
    ],
    "type": "function"
  },
  "preprocess_file_and_save_result": {
    "description": "The class representing a Python function.",
    "std_args": [
      "output_directory",
      "filepath",
      "all_files",
      "header_include_dirs",
      "stats",
      "hip_clang_launch",
      "is_pytorch_extension",
      "clean_ctx",
      "show_progress"
    ],
    "type": "function"
  },
  "preprocessor": {
    "description": "Executes the CUDA -> HIP conversion on the specified file.",
    "std_args": [
      "output_directory",
      "filepath",
      "all_files",
      "header_include_dirs",
      "stats",
      "hip_clang_launch",
      "is_pytorch_extension",
      "clean_ctx",
      "show_progress"
    ],
    "type": "function"
  },
  "preserve_node_meta": {
    "description": "The class representing a Python function.",
    "std_args": [
      "enable"
    ],
    "type": "function"
  },
  "preserve_zero": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "preserved_attr_names": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "preserved_attributes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "prettify_results": {
    "description": "Format a message for constraint violation errors",
    "std_args": [
      "self",
      "original_signature",
      "dynamic_shapes",
      "constraint_violation_error",
      "forced_specializations"
    ],
    "type": "function"
  },
  "pretty_node_names": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pretty_str": {
    "description": "The class representing a Python function.",
    "std_args": [
      "envinfo"
    ],
    "type": "function"
  },
  "prev": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "prev_check_nan": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "prev_col_block_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "prev_idx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "prev_row_block_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "prev_stream": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "prim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "primal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "print": {
    "description": "Print formatted table",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "print_all": {
    "description": "Print all nodes in a list.",
    "std_args": [
      "self",
      "writer"
    ],
    "type": "function"
  },
  "print_n_shadows_summary": {
    "description": "Input:",
    "std_args": [
      "results_comparison"
    ],
    "type": "function"
  },
  "print_node": {
    "description": "Print a node and its events.",
    "std_args": [
      "self",
      "node_name",
      "recursive",
      "tab",
      "writer"
    ],
    "type": "function"
  },
  "print_readable": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "indent"
    ],
    "type": "function"
  },
  "print_sl": {
    "description": "Display the current sparsity level.",
    "std_args": [
      "self",
      "is_verbose",
      "group",
      "sl",
      "epoch"
    ],
    "type": "function"
  },
  "print_source": {
    "description": "Convert a source object to its string representation using the source_ref function.",
    "std_args": [
      "self",
      "source"
    ],
    "type": "function"
  },
  "print_tabular": {
    "description": "Prints the intermediate representation of the graph in tabular",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "priv_sym_name": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "priv_sympy_name": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "probs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "probs_to_logits": {
    "description": "Converts a tensor of probabilities into logits. For the binary case,",
    "std_args": [
      "probs",
      "is_binary"
    ],
    "type": "function"
  },
  "proc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "proceed_signal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "processKernelLaunches": {
    "description": "Replace the CUDA style Kernel launches with the HIP style kernel launches.",
    "std_args": [
      "string",
      "stats"
    ],
    "type": "function"
  },
  "process_forward_inputs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "process_group": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "process_inputs": {
    "description": "Processes args so that they can be passed to the FX graph.",
    "std_args": [
      "self",
      "args"
    ],
    "type": "function"
  },
  "process_outputs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "out"
    ],
    "type": "function"
  },
  "process_signature": {
    "description": "Clean up a given raw function signature.",
    "std_args": [
      "line"
    ],
    "type": "function"
  },
  "processes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "produce_guards": {
    "description": "Like produce_guards_verbose, but only returns the non-verbose python guard expressions",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "produce_guards_expression": {
    "description": "Expected to be used with evaluate_guards_expression(). Produces the guards",
    "std_args": [
      "self",
      "placeholders",
      "guards",
      "ignore_static"
    ],
    "type": "function"
  },
  "produce_guards_verbose": {
    "description": "Generates a list of guards strings which, when evaluated in a context that",
    "std_args": [
      "self",
      "placeholders",
      "sources",
      "source_ref",
      "guards",
      "input_contexts",
      "equalities_inputs",
      "_simplified",
      "ignore_static",
      "langs"
    ],
    "type": "function"
  },
  "producer_name": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "producer_version": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "products": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "prof": {
    "description": "@profile decorator publishes duration.ms, count, success, failure metrics for the function that it decorates.",
    "std_args": [
      "fn",
      "group"
    ],
    "type": "function"
  },
  "profile": {
    "description": "Context manager that manages autograd profiler state and holds a summary of results.",
    "std_args": [
      "self",
      "enabled",
      "use_cuda",
      "use_device",
      "record_shapes",
      "with_flops",
      "profile_memory",
      "with_stack",
      "with_modules",
      "use_kineto",
      "use_cpu",
      "experimental_config",
      "acc_events",
      "custom_trace_id_callback"
    ],
    "type": "class"
  },
  "profile_hook_step": {
    "description": "The class representing a Python function.",
    "std_args": [
      "func"
    ],
    "type": "function"
  },
  "profile_memory": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "profiler_kind": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "profiling_end_time_ns": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "profiling_start_time_ns": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "proj_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "propagate": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "args"
    ],
    "type": "function"
  },
  "propagate_annotation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "model"
    ],
    "type": "function"
  },
  "propagate_dont_convert_inputs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "args"
    ],
    "type": "function"
  },
  "propagate_dtypes_for_known_nodes": {
    "description": "Currently we assume that inputs to the graph are either `torch.float` or",
    "std_args": [
      "graph",
      "node_name_to_match_result_with_qconfig"
    ],
    "type": "function"
  },
  "propagate_qconfig_": {
    "description": "Propagate qconfig through the module hierarchy and assign `qconfig`",
    "std_args": [
      "module",
      "qconfig_dict",
      "prepare_custom_config_dict"
    ],
    "type": "function"
  },
  "propagation_quantizable_ops": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "properties": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "propose_partitions": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "proxy": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "node"
    ],
    "type": "function"
  },
  "proxy_buffer_attributes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "proxy_call": {
    "description": "The class representing a Python function.",
    "std_args": [
      "proxy_mode",
      "func",
      "pre_dispatch",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "proxy_slot": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "proxys_to_metas": {
    "description": "The class representing a Python function.",
    "std_args": [
      "v"
    ],
    "type": "function"
  },
  "prune": {
    "description": "Compute and returns a pruned version of input tensor ``t``.",
    "std_args": [
      "self",
      "t",
      "default_mask",
      "importance_scores"
    ],
    "type": "function"
  },
  "prune_dense_static_sort": {
    "description": "This function does the same thing as described in SparseSemiStructuredCUTLASS, but uses the cuSPASRELt metadata",
    "std_args": [
      "cls",
      "original_tensor",
      "algorithm"
    ],
    "type": "function"
  },
  "pruned_weights": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "psi": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "publish_metric": {
    "description": "The class representing a Python function.",
    "std_args": [
      "metric_group",
      "metric_name",
      "metric_value"
    ],
    "type": "function"
  },
  "purge_step": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "push": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "put_metric": {
    "description": "Publish a metric data point.",
    "std_args": [
      "metric_name",
      "metric_value",
      "metric_group"
    ],
    "type": "function"
  },
  "py_sym_types": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "python_code": {
    "description": "Turn this ``Graph`` into valid Python code.",
    "std_args": [
      "self",
      "root_module",
      "verbose",
      "include_stride",
      "include_device",
      "colored",
      "expanded_def"
    ],
    "type": "function"
  },
  "python_version": {
    "description": "Returns the version of python that was used to create this package.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "pytree_register_structseq": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls"
    ],
    "type": "function"
  },
  "pytype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "q_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "q_memory_dict": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "q_num_blocks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "q_proj_weight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "q_scaling_product": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "qconfig": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "qconfig_equals": {
    "description": "Returns `True` if `q1` equals `q2`, and `False` otherwise.",
    "std_args": [
      "q1",
      "q2"
    ],
    "type": "function"
  },
  "qconfig_mapping": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "qconfig_mappings_list": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "qnnpack_act_qint8_scale_min_2_neg_12": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "qnnpack_default_dynamic_float16_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "qnnpack_default_dynamic_int8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "qnnpack_default_op_fp16_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "qnnpack_default_op_qint8_symmetric_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "qnnpack_default_op_quint8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "qnnpack_weight_only_quint4x2_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "qnnpack_weight_only_quint8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "qnnpack_weight_qint8_neg_127_to_127_scale_min_2_neg_12": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "qnnpack_weighted_op_qint8_symmetric_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "qnnpack_weighted_op_quint8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "qparams": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "qscheme": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "quant": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "quant_attn_output": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "quant_attn_output_weights": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "quant_max": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "quant_max_upper_bound": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "quant_min": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "quant_min_lower_bound": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "quantizable_ops": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "quantization_perchannel_hook": {
    "description": "Apply``torch.quantize_per_channel`` logic to DDP using ``allgather`` protocol.",
    "std_args": [
      "process_group",
      "bucket",
      "bucket_size"
    ],
    "type": "function"
  },
  "quantization_pertensor_hook": {
    "description": "Apply ``torch.quantize_per_tensor`` logic to DDP using ``allgather`` protocol.",
    "std_args": [
      "process_group",
      "bucket"
    ],
    "type": "function"
  },
  "quantize": {
    "description": "Quantize the input float model with post training static quantization.",
    "std_args": [
      "model",
      "run_fn",
      "run_args",
      "mapping",
      "inplace"
    ],
    "type": "function"
  },
  "quantize_dynamic": {
    "description": "Converts a float model to dynamic (i.e. weights-only) quantized model.",
    "std_args": [
      "model",
      "qconfig_spec",
      "dtype",
      "mapping",
      "inplace"
    ],
    "type": "function"
  },
  "quantize_dynamic_jit": {
    "description": "Quantize the input float TorchScript model with",
    "std_args": [
      "model",
      "qconfig_dict",
      "inplace",
      "debug"
    ],
    "type": "function"
  },
  "quantize_jit": {
    "description": "Quantize the input float TorchScript model with",
    "std_args": [
      "model",
      "qconfig_dict",
      "run_fn",
      "run_args",
      "inplace",
      "debug"
    ],
    "type": "function"
  },
  "quantize_linear_modules": {
    "description": "The class representing a Python function.",
    "std_args": [
      "module",
      "dtype"
    ],
    "type": "function"
  },
  "quantize_qat": {
    "description": "Do quantization aware training and output a quantized model",
    "std_args": [
      "model",
      "run_fn",
      "run_args",
      "inplace"
    ],
    "type": "function"
  },
  "quantize_rnn_cell_modules": {
    "description": "The class representing a Python function.",
    "std_args": [
      "module"
    ],
    "type": "function"
  },
  "quantize_rnn_modules": {
    "description": "The class representing a Python function.",
    "std_args": [
      "module",
      "dtype"
    ],
    "type": "function"
  },
  "quantized_gru": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "quantized_lstm": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "quantizers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "quasi": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "query": {
    "description": "Check if all work currently captured by event has completed.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "quote": {
    "description": "Escape a char for regex.",
    "std_args": [
      "self",
      "char"
    ],
    "type": "function"
  },
  "radam": {
    "description": "Functional API that performs RAdam algorithm computation.",
    "std_args": [
      "params",
      "grads",
      "exp_avgs",
      "exp_avg_sqs",
      "state_steps",
      "decoupled_weight_decay",
      "foreach",
      "differentiable",
      "capturable",
      "has_complex",
      "maximize",
      "beta1",
      "beta2",
      "lr",
      "weight_decay",
      "eps"
    ],
    "type": "function"
  },
  "raises": {
    "description": "The class representing a Python function.",
    "std_args": [
      "err",
      "lamda"
    ],
    "type": "function"
  },
  "rand_ops": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "randn": {
    "description": "Returns a tensor filled with random numbers from a normal distribution.",
    "std_args": [
      "shape"
    ],
    "variants": {}
  },
  "random_split": {
    "description": "Randomly split a dataset into non-overlapping new datasets of given lengths.",
    "std_args": [
      "dataset",
      "lengths",
      "generator"
    ],
    "type": "function"
  },
  "random_structured": {
    "description": "Prune tensor by removing random channels along the specified dimension.",
    "std_args": [
      "module",
      "name",
      "amount",
      "dim"
    ],
    "type": "function"
  },
  "random_unstructured": {
    "description": "Prune tensor by removing random (currently unpruned) units.",
    "std_args": [
      "module",
      "name",
      "amount"
    ],
    "type": "function"
  },
  "range_check": {
    "description": "Checks if an index i is within range of a size n list",
    "std_args": [
      "i",
      "n"
    ],
    "type": "function"
  },
  "range_constraints": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "range_end": {
    "description": "Mark the end of a range for a given range_id.",
    "std_args": [
      "range_id"
    ],
    "type": "function"
  },
  "range_pop": {
    "description": "Pop a range off of a stack of nested range spans.  Returns the  zero-based depth of the range that is ended.",
    "std_args": [],
    "type": "function"
  },
  "range_push": {
    "description": "Push a range onto a stack of nested range span.  Returns zero-based depth of the range that is started.",
    "std_args": [
      "msg"
    ],
    "type": "function"
  },
  "range_start": {
    "description": "Mark the start of a range with string message. It returns an unique handle",
    "std_args": [
      "msg"
    ],
    "type": "function"
  },
  "rank": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rank0_only": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "raw_cuda_graph": {
    "description": "Returns the underlying cudaGraph_t. ``keep_graph`` must be True.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "raw_cuda_graph_exec": {
    "description": "Returns the underlying cudaGraphExec_t. ``instantiate`` must have been called if ``keep_graph`` is True, or ``capture_end`` must have been called if ``keep_graph`` is False. If you call ``instantiate()`` after ``raw_cuda_graph_exec()``, the previously returned cudaGraphExec_t will be destroyed. It is your responsibility not to use this object after destruction.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "raw_iterator": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "raw_times": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rcb": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rdzv_backend": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rdzv_configs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rdzv_endpoint": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rdzv_handler": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rdzv_timeout": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "read_data": {
    "description": "Reads torch save data on the coordinator rank, and broadcast afterwards",
    "std_args": [
      "self",
      "plan",
      "planner"
    ],
    "type": "function"
  },
  "read_file": {
    "description": "Read results from a TunableOp CSV file.",
    "std_args": [
      "filename"
    ],
    "type": "function"
  },
  "read_from_stream": {
    "description": "Given IO streams and their label names, yield bytes with label name as tuple.",
    "std_args": [
      "self",
      "chunk"
    ],
    "type": "function"
  },
  "read_metadata": {
    "description": "Extends the default StorageReader to support building the metadata file",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "real_vector": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rebind_unbacked": {
    "description": "Suppose we are retracing a pre-existing FX graph that previously had",
    "std_args": [
      "shape_env",
      "n",
      "result"
    ],
    "type": "function"
  },
  "rebuild_cuda_tensor": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tensor_cls",
      "tensor_size",
      "tensor_stride",
      "tensor_offset",
      "storage_cls",
      "dtype",
      "storage_device",
      "storage_handle",
      "storage_size_bytes",
      "storage_offset_bytes",
      "requires_grad",
      "ref_counter_handle",
      "ref_counter_offset",
      "event_handle",
      "event_sync_required"
    ],
    "type": "function"
  },
  "rebuild_event": {
    "description": "The class representing a Python function.",
    "std_args": [
      "device",
      "handle"
    ],
    "type": "function"
  },
  "rebuild_meta_tensor": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tensor_cls",
      "tensor_size",
      "tensor_stride",
      "tensor_offset",
      "dtype",
      "storage_size_bytes",
      "requires_grad"
    ],
    "type": "function"
  },
  "rebuild_nested_tensor": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rebuild_buffer_func",
      "rebuild_buffer_args",
      "rebuild_sizes_func",
      "rebuild_sizes_args",
      "rebuild_strides_func",
      "rebuild_strides_args",
      "rebuild_offsets_func",
      "rebuild_offsets_args"
    ],
    "type": "function"
  },
  "rebuild_sparse_compressed_tensor": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rebuild_compressed_indices_func",
      "rebuild_compressed_indices_args",
      "rebuild_plain_indices_func",
      "rebuild_plain_indices_args",
      "rebuild_values_func",
      "rebuild_values_args",
      "shape",
      "layout"
    ],
    "type": "function"
  },
  "rebuild_sparse_coo_tensor": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rebuild_indices_func",
      "rebuild_indices_args",
      "rebuild_values_func",
      "rebuild_values_args",
      "shape",
      "is_coalesced"
    ],
    "type": "function"
  },
  "rebuild_storage_empty": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls"
    ],
    "type": "function"
  },
  "rebuild_storage_fd": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "df",
      "size"
    ],
    "type": "function"
  },
  "rebuild_storage_filename": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "manager",
      "handle",
      "size",
      "dtype"
    ],
    "type": "function"
  },
  "rebuild_tensor": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "storage",
      "metadata"
    ],
    "type": "function"
  },
  "rebuild_typed_storage": {
    "description": "The class representing a Python function.",
    "std_args": [
      "storage",
      "dtype"
    ],
    "type": "function"
  },
  "rebuild_typed_storage_child": {
    "description": "The class representing a Python function.",
    "std_args": [
      "storage",
      "storage_type"
    ],
    "type": "function"
  },
  "recalculate_mem_size": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "recommended_max_memory": {
    "description": "Returns recommended max Working set size for GPU memory in bytes.",
    "std_args": [],
    "type": "function"
  },
  "recompile": {
    "description": "Recompile this GraphModule from its ``graph`` attribute. This should be",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "recompute_scale_factor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "record": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "record_duration": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "state"
    ],
    "type": "function"
  },
  "record_event": {
    "description": "Record an event.",
    "std_args": [
      "self",
      "event"
    ],
    "type": "function"
  },
  "record_exception": {
    "description": "Write a structured information about the exception into an error file in JSON format.",
    "std_args": [
      "self",
      "e"
    ],
    "type": "function"
  },
  "record_function": {
    "description": "Context manager/function decorator that adds a label to a code block/function when running autograd profiler.",
    "std_args": [
      "self",
      "name",
      "args"
    ],
    "type": "class"
  },
  "record_memory_history": {
    "description": "Enable/Disable the memory profiler on MTIA allocator",
    "std_args": [
      "enabled",
      "stacks",
      "max_entries"
    ],
    "type": "function"
  },
  "record_rdzv_event": {
    "description": "The class representing a Python function.",
    "std_args": [
      "event"
    ],
    "type": "function"
  },
  "record_shapeenv_event": {
    "description": "The class representing a Python function.",
    "std_args": [
      "save_tracked_fakes",
      "name"
    ],
    "type": "function"
  },
  "record_shapes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "record_stack_traces": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "record_steps": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "record_untuned_enable": {
    "description": "Enable recording untuned of TunableOp perations for offline tuning.",
    "std_args": [
      "val"
    ],
    "type": "function"
  },
  "record_untuned_is_enabled": {
    "description": "Returns whether TunableOp operations are recorded for offline tuning.",
    "std_args": [],
    "type": "function"
  },
  "recursive": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "recursive_add_node": {
    "description": "Start from inputs and going reverse topological order. If any upstream node",
    "std_args": [
      "self",
      "fusion_group",
      "inputs",
      "visited"
    ],
    "type": "function"
  },
  "recursive_undo": {
    "description": "Recursively undo any step performed by the initialisation of",
    "std_args": [
      "self",
      "sched"
    ],
    "type": "function"
  },
  "recv": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "recv_object_list": {
    "description": "Receives picklable objects in ``object_list`` synchronously.",
    "std_args": [
      "object_list",
      "src",
      "group",
      "device",
      "group_src",
      "use_batch"
    ],
    "type": "function"
  },
  "redirect": {
    "description": "Redirect ``std`` (one of ``\"stdout\"`` or ``\"stderr\"``) to a file in the path specified by ``to_file``.",
    "std_args": [
      "std",
      "to_file"
    ],
    "type": "function"
  },
  "redirect_stderr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "redirect_stdout": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "reduce": {
    "description": "The class representing a Python function.",
    "std_args": [
      "inputs",
      "output",
      "root",
      "op",
      "streams",
      "comms",
      "outputs"
    ],
    "type": "function"
  },
  "reduce_acc_nodes_non_tensor_input": {
    "description": "Excludes nodes from ACC supported set that have direct",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "reduce_acc_nodes_non_tensor_input_helper": {
    "description": "Transitively excludes nodes from ACC supported set.",
    "std_args": [
      "self",
      "cpu_worklist"
    ],
    "type": "function"
  },
  "reduce_acc_nodes_non_tensor_output": {
    "description": "Excludes nodes from ACC supported set that produce non-tensor",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "reduce_add": {
    "description": "Sum tensors from multiple GPUs.",
    "std_args": [
      "inputs",
      "destination"
    ],
    "type": "function"
  },
  "reduce_add_coalesced": {
    "description": "Sum tensors from multiple GPUs.",
    "std_args": [
      "inputs",
      "destination",
      "buffer_size"
    ],
    "type": "function"
  },
  "reduce_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "reduce_event": {
    "description": "The class representing a Python function.",
    "std_args": [
      "event"
    ],
    "type": "function"
  },
  "reduce_ex_hook": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "reduce_nested_tensor": {
    "description": "The class representing a Python function.",
    "std_args": [
      "nt"
    ],
    "type": "function"
  },
  "reduce_op": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "reduce_range": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "reduce_scatter": {
    "description": "The class representing a Python function.",
    "std_args": [
      "inputs",
      "outputs",
      "op",
      "streams",
      "comms"
    ],
    "type": "function"
  },
  "reduce_scatter_tensor": {
    "description": "Reduces, then scatters a tensor to all ranks in a group.",
    "std_args": [
      "output",
      "input",
      "op",
      "group",
      "async_op"
    ],
    "type": "function"
  },
  "reduce_sparse_tensor": {
    "description": "The class representing a Python function.",
    "std_args": [
      "sparse"
    ],
    "type": "function"
  },
  "reduce_storage": {
    "description": "The class representing a Python function.",
    "std_args": [
      "storage"
    ],
    "type": "function"
  },
  "reduce_tensor": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tensor"
    ],
    "type": "function"
  },
  "reduce_typed_storage": {
    "description": "The class representing a Python function.",
    "std_args": [
      "storage"
    ],
    "type": "function"
  },
  "reduce_typed_storage_child": {
    "description": "The class representing a Python function.",
    "std_args": [
      "storage"
    ],
    "type": "function"
  },
  "ref": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ref_type": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "reference_representation_rewrite": {
    "description": "The class representing a Python function.",
    "std_args": [
      "model"
    ],
    "type": "function"
  },
  "refine": {
    "description": "Generates constraints for",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "refine_dynamic_shapes_from_suggested_fixes": {
    "description": "When exporting with :func:`dynamic_shapes`, export may fail with a ConstraintViolation error if the specification",
    "std_args": [
      "msg",
      "dynamic_shapes"
    ],
    "type": "function"
  },
  "refine_node": {
    "description": "Returns a list of equality constraints for",
    "std_args": [
      "self",
      "n"
    ],
    "type": "function"
  },
  "reflectable_magic_methods": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "register": {
    "description": "Registers a :class:`~torch.distributions.constraints.Constraint`",
    "std_args": [
      "self",
      "constraint",
      "factory"
    ],
    "type": "function"
  },
  "register_algebraic_expressions_inference_rule": {
    "description": "The class representing a Python function.",
    "std_args": [
      "call_target"
    ],
    "type": "function"
  },
  "register_annotator": {
    "description": "The class representing a Python function.",
    "std_args": [
      "op"
    ],
    "type": "function"
  },
  "register_autocast": {
    "description": "Register an autocast dispatch rule for this custom op.",
    "std_args": [
      "op",
      "device_type",
      "cast_inputs",
      "lib"
    ],
    "type": "function"
  },
  "register_autograd": {
    "description": "Register a backward formula for this custom op.",
    "std_args": [
      "op",
      "backward",
      "setup_context",
      "lib"
    ],
    "type": "function"
  },
  "register_backend": {
    "description": "Registers a new RPC backend.",
    "std_args": [
      "backend_name",
      "construct_rpc_backend_options_handler",
      "init_backend_handler"
    ],
    "type": "function"
  },
  "register_backward_hook": {
    "description": "Register a backward hook on the module.",
    "std_args": [
      "self",
      "hook"
    ],
    "type": "function"
  },
  "register_buffer": {
    "description": "Registers a persistent buffer (non-parameter state).",
    "std_args": [
      "name",
      "tensor",
      "persistent"
    ],
    "variants": {}
  },
  "register_callback": {
    "description": "Adds ET observer to record function callbacks. The data will be",
    "std_args": [
      "self",
      "output_file_path"
    ],
    "type": "function"
  },
  "register_comm_hook": {
    "description": "Register a communication hook.",
    "std_args": [
      "self",
      "state",
      "hook"
    ],
    "type": "function"
  },
  "register_dataclass": {
    "description": "Registers a dataclass as a valid input/output type for :func:`torch.export.export`.",
    "std_args": [
      "cls",
      "serialized_type_name"
    ],
    "type": "function"
  },
  "register_datapipe_as_function": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "function_name",
      "cls_to_register"
    ],
    "type": "function"
  },
  "register_ddp_comm_hook": {
    "description": "Register ``ddp_comm_hooks`` to DDP model.",
    "std_args": [
      "comm_hook_type",
      "model",
      "state"
    ],
    "type": "function"
  },
  "register_extern_hook": {
    "description": "Registers an extern hook on the exporter.",
    "std_args": [
      "self",
      "hook"
    ],
    "type": "function"
  },
  "register_fake": {
    "description": "Register a FakeTensor implementation (\"fake impl\") for this operator.",
    "std_args": [
      "op",
      "func",
      "lib",
      "_stacklevel",
      "allow_override"
    ],
    "type": "function"
  },
  "register_flop_formula": {
    "description": "The class representing a Python function.",
    "std_args": [
      "targets",
      "get_raw"
    ],
    "type": "function"
  },
  "register_forward_hook": {
    "description": "Register a forward hook on the module.",
    "std_args": [
      "self",
      "hook",
      "prepend",
      "with_kwargs",
      "always_call"
    ],
    "type": "function"
  },
  "register_forward_pre_hook": {
    "description": "Register a forward pre-hook on the module.",
    "std_args": [
      "self",
      "hook",
      "prepend",
      "with_kwargs"
    ],
    "type": "function"
  },
  "register_full_backward_hook": {
    "description": "Register a backward hook on the module.",
    "std_args": [
      "self",
      "hook",
      "prepend"
    ],
    "type": "function"
  },
  "register_full_backward_pre_hook": {
    "description": "Register a backward pre-hook on the module.",
    "std_args": [
      "self",
      "hook",
      "prepend"
    ],
    "type": "function"
  },
  "register_function": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "function_name",
      "function"
    ],
    "type": "function"
  },
  "register_functional_optim": {
    "description": "Interface to insert a new functional optimizer to functional_optim_map",
    "std_args": [
      "key",
      "optim"
    ],
    "type": "function"
  },
  "register_handle": {
    "description": "Registers file descriptor to cuFile Driver.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "register_hook": {
    "description": "Register a backward hook.",
    "std_args": [
      "self",
      "fn"
    ],
    "type": "function"
  },
  "register_inference_rule": {
    "description": "The class representing a Python function.",
    "std_args": [
      "call_target"
    ],
    "type": "function"
  },
  "register_intern_hook": {
    "description": "Registers an intern hook on the exporter.",
    "std_args": [
      "self",
      "hook"
    ],
    "type": "function"
  },
  "register_kernel": {
    "description": "Register an implementation for a device type for this operator.",
    "std_args": [
      "op",
      "device_types",
      "func",
      "lib"
    ],
    "type": "function"
  },
  "register_kl": {
    "description": "Decorator to register a pairwise function with :meth:`kl_divergence`.",
    "std_args": [
      "type_p",
      "type_q"
    ],
    "type": "function"
  },
  "register_load_state_dict_post_hook": {
    "description": "Register a load_state_dict post-hook which will be called after",
    "std_args": [
      "self",
      "hook",
      "prepend"
    ],
    "type": "function"
  },
  "register_load_state_dict_pre_hook": {
    "description": "Register a load_state_dict pre-hook which will be called before",
    "std_args": [
      "self",
      "hook",
      "prepend"
    ],
    "type": "function"
  },
  "register_mock_hook": {
    "description": "Registers a mock hook on the exporter.",
    "std_args": [
      "self",
      "hook"
    ],
    "type": "function"
  },
  "register_module_backward_hook": {
    "description": "Register a backward hook common to all the modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_module_buffer_registration_hook": {
    "description": "Register a buffer registration hook common to all modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_module_forward_hook": {
    "description": "Register a global forward hook for all the modules.",
    "std_args": [
      "hook",
      "with_kwargs",
      "always_call"
    ],
    "type": "function"
  },
  "register_module_forward_pre_hook": {
    "description": "Register a forward pre-hook common to all modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_module_full_backward_hook": {
    "description": "Register a backward hook common to all the modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_module_full_backward_pre_hook": {
    "description": "Register a backward pre-hook common to all the modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_module_module_registration_hook": {
    "description": "Register a module registration hook common to all modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_module_parameter_registration_hook": {
    "description": "Register a parameter registration hook common to all modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_multi_grad_hook": {
    "description": "Register a multi-grad backward hook.",
    "std_args": [
      "tensors",
      "fn",
      "mode"
    ],
    "type": "function"
  },
  "register_optimizer_step_post_hook": {
    "description": "Register a post hook common to all optimizers.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_optimizer_step_pre_hook": {
    "description": "Register a pre hook common to all optimizers.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_package": {
    "description": "Registers callables for tagging and deserializing storage objects with an associated priority.",
    "std_args": [
      "priority",
      "tagger",
      "deserializer"
    ],
    "type": "function"
  },
  "register_parameter": {
    "description": "Registers a learnable parameter.",
    "std_args": [
      "name",
      "param"
    ],
    "variants": {}
  },
  "register_parametrization": {
    "description": "Register a parametrization to a tensor in a module.",
    "std_args": [
      "module",
      "tensor_name",
      "parametrization",
      "unsafe"
    ],
    "type": "function"
  },
  "register_prehook": {
    "description": "Register a backward pre-hook.",
    "std_args": [
      "self",
      "fn"
    ],
    "type": "function"
  },
  "register_refinement_rule": {
    "description": "The class representing a Python function.",
    "std_args": [
      "call_target"
    ],
    "type": "function"
  },
  "register_rendezvous_handler": {
    "description": "Register a new rendezvous handler.",
    "std_args": [
      "scheme",
      "handler"
    ],
    "type": "function"
  },
  "register_state_dict_post_hook": {
    "description": "Register a state dict post-hook which will be called after :meth:`~torch.optim.Optimizer.state_dict` is called.",
    "std_args": [
      "self",
      "hook",
      "prepend"
    ],
    "type": "function"
  },
  "register_state_dict_pre_hook": {
    "description": "Register a state dict pre-hook which will be called before :meth:`~torch.optim.Optimizer.state_dict` is called.",
    "std_args": [
      "self",
      "hook",
      "prepend"
    ],
    "type": "function"
  },
  "register_step_post_hook": {
    "description": "Register an optimizer step post hook which will be called after optimizer step.",
    "std_args": [
      "self",
      "hook"
    ],
    "type": "function"
  },
  "register_step_pre_hook": {
    "description": "Register an optimizer step pre hook which will be called before optimizer step.",
    "std_args": [
      "self",
      "hook"
    ],
    "type": "function"
  },
  "register_timers": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "timer_requests"
    ],
    "type": "function"
  },
  "register_torch_dispatch": {
    "description": "Registers a torch_dispatch rule for the given operator and ``torch_dispatch_class``.",
    "std_args": [
      "op",
      "torch_dispatch_class",
      "func",
      "lib"
    ],
    "type": "function"
  },
  "register_transformation_rule": {
    "description": "The class representing a Python function.",
    "std_args": [
      "call_target"
    ],
    "type": "function"
  },
  "register_vmap": {
    "description": "Register a vmap implementation to support :func:`torch.vmap` for this custom op.",
    "std_args": [
      "op",
      "func",
      "lib"
    ],
    "type": "function"
  },
  "reify": {
    "description": "Replace variables of expression with substitution",
    "std_args": [
      "e",
      "s"
    ],
    "type": "function"
  },
  "reify_object": {
    "description": "Reify a Python object with a substitution",
    "std_args": [
      "o",
      "s"
    ],
    "type": "function"
  },
  "reinplace": {
    "description": "Given an fx.GraphModule, modifies it to perform \"reinplacing\",",
    "std_args": [
      "gm",
      "sample_args"
    ],
    "type": "function"
  },
  "reinterpreted_batch_ndims": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rejection_rate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rekey_optim_state_dict": {
    "description": "Re-keys the optimizer state dict ``optim_state_dict`` to use the key type ``optim_state_key_type``.",
    "std_args": [
      "optim_state_dict",
      "optim_state_key_type",
      "model",
      "optim_input",
      "optim"
    ],
    "type": "function"
  },
  "relaxed_sources": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "release": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "scope_id"
    ],
    "type": "function"
  },
  "relu_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "relu_inference_rule": {
    "description": "Input and output shapes should be equal.",
    "std_args": [
      "n",
      "module_instance",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "remote": {
    "description": "Make a remote call to run ``func`` on worker ``to`` and return an",
    "std_args": [
      "to",
      "func",
      "args",
      "kwargs",
      "timeout"
    ],
    "type": "function"
  },
  "remote_optimizers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "remove": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "remove_bookend_non_compute_ops": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "partitions"
    ],
    "type": "function"
  },
  "remove_boolean_dispatch_from_name": {
    "description": "Some ops have a default string representation such as",
    "std_args": [
      "p"
    ],
    "type": "function"
  },
  "remove_dropout": {
    "description": "Removes all dropout layers from the module.",
    "std_args": [
      "model"
    ],
    "type": "function"
  },
  "remove_extension_h_precompiler_headers": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "remove_node": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "node"
    ],
    "type": "function"
  },
  "remove_overlapping_matches": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "remove_parametrizations": {
    "description": "Remove the parametrizations on a tensor in a module.",
    "std_args": [
      "module",
      "tensor_name",
      "leave_parametrized"
    ],
    "type": "function"
  },
  "remove_pass": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "_passes"
    ],
    "type": "function"
  },
  "remove_spectral_norm": {
    "description": "Remove the spectral normalization reparameterization from a module.",
    "std_args": [
      "module",
      "name"
    ],
    "type": "function"
  },
  "remove_tensor_overload_for_qdq_ops": {
    "description": "Remove .tensor overload for quantize/dequantize ops so that we can",
    "std_args": [
      "match_pattern"
    ],
    "type": "function"
  },
  "remove_weight_norm": {
    "description": "Remove the weight normalization reparameterization from a module.",
    "std_args": [
      "module",
      "name"
    ],
    "type": "function"
  },
  "rename": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "path",
      "new_path"
    ],
    "type": "function"
  },
  "rename_privateuse1_backend": {
    "description": "Rename the privateuse1 backend device to make it more convenient to use as a device name within PyTorch APIs.",
    "std_args": [
      "backend_name"
    ],
    "type": "function"
  },
  "render": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "source"
    ],
    "type": "function"
  },
  "rendezvous": {
    "description": "The class representing a Python function.",
    "std_args": [
      "url",
      "rank",
      "world_size",
      "kwargs"
    ],
    "type": "function"
  },
  "rendezvous_barrier": {
    "description": "Main entry point for next rendezvous.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "rendezvous_handler_registry": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rendezvous_iterator": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "reopen": {
    "description": "Reopens the EventFileWriter.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "reorder": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "on_ambiguity"
    ],
    "type": "function"
  },
  "reorganize_partitions": {
    "description": "Given a list of partitions, reorganize partition id,",
    "std_args": [
      "partitions"
    ],
    "type": "function"
  },
  "replace": {
    "description": "Apply symbol replacements to any symbols in the given expression.",
    "std_args": [
      "self",
      "expr"
    ],
    "type": "function"
  },
  "replace_all_uses": {
    "description": "Replace all uses of the old name with new name in the signature.",
    "std_args": [
      "self",
      "old",
      "new"
    ],
    "type": "function"
  },
  "replace_all_uses_with": {
    "description": "Replace all uses of ``self`` in the Graph with the Node ``replace_with``.",
    "std_args": [
      "self",
      "replace_with",
      "delete_user_cb",
      "propagate_meta"
    ],
    "type": "function"
  },
  "replace_dyn_with_fresh_var": {
    "description": "Replace all unknown types with fresh type variables.",
    "std_args": [
      "self",
      "typ"
    ],
    "type": "function"
  },
  "replace_extern_shared": {
    "description": "Match extern __shared__ type foo[]; syntax and use HIP_DYNAMIC_SHARED() MACRO instead.",
    "std_args": [
      "input_string"
    ],
    "type": "function"
  },
  "replace_input_with": {
    "description": "Loop through input nodes of ``self``, and replace all instances of",
    "std_args": [
      "self",
      "old_input",
      "new_input"
    ],
    "type": "function"
  },
  "replace_math_functions": {
    "description": "FIXME: Temporarily replace std:: invocations of math functions",
    "std_args": [
      "input_string"
    ],
    "type": "function"
  },
  "replace_pass": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "_target",
      "_replacement"
    ],
    "type": "function"
  },
  "replace_pattern": {
    "description": "Matches all possible non-overlapping sets of operators and their",
    "std_args": [
      "gm",
      "pattern",
      "replacement"
    ],
    "type": "function"
  },
  "replace_pattern_with_filters": {
    "description": "See replace_pattern for documentation. This function is an overload with an additional match_filter argument.",
    "std_args": [
      "gm",
      "pattern",
      "replacement",
      "match_filters",
      "ignore_literals",
      "replacement_callback",
      "node_name_match"
    ],
    "type": "function"
  },
  "replace_target_nodes_with": {
    "description": "Modifies all nodes in fx_module.graph.nodes which match the specified op code and target,",
    "std_args": [
      "fx_module",
      "old_op",
      "old_target",
      "new_op",
      "new_target"
    ],
    "type": "function"
  },
  "replacement": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "replacements": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "replay": {
    "description": "Replay the CUDA work captured by this graph.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "replay_shape_env_events": {
    "description": "The class representing a Python function.",
    "std_args": [
      "events"
    ],
    "type": "function"
  },
  "replicate": {
    "description": "The class representing a Python function.",
    "std_args": [
      "network",
      "devices",
      "detach"
    ],
    "type": "function"
  },
  "repr_hook": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "require_backward_grad_sync": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "require_forward_param_sync": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "require_hint": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "fallback"
    ],
    "type": "function"
  },
  "required": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "requires": {
    "description": "This function will be called before the pass is run and will check that",
    "std_args": [
      "self",
      "graph_module"
    ],
    "type": "function"
  },
  "requires_grad": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "requires_grad_": {
    "description": "Change if autograd should record operations on parameters in this module.",
    "std_args": [
      "self",
      "requires_grad"
    ],
    "type": "function"
  },
  "res": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "res1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "res2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "reset": {
    "description": "Delete the graph currently held by this instance.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "reset_accumulated_host_memory_stats": {
    "description": "Reset the \"accumulated\" (historical) stats tracked by the host memory allocator.",
    "std_args": [],
    "type": "function"
  },
  "reset_accumulated_memory_stats": {
    "description": "Reset the \"accumulated\" (historical) stats tracked by the CUDA memory allocator.",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "reset_bn_parameters": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "reset_grad_fn_seq_nr": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "reset_histogram": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "x",
      "min_val",
      "max_val"
    ],
    "type": "function"
  },
  "reset_max_memory_allocated": {
    "description": "Reset the starting point in tracking maximum GPU memory occupied by tensors for a given device.",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "reset_max_memory_cached": {
    "description": "Reset the starting point in tracking maximum GPU memory managed by the caching allocator for a given device.",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "reset_min_max_vals": {
    "description": "Resets the min/max values.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "reset_modules": {
    "description": "Maps each module that's been changed with `modules_to_mkldnn` back to its",
    "std_args": [
      "nodes",
      "modules",
      "old_modules"
    ],
    "type": "function"
  },
  "reset_parameters": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "reset_partition_device": {
    "description": "The class representing a Python function.",
    "std_args": [
      "partitions"
    ],
    "type": "function"
  },
  "reset_peak_host_memory_stats": {
    "description": "Reset the \"peak\" stats tracked by the host memory allocator.",
    "std_args": [],
    "type": "function"
  },
  "reset_peak_memory_stats": {
    "description": "Reset the peak memory stats for a given device.",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "reset_running_stats": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "reshape_from_tensor_shape": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "reshape_inference_rule": {
    "description": "The class representing a Python function.",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "reshape_weight_to_matrix": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "weight"
    ],
    "type": "function"
  },
  "resizable": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "resize_": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "size"
    ],
    "type": "function"
  },
  "resolve": {
    "description": "Determine appropriate implementation for this type signature",
    "std_args": [
      "self",
      "types"
    ],
    "type": "function"
  },
  "resolve_bytes": {
    "description": "Return the BytesIO to be used by the StorageReader to load `read_item`.",
    "std_args": [
      "self",
      "read_item"
    ],
    "type": "function"
  },
  "resolve_data": {
    "description": "Transform and prepare ``write_item`` from ``state_dict`` for storage, ensuring idempotency and thread-safety.",
    "std_args": [
      "self",
      "write_item"
    ],
    "type": "function"
  },
  "resolve_name": {
    "description": "Get a human readable string name for a function passed to",
    "std_args": [
      "f"
    ],
    "type": "function"
  },
  "resolve_tensor": {
    "description": "Return the tensor described by ``read_item`` to be used by the StorageReader to load `read_item`.",
    "std_args": [
      "self",
      "read_item"
    ],
    "type": "function"
  },
  "resolve_unbacked_bindings": {
    "description": "When we do fake tensor prop, we oftentimes will allocate new unbacked symints.",
    "std_args": [
      "shape_env",
      "bindings"
    ],
    "type": "function"
  },
  "resources_dir": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "restart_ordering": {
    "description": "Deprecated interface to temporarily resume ordering.",
    "std_args": [
      "on_ambiguity"
    ],
    "type": "function"
  },
  "results": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "return_arg_list": {
    "description": "Constructs a function that takes a node as arg and returns the arg_indices",
    "std_args": [
      "arg_indices"
    ],
    "type": "function"
  },
  "return_first_non_observer_node": {
    "description": "If node is not an observer, returns it.  If node is an observer,",
    "std_args": [
      "node",
      "gm"
    ],
    "type": "function"
  },
  "return_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "return_types": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "return_values": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "returning_nodes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "reverse": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "reverse_dict": {
    "description": "Reverses direction of dependence dict",
    "std_args": [
      "d"
    ],
    "type": "function"
  },
  "rewrite": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "fn"
    ],
    "type": "function"
  },
  "rewrite_with_congruences": {
    "description": "Eliminate expressions of the form b // d and b % d while adding congruences of the form b % d == k.",
    "std_args": [
      "self",
      "s",
      "expr"
    ],
    "type": "function"
  },
  "rfft2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rhs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rhs1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rhs2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "right": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "right_inverse": {
    "description": "Call the ``right_inverse`` methods of the parametrizations in the inverse registration order.",
    "std_args": [
      "self",
      "value"
    ],
    "type": "function"
  },
  "rlock": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rm_file": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "path"
    ],
    "type": "function"
  },
  "rms_norm": {
    "description": "Apply Root Mean Square Layer Normalization.",
    "std_args": [
      "input",
      "normalized_shape",
      "weight",
      "eps"
    ],
    "type": "function"
  },
  "rng": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rnn_op_dtype_configs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "role": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "role_rank": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "role_world_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "root": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "root_log_dir": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "root_node": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rotary_embedding": {
    "description": "RotaryEmbedding op in ONNX.",
    "std_args": [
      "X",
      "cos_cache",
      "sin_cache",
      "position_ids",
      "interleaved",
      "num_heads",
      "rotary_embedding_dim"
    ],
    "type": "function"
  },
  "round_to_int": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "x",
      "dtype"
    ],
    "type": "function"
  },
  "routed_decode": {
    "description": "Decodes binary streams from input DataPipe, yields pathname and decoded data in a tuple.",
    "std_args": [
      "self",
      "handlers",
      "key_fn"
    ],
    "type": "function"
  },
  "row_block_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "row_fn": {
    "description": "The class representing a Python function.",
    "std_args": [
      "m"
    ],
    "type": "function"
  },
  "row_keys": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rpc_api": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rpc_async": {
    "description": "Make a non-blocking RPC call to run function ``func`` on worker ``to``. RPC",
    "std_args": [
      "to",
      "func",
      "args",
      "kwargs",
      "timeout"
    ],
    "type": "function"
  },
  "rpc_sync": {
    "description": "Make a blocking RPC call to run function ``func`` on worker ``to``. RPC",
    "std_args": [
      "to",
      "func",
      "args",
      "kwargs",
      "timeout"
    ],
    "type": "function"
  },
  "rpc_timeout": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rprop": {
    "description": "Functional API that performs rprop algorithm computation.",
    "std_args": [
      "params",
      "grads",
      "prevs",
      "step_sizes",
      "state_steps",
      "foreach",
      "capturable",
      "maximize",
      "differentiable",
      "has_complex",
      "step_size_min",
      "step_size_max",
      "etaminus",
      "etaplus"
    ],
    "type": "function"
  },
  "rref": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rrelu": {
    "description": "rrelu(input, lower=1./8, upper=1./3, training=False, inplace=False) -> Tensor",
    "std_args": [
      "input",
      "lower",
      "upper",
      "training",
      "inplace"
    ],
    "type": "function"
  },
  "rrelu_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rsample": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "sample_shape"
    ],
    "type": "function"
  },
  "rshift": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "function"
  },
  "run": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "shape_env"
    ],
    "type": "function"
  },
  "run_and_parse_first_match": {
    "description": "Run command using run_lambda, returns the first regex match if it exists.",
    "std_args": [
      "run_lambda",
      "command",
      "regex"
    ],
    "type": "function"
  },
  "run_and_read_all": {
    "description": "Run command using run_lambda; reads and returns entire output if rc is 0.",
    "std_args": [
      "run_lambda",
      "command"
    ],
    "type": "function"
  },
  "run_and_return_first_line": {
    "description": "Run command using run_lambda and returns first line if output is not empty.",
    "std_args": [
      "run_lambda",
      "command"
    ],
    "type": "function"
  },
  "run_baseline_no_fusion": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ir",
      "inputs"
    ],
    "type": "function"
  },
  "run_benchmark": {
    "description": "The class representing a Python function.",
    "std_args": [
      "name",
      "function",
      "dtype",
      "seed",
      "device",
      "samples",
      "probability_regular"
    ],
    "type": "function"
  },
  "run_callbacks_on_exit": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "run_checks_after_each_pass": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "run_decompositions": {
    "description": "Run a set of decompositions on the exported program and returns a new",
    "std_args": [
      "self",
      "decomp_table",
      "decompose_custom_triton_ops"
    ],
    "type": "function"
  },
  "run_folding": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "run_id": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "run_method": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "method_name",
      "input"
    ],
    "type": "function"
  },
  "run_nnc": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ir",
      "inputs",
      "dynamic"
    ],
    "type": "function"
  },
  "run_node": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "n"
    ],
    "type": "function"
  },
  "run_nvfuser": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ir",
      "inputs"
    ],
    "type": "function"
  },
  "run_once": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "run_script_path": {
    "description": "Run the provided `training_script` from within this interpreter.",
    "std_args": [
      "training_script",
      "training_script_args"
    ],
    "type": "function"
  },
  "run_test": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ir",
      "inputs",
      "warmup_runs",
      "test_runs"
    ],
    "type": "function"
  },
  "safe_expand": {
    "description": "Expand the given symbolic expression by recursively rewriting product of",
    "std_args": [
      "r"
    ],
    "type": "function"
  },
  "safe_globals": {
    "description": "Context-manager that adds certain globals as safe for ``weights_only`` load.",
    "std_args": [
      "self",
      "safe_globals"
    ],
    "type": "class"
  },
  "sample": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "sample_shape"
    ],
    "type": "function"
  },
  "sample_n": {
    "description": "Generates n samples or n batches of samples if the distribution",
    "std_args": [
      "self",
      "n"
    ],
    "type": "function"
  },
  "sampled_addmm": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sampler": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sampler_args": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sampler_kwargs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "satisfies_constraints": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "params"
    ],
    "type": "function"
  },
  "saturate_host": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "save": {
    "description": ".. warning::",
    "std_args": [
      "ep",
      "f",
      "extra_files",
      "opset_version",
      "pickle_protocol"
    ],
    "type": "function"
  },
  "save_binary": {
    "description": "Save raw bytes to the package.",
    "std_args": [
      "self",
      "package",
      "resource",
      "binary"
    ],
    "type": "function"
  },
  "save_cache_artifacts": {
    "description": "Serializes all the cache artifacts that were created during the compilation",
    "std_args": [],
    "type": "function"
  },
  "save_distributed": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "save_for_backward": {
    "description": "See :meth:`Function.save_for_backward`.",
    "std_args": [
      "self",
      "args"
    ],
    "type": "function"
  },
  "save_for_forward": {
    "description": "Save given tensors for a future call to :func:`~Function.jvp`.",
    "std_args": [
      "self",
      "tensors"
    ],
    "type": "function"
  },
  "save_id": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "save_on_cpu": {
    "description": "Context manager under which tensors saved by the forward pass will be stored on cpu, then retrieved for backward.",
    "std_args": [
      "self",
      "pin_memory",
      "device_type"
    ],
    "type": "class"
  },
  "save_pickle": {
    "description": "Save a python object to the archive using pickle. Equivalent to :func:`torch.save` but saving into",
    "std_args": [
      "self",
      "package",
      "resource",
      "obj",
      "dependencies",
      "pickle_protocol"
    ],
    "type": "function"
  },
  "save_source_file": {
    "description": "Adds the local file system ``file_or_directory`` to the source package to provide the code",
    "std_args": [
      "self",
      "module_name",
      "file_or_directory",
      "dependencies"
    ],
    "type": "function"
  },
  "save_source_string": {
    "description": "Adds ``src`` as the source code for ``module_name`` in the exported package.",
    "std_args": [
      "self",
      "module_name",
      "src",
      "is_package",
      "dependencies"
    ],
    "type": "function"
  },
  "save_state_dict": {
    "description": "This method is deprecated. Please switch to 'save'.",
    "std_args": [
      "state_dict",
      "storage_writer",
      "process_group",
      "coordinator_rank",
      "no_dist",
      "planner"
    ],
    "type": "function"
  },
  "save_storage": {
    "description": "Saves data from the storage into the file.",
    "std_args": [
      "self",
      "storage",
      "offset"
    ],
    "type": "function"
  },
  "save_text": {
    "description": "Save text data to the package.",
    "std_args": [
      "self",
      "package",
      "resource",
      "text"
    ],
    "type": "function"
  },
  "saved_state": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "saved_tensors": {
    "description": "See :meth:`Function.saved_tensors`.",
    "std_args": [],
    "type": "attribute"
  },
  "saved_tensors_hooks": {
    "description": "Context-manager that sets a pair of pack / unpack hooks for saved tensors.",
    "std_args": [
      "self",
      "pack_hook",
      "unpack_hook"
    ],
    "type": "class"
  },
  "scalar": {
    "description": "Output a `Summary` protocol buffer containing a single scalar value.",
    "std_args": [
      "name",
      "tensor",
      "collections",
      "new_style",
      "double_precision"
    ],
    "type": "function"
  },
  "scale": {
    "description": "Multiplies ('scales') a tensor or list of tensors by the scale factor.",
    "std_args": [
      "self",
      "outputs"
    ],
    "type": "function"
  },
  "scale_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scale_exact_match": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scale_factor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scale_fn": {
    "description": "Get the scaling policy.",
    "std_args": [
      "self",
      "x"
    ],
    "type": "function"
  },
  "scale_grad_by_freq": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scale_max_upper_bound": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scale_min_lower_bound": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scale_mode": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scale_tril": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "scaled_dot_product_attention": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scaled_modified_bessel_k0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scaled_modified_bessel_k1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scatter_full_optim_state_dict": {
    "description": "Scatter the full optimizer state dict from rank 0 to all other ranks.",
    "std_args": [
      "full_optim_state_dict",
      "model",
      "optim_input",
      "optim",
      "group"
    ],
    "type": "function"
  },
  "scatter_kwargs": {
    "description": "Scatter with support for kwargs dictionary.",
    "std_args": [
      "inputs",
      "kwargs",
      "target_gpus",
      "dim"
    ],
    "type": "function"
  },
  "scatter_object_list": {
    "description": "Scatters picklable objects in ``scatter_object_input_list`` to the whole group.",
    "std_args": [
      "scatter_object_output_list",
      "scatter_object_input_list",
      "src",
      "group",
      "group_src"
    ],
    "type": "function"
  },
  "schedule": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scope": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scope_id": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scramble": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "script_if_tracing": {
    "description": "Compiles ``fn`` when it is first called during tracing.",
    "std_args": [
      "fn"
    ],
    "type": "function"
  },
  "script_module_serializer": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "script_object_tracker": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "script_qconfig": {
    "description": "Instantiate the activation and weight observer modules and script",
    "std_args": [
      "qconfig"
    ],
    "type": "function"
  },
  "script_qconfig_dict": {
    "description": "Helper function used by `prepare_jit`.",
    "std_args": [
      "qconfig_dict"
    ],
    "type": "function"
  },
  "sdp_kernel": {
    "description": ".. warning:: This flag is beta and subject to change.",
    "std_args": [
      "enable_flash",
      "enable_math",
      "enable_mem_efficient",
      "enable_cudnn"
    ],
    "type": "function"
  },
  "sdpa_backward_flop": {
    "description": "Count flops for self-attention backward.",
    "std_args": [
      "grad_out_shape",
      "query_shape",
      "key_shape",
      "value_shape",
      "args",
      "out_shape",
      "kwargs"
    ],
    "type": "function"
  },
  "sdpa_backward_flop_count": {
    "description": "The class representing a Python function.",
    "std_args": [
      "grad_out_shape",
      "query_shape",
      "key_shape",
      "value_shape"
    ],
    "type": "function"
  },
  "sdpa_flop": {
    "description": "Count flops for self-attention.",
    "std_args": [
      "query_shape",
      "key_shape",
      "value_shape",
      "args",
      "out_shape",
      "kwargs"
    ],
    "type": "function"
  },
  "sdpa_flop_count": {
    "description": "Count flops for self-attention.",
    "std_args": [
      "query_shape",
      "key_shape",
      "value_shape"
    ],
    "type": "function"
  },
  "sdpa_kernel": {
    "description": "Context manager to select which backend to use for scaled dot product attention.",
    "std_args": [
      "backends",
      "set_priority"
    ],
    "type": "function"
  },
  "search": {
    "description": "Search whether word is present in the Trie.",
    "std_args": [
      "self",
      "word"
    ],
    "type": "function"
  },
  "see": {
    "description": "Observe a key and raise an error if it is seen multiple times.",
    "std_args": [
      "self",
      "key"
    ],
    "type": "function"
  },
  "seed": {
    "description": "Set the seed for generating random numbers to a random number for the current GPU.",
    "std_args": [],
    "type": "function"
  },
  "seed_all": {
    "description": "Set the seed for generating random numbers to a random number on all GPUs.",
    "std_args": [],
    "type": "function"
  },
  "seen": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "seen_subgraphs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "select_unit": {
    "description": "Determine how to scale times for O(1) magnitude.",
    "std_args": [
      "t"
    ],
    "type": "function"
  },
  "self_attn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "self_cpu_memory_usage": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "self_cpu_percent": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "self_cpu_time_total": {
    "description": "Returns total time spent on CPU.",
    "std_args": [],
    "type": "attribute"
  },
  "self_cpu_time_total_str": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "self_cuda_memory_usage": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "self_cuda_time_total": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "self_device_memory_usage": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "self_device_time_total": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "self_device_time_total_str": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "selu_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "send": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "obj"
    ],
    "type": "function"
  },
  "send_object_list": {
    "description": "Sends picklable objects in ``object_list`` synchronously.",
    "std_args": [
      "object_list",
      "dst",
      "group",
      "device",
      "group_dst",
      "use_batch"
    ],
    "type": "function"
  },
  "sentinels": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "separator": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "seq": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "seq_len_kv": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "seq_len_q": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "seq_lengths": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sequence": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sequence_nr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sequence_sharding": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "serialization": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "serialize": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "serialized_reduces": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "session_streams": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "set": {
    "description": "Write a key/value pair into ``EtcdStore``.",
    "std_args": [
      "self",
      "key",
      "value"
    ],
    "type": "function"
  },
  "set_backend_pattern_config": {
    "description": "Set the config for an pattern that can be run on the target backend.",
    "std_args": [
      "self",
      "config"
    ],
    "type": "function"
  },
  "set_backend_pattern_configs": {
    "description": "Set the configs for patterns that can be run on the target backend.",
    "std_args": [
      "self",
      "configs"
    ],
    "type": "function"
  },
  "set_backoff_factor": {
    "description": "Set a new scale backoff factor.",
    "std_args": [
      "self",
      "new_factor"
    ],
    "type": "function"
  },
  "set_checkpoint_debug_enabled": {
    "description": "Context manager that sets whether checkpoint should print additional debug",
    "std_args": [
      "enabled"
    ],
    "type": "function"
  },
  "set_checkpoint_early_stop": {
    "description": "Context manager that sets whether checkpoint should stop recomputation early.",
    "std_args": [
      "enable"
    ],
    "type": "function"
  },
  "set_closed": {
    "description": "Mark rendezvous 'closed' for current run_id, which is used to signal other",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "set_codegen": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "codegen"
    ],
    "type": "function"
  },
  "set_cpu_parent": {
    "description": "Set the immediate CPU parent of type FunctionEvent.",
    "std_args": [
      "self",
      "parent"
    ],
    "type": "function"
  },
  "set_crc32_options": {
    "description": "Set whether :func:`torch.save` computes and writes crc32 for each record.",
    "std_args": [
      "compute_crc32"
    ],
    "type": "function"
  },
  "set_current_meta": {
    "description": "The class representing a Python function.",
    "std_args": [
      "node",
      "pass_name"
    ],
    "type": "function"
  },
  "set_custom_trace_id_callback": {
    "description": "Sets a callback to be called when a new trace ID is generated.",
    "std_args": [
      "self",
      "callback"
    ],
    "type": "function"
  },
  "set_default_device": {
    "description": "Sets the default ``torch.Tensor`` to be allocated on ``device``.  This",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "set_default_dtype": {
    "description": "Sets the default floating point dtype to :attr:`d`. Supports floating point dtype",
    "std_args": [
      "d"
    ],
    "type": "function"
  },
  "set_default_load_endianness": {
    "description": "Set fallback byte order for loading files",
    "std_args": [
      "endianness"
    ],
    "type": "function"
  },
  "set_default_mmap_options": {
    "description": "Context manager or function to set default mmap options for :func:`torch.load` with ``mmap=True`` to flags.",
    "std_args": [
      "self",
      "flags"
    ],
    "type": "class"
  },
  "set_default_tensor_type": {
    "description": ".. warning::",
    "std_args": [
      "t"
    ],
    "type": "function"
  },
  "set_default_validate_args": {
    "description": "Sets whether validation is enabled or disabled.",
    "std_args": [
      "value"
    ],
    "type": "function"
  },
  "set_detect_anomaly": {
    "description": "Context-manager that sets the anomaly detection for the autograd engine on or off.",
    "std_args": [
      "self",
      "mode",
      "check_nan"
    ],
    "type": "class"
  },
  "set_deterministic_debug_mode": {
    "description": "Sets the debug mode for deterministic operations.",
    "std_args": [
      "debug_mode"
    ],
    "type": "function"
  },
  "set_device": {
    "description": "Set the current device.",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "set_device_idx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "set_device_index": {
    "description": "Set the current device index to a given device.",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "set_device_map": {
    "description": "Set device mapping between each RPC caller and callee pair. This",
    "std_args": [
      "self",
      "to",
      "device_map"
    ],
    "type": "function"
  },
  "set_device_states": {
    "description": "Sets random number generator states for the specified devices.",
    "std_args": [
      "devices",
      "states",
      "device_type"
    ],
    "type": "function"
  },
  "set_device_type": {
    "description": "Set the default device type for checkpointing.",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "set_devices": {
    "description": "Set local devices used by the TensorPipe RPC agent. When processing",
    "std_args": [
      "self",
      "devices"
    ],
    "type": "function"
  },
  "set_df_wrapper": {
    "description": "The class representing a Python function.",
    "std_args": [
      "wrapper"
    ],
    "type": "function"
  },
  "set_dir": {
    "description": "Optionally set the Torch Hub directory used to save downloaded models & weights.",
    "std_args": [
      "d"
    ],
    "type": "function"
  },
  "set_dtype_configs": {
    "description": "Set the supported data types passed as arguments to quantize ops in the",
    "std_args": [
      "self",
      "dtype_configs"
    ],
    "type": "function"
  },
  "set_enable_guard_collectives": {
    "description": "Enables use of collectives *during* guard evaluation to synchronize behavior",
    "std_args": [
      "enabled"
    ],
    "type": "function"
  },
  "set_enabled": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "value"
    ],
    "type": "function"
  },
  "set_epoch": {
    "description": "Set the epoch for this sampler.",
    "std_args": [
      "self",
      "epoch"
    ],
    "type": "function"
  },
  "set_exception": {
    "description": "Set an exception for this ``Future``, which will mark this ``Future`` as",
    "std_args": [
      "self",
      "result"
    ],
    "type": "function"
  },
  "set_extra_resource_collection": {
    "description": "Collects extra resources such as generated kernels, index tensor data, and any other",
    "std_args": [
      "self",
      "val"
    ],
    "type": "function"
  },
  "set_extra_state": {
    "description": "Set extra state contained in the loaded `state_dict`.",
    "std_args": [
      "self",
      "state"
    ],
    "type": "function"
  },
  "set_fastpath_enabled": {
    "description": "Sets whether fast path is enabled",
    "std_args": [
      "value"
    ],
    "type": "function"
  },
  "set_filename": {
    "description": "Set the filename to use for input/output of tuning results.",
    "std_args": [
      "filename",
      "insert_device_ordinal"
    ],
    "type": "function"
  },
  "set_flags": {
    "description": "Set if nnpack is enabled globally",
    "std_args": [
      "_enabled"
    ],
    "type": "function"
  },
  "set_float32_matmul_precision": {
    "description": "Sets the internal precision of float32 matrix multiplications.",
    "std_args": [
      "precision"
    ],
    "type": "function"
  },
  "set_float_to_observed_mapping": {
    "description": "Set the mapping from a custom float module class to a custom observed module class.",
    "std_args": [
      "self",
      "float_class",
      "observed_class",
      "quant_type"
    ],
    "type": "function"
  },
  "set_function_type_qconfig": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "function_type",
      "quantization_config"
    ],
    "type": "function"
  },
  "set_fuser_method": {
    "description": "Set the function that specifies how to fuse this BackendPatternConfig's pattern.",
    "std_args": [
      "self",
      "fuser_method"
    ],
    "type": "function"
  },
  "set_getstate_hook": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "hook_fn"
    ],
    "type": "function"
  },
  "set_global": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "quantization_config"
    ],
    "type": "function"
  },
  "set_grad_enabled": {
    "description": "Context-manager that sets gradient calculation on or off.",
    "std_args": [
      "self",
      "mode"
    ],
    "type": "class"
  },
  "set_grad_fn_seq_nr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "seq_nr"
    ],
    "type": "function"
  },
  "set_growth_factor": {
    "description": "Set a new scale growth factor.",
    "std_args": [
      "self",
      "new_factor"
    ],
    "type": "function"
  },
  "set_growth_interval": {
    "description": "Set a new growth interval.",
    "std_args": [
      "self",
      "new_interval"
    ],
    "type": "function"
  },
  "set_input_quantized_indexes": {
    "description": "Set the indexes of the inputs of the graph that should be quantized.",
    "std_args": [
      "self",
      "indexes"
    ],
    "type": "function"
  },
  "set_materialize_grads": {
    "description": "Set whether to materialize grad tensors. Default is ``True``.",
    "std_args": [
      "self",
      "value"
    ],
    "type": "function"
  },
  "set_max_tuning_duration": {
    "description": "Set max time in milliseconds to spend tuning a given solution.",
    "std_args": [
      "duration"
    ],
    "type": "function"
  },
  "set_max_tuning_iterations": {
    "description": "Set max number of iterations to spend tuning a given solution.",
    "std_args": [
      "iterations"
    ],
    "type": "function"
  },
  "set_meta": {
    "description": "The class representing a Python function.",
    "std_args": [
      "proxy",
      "val"
    ],
    "type": "function"
  },
  "set_model_state_dict": {
    "description": "Load the model state_dict.",
    "std_args": [
      "model",
      "model_state_dict",
      "options"
    ],
    "type": "function"
  },
  "set_module_name": {
    "description": "Set quantization_config for a submodule with name: `module_name`, for example:",
    "std_args": [
      "self",
      "module_name",
      "quantization_config"
    ],
    "type": "function"
  },
  "set_module_name_object_type_order": {
    "description": "Set the QConfig for modules matching a combination of the given module name, object type,",
    "std_args": [
      "self",
      "module_name",
      "object_type",
      "index",
      "qconfig"
    ],
    "type": "function"
  },
  "set_module_name_qconfig": {
    "description": "Set quantization_config for a submodule with name: `module_name`, for example:",
    "std_args": [
      "self",
      "module_name",
      "quantization_config"
    ],
    "type": "function"
  },
  "set_module_name_regex": {
    "description": "Set the QConfig for modules matching the given regex string.",
    "std_args": [
      "self",
      "module_name_regex",
      "qconfig"
    ],
    "type": "function"
  },
  "set_module_type": {
    "description": "Set quantization_config for a submodule with type: `module_type`, for example:",
    "std_args": [
      "self",
      "module_type",
      "quantization_config"
    ],
    "type": "function"
  },
  "set_module_type_qconfig": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "module_type",
      "quantization_config"
    ],
    "type": "function"
  },
  "set_multithreading_enabled": {
    "description": "Context-manager that sets multithreaded backwards on or off.",
    "std_args": [
      "self",
      "mode"
    ],
    "type": "class"
  },
  "set_name": {
    "description": "Set the name of the target backend.",
    "std_args": [
      "self",
      "name"
    ],
    "type": "function"
  },
  "set_non_traceable_module_classes": {
    "description": "Set the modules that are not symbolically traceable, identified by class.",
    "std_args": [
      "self",
      "module_classes"
    ],
    "type": "function"
  },
  "set_non_traceable_module_names": {
    "description": "Set the modules that are not symbolically traceable, identified by name.",
    "std_args": [
      "self",
      "module_names"
    ],
    "type": "function"
  },
  "set_object_type": {
    "description": "Set the QConfig for a given module type, function, or method name.",
    "std_args": [
      "self",
      "object_type",
      "qconfig"
    ],
    "type": "function"
  },
  "set_observation_type": {
    "description": "Set how observers should be inserted in the graph for this pattern.",
    "std_args": [
      "self",
      "observation_type"
    ],
    "type": "function"
  },
  "set_observed_to_quantized_mapping": {
    "description": "Set the mapping from a custom observed module class to a custom quantized module class.",
    "std_args": [
      "self",
      "observed_class",
      "quantized_class",
      "quant_type"
    ],
    "type": "function"
  },
  "set_operator_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "operator_type",
      "quantization_config"
    ],
    "type": "function"
  },
  "set_optimizer_state_dict": {
    "description": "Load the optimizers state_dict.",
    "std_args": [
      "model",
      "optimizers",
      "optim_state_dict",
      "options"
    ],
    "type": "function"
  },
  "set_original_aten_op": {
    "description": "The class representing a Python function.",
    "std_args": [
      "func"
    ],
    "type": "function"
  },
  "set_output_quantized_indexes": {
    "description": "Set the indexes of the outputs of the graph that should be quantized.",
    "std_args": [
      "self",
      "indexes"
    ],
    "type": "function"
  },
  "set_parents_and_children": {
    "description": "Given a list of partitions, mark parents and children for each partition",
    "std_args": [
      "partitions"
    ],
    "type": "function"
  },
  "set_pattern": {
    "description": "Set the pattern to configure.",
    "std_args": [
      "self",
      "pattern"
    ],
    "type": "function"
  },
  "set_per_process_memory_fraction": {
    "description": "Set memory fraction for a process.",
    "std_args": [
      "fraction",
      "device"
    ],
    "type": "function"
  },
  "set_preserved_attributes": {
    "description": "Set the names of the attributes that will persist in the graph module even if they are not used in",
    "std_args": [
      "self",
      "attributes"
    ],
    "type": "function"
  },
  "set_proxy_slot": {
    "description": "The class representing a Python function.",
    "std_args": [
      "obj",
      "tracer",
      "proxy"
    ],
    "type": "function"
  },
  "set_reduce_ex_hook": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "hook_fn"
    ],
    "type": "function"
  },
  "set_result": {
    "description": "Set the result for this ``Future``, which will mark this ``Future`` as",
    "std_args": [
      "self",
      "result"
    ],
    "type": "function"
  },
  "set_rng_state": {
    "description": "Sets the random number generator state.",
    "std_args": [
      "new_state",
      "device"
    ],
    "type": "function"
  },
  "set_rng_state_all": {
    "description": "Set the random number generator state of all devices.",
    "std_args": [
      "new_states"
    ],
    "type": "function"
  },
  "set_rotating_buffer_size": {
    "description": "Set rotating buffer size to this value in MB, if the buffer size is greater than zero.",
    "std_args": [
      "buffer_size"
    ],
    "type": "function"
  },
  "set_seed": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "seed"
    ],
    "type": "function"
  },
  "set_sharing_strategy": {
    "description": "Set the strategy for sharing CPU tensors.",
    "std_args": [
      "new_strategy"
    ],
    "type": "function"
  },
  "set_shuffle": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "shuffle"
    ],
    "type": "function"
  },
  "set_shuffle_settings": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "set_stack_trace": {
    "description": "The class representing a Python function.",
    "std_args": [
      "stack"
    ],
    "type": "function"
  },
  "set_stance": {
    "description": "Set the current stance of the compiler.",
    "std_args": [
      "stance",
      "skip_guard_eval_unsafe",
      "force_backend"
    ],
    "type": "function"
  },
  "set_standalone_module_class": {
    "description": "Set the configuration for running a standalone module identified by ``module_class``.",
    "std_args": [
      "self",
      "module_class",
      "qconfig_mapping",
      "example_inputs",
      "prepare_custom_config",
      "backend_config"
    ],
    "type": "function"
  },
  "set_standalone_module_name": {
    "description": "Set the configuration for running a standalone module identified by ``module_name``.",
    "std_args": [
      "self",
      "module_name",
      "qconfig_mapping",
      "example_inputs",
      "prepare_custom_config",
      "backend_config"
    ],
    "type": "function"
  },
  "set_state": {
    "description": "See base class.",
    "std_args": [
      "self",
      "state",
      "token"
    ],
    "type": "function"
  },
  "set_state_dict": {
    "description": "Load the model state_dict and optimizers state_dict.",
    "std_args": [
      "model",
      "optimizers",
      "model_state_dict",
      "optim_state_dict",
      "options"
    ],
    "type": "function"
  },
  "set_state_dict_type": {
    "description": "Set the ``state_dict_type`` of all the descendant FSDP modules of the target module.",
    "std_args": [
      "module",
      "state_dict_type",
      "state_dict_config",
      "optim_state_dict_config"
    ],
    "type": "function"
  },
  "set_stream": {
    "description": "Set the current stream.This is a wrapper API to set the stream.",
    "std_args": [
      "stream"
    ],
    "type": "function"
  },
  "set_sync_debug_mode": {
    "description": "Set the debug mode for cuda synchronizing operations.",
    "std_args": [
      "debug_mode"
    ],
    "type": "function"
  },
  "set_torch_threads": {
    "description": "The class representing a Python function.",
    "std_args": [
      "n"
    ],
    "type": "function"
  },
  "set_trace": {
    "description": "Sets a breakpoint in `gm`'s generated python code. It drops into pdb when",
    "std_args": [
      "gm"
    ],
    "type": "function"
  },
  "set_unbacked_var_to_val": {
    "description": "Used only when propagate_real_tensors; registers a value for an",
    "std_args": [
      "self",
      "k",
      "v"
    ],
    "type": "function"
  },
  "set_up_planner": {
    "description": "Setups of the planner, extnding default behavior by creating the Metadata object from the state dict",
    "std_args": [
      "self",
      "state_dict",
      "metadata",
      "is_coordinator"
    ],
    "type": "function"
  },
  "set_up_storage_reader": {
    "description": "Implementation of the StorageReader method",
    "std_args": [
      "self",
      "metadata",
      "is_coordinator"
    ],
    "type": "function"
  },
  "set_up_storage_writer": {
    "description": "Initialize this instance.",
    "std_args": [
      "self",
      "is_coordinator",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "set_warn_always": {
    "description": "When this flag is False (default) then some PyTorch warnings may only",
    "std_args": [
      "b"
    ],
    "type": "function"
  },
  "set_weight": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "w"
    ],
    "type": "function"
  },
  "set_weight_bias": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "w",
      "b",
      "row_block_size",
      "col_block_size"
    ],
    "type": "function"
  },
  "setattr_recursive": {
    "description": "The class representing a Python function.",
    "std_args": [
      "obj",
      "attr",
      "value"
    ],
    "type": "function"
  },
  "setdefault": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "setter": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "settings": {
    "description": "Get the settings of the rendezvous.",
    "std_args": [],
    "type": "attribute"
  },
  "setup": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "setup_input_hook": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "args"
    ],
    "type": "function"
  },
  "setup_kv_store": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "rdzv_version"
    ],
    "type": "function"
  },
  "setup_lease_renewal": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "full_path",
      "ttl"
    ],
    "type": "function"
  },
  "setup_output_hook": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "args"
    ],
    "type": "function"
  },
  "setup_str": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "shape_as_tensor": {
    "description": "Reshape a tensor to the given shape.",
    "std_args": [],
    "type": "attribute"
  },
  "shape_env": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "shape_env_check_state_equal": {
    "description": "The class representing a Python function.",
    "std_args": [
      "env1",
      "env2",
      "non_state_variable_names",
      "map_value"
    ],
    "type": "function"
  },
  "shape_env_to_source_to_symbol_cache": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "shape_wrapper": {
    "description": "The class representing a Python function.",
    "std_args": [
      "f"
    ],
    "type": "function"
  },
  "shard_full_optim_state_dict": {
    "description": "Shard a full optimizer state-dict.",
    "std_args": [
      "full_optim_state_dict",
      "model",
      "optim_input",
      "optim"
    ],
    "type": "function"
  },
  "sharded_optim_state_dict": {
    "description": "Return the optimizer state-dict in its sharded form.",
    "std_args": [
      "model",
      "optim",
      "group"
    ],
    "type": "function"
  },
  "sharding_filter": {
    "description": "Wrapper that allows DataPipe to be sharded (functional name: ``sharding_filter``).",
    "std_args": [
      "self",
      "sharding_group_filter"
    ],
    "type": "function"
  },
  "sharding_group_filter": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "share_memory": {
    "description": "Calls tensor.share_memory_() on the state sum tensors.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "share_memory_": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "share_qparams_op_dtype_configs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "shared_cache": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "shift": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "shifted_chebyshev_polynomial_t": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "shifted_chebyshev_polynomial_u": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "shifted_chebyshev_polynomial_v": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "shifted_chebyshev_polynomial_w": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "short": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "shortlist_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "should_fall_back_if_binding_fails": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "should_preserve_node_meta": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "should_record_events": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "should_synchronize_after_execute": {
    "description": "Whether to synchronize after executing the stage.",
    "std_args": [],
    "type": "attribute"
  },
  "shuffle": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "shutdown": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "signal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "signal_name": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "signature": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "significant_figures": {
    "description": "Approximate significant figure estimate.",
    "std_args": [],
    "type": "attribute"
  },
  "sigval": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "simplex": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "simplify": {
    "description": "Use known constraints and replacements to simplify the given expr",
    "std_args": [
      "self",
      "expr",
      "size_oblivious"
    ],
    "type": "function"
  },
  "sinc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sio": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "size": {
    "description": "Get tensor shape",
    "std_args": [],
    "variants": {}
  },
  "size_based": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "size_based_auto_wrap_policy": {
    "description": "A size-based auto wrap policy.",
    "std_args": [
      "module",
      "recurse",
      "nonwrapped_numel",
      "min_num_params",
      "force_leaf_modules",
      "exclude_wrap_modules"
    ],
    "type": "function"
  },
  "size_based_partition": {
    "description": "This method is to partition the fx module based on memory size.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "size_bytes": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "size_hint": {
    "description": "Gets a size hint for a given expression from the underlying shapes we had.",
    "std_args": [
      "self",
      "expr",
      "allow_none"
    ],
    "type": "function"
  },
  "size_in_bytes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "size_inference_rule": {
    "description": "The constraint is just lhs = rhs.",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "sizes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sizes_strides_methods": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "skip_all_reduce_unused_params": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "skip_data": {
    "description": "Context-manager that skips writing/reading storage bytes for ``torch.save`` / ``torch.load`` calls.",
    "std_args": [
      "self",
      "materialize_fake_tensors"
    ],
    "type": "class"
  },
  "skip_guard_on_all_nn_modules_unsafe": {
    "description": "A common function to skip guards on all nn modules, both user defined as",
    "std_args": [
      "guard_entries"
    ],
    "type": "function"
  },
  "skip_guard_on_globals_unsafe": {
    "description": "A common function to skip guards on all globals. This is unsafe to use by",
    "std_args": [
      "guard_entries"
    ],
    "type": "function"
  },
  "skip_guard_on_inbuilt_nn_modules_unsafe": {
    "description": "A common function to skip guards on the inbuilt nn modules like",
    "std_args": [
      "guard_entries"
    ],
    "type": "function"
  },
  "skip_init": {
    "description": "Given a module class object and args / kwargs, instantiate the module without initializing parameters / buffers.",
    "std_args": [
      "module_cls",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "skipped_module_classes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "skipped_module_names": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sl_lambdas": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "smooth_l1_loss": {
    "description": "Compute the Smooth L1 loss.",
    "std_args": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction",
      "beta"
    ],
    "type": "function"
  },
  "snapshot": {
    "description": "Return a dictionary of MTIA memory allocator history",
    "std_args": [],
    "type": "function"
  },
  "snapshot_fake": {
    "description": "The class representing a Python function.",
    "std_args": [
      "val",
      "include_real"
    ],
    "type": "function"
  },
  "sobolstate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "soft_margin_loss": {
    "description": "Compute the soft margin loss.",
    "std_args": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "softmin": {
    "description": "Apply a softmin function.",
    "std_args": [
      "input",
      "dim",
      "_stacklevel",
      "dtype"
    ],
    "type": "function"
  },
  "solution": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "solve_constraints": {
    "description": "Finds a valid traversal order based on the given constraints and orders",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "solve_ex": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "solve_triangular": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sorted_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "source": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "source_datapipe": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "source_name_to_debug_name": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "source_pairs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "source_range": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sparse": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sparse_": {
    "description": "Fill the 2D input `Tensor` as a sparse matrix.",
    "std_args": [
      "tensor",
      "sparsity",
      "std",
      "generator"
    ],
    "type": "function"
  },
  "sparse_nn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sparse_nn_partition": {
    "description": "This method partition a sparse nn module.",
    "std_args": [
      "self",
      "available_mem_bytes"
    ],
    "type": "function"
  },
  "sparse_tensor_constructor": {
    "description": "sparse_tensor_constructor creates a sparse tensor with coo format.",
    "std_args": [
      "size",
      "dtype",
      "sparse_dim",
      "nnz",
      "is_coalesced"
    ],
    "type": "function"
  },
  "sparsifier": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sparsity": {
    "description": "Computes the percentage of blocks that are sparse (i.e. not computed)",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "sparsity_compute_fn": {
    "description": "\"Computes the current level of sparsity.",
    "std_args": [
      "s_0",
      "s_f",
      "t",
      "t_0",
      "dt",
      "n",
      "initially_zero"
    ],
    "type": "function"
  },
  "spawn": {
    "description": "Spawns ``nprocs`` processes that run ``fn`` with ``args``.",
    "std_args": [
      "fn",
      "args",
      "nprocs",
      "join",
      "daemon",
      "start_method"
    ],
    "type": "function"
  },
  "spdiags": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "spec": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "specialize_on": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "specialize_zero_one": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "spectral_norm": {
    "description": "Apply spectral normalization to a parameter in the given module.",
    "std_args": [
      "module",
      "name",
      "n_power_iterations",
      "eps",
      "dim"
    ],
    "type": "function"
  },
  "spherical_bessel_j0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "split_args_kwargs_into_chunks": {
    "description": "Given a sequence of args and kwargs, split them into a number of chunks",
    "std_args": [
      "args",
      "kwargs",
      "chunks",
      "args_chunk_spec",
      "kwargs_chunk_spec"
    ],
    "type": "function"
  },
  "split_by_tags": {
    "description": "Splits a GraphModule using tags on its graph nodes. We honor the order of",
    "std_args": [
      "gm",
      "tags",
      "return_fqn_mapping",
      "return_tuple",
      "GraphModuleCls"
    ],
    "type": "function"
  },
  "split_const_subgraphs": {
    "description": "Looks through `module` for any nodes that have all constant attribute inputs",
    "std_args": [
      "module",
      "skip_folding_node_fn",
      "device_for_folded_attrs"
    ],
    "type": "function"
  },
  "split_dim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "split_gates": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "split_group": {
    "description": "Create a new process group split from the given parent process group.",
    "std_args": [
      "parent_pg",
      "split_ranks",
      "timeout",
      "pg_options",
      "group_desc"
    ],
    "type": "function"
  },
  "split_outside_bracket": {
    "description": "Given a line of text, split it on comma unless the comma is within a bracket '[]'.",
    "std_args": [
      "line",
      "delimiter"
    ],
    "type": "function"
  },
  "split_result_tensors": {
    "description": "A free function for use in the merge_matmul graph transformation below that",
    "std_args": [
      "result",
      "inputs"
    ],
    "type": "function"
  },
  "split_type_line": {
    "description": "Split the comment with the type annotation into parts for argument and return types.",
    "std_args": [
      "type_line"
    ],
    "type": "function"
  },
  "spsolve": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "squash_mask": {
    "description": "Squashes the sparse masks into the appropriate tensors.",
    "std_args": [
      "self",
      "params_to_keep",
      "params_to_keep_per_layer",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "src": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "src_data_rank": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "src_device_obj": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "src_prev_stream": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "stack_trace": {
    "description": "Return the Python stack trace that was recorded during tracing, if any.",
    "std_args": [],
    "type": "attribute"
  },
  "stage": {
    "description": "Override of AsyncStager.stage",
    "std_args": [
      "self",
      "state_dict"
    ],
    "type": "function"
  },
  "stage_index_to_group_rank": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "stage_name": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "staging_completion": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "standalone_module_classes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "standalone_module_input_quantized_idxs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "standalone_module_names": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "standalone_module_output_quantized_idxs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "start": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "start_dim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "start_factor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "start_index": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "start_localSGD_iter": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "start_method": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "start_node": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "start_nodes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "start_powerSGD_iter": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "start_processes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "fn",
      "args",
      "nprocs",
      "join",
      "daemon",
      "start_method",
      "numa_options"
    ],
    "type": "function"
  },
  "state": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "state_dict": {
    "description": "Returns a dictionary containing a whole state of the module.",
    "std_args": [
      "destination",
      "prefix",
      "keep_vars"
    ],
    "variants": {}
  },
  "state_dict_cache": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "state_dict_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "state_dict_metadata": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "state_dict_type": {
    "description": "Set the ``state_dict_type`` of all the descendant FSDP modules of the target module.",
    "std_args": [
      "module",
      "state_dict_type",
      "state_dict_config",
      "optim_state_dict_config"
    ],
    "type": "function"
  },
  "static_graph": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "statically_known_false": {
    "description": "Returns True if x can be simplified to a constant and is False.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "statically_known_true": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "file",
      "line"
    ],
    "type": "function"
  },
  "stats": {
    "description": "Returns detailed function counts.",
    "std_args": [
      "self",
      "inclusive"
    ],
    "type": "function"
  },
  "status": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "stddev": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "stderrs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "stdouts": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "step": {
    "description": "Performs a single optimization step.",
    "std_args": [],
    "variants": {}
  },
  "step_num": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "step_ratio": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "step_rec_fn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "step_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "steps": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "stmt": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "stmt_callgrind_out": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "stmt_exclusive_stats": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "stmt_inclusive_stats": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "stop": {
    "description": "Stops cuda profiler data collection.",
    "std_args": [],
    "type": "function"
  },
  "stop_etcd": {
    "description": "The class representing a Python function.",
    "std_args": [
      "subprocess",
      "data_dir"
    ],
    "type": "function"
  },
  "stopped": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "storage_alignment": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "storage_context": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "storage_data": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "storage_from_cache": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "key"
    ],
    "type": "function"
  },
  "storage_index": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "storage_meta": {
    "description": "Return the storage-specific metadata. This is used to store additional information",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "storage_offset": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "storage_offsets": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "storage_to_tensor_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "storage"
    ],
    "type": "function"
  },
  "store": {
    "description": "Store used by torchelastic control plane",
    "std_args": [],
    "type": "attribute"
  },
  "store_extra_data": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "rdzv_version",
      "key",
      "value"
    ],
    "type": "function"
  },
  "store_timeout": {
    "description": "This sets the timeout and then restores the old timeout when the context",
    "std_args": [
      "store",
      "timeout"
    ],
    "type": "function"
  },
  "str": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "str2bool": {
    "description": "ArgumentParser doesn't support type=bool. Thus, this helper method will convert",
    "std_args": [
      "v"
    ],
    "type": "function"
  },
  "str_hook": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "str_signature": {
    "description": "String representation of type signature",
    "std_args": [
      "sig"
    ],
    "type": "function"
  },
  "strategy": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "stream": {
    "description": "Wrap around the Context-manager StreamContext that selects a given stream.",
    "std_args": [
      "stream"
    ],
    "type": "function"
  },
  "stream_ctx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "strict": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "strict_fusion": {
    "description": "Give errors if not all nodes have been fused in inference, or symbolically differentiated in training.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "stride": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sub_label": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "subgroup": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "submod_name": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "submodule_inputs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "submodule_node": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "submodules": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "subprocess_handlers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "substitute": {
    "description": "The class representing a Python function.",
    "std_args": [
      "args",
      "local_rank"
    ],
    "type": "function"
  },
  "substitute_all_types": {
    "description": "Apply the most general unifier to all types in a graph",
    "std_args": [
      "graph",
      "mapping"
    ],
    "type": "function"
  },
  "substitute_in_graph": {
    "description": "Register a polyfill handler for a function, usually a C function from the C extension, to be",
    "std_args": [
      "original_fn",
      "can_constant_fold_through",
      "skip_signature_check"
    ],
    "type": "function"
  },
  "substitute_solution_one_type": {
    "description": "Apply the most general unifier to a type",
    "std_args": [
      "mapping",
      "t"
    ],
    "type": "function"
  },
  "subsystem": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "success": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "suffixes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sum_reducer": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "summarize": {
    "description": "Build TaskSpec portion of repr string for other containers.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "summon_full_params": {
    "description": "Expose full params for FSDP instances with this context manager.",
    "std_args": [
      "module",
      "recurse",
      "writeback",
      "rank0_only",
      "offload_to_cpu",
      "with_grads"
    ],
    "type": "function"
  },
  "super_signature": {
    "description": "A signature that would break ambiguities",
    "std_args": [
      "signatures"
    ],
    "type": "function"
  },
  "supercedes": {
    "description": "A is consistent and strictly more specific than B",
    "std_args": [
      "a",
      "b"
    ],
    "type": "function"
  },
  "support": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "supported_activities": {
    "description": "Returns a set of supported profiler tracing activities.",
    "std_args": [],
    "type": "function"
  },
  "supported_config_and_operators": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "supported_engines": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "supported_export_stacks_metrics": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "supports_complex": {
    "description": "Return true if reduce ops is supported. False otherwise.",
    "std_args": [
      "reduceOp"
    ],
    "type": "function"
  },
  "suppress_check_failures": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "suppress_guards": {
    "description": "Context manager to ignore all guards generated inside",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "swap": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "swap_tensors": {
    "description": "This function swaps the content of the two Tensor objects.",
    "std_args": [
      "t1",
      "t2"
    ],
    "type": "function"
  },
  "sym_and": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "function"
  },
  "sym_eq": {
    "description": "Like ==, but when run on list/tuple, it will recursively test equality",
    "std_args": [
      "x",
      "y"
    ],
    "type": "function"
  },
  "sym_float": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "sym_fresh_size": {
    "description": "The class representing a Python function.",
    "std_args": [
      "expr"
    ],
    "type": "function"
  },
  "sym_int": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "sym_ite": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "then_val",
      "else_val"
    ],
    "type": "function"
  },
  "sym_max": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "function"
  },
  "sym_min": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "function"
  },
  "sym_name": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sym_node_log": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sym_not": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "sym_or": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "function"
  },
  "sym_sqrt": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sym_sum": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "args"
    ],
    "type": "function"
  },
  "symbol_dict": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "symbol_iter": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "symbol_to_source": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "symbolic": {
    "description": "Create a symbolic FX operator to represent an arbitrary ONNX operator.",
    "std_args": [
      "domain_op",
      "inputs",
      "attrs",
      "dtype",
      "shape",
      "version",
      "metadata_props"
    ],
    "type": "function"
  },
  "symbolic_context": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "symbolic_multi_out": {
    "description": "Create a symbolic FX operator to represent an arbitrary ONNX operator with multiple outputs.",
    "std_args": [
      "domain_op",
      "inputs",
      "attrs",
      "dtypes",
      "shapes",
      "version",
      "metadata_props"
    ],
    "type": "function"
  },
  "symbolic_relations": {
    "description": "Infers algebraic relations",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "symbolic_trace": {
    "description": "The class representing a Python function.",
    "std_args": [
      "root",
      "meta_args",
      "concrete_args"
    ],
    "type": "function"
  },
  "symbols": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "symmetric": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "symnode_tracker": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sympy_expr_tracker": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sympy_is_channels_last_contiguous_2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "sizes",
      "strides"
    ],
    "type": "function"
  },
  "sympy_is_channels_last_contiguous_3d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "sizes",
      "strides"
    ],
    "type": "function"
  },
  "sympy_is_channels_last_strides_2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "sizes",
      "strides"
    ],
    "type": "function"
  },
  "sympy_is_channels_last_strides_3d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "sizes",
      "strides"
    ],
    "type": "function"
  },
  "sympy_is_channels_last_strides_generic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "sizes",
      "strides",
      "dim_order"
    ],
    "type": "function"
  },
  "sympy_is_contiguous": {
    "description": "The class representing a Python function.",
    "std_args": [
      "sizes",
      "strides"
    ],
    "type": "function"
  },
  "sympy_is_contiguous_generic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "sizes",
      "strides",
      "dim_order"
    ],
    "type": "function"
  },
  "synchronize_staging": {
    "description": "No-op function, since staging is blocking.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "sys_importer": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "table": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "sort_by",
      "row_limit",
      "max_src_column_width",
      "max_name_column_width",
      "max_shapes_column_width",
      "header",
      "top_level_events_only"
    ],
    "type": "function"
  },
  "tag": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tail": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tail_logfile": {
    "description": "The class representing a Python function.",
    "std_args": [
      "header",
      "file",
      "dst",
      "finished",
      "interval_sec"
    ],
    "type": "function"
  },
  "tangent": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "target": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "target_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "targets": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "task_spec": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tau": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tee_stderrs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tee_stdouts": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "temperature": {
    "description": "Return the average temperature of the GPU sensor in Degrees C (Centigrades).",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "tensor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tensor_constants": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tensor_data": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tensor_inference_rule": {
    "description": "If the tensor is a scalar, we will skip it since we",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "tensor_proto": {
    "description": "Outputs a `Summary` protocol buffer containing the full tensor.",
    "std_args": [
      "tag",
      "tensor"
    ],
    "type": "function"
  },
  "tensor_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tensor_source": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tensor_storage_offset": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tensor_storage_size": {
    "description": "Calculates the storage size of the underlying tensor, or None if this is not a tensor write.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "tensor_stride": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tensor_tracker": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tensor_type": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tensor_val": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tensorboard_trace_handler": {
    "description": "Outputs tracing files to directory of ``dir_name``, then that directory can be",
    "std_args": [
      "dir_name",
      "worker_name",
      "use_gzip"
    ],
    "type": "function"
  },
  "tensorinv": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tensors": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tensorsolve": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "test_pass_manager_builder": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_these_before_those_pass_constraint": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_this_before_that_pass_constraint": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_two_pass_managers": {
    "description": "Make sure we can construct the PassManager twice and not share any",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "text": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tag",
      "text"
    ],
    "type": "function"
  },
  "then": {
    "description": "Append the given callback function to this ``Future``, which will be run",
    "std_args": [
      "self",
      "callback"
    ],
    "type": "function"
  },
  "these_before_those_pass_constraint": {
    "description": "Defines a partial order ('depends on' function) where `these` must occur",
    "std_args": [
      "these",
      "those"
    ],
    "type": "function"
  },
  "this_before_that_pass_constraint": {
    "description": "Defines a partial order ('depends on' function) where `this` must occur",
    "std_args": [
      "this",
      "that"
    ],
    "type": "function"
  },
  "thread": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "thread_count": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "thread_count_consolidation": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "threshold_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "thunkify": {
    "description": "Delays computation of f until it's called again",
    "std_args": [
      "tracer",
      "f",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "time_cpu": {
    "description": "The class representing a Python function.",
    "std_args": [
      "fn",
      "inputs",
      "test_runs"
    ],
    "type": "function"
  },
  "time_cuda": {
    "description": "The class representing a Python function.",
    "std_args": [
      "fn",
      "inputs",
      "test_runs"
    ],
    "type": "function"
  },
  "time_range": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "timeit": {
    "description": "Mirrors the semantics of timeit.Timer.timeit().",
    "std_args": [
      "self",
      "number"
    ],
    "type": "function"
  },
  "timeout": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "timer": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "times": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "timestamp": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "timestamp_isoformat": {
    "description": "Return timestamp in ISO format (YYYY-MM-DD_HH:MM:SS).",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "title": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "to": {
    "description": "Move and/or cast the parameters and buffers.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "to_bool": {
    "description": "Called when a proxy object is being converted to a boolean, such as",
    "std_args": [
      "self",
      "obj"
    ],
    "type": "function"
  },
  "to_dense": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "to_dict": {
    "description": "Convert this ``FuseCustomConfig`` to a dictionary with the items described in",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "to_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "x",
      "dtype"
    ],
    "type": "function"
  },
  "to_empty": {
    "description": "Move the parameters and buffers to the specified device without copying storage.",
    "std_args": [
      "self",
      "device",
      "recurse"
    ],
    "type": "function"
  },
  "to_float": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "to_folder": {
    "description": "Dumps out module to ``folder`` with ``module_name`` so that it can be",
    "std_args": [
      "self",
      "folder",
      "module_name"
    ],
    "type": "function"
  },
  "to_json": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "to_kwargs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "inputs",
      "kwargs",
      "device_id"
    ],
    "type": "function"
  },
  "to_map": {
    "description": "Certain APIs take redirect settings either as a single value (e.g. apply to all",
    "std_args": [
      "val_or_map",
      "local_world_size"
    ],
    "type": "function"
  },
  "to_mkldnn": {
    "description": "The class representing a Python function.",
    "std_args": [
      "module",
      "dtype"
    ],
    "type": "function"
  },
  "to_node": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "num"
    ],
    "type": "function"
  },
  "to_padded_tensor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "to_sparse_semi_structured": {
    "description": "This function converts a dense tensor into a sparse semi-structured tensor.",
    "std_args": [
      "original_tensor",
      "transposed"
    ],
    "type": "function"
  },
  "to_str": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "to_string": {
    "description": "Returns a string representation of the block mask. Quite nifty.",
    "std_args": [
      "self",
      "grid_size",
      "limit"
    ],
    "type": "function"
  },
  "to_tensor": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "value"
    ],
    "type": "function"
  },
  "to_underlying_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "qdtype"
    ],
    "type": "function"
  },
  "to_z3_boolean_expr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "e"
    ],
    "type": "function"
  },
  "toggle_collection_dynamic": {
    "description": "Toggles the collection of activities for the current profiler instance.",
    "std_args": [
      "self",
      "enabled",
      "activities"
    ],
    "type": "function"
  },
  "tolist": {
    "description": "Return a list containing the elements of this storage.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "top_node_idx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "topo_sort": {
    "description": "The class representing a Python function.",
    "std_args": [
      "nodes"
    ],
    "type": "function"
  },
  "toq": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "torch.utils": {
    "description": "Torch Utilities Namespace",
    "std_args": []
  },
  "torch.utils.data": {
    "description": "Torch Data Utilities Namespace",
    "std_args": []
  },
  "torch_abs_override": {
    "description": "The class representing a Python function.",
    "std_args": [
      "input",
      "out"
    ],
    "type": "function"
  },
  "torch_dim_inference_rule": {
    "description": "The class representing a Python function.",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "torch_fn_counts": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "torch_fn_metadata": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "torch_linear_inference_rule": {
    "description": "The class representing a Python function.",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "torch_nn_relu_override": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "x"
    ],
    "type": "function"
  },
  "torch_relu_override": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "torch_save_to_dcp": {
    "description": "Given the location of a torch save file, converts it into a DCP checkpoint.",
    "std_args": [
      "torch_save_path",
      "dcp_checkpoint_dir"
    ],
    "type": "function"
  },
  "torch_where_override": {
    "description": "The class representing a Python function.",
    "std_args": [
      "condition",
      "x",
      "y"
    ],
    "type": "function"
  },
  "total_average": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "total_count": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "total_cpu_percent": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "total_device_percent": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "total_iters": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "total_numel_after_compression": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "total_numel_before_compression": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "total_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "total_steps": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "total_t": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "total_time_seconds": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "trace_asserts": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "trace_dependencies": {
    "description": "Trace the execution of a callable in order to determine which modules it uses.",
    "std_args": [
      "callable",
      "inputs"
    ],
    "type": "function"
  },
  "trace_id": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "trace_name": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "trace_shape_events_log": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "traced": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "traced_func_name": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "traced_params": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tracer": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tracing_mode": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "track_tensor": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tensor",
      "proxy",
      "constant",
      "tracer"
    ],
    "type": "function"
  },
  "track_tensor_tree": {
    "description": "The class representing a Python function.",
    "std_args": [
      "inner_res",
      "proxy_res",
      "constant",
      "tracer"
    ],
    "type": "function"
  },
  "tracked_fakes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tracker": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tracker_mode": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "train": {
    "description": "Batchnorm's training behavior is using the self.training flag. Prevent",
    "std_args": [
      "self",
      "mode"
    ],
    "type": "function"
  },
  "training": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "transfer_parametrizations_and_params": {
    "description": "Transfer parametrizations and the parameters they parametrize from :attr:`from_module` to :attr:`to_module`.",
    "std_args": [
      "from_module",
      "to_module",
      "tensor_name"
    ],
    "type": "function"
  },
  "transfer_rate_bytes_per_sec": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "transform": {
    "description": "Transform ``self.module`` and return the transformed",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "transform_algebraic_expression": {
    "description": "Transforms an algebraic expression to z3 format",
    "std_args": [
      "expr",
      "counter",
      "dimension_dict"
    ],
    "type": "function"
  },
  "transform_all_constraints": {
    "description": "Given a trace, generates constraints and transforms them to z3 format",
    "std_args": [
      "traced",
      "counter"
    ],
    "type": "function"
  },
  "transform_all_constraints_trace_time": {
    "description": "Takes a node and a graph and generates two sets of constraints.",
    "std_args": [
      "tracer_root",
      "graph",
      "node",
      "counter"
    ],
    "type": "function"
  },
  "transform_constraint": {
    "description": "Transforms a constraint into a simpler constraint.",
    "std_args": [
      "constraint",
      "counter"
    ],
    "type": "function"
  },
  "transform_dimension": {
    "description": "Takes a dimension variable or a number and transforms it to a tuple",
    "std_args": [
      "dimension",
      "counter",
      "dimension_dict"
    ],
    "type": "function"
  },
  "transform_for_annotation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "model"
    ],
    "type": "function"
  },
  "transform_get_item": {
    "description": "generate an equality of the form:",
    "std_args": [
      "constraint",
      "counter"
    ],
    "type": "function"
  },
  "transform_get_item_tensor": {
    "description": "When the index is a tuple, then the output will be a tensor",
    "std_args": [
      "constraint",
      "counter"
    ],
    "type": "function"
  },
  "transform_index_select": {
    "description": "The constraints consider the given tensor size, checks if the index is valid",
    "std_args": [
      "constraint",
      "counter"
    ],
    "type": "function"
  },
  "transform_object": {
    "description": "Extension from the planner interface to make it easy to extend the default planner.",
    "std_args": [
      "self",
      "write_item",
      "object"
    ],
    "type": "function"
  },
  "transform_tensor": {
    "description": "Extension from the planner interface to make it easy to extend the default planner.",
    "std_args": [
      "self",
      "read_item",
      "tensor"
    ],
    "type": "function"
  },
  "transform_to": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "transform_to_z3": {
    "description": "The class representing a Python function.",
    "std_args": [
      "constraint",
      "counter",
      "dimension_dict"
    ],
    "type": "function"
  },
  "transform_transpose": {
    "description": "Similar to a sequence of two index-selects",
    "std_args": [
      "constraint",
      "counter"
    ],
    "type": "function"
  },
  "transform_var": {
    "description": "Transforms tensor variables to a format understood by z3",
    "std_args": [
      "tensor",
      "counter",
      "dimension_dict"
    ],
    "type": "function"
  },
  "transformer_auto_wrap_policy": {
    "description": "See :func:`_module_wrap_policy`, where ``transformer_layer_cls`` is the",
    "std_args": [
      "module",
      "recurse",
      "nonwrapped_numel",
      "transformer_layer_cls"
    ],
    "type": "function"
  },
  "transforms": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "transitive_get": {
    "description": "Transitive dict.get",
    "std_args": [
      "key",
      "d"
    ],
    "type": "function"
  },
  "translation_validation_enabled": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "translation_validation_timeout": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "transpose_inference_rule": {
    "description": "Can be considered as a sequence of two index selects, so we generate constraints accordingly",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "traverse": {
    "description": "Traverse the DataPipes and their attributes to extract the DataPipe graph.",
    "std_args": [
      "datapipe",
      "only_datapipe"
    ],
    "type": "function"
  },
  "traverse_dps": {
    "description": "Traverse the DataPipes and their attributes to extract the DataPipe graph.",
    "std_args": [
      "datapipe"
    ],
    "type": "function"
  },
  "triangular_solve": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "tril_matrix_to_vec": {
    "description": "Convert a `D x D` matrix or a batch of matrices into a (batched) vector",
    "std_args": [
      "mat",
      "diag"
    ],
    "type": "function"
  },
  "trim_sigfig": {
    "description": "Trim `x` to `n` significant figures. (e.g. 3.14159, 2 -> 3.10000)",
    "std_args": [
      "x",
      "n"
    ],
    "type": "function"
  },
  "trim_significant_figures": {
    "description": "Enables trimming of significant figures when building the formatted table.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "triplet_margin_loss": {
    "description": "Compute the triplet loss between given input tensors and a margin greater than 0.",
    "std_args": [
      "anchor",
      "positive",
      "negative",
      "margin",
      "p",
      "eps",
      "swap",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "triplet_margin_with_distance_loss": {
    "description": "Compute the triplet margin loss for input tensors using a custom distance function.",
    "std_args": [
      "anchor",
      "positive",
      "negative",
      "distance_function",
      "margin",
      "swap",
      "reduction"
    ],
    "type": "function"
  },
  "truediv": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "function"
  },
  "trunc_normal_": {
    "description": "Fill the input Tensor with values drawn from a truncated normal distribution.",
    "std_args": [
      "tensor",
      "mean",
      "std",
      "a",
      "b",
      "generator"
    ],
    "type": "function"
  },
  "trunc_to_int": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "x",
      "dtype"
    ],
    "type": "function"
  },
  "truncate_rows": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "try_acquire": {
    "description": "Try to atomically create a file under exclusive access.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "try_ann_to_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ann",
      "loc",
      "rcb"
    ],
    "type": "function"
  },
  "try_create_rendezvous": {
    "description": "Create new rendezvous state or raise an exception that indicates an unexpected state (e.g. already exists).",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "try_real_annotations": {
    "description": "Try to use the Py3.5+ annotation syntax to get the type.",
    "std_args": [
      "fn",
      "loc"
    ],
    "type": "function"
  },
  "try_wait_for_state_change": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "etcd_index",
      "timeout"
    ],
    "type": "function"
  },
  "tune_gemm_in_file": {
    "description": "tune GEMM in file.",
    "std_args": [
      "filename"
    ],
    "type": "function"
  },
  "tuning_enable": {
    "description": "Enable tuning of TunableOp implementations.",
    "std_args": [
      "val"
    ],
    "type": "function"
  },
  "tuning_is_enabled": {
    "description": "Returns whether TunableOp implementations can be tuned.",
    "std_args": [],
    "type": "function"
  },
  "tvar": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "type": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "type_before_parametrizations": {
    "description": "Return the module type before parametrizations were applied and if not, then it returns the module type.",
    "std_args": [
      "module"
    ],
    "type": "function"
  },
  "type_check": {
    "description": "A gradual type checker for graphs",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "type_check_node": {
    "description": "Type check a given fx node.",
    "std_args": [
      "self",
      "n"
    ],
    "type": "function"
  },
  "type_inference_rule": {
    "description": "We generate the constraint: input = output",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "type_matches": {
    "description": "The class representing a Python function.",
    "std_args": [
      "signature_type",
      "argument_type"
    ],
    "type": "function"
  },
  "typename": {
    "description": "Get the name of `type`.",
    "std_args": [
      "type"
    ],
    "type": "function"
  },
  "unary": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "fn",
      "data",
      "mask"
    ],
    "type": "function"
  },
  "unary_magic_methods": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "unary_methods": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "unary_nonmagic_methods": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "unbacked_sources": {
    "description": "Comma delimited list of sources that should be marked as unbacked. Primarily useful for large",
    "std_args": [],
    "type": "attribute"
  },
  "unbatch": {
    "description": "Undos batching of data (functional name: ``unbatch``).",
    "std_args": [
      "self",
      "unbatch_level"
    ],
    "type": "function"
  },
  "unbatch_level": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "unflatten": {
    "description": "Unflatten an ExportedProgram, producing a module with the same module",
    "std_args": [
      "module",
      "flat_args_adapter"
    ],
    "type": "function"
  },
  "unflattened_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "unfold": {
    "description": "Extract sliding local blocks from a batched input tensor.",
    "std_args": [
      "input",
      "kernel_size",
      "dilation",
      "padding",
      "stride"
    ],
    "type": "function"
  },
  "unifiable": {
    "description": "Register standard unify and reify operations on class",
    "std_args": [
      "cls"
    ],
    "type": "function"
  },
  "uniform": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "uniform_": {
    "description": "Fill the input Tensor with values drawn from the uniform distribution.",
    "std_args": [
      "tensor",
      "a",
      "b",
      "generator"
    ],
    "type": "function"
  },
  "unify": {
    "description": "The class representing a Python function.",
    "std_args": [
      "u",
      "v"
    ],
    "type": "function"
  },
  "unify_eq": {
    "description": "Apply unification to a set of",
    "std_args": [
      "list_of_eq"
    ],
    "type": "function"
  },
  "unify_object": {
    "description": "Unify two Python objects",
    "std_args": [
      "u",
      "v",
      "s"
    ],
    "type": "function"
  },
  "uninteresting_files": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "unique_consecutive": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "unique_id": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "unit_interval": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "unit_to_english": {
    "description": "The class representing a Python function.",
    "std_args": [
      "u"
    ],
    "type": "function"
  },
  "unop_map": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "unpack_dual": {
    "description": "Unpack a \"dual tensor\" to get both its Tensor value and its forward AD gradient.",
    "std_args": [
      "tensor",
      "level"
    ],
    "type": "function"
  },
  "unpack_hook": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "unpack_sequence": {
    "description": "Unpack PackedSequence into a list of variable length Tensors.",
    "std_args": [
      "packed_sequences"
    ],
    "type": "function"
  },
  "unpad_sequence": {
    "description": "Unpad padded Tensor into a list of variable length Tensors.",
    "std_args": [
      "padded_sequences",
      "lengths",
      "batch_first"
    ],
    "type": "function"
  },
  "unravel_index": {
    "description": "Converts a tensor of flat indices into a tuple of coordinate tensors that",
    "std_args": [
      "indices",
      "shape"
    ],
    "type": "function"
  },
  "unregister_callback": {
    "description": "Removes ET observer from record function callbacks.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "unsafe": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "unscale_": {
    "description": "Divides (\"unscales\") the optimizer's gradient tensors by the scale factor.",
    "std_args": [
      "self",
      "optimizer"
    ],
    "type": "function"
  },
  "unserializable_hook": {
    "description": "Mark a function as an unserializable hook with this decorator.",
    "std_args": [
      "f"
    ],
    "type": "function"
  },
  "unsorted_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "untyped": {
    "description": "Return the internal :class:`torch.UntypedStorage`.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "unwrap_all": {
    "description": "The class representing a Python function.",
    "std_args": [
      "globals"
    ],
    "type": "function"
  },
  "unwrap_proxy": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "e"
    ],
    "type": "function"
  },
  "update": {
    "description": "Update the scale factor.",
    "std_args": [
      "self",
      "new_scale"
    ],
    "type": "function"
  },
  "update_arg": {
    "description": "Update an existing positional argument to contain the new value",
    "std_args": [
      "self",
      "idx",
      "arg"
    ],
    "type": "function"
  },
  "update_bn": {
    "description": "Update BatchNorm running_mean, running_var buffers in the model.",
    "std_args": [
      "loader",
      "model",
      "device"
    ],
    "type": "function"
  },
  "update_bn_stats": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "update_equivalent_types_dict": {
    "description": "Help function for user who wants to customize the _EQUIVALENT_TYPES and _EQUIVALENT_TYPES_DICT.",
    "std_args": [
      "customized_equivalent_types"
    ],
    "type": "function"
  },
  "update_in": {
    "description": "Update value in a (potentially) nested dictionary",
    "std_args": [
      "d",
      "keys",
      "func",
      "default",
      "factory"
    ],
    "type": "function"
  },
  "update_kwarg": {
    "description": "Update an existing keyword argument to contain the new value",
    "std_args": [
      "self",
      "key",
      "arg"
    ],
    "type": "function"
  },
  "update_mask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "module",
      "tensor_name",
      "nearliness",
      "kwargs"
    ],
    "type": "function"
  },
  "update_parameters": {
    "description": "Update model parameters.",
    "std_args": [
      "self",
      "model"
    ],
    "type": "function"
  },
  "upload_completion": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "upper": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "upsample_bilinear": {
    "description": "Upsamples the input, using bilinear upsampling.",
    "std_args": [
      "input",
      "size",
      "scale_factor"
    ],
    "type": "function"
  },
  "upsample_nearest": {
    "description": "Upsamples the input, using nearest neighbours' pixel values.",
    "std_args": [
      "input",
      "size",
      "scale_factor"
    ],
    "type": "function"
  },
  "upsample_rate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "upscale_factor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "usable": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_agent_store": {
    "description": "See base class.",
    "std_args": [],
    "type": "attribute"
  },
  "use_async_staging": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_beta1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_buffers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_collectives": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_count": {
    "description": "Returns the reference count of this pool.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "use_cpu": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_cuda": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_deterministic_algorithms": {
    "description": "Sets whether PyTorch operations must use \"deterministic\"",
    "std_args": [
      "mode",
      "warn_only"
    ],
    "type": "function"
  },
  "use_device": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_error_feedback": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_local_output": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_mem_pool": {
    "description": "A context manager that routes allocations to a given pool.",
    "std_args": [
      "pool",
      "device"
    ],
    "type": "function"
  },
  "use_mkl_length": {
    "description": "This is a heuristic that can be passed into `optimize_for_inference` that",
    "std_args": [
      "graph"
    ],
    "type": "function"
  },
  "use_nested_tensor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_ninja": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_non_blocking_copy": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_pinned_memory": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_pinned_memory_for_d2h": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_shared_memory": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_side_stream_for_tensor_copies": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "used_mem_bytes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "user_hooks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "user_inputs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "user_inputs_to_mutate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "user_outputs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "user_pre_hooks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "user_to_last_uses": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "users": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "utilization": {
    "description": "Return the percent of time over the past sample period during which one or",
    "std_args": [
      "device"
    ],
    "type": "function"
  },
  "v_proj_weight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "val": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "valfilter": {
    "description": "Filter items in dictionary by value",
    "std_args": [
      "predicate",
      "d",
      "factory"
    ],
    "type": "function"
  },
  "valid_index": {
    "description": "Given a list of dimensions, checks if an index is valid in the list",
    "std_args": [
      "index",
      "dims"
    ],
    "type": "function"
  },
  "valid_index_tensor": {
    "description": "if the slice instances exceed the length of the dimensions",
    "std_args": [
      "index",
      "dims"
    ],
    "type": "function"
  },
  "validate": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "model"
    ],
    "type": "function"
  },
  "validate_checkpoint_id": {
    "description": "Implementation of the StorageReader method",
    "std_args": [
      "cls",
      "checkpoint_id"
    ],
    "type": "function"
  },
  "validate_constraints": {
    "description": "Validates that current pass schedule defined by `self.passes` is valid",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "validate_cuda_device": {
    "description": "The class representing a Python function.",
    "std_args": [
      "location"
    ],
    "type": "function"
  },
  "validate_hpu_device": {
    "description": "The class representing a Python function.",
    "std_args": [
      "location"
    ],
    "type": "function"
  },
  "validate_input_col": {
    "description": "Check that function used in a callable datapipe works with the input column.",
    "std_args": [
      "fn",
      "input_col"
    ],
    "type": "function"
  },
  "validate_partition": {
    "description": "The class representing a Python function.",
    "std_args": [
      "partition"
    ],
    "type": "function"
  },
  "validate_pathname_binary_tuple": {
    "description": "The class representing a Python function.",
    "std_args": [
      "data"
    ],
    "type": "function"
  },
  "validate_qmin_qmax": {
    "description": "Validates that the user-specified quantization range is properly initialized",
    "std_args": [
      "quant_min",
      "quant_max"
    ],
    "type": "function"
  },
  "validator": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "valmap": {
    "description": "Apply function to values of dictionary",
    "std_args": [
      "func",
      "d",
      "factory"
    ],
    "type": "function"
  },
  "value": {
    "description": "Obtain the value of an already-completed future.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "value_and_grad": {
    "description": "Creates a function that evaluates both 'func' and the gradient of 'func'.",
    "std_args": [
      "func",
      "argnums",
      "has_aux"
    ],
    "variants": {}
  },
  "values": {
    "description": "Return an iterable of the ParameterDict values.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "vander": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "variables": {
    "description": "Context manager for logic variables",
    "std_args": [
      "variables"
    ],
    "type": "function"
  },
  "variadic_signature_matches": {
    "description": "The class representing a Python function.",
    "std_args": [
      "types",
      "full_signature"
    ],
    "type": "function"
  },
  "variadic_signature_matches_iter": {
    "description": "Check if a set of input types matches a variadic signature.",
    "std_args": [
      "types",
      "full_signature"
    ],
    "type": "function"
  },
  "variance": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "variant": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "vars": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "vdim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "vec_to_tril_matrix": {
    "description": "Convert a vector or a batch of vectors into a batched `D x D`",
    "std_args": [
      "vec",
      "diag"
    ],
    "type": "function"
  },
  "vector_to_parameters": {
    "description": "Copy slices of a vector into an iterable of parameters.",
    "std_args": [
      "vec",
      "parameters"
    ],
    "type": "function"
  },
  "verbose": {
    "description": "On-demand oneMKL verbosing functionality.",
    "std_args": [
      "self",
      "enable"
    ],
    "type": "class"
  },
  "verbose_progress": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "verifier": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "verifiers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "verify": {
    "description": "Verifies that an exported program is valid for each additional input.",
    "std_args": [
      "self",
      "ep"
    ],
    "type": "function"
  },
  "verify_ninja_availability": {
    "description": "Raise ``RuntimeError`` if `ninja <https://ninja-build.org/>`_ build system is not available on the system, does nothing otherwise.",
    "std_args": [],
    "type": "function"
  },
  "version": {
    "description": "Return the version of cuDNN.",
    "std_args": [],
    "type": "function"
  },
  "vhp": {
    "description": "Compute the dot product between vector ``v`` and Hessian of a  given scalar function at a specified point.",
    "std_args": [
      "func",
      "inputs",
      "v",
      "create_graph",
      "strict"
    ],
    "type": "function"
  },
  "video": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tag",
      "tensor",
      "fps"
    ],
    "type": "function"
  },
  "videohandler": {
    "description": "The class representing a Python function.",
    "std_args": [
      "extension",
      "data"
    ],
    "type": "function"
  },
  "view_base_context": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "view_inference_rule": {
    "description": "Similar to reshape but with an extra condition on the strides",
    "std_args": [
      "n",
      "symbols",
      "constraints",
      "counter"
    ],
    "type": "function"
  },
  "visit_AnnAssign": {
    "description": "Swap out Python's AnnAssign with an Assign node where the annotation function is called.",
    "std_args": [
      "self",
      "node"
    ],
    "type": "function"
  },
  "visit_Assert": {
    "description": "Swap out the Assert node (Python's `assert`) with a callsite to the",
    "std_args": [
      "self",
      "node"
    ],
    "type": "function"
  },
  "vjp": {
    "description": "Compute the dot product between a vector ``v`` and the Jacobian of the given function at the point given by the inputs.",
    "std_args": [
      "func",
      "inputs",
      "v",
      "create_graph",
      "strict"
    ],
    "type": "function"
  },
  "vmap": {
    "description": "Vectorizing map. Creates a function which maps 'func' over argument axes.",
    "std_args": [
      "func",
      "in_axes",
      "out_axes",
      "randomness"
    ],
    "variants": {}
  },
  "vr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "wait": {
    "description": "Make all future work submitted to the given stream wait for this event.",
    "std_args": [
      "self",
      "stream"
    ],
    "type": "function"
  },
  "wait_all": {
    "description": "Waits for all provided futures to be complete, and returns",
    "std_args": [
      "futures"
    ],
    "type": "function"
  },
  "wait_event": {
    "description": "Make all future work submitted to the stream wait for an event.",
    "std_args": [
      "self",
      "event"
    ],
    "type": "function"
  },
  "wait_for_final": {
    "description": "Helper method for the confirm phase.",
    "std_args": [
      "self",
      "expected_version"
    ],
    "type": "function"
  },
  "wait_for_peers": {
    "description": "Helper method for the join phase.",
    "std_args": [
      "self",
      "expected_version"
    ],
    "type": "function"
  },
  "wait_for_rendezvous_to_free": {
    "description": "When there's an existing valid rendezvous in state 'final', we have to wait until the next opportunity to join.",
    "std_args": [
      "self",
      "expected_version"
    ],
    "type": "function"
  },
  "wait_seconds": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "wait_stream": {
    "description": "Synchronize with another stream.",
    "std_args": [
      "self",
      "stream"
    ],
    "type": "function"
  },
  "warm_start": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "warmup_steps": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "warn_after_seconds": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "warn_if_has_hooks": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tensor"
    ],
    "type": "function"
  },
  "warn_only": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "warning_text": {
    "description": "The text for ambiguity warnings",
    "std_args": [
      "name",
      "amb"
    ],
    "type": "function"
  },
  "waves_per_eu": {
    "description": "ROCm-specific waves per execution unit.",
    "std_args": [],
    "type": "attribute"
  },
  "weight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "weight_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "weight_dtype_with_constraints": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "weight_fake_quant": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "weight_hh": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "weight_ih": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "weight_is_quantized": {
    "description": "Given a qconfig, decide if the weight needs to be",
    "std_args": [
      "qconfig"
    ],
    "type": "function"
  },
  "weight_is_statically_quantized": {
    "description": "Given a qconfig, decide if the weight needs to be statically",
    "std_args": [
      "qconfig"
    ],
    "type": "function"
  },
  "weight_norm": {
    "description": "Apply weight normalization to a parameter in the given module.",
    "std_args": [
      "module",
      "name",
      "dim"
    ],
    "type": "function"
  },
  "weight_observer_range_neg_127_to_127": {
    "description": "Symmetric weight observer with the 8-bit values restricted to [-127, +127], excluding -128.",
    "std_args": [],
    "type": "attribute"
  },
  "weight_only_quint4x2_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "weight_only_quint8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "weighted_op_quint8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "weights": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "will_sync_module_buffers": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "window_common_args": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "with_args": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "with_cache": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "cache_size"
    ],
    "type": "function"
  },
  "with_callable_args": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "with_flops": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "with_kwargs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "with_modules": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "with_options": {
    "description": "Return a subclass with alternative constructor that extends any original keyword arguments to the original constructor with the given options.",
    "std_args": [
      "cls",
      "options"
    ],
    "type": "function"
  },
  "with_shape_env": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "shape_env"
    ],
    "type": "function"
  },
  "with_stack": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "worker_id": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "worker_init_fn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "worker_main": {
    "description": "This is a context manager that wraps your main entry function. This combines",
    "std_args": [],
    "type": "function"
  },
  "worker_pid": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "workers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "world_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "wrap": {
    "description": "Annotate that a module should be wrapped. Annotated modules will only be",
    "std_args": [
      "module",
      "wrap_overrides"
    ],
    "type": "function"
  },
  "wrap_bool": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "num"
    ],
    "type": "function"
  },
  "wrap_float": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "num"
    ],
    "type": "function"
  },
  "wrap_int": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "num"
    ],
    "type": "function"
  },
  "wrap_key": {
    "description": "The class representing a Python function.",
    "std_args": [
      "f",
      "tensors",
      "tracer",
      "pre_dispatch"
    ],
    "type": "function"
  },
  "wrap_node": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "wrap_numpy": {
    "description": "Decorator that turns a function from ``np.ndarray``s to ``np.ndarray``s into a function",
    "std_args": [
      "fn"
    ],
    "type": "function"
  },
  "wrap_torch_function": {
    "description": "Wraps a given function with ``__torch_function__`` -related functionality.",
    "std_args": [
      "dispatcher"
    ],
    "type": "function"
  },
  "wrapped": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "wrapper_and_args_for_make_fx": {
    "description": "The class representing a Python function.",
    "std_args": [
      "func",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "wrapper_class": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "wrapper_singleton": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "write_data": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "plan",
      "planner"
    ],
    "type": "function"
  },
  "write_file": {
    "description": "Write results to a CSV file.",
    "std_args": [
      "filename"
    ],
    "type": "function"
  },
  "write_file_on_exit": {
    "description": "During Tuning Context destruction, write file to disk.",
    "std_args": [
      "val"
    ],
    "type": "function"
  },
  "writer": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "x86_default_dynamic_float16_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "x86_default_dynamic_int8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "x86_default_op_fp16_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "x86_default_op_quint8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "x86_weight_only_quint4x2_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "x86_weight_only_quint8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "x86_weighted_op_int8_dtype_config": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "xavier_normal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "xavier_normal_": {
    "description": "Fill the input `Tensor` with values using a Xavier normal distribution.",
    "std_args": [
      "tensor",
      "gain",
      "generator"
    ],
    "type": "function"
  },
  "xavier_uniform": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "xavier_uniform_": {
    "description": "Fill the input `Tensor` with values using a Xavier uniform distribution.",
    "std_args": [
      "tensor",
      "gain",
      "generator"
    ],
    "type": "function"
  },
  "xfail": {
    "description": "The class representing a Python function.",
    "std_args": [
      "func"
    ],
    "type": "function"
  },
  "xlog1py": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "xlogy": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "xpu": {
    "description": "Move all model parameters and buffers to the XPU.",
    "std_args": [
      "self",
      "device"
    ],
    "type": "function"
  },
  "z3_dyn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "z3op": {
    "description": "The class representing a Python function.",
    "std_args": [
      "op",
      "validator"
    ],
    "type": "function"
  },
  "z3str": {
    "description": "The class representing a Python function.",
    "std_args": [
      "e"
    ],
    "type": "function"
  },
  "z3var": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "symbol"
    ],
    "type": "function"
  },
  "zero_grad": {
    "description": "Sets the gradients of all optimized torch.Tensor s to zero.",
    "std_args": [],
    "variants": {}
  },
  "zero_infinity": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "zero_point": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "zero_point_domain": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "zero_point_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "zero_point_exact_match": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "zeros_": {
    "description": "Fill the input Tensor with the scalar value `0`.",
    "std_args": [
      "tensor"
    ],
    "type": "function"
  },
  "zeta": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "zip": {
    "description": "Aggregates elements into a tuple from each of the input DataPipes (functional name: ``zip``).",
    "std_args": [
      "self",
      "datapipes"
    ],
    "type": "function"
  },
  "zip_file": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "zip_reader": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  }
}