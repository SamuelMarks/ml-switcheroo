{
  "A": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "A1": {
    "description": "Return `self` as a flattened `ndarray`.",
    "std_args": [],
    "type": "attribute"
  },
  "ALiBi": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "ARRAY_ATTR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ARRAY_SHAPES_TO_TEST": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ASSIGN": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ATTRIBUTE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "AbstractVariable": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "var_type"
    ],
    "type": "class"
  },
  "Accuracy": {
    "description": "Accuracy metric. This metric subclasses :class:`Average`,",
    "std_args": [
      "self",
      "threshold",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "ActivityRegularization": {
    "description": "Layer that applies an update to the cost function based input activity.\n\nArgs:\n    l1: L1 regularization factor (positive float).\n    l2: L2 regularization factor (positive float).\n\nInput shape:\n    Arbitrary. Use the keyword argument `input_shape`\n    (tuple of integers, does not include the samples axis)\n    when using this layer as the first layer in a model.\n\nOutput shape:\n    Same shape as input.",
    "std_args": [
      "l1",
      "l2",
      "kwargs"
    ],
    "type": "class"
  },
  "Adadelta": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "eps",
      "lr",
      "rho",
      "weight_decay"
    ],
    "type": "class"
  },
  "Adafactor": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "lr",
      "weight_decay"
    ],
    "type": "class"
  },
  "Adagrad": {
    "description": "Auto-discovered via Consensus (Score: 4.0)",
    "std_args": [
      "eps",
      "initial_accumulator_value",
      "lr"
    ],
    "type": "class"
  },
  "Adam": {
    "description": "Auto-discovered via Consensus (Score: 4.0)",
    "std_args": [
      "eps",
      "lr"
    ],
    "type": "class"
  },
  "Adamax": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "eps",
      "lr",
      "weight_decay"
    ],
    "type": "class"
  },
  "Adamw": {
    "description": "Auto-discovered via Consensus (Score: 4.0)",
    "std_args": [
      "eps",
      "lr",
      "weight_decay"
    ],
    "type": "class"
  },
  "AdaptiveAveragePooling1D": {
    "description": "Adaptive average pooling operation for 1D temporal or spatial data.\n\nThis layer applies an adaptive average pooling operation, which pools the\ninput such that the output has a target length specified by `output_size`,\nregardless of the input length. The kernel size and stride are automatically\ncomputed to achieve the target output size.\n\nArgs:\n    output_size: Integer specifying the target output length.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        `\"channels_last\"` corresponds to inputs with shape\n        `(batch, length, channels)`.\n        `\"channels_first\"` corresponds to inputs with shape\n        `(batch, channels, length)`.\n        Defaults to the value found in your Keras config file at\n        `~/.keras/keras.json`. If never set, `\"channels_last\"` is used.\n\nInput shape:\n    - If `data_format=\"channels_last\"`: 3D tensor\n        `(batch_size, length, channels)`\n    - If `data_format=\"channels_first\"`: 3D tensor\n        `(batch_size, channels, length)`\n\nOutput shape:\n    - If `data_format=\"channels_last\"`:\n        `(batch_size, output_length, channels)`\n    - If `data_format=\"channels_first\"`:\n        `(batch_size, channels, output_length)`\n\nExamples:\n    >>> import numpy as np\n    >>> input_seq = np.random.rand(1, 64, 3)\n    >>> layer = AdaptiveAveragePooling1D(output_size=32)\n    >>> output_seq = layer(input_seq)\n    >>> output_seq.shape\n    (1, 32, 3)",
    "std_args": [
      "output_size",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "AdaptiveAveragePooling2D": {
    "description": "Adaptive average pooling operation for 2D spatial data.\n\nThis layer applies an adaptive average pooling operation, which pools the\ninput such that the output has a target spatial size specified by\n`output_size`, regardless of the input spatial size. The kernel size\nand stride are automatically computed to achieve the target output size.\n\nArgs:\n    output_size: Integer or tuple of 2 integers specifying the\n        target output size.\n        If an integer, the same value is used for both height and width.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        `\"channels_last\"` corresponds to inputs with shape\n        `(batch, height, width, channels)`.\n        `\"channels_first\"` corresponds to inputs with shape\n        `(batch, channels, height, width)`.\n        Defaults to the value found in your Keras config file at\n        `~/.keras/keras.json`. If never set, `\"channels_last\"` is used.\n\nInput shape:\n    - If `data_format=\"channels_last\"`: 4D tensor\n        `(batch_size, height, width, channels)`\n    - If `data_format=\"channels_first\"`: 4D tensor\n        `(batch_size, channels, height, width)`\n\nOutput shape:\n    - If `data_format=\"channels_last\"`:\n        `(batch_size, output_height, output_width, channels)`\n    - If `data_format=\"channels_first\"`:\n        `(batch_size, channels, output_height, output_width)`\n\nExamples:\n    >>> import numpy as np\n    >>> input_img = np.random.rand(1, 64, 64, 3)\n    >>> layer = AdaptiveAveragePooling2D(output_size=32)\n    >>> output_img = layer(input_img)\n    >>> output_img.shape\n    (1, 32, 32, 3)",
    "std_args": [
      "output_size",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "AdaptiveAveragePooling3D": {
    "description": "Adaptive average pooling operation for 3D volumetric data.\n\nThis layer applies an adaptive average pooling operation, which pools the\ninput such that the output has a target spatial size specified by\n`output_size`, regardless of the input spatial size. The kernel size\nand stride are automatically computed to achieve the target output size.\n\nArgs:\n    output_size: Integer or tuple of 3 integers specifying the\n        target output size.\n        If an integer, the same value is used for depth, height, and width.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        `\"channels_last\"` corresponds to inputs with shape\n        `(batch, depth, height, width, channels)`.\n        `\"channels_first\"` corresponds to inputs with shape\n        `(batch, channels, depth, height, width)`.\n        Defaults to the value found in your Keras config file at\n        `~/.keras/keras.json`. If never set, `\"channels_last\"` is used.\n\nInput shape:\n    - If `data_format=\"channels_last\"`: 5D tensor\n        `(batch_size, depth, height, width, channels)`\n    - If `data_format=\"channels_first\"`: 5D tensor\n        `(batch_size, channels, depth, height, width)`\n\nOutput shape:\n    - If `data_format=\"channels_last\"`:\n        `(batch_size, output_depth, output_height, output_width, channels)`\n    - If `data_format=\"channels_first\"`:\n        `(batch_size, channels, output_depth, output_height, output_width)`\n\nExamples:\n    >>> import numpy as np\n    >>> input_vol = np.random.rand(1, 32, 32, 32, 3)\n    >>> layer = AdaptiveAveragePooling3D(output_size=16)\n    >>> output_vol = layer(input_vol)\n    >>> output_vol.shape\n    (1, 16, 16, 16, 3)",
    "std_args": [
      "output_size",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "AdaptiveAvgPool1d": {
    "description": "Applies a 1D adaptive average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "output_size"
    ],
    "type": "class"
  },
  "AdaptiveAvgPool2d": {
    "description": "Applies a 2D adaptive average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "output_size"
    ],
    "type": "class"
  },
  "AdaptiveAvgPool3d": {
    "description": "Applies a 3D adaptive average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "output_size"
    ],
    "type": "class"
  },
  "AdaptiveGradClipState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "AdaptiveLogSoftmaxWithLoss": {
    "description": "Efficient softmax approximation.",
    "std_args": [
      "self",
      "in_features",
      "n_classes",
      "cutoffs",
      "div_value",
      "head_bias",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "AdaptiveMaxPool1d": {
    "description": "Applies a 1D adaptive max pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "output_size",
      "return_indices"
    ],
    "type": "class"
  },
  "AdaptiveMaxPool2d": {
    "description": "Applies a 2D adaptive max pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "output_size",
      "return_indices"
    ],
    "type": "class"
  },
  "AdaptiveMaxPool3d": {
    "description": "Applies a 3D adaptive max pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "output_size",
      "return_indices"
    ],
    "type": "class"
  },
  "AdaptiveMaxPooling1D": {
    "description": "Adaptive max pooling operation for 1D temporal or spatial data.\n\nThis layer applies an adaptive max pooling operation, which pools the\ninput such that the output has a target length specified by `output_size`,\nregardless of the input length. The kernel size and stride are automatically\ncomputed to achieve the target output size.\n\nArgs:\n    output_size: Integer specifying the target output length.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        `\"channels_last\"` corresponds to inputs with shape\n        `(batch, length, channels)`.\n        `\"channels_first\"` corresponds to inputs with shape\n        `(batch, channels, length)`.\n        Defaults to the value found in your Keras config file at\n        `~/.keras/keras.json`. If never set, `\"channels_last\"` is used.\n\nInput shape:\n    - If `data_format=\"channels_last\"`: 3D tensor\n        `(batch_size, length, channels)`\n    - If `data_format=\"channels_first\"`: 3D tensor\n        `(batch_size, channels, length)`\n\nOutput shape:\n    - If `data_format=\"channels_last\"`:\n        `(batch_size, output_length, channels)`\n    - If `data_format=\"channels_first\"`:\n        `(batch_size, channels, output_length)`\n\nExamples:\n    >>> import numpy as np\n    >>> input_seq = np.random.rand(1, 64, 3)\n    >>> layer = AdaptiveMaxPooling1D(output_size=32)\n    >>> output_seq = layer(input_seq)\n    >>> output_seq.shape\n    (1, 32, 3)",
    "std_args": [
      "output_size",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "AdaptiveMaxPooling2D": {
    "description": "Adaptive max pooling operation for 2D spatial data.\n\nThis layer applies an adaptive max pooling operation, which pools the\ninput such that the output has a target spatial size specified by\n`output_size`, regardless of the input spatial size. The kernel size\nand stride are automatically computed to achieve the target output size.\n\nArgs:\n    output_size: Integer or tuple of 2 integers specifying the\n        target output size.\n        If an integer, the same value is used for both height and width.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        `\"channels_last\"` corresponds to inputs with shape\n        `(batch, height, width, channels)`.\n        `\"channels_first\"` corresponds to inputs with shape\n        `(batch, channels, height, width)`.\n        Defaults to the value found in your Keras config file at\n        `~/.keras/keras.json`. If never set, `\"channels_last\"` is used.\n\nInput shape:\n    - If `data_format=\"channels_last\"`: 4D tensor\n        `(batch_size, height, width, channels)`\n    - If `data_format=\"channels_first\"`: 4D tensor\n        `(batch_size, channels, height, width)`\n\nOutput shape:\n    - If `data_format=\"channels_last\"`:\n        `(batch_size, output_height, output_width, channels)`\n    - If `data_format=\"channels_first\"`:\n        `(batch_size, channels, output_height, output_width)`\n\nExamples:\n    >>> import numpy as np\n    >>> input_img = np.random.rand(1, 64, 64, 3)\n    >>> layer = AdaptiveMaxPooling2D(output_size=32)\n    >>> output_img = layer(input_img)\n    >>> output_img.shape\n    (1, 32, 32, 3)",
    "std_args": [
      "output_size",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "AdaptiveMaxPooling3D": {
    "description": "Adaptive max pooling operation for 3D volumetric data.\n\nThis layer applies an adaptive max pooling operation, which pools the\ninput such that the output has a target spatial size specified by\n`output_size`, regardless of the input spatial size. The kernel size\nand stride are automatically computed to achieve the target output size.\n\nArgs:\n    output_size: Integer or tuple of 3 integers specifying the\n        target output size.\n        If an integer, the same value is used for depth, height, and width.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        `\"channels_last\"` corresponds to inputs with shape\n        `(batch, depth, height, width, channels)`.\n        `\"channels_first\"` corresponds to inputs with shape\n        `(batch, channels, depth, height, width)`.\n        Defaults to the value found in your Keras config file at\n        `~/.keras/keras.json`. If never set, `\"channels_last\"` is used.\n\nInput shape:\n    - If `data_format=\"channels_last\"`: 5D tensor\n        `(batch_size, depth, height, width, channels)`\n    - If `data_format=\"channels_first\"`: 5D tensor\n        `(batch_size, channels, depth, height, width)`\n\nOutput shape:\n    - If `data_format=\"channels_last\"`:\n        `(batch_size, output_depth, output_height, output_width, channels)`\n    - If `data_format=\"channels_first\"`:\n        `(batch_size, channels, output_depth, output_height, output_width)`\n\nExamples:\n    >>> import numpy as np\n    >>> input_vol = np.random.rand(1, 32, 32, 32, 3)\n    >>> layer = AdaptiveMaxPooling3D(output_size=16)\n    >>> output_vol = layer(input_vol)\n    >>> output_vol.shape\n    (1, 16, 16, 16, 3)",
    "std_args": [
      "output_size",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "AddAxisHook": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "AddDecayedWeightsState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "AddNoiseState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "AdditiveAttention": {
    "description": "Additive attention layer, a.k.a. Bahdanau-style attention.\n\nInputs are a list with 2 or 3 elements:\n1. A `query` tensor of shape `(batch_size, Tq, dim)`.\n2. A `value` tensor of shape `(batch_size, Tv, dim)`.\n3. A optional `key` tensor of shape `(batch_size, Tv, dim)`. If none\n    supplied, `value` will be used as `key`.\n\nThe calculation follows the steps:\n1. Calculate attention scores using `query` and `key` with shape\n    `(batch_size, Tq, Tv)` as a non-linear sum\n    `scores = reduce_sum(tanh(query + key), axis=-1)`.\n2. Use scores to calculate a softmax distribution with shape\n    `(batch_size, Tq, Tv)`.\n3. Use the softmax distribution to create a linear combination of `value`\n    with shape `(batch_size, Tq, dim)`.\n\nArgs:\n    use_scale: If `True`, will create a scalar variable to scale the\n        attention scores.\n    dropout: Float between 0 and 1. Fraction of the units to drop for the\n        attention scores. Defaults to `0.0`.\n\nCall arguments:\n    inputs: List of the following tensors:\n        - `query`: Query tensor of shape `(batch_size, Tq, dim)`.\n        - `value`: Value tensor of shape `(batch_size, Tv, dim)`.\n        - `key`: Optional key tensor of shape `(batch_size, Tv, dim)`. If\n            not given, will use `value` for both `key` and `value`, which is\n            the most common case.\n    mask: List of the following tensors:\n        - `query_mask`: A boolean mask tensor of shape `(batch_size, Tq)`.\n            If given, the output will be zero at the positions where\n            `mask==False`.\n        - `value_mask`: A boolean mask tensor of shape `(batch_size, Tv)`.\n            If given, will apply the mask such that values at positions\n             where `mask==False` do not contribute to the result.\n    return_attention_scores: bool, it `True`, returns the attention scores\n        (after masking and softmax) as an additional output argument.\n    training: Python boolean indicating whether the layer should behave in\n        training mode (adding dropout) or in inference mode (no dropout).\n    use_causal_mask: Boolean. Set to `True` for decoder self-attention. Adds\n        a mask such that position `i` cannot attend to positions `j > i`.\n        This prevents the flow of information from the future towards the\n        past. Defaults to `False`.\n\nOutput:\n    Attention outputs of shape `(batch_size, Tq, dim)`.\n    (Optional) Attention scores after masking and softmax with shape\n        `(batch_size, Tq, Tv)`.",
    "std_args": [
      "use_scale",
      "dropout",
      "kwargs"
    ],
    "type": "class"
  },
  "AllToShardedLinear": {
    "description": "Each member of the group applies part of the affine transformation such",
    "std_args": [
      "self",
      "input_dims",
      "output_dims",
      "bias",
      "group"
    ],
    "type": "class"
  },
  "Alphadropout": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "class"
  },
  "ApplyCaller": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "ApplyIfFiniteState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ArithOp": {
    "description": "Used in Op.APPLY expression to specify the function part.",
    "std_args": [],
    "type": "class"
  },
  "ArrayAt": {
    "description": "A helper object to apply updates at specific indices.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "ArrayAttr": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "ArrayFunctionInterceptor": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "ArrayIterator": {
    "description": "A helper object to iterate over the 1st dimension of an array.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "ArrayLike": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "value"
    ],
    "type": "class"
  },
  "ArrayNoInheritance": {
    "description": "Quantity-like class that does not inherit from ndarray",
    "std_args": [
      "self",
      "data",
      "units"
    ],
    "type": "class"
  },
  "ArrayRefDef": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "index",
      "outer_index"
    ],
    "type": "class"
  },
  "ArrayRefOutput": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "value"
    ],
    "type": "class"
  },
  "ArrayRepr": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "shape",
      "dtype"
    ],
    "type": "class"
  },
  "AttrPriority": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "AttrType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "AttributeStatus": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "AugMix": {
    "description": "Performs the AugMix data augmentation technique.\n\nAugMix aims to produce images with variety while preserving the image\nsemantics and local statistics. During the augmentation process,\nthe same augmentation is applied across all images in the batch\nin num_chains different ways, with each chain consisting of\nchain_depth augmentations.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nReferences:\n    - [AugMix paper](https://arxiv.org/pdf/1912.02781)\n    - [Official Code](https://github.com/google-research/augmix)\n\nArgs:\n    value_range: the range of values the incoming images will have.\n        Represented as a two number tuple written (low, high).\n        This is typically either `(0, 1)` or `(0, 255)` depending\n        on how your preprocessing pipeline is set up.\n    num_chains: an integer representing the number of different chains to\n        be mixed, defaults to 3.\n    chain_depth: an integer representing the maximum number of\n        transformations to be applied in each chain. The actual number\n        of transformations in each chain will be sampled randomly\n        from the range `[0, `chain_depth`]`. Defaults to 3.\n    factor: The strength of the augmentation as a normalized value\n        between 0 and 1. Default is 0.3.\n    alpha: a float value used as the probability coefficients for the\n        Beta and Dirichlet distributions, defaults to 1.0.\n    all_ops: Use all operations (including random_brightness,\n        random_color_degeneration, random_contrast and random_sharpness).\n        Default is True.\n    interpolation: The interpolation method to use for resizing operations.\n        Options include `\"nearest\"`, `\"bilinear\"`. Default is `\"bilinear\"`.\n    seed: Integer. Used to create a random seed.",
    "std_args": [
      "value_range",
      "num_chains",
      "chain_depth",
      "factor",
      "alpha",
      "all_ops",
      "interpolation",
      "seed",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "AutoContrast": {
    "description": "Performs the auto-contrast operation on an image.\n\nAuto contrast stretches the values of an image across the entire available\n`value_range`. This makes differences between pixels more obvious. An\nexample of this is if an image only has values `[0, 1]` out of the range\n`[0, 255]`, auto contrast will change the `1` values to be `255`.\n\nThis layer is active at both training and inference time.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nArgs:\n    value_range: Range of values the incoming images will have.\n        Represented as a two number tuple written `(low, high)`.\n        This is typically either `(0, 1)` or `(0, 255)` depending\n        on how your preprocessing pipeline is set up.\n        Defaults to `(0, 255)`.",
    "std_args": [
      "value_range",
      "kwargs"
    ],
    "type": "class"
  },
  "AuxData": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "AuxOutput": {
    "description": "Auxiliary outputs from flex_attention operation.",
    "std_args": [],
    "type": "class"
  },
  "AuxRequest": {
    "description": "Request which auxiliary outputs to compute from flex_attention.",
    "std_args": [],
    "type": "class"
  },
  "AveragePooling1D": {
    "description": "Average pooling for temporal data.\n\nDownsamples the input representation by taking the average value over the\nwindow defined by `pool_size`. The window is shifted by `strides`.  The\nresulting output when using \"valid\" padding option has a shape of:\n`output_shape = (input_shape - pool_size + 1) / strides)`\n\nThe resulting output shape when using the \"same\" padding option is:\n`output_shape = input_shape / strides`\n\nArgs:\n    pool_size: int, size of the max pooling window.\n    strides: int or None. Specifies how much the pooling window moves\n        for each pooling step. If None, it will default to `pool_size`.\n    padding: string, either `\"valid\"` or `\"same\"` (case-insensitive).\n        `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n        the left/right or up/down of the input such that output has the same\n        height/width dimension as the input.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, steps, features)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, features, steps)`. It defaults to the `image_data_format`\n        value found in your Keras config file at `~/.keras/keras.json`.\n        If you never set it, then it will be `\"channels_last\"`.\n\nInput shape:\n\n- If `data_format=\"channels_last\"`:\n    3D tensor with shape `(batch_size, steps, features)`.\n- If `data_format=\"channels_first\"`:\n    3D tensor with shape `(batch_size, features, steps)`.\n\nOutput shape:\n\n- If `data_format=\"channels_last\"`:\n    3D tensor with shape `(batch_size, downsampled_steps, features)`.\n- If `data_format=\"channels_first\"`:\n    3D tensor with shape `(batch_size, features, downsampled_steps)`.\n\nExamples:\n\n`strides=1` and `padding=\"valid\"`:\n\n>>> x = np.array([1., 2., 3., 4., 5.])\n>>> x = np.reshape(x, [1, 5, 1])\n>>> avg_pool_1d = keras.layers.AveragePooling1D(pool_size=2,\n...    strides=1, padding=\"valid\")\n>>> avg_pool_1d(x)\n\n`strides=2` and `padding=\"valid\"`:\n\n>>> x = np.array([1., 2., 3., 4., 5.])\n>>> x = np.reshape(x, [1, 5, 1])\n>>> avg_pool_1d = keras.layers.AveragePooling1D(pool_size=2,\n...    strides=2, padding=\"valid\")\n>>> avg_pool_1d(x)\n\n`strides=1` and `padding=\"same\"`:\n\n>>> x = np.array([1., 2., 3., 4., 5.])\n>>> x = np.reshape(x, [1, 5, 1])\n>>> avg_pool_1d = keras.layers.AveragePooling1D(pool_size=2,\n...    strides=1, padding=\"same\")\n>>> avg_pool_1d(x)",
    "std_args": [
      "pool_size",
      "strides",
      "padding",
      "data_format",
      "name",
      "kwargs"
    ],
    "type": "class"
  },
  "AveragePooling2D": {
    "description": "Average pooling operation for 2D spatial data.\n\nDownsamples the input along its spatial dimensions (height and width)\nby taking the average value over an input window\n(of size defined by `pool_size`) for each channel of the input.\nThe window is shifted by `strides` along each dimension.\n\nThe resulting output when using the `\"valid\"` padding option has a spatial\nshape (number of rows or columns) of:\n`output_shape = math.floor((input_shape - pool_size) / strides) + 1`\n(when `input_shape >= pool_size`)\n\nThe resulting output shape when using the `\"same\"` padding option is:\n`output_shape = input_shape`\n\nArgs:\n    pool_size: int or tuple of 2 integers, factors by which to downscale\n        (dim1, dim2). If only one integer is specified, the same\n        window length will be used for all dimensions.\n    strides: int or tuple of 2 integers, or None. Strides values. If None,\n        it will default to `pool_size`. If only one int is specified, the\n        same stride size will be used for all dimensions.\n    padding: string, either `\"valid\"` or `\"same\"` (case-insensitive).\n        `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n        the left/right or up/down of the input such that output has the same\n        height/width dimension as the input.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, height, width, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, channels, height, width)`. It defaults to the\n        `image_data_format` value found in your Keras config file at\n        `~/.keras/keras.json`. If you never set it, then it will be\n        `\"channels_last\"`.\n\nInput shape:\n\n- If `data_format=\"channels_last\"`:\n    4D tensor with shape `(batch_size, height, width, channels)`.\n- If `data_format=\"channels_first\"`:\n    4D tensor with shape `(batch_size, channels, height, width)`.\n\nOutput shape:\n\n- If `data_format=\"channels_last\"`:\n    4D tensor with shape\n    `(batch_size, pooled_height, pooled_width, channels)`.\n- If `data_format=\"channels_first\"`:\n    4D tensor with shape\n    `(batch_size, channels, pooled_height, pooled_width)`.\n\nExamples:\n\n`strides=(1, 1)` and `padding=\"valid\"`:\n\n>>> x = np.array([[1., 2., 3.],\n...               [4., 5., 6.],\n...               [7., 8., 9.]])\n>>> x = np.reshape(x, [1, 3, 3, 1])\n>>> avg_pool_2d = keras.layers.AveragePooling2D(pool_size=(2, 2),\n...    strides=(1, 1), padding=\"valid\")\n>>> avg_pool_2d(x)\n\n`strides=(2, 2)` and `padding=\"valid\"`:\n\n>>> x = np.array([[1., 2., 3., 4.],\n...              [5., 6., 7., 8.],\n...              [9., 10., 11., 12.]])\n>>> x = np.reshape(x, [1, 3, 4, 1])\n>>> avg_pool_2d = keras.layers.AveragePooling2D(pool_size=(2, 2),\n...    strides=(2, 2), padding=\"valid\")\n>>> avg_pool_2d(x)\n\n`stride=(1, 1)` and `padding=\"same\"`:\n\n>>> x = np.array([[1., 2., 3.],\n...                  [4., 5., 6.],\n...                  [7., 8., 9.]])\n>>> x = np.reshape(x, [1, 3, 3, 1])\n>>> avg_pool_2d = keras.layers.AveragePooling2D(pool_size=(2, 2),\n...    strides=(1, 1), padding=\"same\")\n>>> avg_pool_2d(x)",
    "std_args": [
      "pool_size",
      "strides",
      "padding",
      "data_format",
      "name",
      "kwargs"
    ],
    "type": "class"
  },
  "AveragePooling3D": {
    "description": "Average pooling operation for 3D data (spatial or spatio-temporal).\n\nDownsamples the input along its spatial dimensions (depth, height, and\nwidth) by taking the average value over an input window (of size defined by\n`pool_size`) for each channel of the input. The window is shifted by\n`strides` along each dimension.\n\nArgs:\n    pool_size: int or tuple of 3 integers, factors by which to downscale\n        (dim1, dim2, dim3). If only one integer is specified, the same\n        window length will be used for all dimensions.\n    strides: int or tuple of 3 integers, or None. Strides values. If None,\n        it will default to `pool_size`. If only one int is specified, the\n        same stride size will be used for all dimensions.\n    padding: string, either `\"valid\"` or `\"same\"` (case-insensitive).\n        `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n        the left/right or up/down of the input such that output has the same\n        height/width dimension as the input.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape\n        `(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)` while\n        `\"channels_first\"` corresponds to inputs with shape\n        `(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3)`.\n        It defaults to the `image_data_format` value found in your Keras\n        config file at `~/.keras/keras.json`. If you never set it, then it\n        will be `\"channels_last\"`.\n\nInput shape:\n\n- If `data_format=\"channels_last\"`:\n    5D tensor with shape:\n    `(batch_size, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n- If `data_format=\"channels_first\"`:\n    5D tensor with shape:\n    `(batch_size, channels, spatial_dim1, spatial_dim2, spatial_dim3)`\n\nOutput shape:\n\n- If `data_format=\"channels_last\"`:\n    5D tensor with shape:\n    `(batch_size, pooled_dim1, pooled_dim2, pooled_dim3, channels)`\n- If `data_format=\"channels_first\"`:\n    5D tensor with shape:\n    `(batch_size, channels, pooled_dim1, pooled_dim2, pooled_dim3)`\n\nExample:\n\n```python\ndepth = 30\nheight = 30\nwidth = 30\nchannels = 3\n\ninputs = keras.layers.Input(shape=(depth, height, width, channels))\nlayer = keras.layers.AveragePooling3D(pool_size=3)\noutputs = layer(inputs)  # Shape: (batch_size, 10, 10, 10, 3)\n```",
    "std_args": [
      "pool_size",
      "strides",
      "padding",
      "data_format",
      "name",
      "kwargs"
    ],
    "type": "class"
  },
  "AvgPool1d": {
    "description": "Applies a 1D average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "kernel_size",
      "stride",
      "padding",
      "ceil_mode",
      "count_include_pad"
    ],
    "type": "class"
  },
  "AvgPool2d": {
    "description": "Applies a 2D average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "kernel_size",
      "stride",
      "padding",
      "ceil_mode",
      "count_include_pad",
      "divisor_override"
    ],
    "type": "class"
  },
  "AvgPool3d": {
    "description": "Applies a 3D average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "kernel_size",
      "stride",
      "padding",
      "ceil_mode",
      "count_include_pad",
      "divisor_override"
    ],
    "type": "class"
  },
  "AxesValue": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Axis": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "AxisError": {
    "description": "Axis supplied was invalid.",
    "std_args": [
      "self",
      "axis",
      "ndim",
      "msg_prefix"
    ],
    "type": "class"
  },
  "AxisFn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "AxisIndex": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "AxisName": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "B": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BCELoss": {
    "description": "Creates a criterion that measures the Binary Cross Entropy between the target and",
    "std_args": [
      "self",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "BCEWithLogitsLoss": {
    "description": "This loss combines a `Sigmoid` layer and the `BCELoss` in one single",
    "std_args": [
      "self",
      "weight",
      "size_average",
      "reduce",
      "reduction",
      "pos_weight"
    ],
    "type": "class"
  },
  "BLOCKS_ARE_CONTIGUOUS": {
    "description": "If True, guarantees that all blocks in the mask are contiguous.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_M": {
    "description": "Thread block size for the sequence length dimension of Q in forward pass.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_M1": {
    "description": "Thread block size for Q dimension in backward pass. Use as 'bwd_BLOCK_M1'.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_M2": {
    "description": "Thread block size for second Q dimension in backward pass. Use as 'bwd_BLOCK_M2'.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_N": {
    "description": "Thread block size for the sequence length dimension of K/V in forward pass.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_N1": {
    "description": "Thread block size for K/V dimension in backward pass. Use as 'bwd_BLOCK_N1'.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_N2": {
    "description": "Thread block size for second K/V dimension in backward pass. Use as 'bwd_BLOCK_N2'.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_SIZE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BUILDING_DOCS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Base": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "BasePruningMethod": {
    "description": "Abstract base class for creation of new pruning techniques.",
    "std_args": [],
    "type": "class"
  },
  "BatchNorm1d": {
    "description": "Applies Batch Normalization over a 2D or 3D input.",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "BatchNorm2d": {
    "description": "Applies Batch Normalization over a 4D input.",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "BatchNorm3d": {
    "description": "Applies Batch Normalization over a 5D input.",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "Bidirectional": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "class"
  },
  "BitGenerator": {
    "description": "Base Class for generic BitGenerators, which provide a stream",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "BlockMask": {
    "description": "BlockMask is our format for representing a block-sparse attention mask.",
    "std_args": [
      "self",
      "seq_lengths",
      "kv_num_blocks",
      "kv_indices",
      "full_kv_num_blocks",
      "full_kv_indices",
      "q_num_blocks",
      "q_indices",
      "full_q_num_blocks",
      "full_q_indices",
      "BLOCK_SIZE",
      "mask_mod"
    ],
    "type": "class"
  },
  "BoolDType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Broadcasted": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "Buffer": {
    "description": "A kind of Tensor that should not be considered a model",
    "std_args": [
      "self",
      "data",
      "requires_grad",
      "persistent"
    ],
    "type": "class"
  },
  "BwdFn": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "bwd",
      "tree_node_args"
    ],
    "type": "class"
  },
  "ByteDType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BytesDType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "BytesIOSRandomSize": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "C": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CACHE_DIR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CASES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CLongDoubleDType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "COLOR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "COMMENT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "COMMON_FIXED_EXTENSIONS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "COMMON_FREE_EXTENSIONS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "COMPLEX": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "COUNTER": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CSAIterator": {
    "description": "Flat iterator object that uses its own setter/getter",
    "std_args": [
      "self",
      "a"
    ],
    "type": "class"
  },
  "CTCLoss": {
    "description": "The Connectionist Temporal Classification loss.",
    "std_args": [
      "self",
      "blank",
      "reduction",
      "zero_infinity"
    ],
    "type": "class"
  },
  "CallInfo": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "object_id",
      "type",
      "path",
      "input_args",
      "input_kwargs",
      "outputs",
      "flops",
      "vjp_flops"
    ],
    "type": "class"
  },
  "CallableProxy": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "callable",
      "accessor"
    ],
    "type": "class"
  },
  "Carry": {
    "description": "Helper class for :func:`flax.nnx.scan` function to mark input and output axis as carry.",
    "std_args": [],
    "type": "class"
  },
  "CategoryEncoding": {
    "description": "A preprocessing layer which encodes integer features.\n\nThis layer provides options for condensing data into a categorical encoding\nwhen the total number of tokens are known in advance. It accepts integer\nvalues as inputs, and it outputs a dense or sparse representation of those\ninputs. For integer inputs where the total number of tokens is not known,\nuse `keras.layers.IntegerLookup` instead.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nExamples:\n\n**One-hot encoding data**\n\n>>> layer = keras.layers.CategoryEncoding(\n...           num_tokens=4, output_mode=\"one_hot\")\n>>> layer([3, 2, 0, 1])\narray([[0., 0., 0., 1.],\n        [0., 0., 1., 0.],\n        [1., 0., 0., 0.],\n        [0., 1., 0., 0.]]>\n\n**Multi-hot encoding data**\n\n>>> layer = keras.layers.CategoryEncoding(\n...           num_tokens=4, output_mode=\"multi_hot\")\n>>> layer([[0, 1], [0, 0], [1, 2], [3, 1]])\narray([[1., 1., 0., 0.],\n        [1., 0., 0., 0.],\n        [0., 1., 1., 0.],\n        [0., 1., 0., 1.]]>\n\n**Using weighted inputs in `\"count\"` mode**\n\n>>> layer = keras.layers.CategoryEncoding(\n...           num_tokens=4, output_mode=\"count\")\n>>> count_weights = np.array([[.1, .2], [.1, .1], [.2, .3], [.4, .2]])\n>>> layer([[0, 1], [0, 0], [1, 2], [3, 1]], count_weights=count_weights)\n  array([[0.1, 0.2, 0. , 0. ],\n         [0.2, 0. , 0. , 0. ],\n         [0. , 0.2, 0.3, 0. ],\n         [0. , 0.2, 0. , 0.4]]>\n\nArgs:\n    num_tokens: The total number of tokens the layer should support. All\n        inputs to the layer must integers in the range `0 <= value <\n        num_tokens`, or an error will be thrown.\n    output_mode: Specification for the output of the layer.\n        Values can be `\"one_hot\"`, `\"multi_hot\"` or `\"count\"`,\n        configuring the layer as follows:\n            - `\"one_hot\"`: Encodes each individual element in the input\n                into an array of `num_tokens` size, containing a 1 at the\n                element index. If the last dimension is size 1, will encode\n                on that dimension. If the last dimension is not size 1,\n                will append a new dimension for the encoded output.\n            - `\"multi_hot\"`: Encodes each sample in the input into a single\n                array of `num_tokens` size, containing a 1 for each\n                vocabulary term present in the sample. Treats the last\n                dimension as the sample dimension, if input shape is\n                `(..., sample_length)`, output shape will be\n                `(..., num_tokens)`.\n            - `\"count\"`: Like `\"multi_hot\"`, but the int array contains a\n                count of the number of times the token at that index\n                appeared in the sample.\n        For all output modes, currently only output up to rank 2 is\n        supported.\n        Defaults to `\"multi_hot\"`.\n    sparse: Whether to return a sparse tensor; for backends that support\n        sparse tensors.\n\nCall arguments:\n    inputs: A 1D or 2D tensor of integer inputs.\n    count_weights: A tensor in the same shape as `inputs` indicating the\n        weight for each sample value when summing up in `count` mode.\n        Not used in `\"multi_hot\"` or `\"one_hot\"` modes.",
    "std_args": [
      "num_tokens",
      "output_mode",
      "sparse",
      "kwargs"
    ],
    "type": "class"
  },
  "CausalBias": {
    "description": "A bias representing causal attention patterns. For an overview of the bias structure, see the :class:`CausalVariant` enum.",
    "std_args": [
      "self",
      "variant",
      "seq_len_q",
      "seq_len_kv"
    ],
    "type": "class"
  },
  "CausalVariant": {
    "description": "Enum for causal variants used in attention mechanisms.",
    "std_args": [],
    "type": "class"
  },
  "CenterCrop": {
    "description": "Crops the given image at the center.",
    "std_args": [
      "size"
    ],
    "type": "class"
  },
  "ChannelShuffle": {
    "description": "Divides and rearranges the channels in a tensor.",
    "std_args": [
      "self",
      "groups"
    ],
    "type": "class"
  },
  "Chebyshev": {
    "description": "A Chebyshev series class.",
    "std_args": [
      "self",
      "coef",
      "domain",
      "window",
      "symbol"
    ],
    "type": "class"
  },
  "CheckifyFn": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "f"
    ],
    "type": "class"
  },
  "CircularPad1d": {
    "description": "Pads the input tensor using circular padding of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "CircularPad2d": {
    "description": "Pads the input tensor using circular padding of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "CircularPad3d": {
    "description": "Pads the input tensor using circular padding of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ClipByGlobalNormState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ClipGradNorm": {
    "description": "Clips gradient norm of an iterable of parameters.",
    "std_args": [
      "parameters",
      "max_norm"
    ]
  },
  "ClipState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Color": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "CombineIncludePaths": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Compile": {
    "description": "JIT Alias.",
    "std_args": [
      "func"
    ],
    "type": "function"
  },
  "Compiled": {
    "description": "Compiled representation of a function specialized to types/values.",
    "std_args": [
      "self",
      "compiled",
      "jit_wrapped"
    ],
    "type": "class"
  },
  "CompilerChecker": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "Complex128DType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Complex64DType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "ComplexWarning": {
    "description": "The warning raised when casting a complex dtype to a real dtype.",
    "std_args": [],
    "type": "class"
  },
  "ComplicatedSubArray": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "ComputeCv": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CondCases": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "ConditionallyMaskState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ConditionallyTransformState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ConstantPad1d": {
    "description": "Pads the input tensor boundaries with a constant value.",
    "std_args": [
      "self",
      "padding",
      "value"
    ],
    "type": "class"
  },
  "ConstantPad2d": {
    "description": "Pads the input tensor boundaries with a constant value.",
    "std_args": [
      "self",
      "padding",
      "value"
    ],
    "type": "class"
  },
  "ConstantPad3d": {
    "description": "Pads the input tensor boundaries with a constant value.",
    "std_args": [
      "self",
      "padding",
      "value"
    ],
    "type": "class"
  },
  "Container": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "kwargs"
    ],
    "type": "class"
  },
  "ControlVariate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Conv1DTranspose": {
    "description": "1D transposed convolution layer.\n\nThe need for transposed convolutions generally arise from the desire to use\na transformation going in the opposite direction of a normal convolution,\ni.e., from something that has the shape of the output of some convolution\nto something that has the shape of its input while maintaining a\nconnectivity pattern that is compatible with said convolution.\n\nArgs:\n    filters: int, the dimension of the output space (the number of filters\n        in the transpose convolution).\n    kernel_size: int or tuple/list of 1 integer, specifying the size of the\n        transposed convolution window.\n    strides: int or tuple/list of 1 integer, specifying the stride length\n        of the transposed convolution. `strides > 1` is incompatible with\n        `dilation_rate > 1`.\n    padding: string, either `\"valid\"` or `\"same\"` (case-insensitive).\n        `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n        the left/right or up/down of the input such that output has the same\n        height/width dimension as the input.\n    output_padding: An integer tuple/list of 1 integer specifying the\n        amount of padding along the time dimension of the output tensor.\n        The amount of output padding must be lower than the stride.\n        If set to `None` (default), the output shape is inferred.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, steps, features)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, features, steps)`. It defaults to the `image_data_format`\n        value found in your Keras config file at `~/.keras/keras.json`.\n        If you never set it, then it will be `\"channels_last\"`.\n    dilation_rate: An integer tuple/list of 1 integer, specifying\n        the dilation rate to use for dilated convolution.\n        Currently, specifying a `dilation_rate` value != 1 is\n        incompatible with specifying a stride value != 1.\n        Also dilation rate larger than 1 is not currently supported.\n    activation: Activation function. If `None`, no activation is applied.\n    use_bias: bool, if `True`, bias will be added to the output.\n    kernel_initializer: Initializer for the convolution kernel. If `None`,\n        the default initializer (`\"glorot_uniform\"`) will be used.\n    bias_initializer: Initializer for the bias vector. If `None`, the\n        default initializer (`\"zeros\"`) will be used.\n    kernel_regularizer: Optional regularizer for the convolution kernel.\n    bias_regularizer: Optional regularizer for the bias vector.\n    activity_regularizer: Optional regularizer function for the output.\n    kernel_constraint: Optional projection function to be applied to the\n        kernel after being updated by an `Optimizer` (e.g. used to implement\n        norm constraints or value constraints for layer weights). The\n        function must take as input the unprojected variable and must return\n        the projected variable (which must have the same shape). Constraints\n        are not safe to use when doing asynchronous distributed training.\n    bias_constraint: Optional projection function to be applied to the\n        bias after being updated by an `Optimizer`.\n\nInput shape:\n\n- If `data_format=\"channels_last\"`:\n    A 3D tensor with shape: `(batch_shape, steps, channels)`\n- If `data_format=\"channels_first\"`:\n    A 3D tensor with shape: `(batch_shape, channels, steps)`\n\nOutput shape:\n\n- If `data_format=\"channels_last\"`:\n    A 3D tensor with shape: `(batch_shape, new_steps, filters)`\n- If `data_format=\"channels_first\"`:\n    A 3D tensor with shape: `(batch_shape, filters, new_steps)`\n\nReturns:\n    A 3D tensor representing\n    `activation(conv1d_transpose(inputs, kernel) + bias)`.\n\nRaises:\n    ValueError: when both `strides > 1` and `dilation_rate > 1`.\n\nReferences:\n- [A guide to convolution arithmetic for deep learning](\n    https://arxiv.org/abs/1603.07285v1)\n- [Deconvolutional Networks](\n    https://www.matthewzeiler.com/mattzeiler/deconvolutionalnetworks.pdf)\n\nExample:\n\n>>> x = np.random.rand(4, 10, 128)\n>>> y = keras.layers.Conv1DTranspose(32, 3, 2, activation='relu')(x)\n>>> print(y.shape)\n(4, 21, 32)",
    "std_args": [
      "filters",
      "kernel_size",
      "strides",
      "padding",
      "output_padding",
      "data_format",
      "dilation_rate",
      "activation",
      "use_bias",
      "kernel_initializer",
      "bias_initializer",
      "kernel_regularizer",
      "bias_regularizer",
      "activity_regularizer",
      "kernel_constraint",
      "bias_constraint",
      "kwargs"
    ],
    "type": "class"
  },
  "Conv1d": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "Conv2DTranspose": {
    "description": "2D transposed convolution layer.\n\nThe need for transposed convolutions generally arise from the desire to use\na transformation going in the opposite direction of a normal convolution,\ni.e., from something that has the shape of the output of some convolution\nto something that has the shape of its input while maintaining a\nconnectivity pattern that is compatible with said convolution.\n\nArgs:\n    filters: int, the dimension of the output space (the number of filters\n        in the transposed convolution).\n    kernel_size: int or tuple/list of 1 integer, specifying the size of the\n        transposed convolution window.\n    strides: int or tuple/list of 1 integer, specifying the stride length\n        of the transposed convolution. `strides > 1` is incompatible with\n        `dilation_rate > 1`.\n    padding: string, either `\"valid\"` or `\"same\"` (case-insensitive).\n        `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n        the left/right or up/down of the input. When `padding=\"same\"` and\n        `strides=1`, the output has the same size as the input.\n    output_padding: An integer or tuple/list of 2 integers,\n        specifying the amount of padding along the height and width\n        of the output tensor.\n        Can be a single integer to specify the same value for all\n        spatial dimensions.\n        The amount of output padding along a given dimension must be\n        lower than the stride along that same dimension.\n        If set to `None` (default), the output shape is inferred.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape\n        `(batch_size, height, width, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch_size, channels, height, width)`. It defaults to the\n        `image_data_format` value found in your Keras config file at\n        `~/.keras/keras.json`. If you never set it, then it will be\n        `\"channels_last\"`.\n     dilation_rate: An integer or tuple/list of 2 integers,\n        specifying the dilation rate for\n        all spatial dimensions for dilated convolution.\n        Specifying different dilation rates\n        for different dimensions is not supported.\n        Currently, specifying any `dilation_rate` value != 1 is\n        incompatible with specifying any stride value != 1.\n    activation: Activation function. If `None`, no activation is applied.\n    use_bias: bool, if `True`, bias will be added to the output.\n    kernel_initializer: Initializer for the convolution kernel. If `None`,\n        the default initializer (`\"glorot_uniform\"`) will be used.\n    bias_initializer: Initializer for the bias vector. If `None`, the\n        default initializer (`\"zeros\"`) will be used.\n    kernel_regularizer: Optional regularizer for the convolution kernel.\n    bias_regularizer: Optional regularizer for the bias vector.\n    activity_regularizer: Optional regularizer function for the output.\n    kernel_constraint: Optional projection function to be applied to the\n        kernel after being updated by an `Optimizer` (e.g. used to implement\n        norm constraints or value constraints for layer weights). The\n        function must take as input the unprojected variable and must return\n        the projected variable (which must have the same shape). Constraints\n        are not safe to use when doing asynchronous distributed training.\n    bias_constraint: Optional projection function to be applied to the\n        bias after being updated by an `Optimizer`.\n\nInput shape:\n\n- If `data_format=\"channels_last\"`:\n    A 4D tensor with shape: `(batch_size, height, width, channels)`\n- If `data_format=\"channels_first\"`:\n    A 4D tensor with shape: `(batch_size, channels, height, width)`\n\nOutput shape:\n\n- If `data_format=\"channels_last\"`:\n    A 4D tensor with shape: `(batch_size, new_height, new_width, filters)`\n- If `data_format=\"channels_first\"`:\n    A 4D tensor with shape: `(batch_size, filters, new_height, new_width)`\n\nReturns:\n    A 4D tensor representing\n    `activation(conv2d_transpose(inputs, kernel) + bias)`.\n\nRaises:\n    ValueError: when both `strides > 1` and `dilation_rate > 1`.\n\nReferences:\n- [A guide to convolution arithmetic for deep learning](\n    https://arxiv.org/abs/1603.07285v1)\n- [Deconvolutional Networks](\n    https://www.matthewzeiler.com/mattzeiler/deconvolutionalnetworks.pdf)\n\nExample:\n\n>>> x = np.random.rand(4, 10, 8, 128)\n>>> y = keras.layers.Conv2DTranspose(32, 2, 2, activation='relu')(x)\n>>> print(y.shape)\n(4, 20, 16, 32)",
    "std_args": [
      "filters",
      "kernel_size",
      "strides",
      "padding",
      "output_padding",
      "data_format",
      "dilation_rate",
      "activation",
      "use_bias",
      "kernel_initializer",
      "bias_initializer",
      "kernel_regularizer",
      "bias_regularizer",
      "activity_regularizer",
      "kernel_constraint",
      "bias_constraint",
      "kwargs"
    ],
    "type": "class"
  },
  "Conv3DTranspose": {
    "description": "3D transposed convolution layer.\n\nThe need for transposed convolutions generally arise from the desire to use\na transformation going in the opposite direction of a normal convolution,\ni.e., from something that has the shape of the output of some convolution\nto something that has the shape of its input while maintaining a\nconnectivity pattern that is compatible with said convolution.\n\nArgs:\n    filters: int, the dimension of the output space (the number of filters\n        in the transposed convolution).\n    kernel_size: int or tuple/list of 1 integer, specifying the size of the\n        transposed convolution window.\n    strides: int or tuple/list of 1 integer, specifying the stride length\n        of the transposed convolution. `strides > 1` is incompatible with\n        `dilation_rate > 1`.\n    padding: string, either `\"valid\"` or `\"same\"` (case-insensitive).\n        `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n        the left/right or up/down of the input. When `padding=\"same\"` and\n        `strides=1`, the output has the same size as the input.\n     output_padding: An integer or tuple/list of 3 integers,\n        specifying the amount of padding along the depth, height, and\n        width.\n        Can be a single integer to specify the same value for all\n        spatial dimensions.\n        The amount of output padding along a given dimension must be\n        lower than the stride along that same dimension.\n        If set to `None` (default), the output shape is inferred.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape\n        `(batch_size, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch_size, channels, spatial_dim1, spatial_dim2, spatial_dim3)`.\n        It defaults to the `image_data_format` value found in your Keras\n        config file at `~/.keras/keras.json`. If you never set it, then it\n        will be `\"channels_last\"`.\n    dilation_rate: an integer or tuple/list of 3 integers, specifying\n        the dilation rate to use for dilated convolution.\n        Can be a single integer to specify the same value for\n        all spatial dimensions.\n        Currently, specifying any `dilation_rate` value != 1 is\n        incompatible with specifying any stride value != 1.\n    activation: Activation function. If `None`, no activation is applied.\n    use_bias: bool, if `True`, bias will be added to the output.\n    kernel_initializer: Initializer for the convolution kernel. If `None`,\n        the default initializer (`\"glorot_uniform\"`) will be used.\n    bias_initializer: Initializer for the bias vector. If `None`, the\n        default initializer (`\"zeros\"`) will be used.\n    kernel_regularizer: Optional regularizer for the convolution kernel.\n    bias_regularizer: Optional regularizer for the bias vector.\n    activity_regularizer: Optional regularizer function for the output.\n    kernel_constraint: Optional projection function to be applied to the\n        kernel after being updated by an `Optimizer` (e.g. used to implement\n        norm constraints or value constraints for layer weights). The\n        function must take as input the unprojected variable and must return\n        the projected variable (which must have the same shape). Constraints\n        are not safe to use when doing asynchronous distributed training.\n    bias_constraint: Optional projection function to be applied to the\n        bias after being updated by an `Optimizer`.\n\nInput shape:\n\n- If `data_format=\"channels_last\"`:\n    5D tensor with shape:\n    `(batch_size, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n- If `data_format=\"channels_first\"`:\n    5D tensor with shape:\n    `(batch_size, channels, spatial_dim1, spatial_dim2, spatial_dim3)`\n\nOutput shape:\n\n- If `data_format=\"channels_last\"`:\n    5D tensor with shape:\n    `(batch_size, new_spatial_dim1, new_spatial_dim2, new_spatial_dim3,\n    filters)`\n- If `data_format=\"channels_first\"`:\n    5D tensor with shape:\n    `(batch_size, filters, new_spatial_dim1, new_spatial_dim2,\n    new_spatial_dim3)`\n\nReturns:\n    A 5D tensor representing `activation(conv3d(inputs, kernel) + bias)`.\n\nRaises:\n    ValueError: when both `strides > 1` and `dilation_rate > 1`.\n\nReferences:\n- [A guide to convolution arithmetic for deep learning](\n    https://arxiv.org/abs/1603.07285v1)\n- [Deconvolutional Networks](\n    https://www.matthewzeiler.com/mattzeiler/deconvolutionalnetworks.pdf)\n\nExample:\n\n>>> x = np.random.rand(4, 10, 8, 12, 128)\n>>> y = keras.layers.Conv3DTranspose(32, 2, 2, activation='relu')(x)\n>>> print(y.shape)\n(4, 20, 16, 24, 32)",
    "std_args": [
      "filters",
      "kernel_size",
      "strides",
      "padding",
      "data_format",
      "output_padding",
      "dilation_rate",
      "activation",
      "use_bias",
      "kernel_initializer",
      "bias_initializer",
      "kernel_regularizer",
      "bias_regularizer",
      "activity_regularizer",
      "kernel_constraint",
      "bias_constraint",
      "kwargs"
    ],
    "type": "class"
  },
  "Conv3d": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "ConvLSTM1D": {
    "description": "1D Convolutional LSTM.\n\nSimilar to an LSTM layer, but the input transformations\nand recurrent transformations are both convolutional.\n\nArgs:\n    filters: int, the dimension of the output space (the number of filters\n        in the convolution).\n    kernel_size: int or tuple/list of 1 integer, specifying the size of\n        the convolution window.\n    strides: int or tuple/list of 1 integer, specifying the stride length\n        of the convolution. `strides > 1` is incompatible with\n        `dilation_rate > 1`.\n    padding: string, `\"valid\"` or `\"same\"` (case-insensitive).\n        `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n        the left/right or up/down of the input such that output has the\n        same height/width dimension as the input.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, steps, features)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, features, steps)`. It defaults to the `image_data_format`\n        value found in your Keras config file at `~/.keras/keras.json`.\n        If you never set it, then it will be `\"channels_last\"`.\n    dilation_rate: int or tuple/list of 1 integers, specifying the dilation\n        rate to use for dilated convolution.\n    activation: Activation function to use. By default hyperbolic tangent\n        activation function is applied (`tanh(x)`).\n    recurrent_activation: Activation function to use for the recurrent step.\n    use_bias: Boolean, whether the layer uses a bias vector.\n    kernel_initializer: Initializer for the `kernel` weights matrix,\n        used for the linear transformation of the inputs.\n    recurrent_initializer: Initializer for the `recurrent_kernel` weights\n        matrix, used for the linear transformation of the recurrent state.\n    bias_initializer: Initializer for the bias vector.\n    unit_forget_bias: Boolean. If `True`, add 1 to the bias of\n        the forget gate at initialization.\n        Use in combination with `bias_initializer=\"zeros\"`.\n        This is recommended in [Jozefowicz et al., 2015](\n        http://www.jmlr.org/proceedings/papers/v37/jozefowicz15.pdf)\n    kernel_regularizer: Regularizer function applied to the `kernel` weights\n        matrix.\n    recurrent_regularizer: Regularizer function applied to the\n        `recurrent_kernel` weights matrix.\n    bias_regularizer: Regularizer function applied to the bias vector.\n    activity_regularizer: Regularizer function applied to.\n    kernel_constraint: Constraint function applied to the `kernel` weights\n        matrix.\n    recurrent_constraint: Constraint function applied to the\n        `recurrent_kernel` weights matrix.\n    bias_constraint: Constraint function applied to the bias vector.\n    dropout: Float between 0 and 1. Fraction of the units to drop for the\n        linear transformation of the inputs.\n    recurrent_dropout: Float between 0 and 1. Fraction of the units to drop\n        for the linear transformation of the recurrent state.\n    seed: Random seed for dropout.\n    return_sequences: Boolean. Whether to return the last output\n        in the output sequence, or the full sequence. Default: `False`.\n    return_state: Boolean. Whether to return the last state in addition\n        to the output. Default: `False`.\n    go_backwards: Boolean (default: `False`).\n        If `True`, process the input sequence backwards and return the\n        reversed sequence.\n    stateful: Boolean (default False). If `True`, the last state\n        for each sample at index i in a batch will be used as initial\n        state for the sample of index i in the following batch.\n    unroll: Boolean (default: `False`).\n        If `True`, the network will be unrolled,\n        else a symbolic loop will be used.\n        Unrolling can speed-up a RNN,\n        although it tends to be more memory-intensive.\n        Unrolling is only suitable for short sequences.\n\n\nCall arguments:\n    inputs: A 4D tensor.\n    initial_state: List of initial state tensors to be passed to the first\n        call of the cell.\n    mask: Binary tensor of shape `(samples, timesteps)` indicating whether a\n        given timestep should be masked.\n    training: Python boolean indicating whether the layer should behave in\n        training mode or in inference mode.\n        This is only relevant if `dropout` or `recurrent_dropout` are set.\n\nInput shape:\n\n- If `data_format=\"channels_first\"`:\n    4D tensor with shape: `(samples, time, channels, rows)`\n- If `data_format=\"channels_last\"`:\n    4D tensor with shape: `(samples, time, rows, channels)`\n\nOutput shape:\n\n- If `return_state`: a list of tensors. The first tensor is the output.\n    The remaining tensors are the last states,\n    each 3D tensor with shape: `(samples, filters, new_rows)` if\n    `data_format='channels_first'`\n    or shape: `(samples, new_rows, filters)` if\n    `data_format='channels_last'`.\n    `rows` values might have changed due to padding.\n- If `return_sequences`: 4D tensor with shape: `(samples, timesteps,\n    filters, new_rows)` if data_format='channels_first'\n    or shape: `(samples, timesteps, new_rows, filters)` if\n    `data_format='channels_last'`.\n- Else, 3D tensor with shape: `(samples, filters, new_rows)` if\n    `data_format='channels_first'`\n    or shape: `(samples, new_rows, filters)` if\n    `data_format='channels_last'`.\n\nReferences:\n\n- [Shi et al., 2015](http://arxiv.org/abs/1506.04214v1)\n    (the current implementation does not include the feedback loop on the\n    cells output).",
    "std_args": [
      "filters",
      "kernel_size",
      "strides",
      "padding",
      "data_format",
      "dilation_rate",
      "activation",
      "recurrent_activation",
      "use_bias",
      "kernel_initializer",
      "recurrent_initializer",
      "bias_initializer",
      "unit_forget_bias",
      "kernel_regularizer",
      "recurrent_regularizer",
      "bias_regularizer",
      "activity_regularizer",
      "kernel_constraint",
      "recurrent_constraint",
      "bias_constraint",
      "dropout",
      "recurrent_dropout",
      "seed",
      "return_sequences",
      "return_state",
      "go_backwards",
      "stateful",
      "kwargs"
    ],
    "type": "class"
  },
  "ConvLSTM2D": {
    "description": "2D Convolutional LSTM.\n\nSimilar to an LSTM layer, but the input transformations\nand recurrent transformations are both convolutional.\n\nArgs:\n    filters: int, the dimension of the output space (the number of filters\n        in the convolution).\n    kernel_size: int or tuple/list of 2 integers, specifying the size of the\n        convolution window.\n    strides: int or tuple/list of 2 integers, specifying the stride length\n        of the convolution. `strides > 1` is incompatible with\n        `dilation_rate > 1`.\n    padding: string, `\"valid\"` or `\"same\"` (case-insensitive).\n        `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n        the left/right or up/down of the input such that output has the same\n        height/width dimension as the input.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, steps, features)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, features, steps)`. It defaults to the `image_data_format`\n        value found in your Keras config file at `~/.keras/keras.json`.\n        If you never set it, then it will be `\"channels_last\"`.\n    dilation_rate: int or tuple/list of 2 integers, specifying the dilation\n        rate to use for dilated convolution.\n    activation: Activation function to use. By default hyperbolic tangent\n        activation function is applied (`tanh(x)`).\n    recurrent_activation: Activation function to use for the recurrent step.\n    use_bias: Boolean, whether the layer uses a bias vector.\n    kernel_initializer: Initializer for the `kernel` weights matrix,\n        used for the linear transformation of the inputs.\n    recurrent_initializer: Initializer for the `recurrent_kernel` weights\n        matrix, used for the linear transformation of the recurrent state.\n    bias_initializer: Initializer for the bias vector.\n    unit_forget_bias: Boolean. If `True`, add 1 to the bias of the forget\n        gate at initialization.\n        Use in combination with `bias_initializer=\"zeros\"`.\n        This is recommended in [Jozefowicz et al., 2015](\n        http://www.jmlr.org/proceedings/papers/v37/jozefowicz15.pdf)\n    kernel_regularizer: Regularizer function applied to the `kernel` weights\n        matrix.\n    recurrent_regularizer: Regularizer function applied to the\n        `recurrent_kernel` weights matrix.\n    bias_regularizer: Regularizer function applied to the bias vector.\n    activity_regularizer: Regularizer function applied to.\n    kernel_constraint: Constraint function applied to the `kernel` weights\n        matrix.\n    recurrent_constraint: Constraint function applied to the\n        `recurrent_kernel` weights matrix.\n    bias_constraint: Constraint function applied to the bias vector.\n    dropout: Float between 0 and 1. Fraction of the units to drop for the\n        linear transformation of the inputs.\n    recurrent_dropout: Float between 0 and 1. Fraction of the units to drop\n        for the linear transformation of the recurrent state.\n    seed: Random seed for dropout.\n    return_sequences: Boolean. Whether to return the last output\n        in the output sequence, or the full sequence. Default: `False`.\n    return_state: Boolean. Whether to return the last state in addition\n        to the output. Default: `False`.\n    go_backwards: Boolean (default: `False`).\n        If `True`, process the input sequence backwards and return the\n        reversed sequence.\n    stateful: Boolean (default False). If `True`, the last state\n        for each sample at index i in a batch will be used as initial\n        state for the sample of index i in the following batch.\n    unroll: Boolean (default: `False`).\n        If `True`, the network will be unrolled,\n        else a symbolic loop will be used.\n        Unrolling can speed-up a RNN,\n        although it tends to be more memory-intensive.\n        Unrolling is only suitable for short sequences.\n\n\nCall arguments:\n    inputs: A 5D tensor.\n    mask: Binary tensor of shape `(samples, timesteps)` indicating whether a\n        given timestep should be masked.\n    training: Python boolean indicating whether the layer should behave in\n        training mode or in inference mode.\n        This is only relevant if `dropout` or `recurrent_dropout` are set.\n    initial_state: List of initial state tensors to be passed to the first\n        call of the cell.\n\nInput shape:\n\n- If `data_format='channels_first'`:\n    5D tensor with shape: `(samples, time, channels, rows, cols)`\n- If `data_format='channels_last'`:\n    5D tensor with shape: `(samples, time, rows, cols, channels)`\n\nOutput shape:\n\n- If `return_state`: a list of tensors. The first tensor is the output.\n    The remaining tensors are the last states,\n    each 4D tensor with shape: `(samples, filters, new_rows, new_cols)` if\n    `data_format='channels_first'`\n    or shape: `(samples, new_rows, new_cols, filters)` if\n    `data_format='channels_last'`. `rows` and `cols` values might have\n    changed due to padding.\n- If `return_sequences`: 5D tensor with shape: `(samples, timesteps,\n    filters, new_rows, new_cols)` if data_format='channels_first'\n    or shape: `(samples, timesteps, new_rows, new_cols, filters)` if\n    `data_format='channels_last'`.\n- Else, 4D tensor with shape: `(samples, filters, new_rows, new_cols)` if\n    `data_format='channels_first'`\n    or shape: `(samples, new_rows, new_cols, filters)` if\n    `data_format='channels_last'`.\n\nReferences:\n\n- [Shi et al., 2015](http://arxiv.org/abs/1506.04214v1)\n    (the current implementation does not include the feedback loop on the\n    cells output).",
    "std_args": [
      "filters",
      "kernel_size",
      "strides",
      "padding",
      "data_format",
      "dilation_rate",
      "activation",
      "recurrent_activation",
      "use_bias",
      "kernel_initializer",
      "recurrent_initializer",
      "bias_initializer",
      "unit_forget_bias",
      "kernel_regularizer",
      "recurrent_regularizer",
      "bias_regularizer",
      "activity_regularizer",
      "kernel_constraint",
      "recurrent_constraint",
      "bias_constraint",
      "dropout",
      "recurrent_dropout",
      "seed",
      "return_sequences",
      "return_state",
      "go_backwards",
      "stateful",
      "kwargs"
    ],
    "type": "class"
  },
  "ConvLSTM3D": {
    "description": "3D Convolutional LSTM.\n\nSimilar to an LSTM layer, but the input transformations\nand recurrent transformations are both convolutional.\n\nArgs:\n    filters: int, the dimension of the output space (the number of filters\n        in the convolution).\n    kernel_size: int or tuple/list of 3 integers, specifying the size of the\n        convolution window.\n    strides: int or tuple/list of 3 integers, specifying the stride length\n        of the convolution. `strides > 1` is incompatible with\n        `dilation_rate > 1`.\n    padding: string, `\"valid\"` or `\"same\"` (case-insensitive).\n        `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n        the left/right or up/down of the input such that output has the same\n        height/width dimension as the input.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, steps, features)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, features, steps)`. It defaults to the `image_data_format`\n        value found in your Keras config file at `~/.keras/keras.json`.\n        If you never set it, then it will be `\"channels_last\"`.\n    dilation_rate: int or tuple/list of 3 integers, specifying the dilation\n        rate to use for dilated convolution.\n    activation: Activation function to use. By default hyperbolic tangent\n        activation function is applied (`tanh(x)`).\n    recurrent_activation: Activation function to use for the recurrent step.\n    use_bias: Boolean, whether the layer uses a bias vector.\n    kernel_initializer: Initializer for the `kernel` weights matrix,\n        used for the linear transformation of the inputs.\n    recurrent_initializer: Initializer for the `recurrent_kernel` weights\n        matrix, used for the linear transformation of the recurrent state.\n    bias_initializer: Initializer for the bias vector.\n    unit_forget_bias: Boolean. If `True`, add 1 to the bias of the forget\n        gate at initialization.\n        Use in combination with `bias_initializer=\"zeros\"`.\n        This is recommended in [Jozefowicz et al., 2015](\n        http://www.jmlr.org/proceedings/papers/v37/jozefowicz15.pdf)\n    kernel_regularizer: Regularizer function applied to the `kernel` weights\n        matrix.\n    recurrent_regularizer: Regularizer function applied to the\n        `recurrent_kernel` weights matrix.\n    bias_regularizer: Regularizer function applied to the bias vector.\n    activity_regularizer: Regularizer function applied to.\n    kernel_constraint: Constraint function applied to the `kernel` weights\n        matrix.\n    recurrent_constraint: Constraint function applied to the\n        `recurrent_kernel` weights matrix.\n    bias_constraint: Constraint function applied to the bias vector.\n    dropout: Float between 0 and 1. Fraction of the units to drop for the\n        linear transformation of the inputs.\n    recurrent_dropout: Float between 0 and 1. Fraction of the units to drop\n        for the linear transformation of the recurrent state.\n    seed: Random seed for dropout.\n    return_sequences: Boolean. Whether to return the last output\n        in the output sequence, or the full sequence. Default: `False`.\n    return_state: Boolean. Whether to return the last state in addition\n        to the output. Default: `False`.\n    go_backwards: Boolean (default: `False`).\n        If `True`, process the input sequence backwards and return the\n        reversed sequence.\n    stateful: Boolean (default False). If `True`, the last state\n        for each sample at index i in a batch will be used as initial\n        state for the sample of index i in the following batch.\n    unroll: Boolean (default: `False`).\n        If `True`, the network will be unrolled,\n        else a symbolic loop will be used.\n        Unrolling can speed-up a RNN,\n        although it tends to be more memory-intensive.\n        Unrolling is only suitable for short sequences.\n\n\nCall arguments:\n    inputs: A 6D tensor.\n    mask: Binary tensor of shape `(samples, timesteps)` indicating whether a\n        given timestep should be masked.\n    training: Python boolean indicating whether the layer should behave in\n        training mode or in inference mode.\n        This is only relevant if `dropout` or `recurrent_dropout` are set.\n    initial_state: List of initial state tensors to be passed to the first\n        call of the cell.\n\nInput shape:\n\n- If `data_format='channels_first'`:\n    5D tensor with shape: `(samples, time, channels, *spatial_dims)`\n- If `data_format='channels_last'`:\n    5D tensor with shape: `(samples, time, *spatial_dims, channels)`\n\nOutput shape:\n\n- If `return_state`: a list of tensors. The first tensor is the output.\n    The remaining tensors are the last states,\n    each 4D tensor with shape: `(samples, filters, *spatial_dims)` if\n    `data_format='channels_first'`\n    or shape: `(samples, *spatial_dims, filters)` if\n    `data_format='channels_last'`.\n- If `return_sequences`: 5D tensor with shape: `(samples, timesteps,\n    filters, *spatial_dims)` if data_format='channels_first'\n    or shape: `(samples, timesteps, *spatial_dims, filters)` if\n    `data_format='channels_last'`.\n- Else, 4D tensor with shape: `(samples, filters, *spatial_dims)` if\n    `data_format='channels_first'`\n    or shape: `(samples, *spatial_dims, filters)` if\n    `data_format='channels_last'`.\n\nReferences:\n\n- [Shi et al., 2015](http://arxiv.org/abs/1506.04214v1)\n    (the current implementation does not include the feedback loop on the\n    cells output).",
    "std_args": [
      "filters",
      "kernel_size",
      "strides",
      "padding",
      "data_format",
      "dilation_rate",
      "activation",
      "recurrent_activation",
      "use_bias",
      "kernel_initializer",
      "recurrent_initializer",
      "bias_initializer",
      "unit_forget_bias",
      "kernel_regularizer",
      "recurrent_regularizer",
      "bias_regularizer",
      "activity_regularizer",
      "kernel_constraint",
      "recurrent_constraint",
      "bias_constraint",
      "dropout",
      "recurrent_dropout",
      "seed",
      "return_sequences",
      "return_state",
      "go_backwards",
      "stateful",
      "kwargs"
    ],
    "type": "class"
  },
  "ConvT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ConvTranspose1d": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "output_padding",
      "groups",
      "bias",
      "dilation",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "ConvTranspose2d": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "output_padding",
      "groups",
      "bias",
      "dilation",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "ConvTranspose3d": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "output_padding",
      "groups",
      "bias",
      "dilation",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "Convolution1D": {
    "description": "1D convolution layer (e.g. temporal convolution).\n\nThis layer creates a convolution kernel that is convolved with the layer\ninput over a single spatial (or temporal) dimension to produce a tensor of\noutputs. If `use_bias` is True, a bias vector is created and added to the\noutputs. Finally, if `activation` is not `None`, it is applied to the\noutputs as well.\n\nArgs:\n    filters: int, the dimension of the output space (the number of filters\n        in the convolution).\n    kernel_size: int or tuple/list of 1 integer, specifying the size of the\n        convolution window.\n    strides: int or tuple/list of 1 integer, specifying the stride length\n        of the convolution. `strides > 1` is incompatible with\n        `dilation_rate > 1`.\n    padding: string, `\"valid\"`, `\"same\"` or `\"causal\"`(case-insensitive).\n        `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n        the left/right or up/down of the input. When `padding=\"same\"` and\n        `strides=1`, the output has the same size as the input.\n        `\"causal\"` results in causal(dilated) convolutions, e.g. `output[t]`\n        does not depend on`input[t+1:]`. Useful when modeling temporal data\n        where the model should not violate the temporal order.\n        See [WaveNet: A Generative Model for Raw Audio, section2.1](\n        https://arxiv.org/abs/1609.03499).\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, steps, features)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, features, steps)`. It defaults to the `image_data_format`\n        value found in your Keras config file at `~/.keras/keras.json`.\n        If you never set it, then it will be `\"channels_last\"`.\n    dilation_rate: int or tuple/list of 1 integers, specifying the dilation\n        rate to use for dilated convolution.\n    groups: A positive int specifying the number of groups in which the\n        input is split along the channel axis. Each group is convolved\n        separately with `filters // groups` filters. The output is the\n        concatenation of all the `groups` results along the channel axis.\n        Input channels and `filters` must both be divisible by `groups`.\n    activation: Activation function. If `None`, no activation is applied.\n    use_bias: bool, if `True`, bias will be added to the output.\n    kernel_initializer: Initializer for the convolution kernel. If `None`,\n        the default initializer (`\"glorot_uniform\"`) will be used.\n    bias_initializer: Initializer for the bias vector. If `None`, the\n        default initializer (`\"zeros\"`) will be used.\n    kernel_regularizer: Optional regularizer for the convolution kernel.\n    bias_regularizer: Optional regularizer for the bias vector.\n    activity_regularizer: Optional regularizer function for the output.\n    kernel_constraint: Optional projection function to be applied to the\n        kernel after being updated by an `Optimizer` (e.g. used to implement\n        norm constraints or value constraints for layer weights). The\n        function must take as input the unprojected variable and must return\n        the projected variable (which must have the same shape). Constraints\n        are not safe to use when doing asynchronous distributed training.\n    bias_constraint: Optional projection function to be applied to the\n        bias after being updated by an `Optimizer`.\n\nInput shape:\n\n- If `data_format=\"channels_last\"`:\n    A 3D tensor with shape: `(batch_shape, steps, channels)`\n- If `data_format=\"channels_first\"`:\n    A 3D tensor with shape: `(batch_shape, channels, steps)`\n\nOutput shape:\n\n- If `data_format=\"channels_last\"`:\n    A 3D tensor with shape: `(batch_shape, new_steps, filters)`\n- If `data_format=\"channels_first\"`:\n    A 3D tensor with shape: `(batch_shape, filters, new_steps)`\n\nReturns:\n    A 3D tensor representing `activation(conv1d(inputs, kernel) + bias)`.\n\nRaises:\n    ValueError: when both `strides > 1` and `dilation_rate > 1`.\n\nExample:\n\n>>> # The inputs are 128-length vectors with 10 timesteps, and the\n>>> # batch size is 4.\n>>> x = np.random.rand(4, 10, 128)\n>>> y = keras.layers.Conv1D(32, 3, activation='relu')(x)\n>>> print(y.shape)\n(4, 8, 32)",
    "std_args": [
      "filters",
      "kernel_size",
      "strides",
      "padding",
      "data_format",
      "dilation_rate",
      "groups",
      "activation",
      "use_bias",
      "kernel_initializer",
      "bias_initializer",
      "kernel_regularizer",
      "bias_regularizer",
      "activity_regularizer",
      "kernel_constraint",
      "bias_constraint",
      "kwargs"
    ],
    "type": "class"
  },
  "Convolution1DTranspose": {
    "description": "1D transposed convolution layer.\n\nThe need for transposed convolutions generally arise from the desire to use\na transformation going in the opposite direction of a normal convolution,\ni.e., from something that has the shape of the output of some convolution\nto something that has the shape of its input while maintaining a\nconnectivity pattern that is compatible with said convolution.\n\nArgs:\n    filters: int, the dimension of the output space (the number of filters\n        in the transpose convolution).\n    kernel_size: int or tuple/list of 1 integer, specifying the size of the\n        transposed convolution window.\n    strides: int or tuple/list of 1 integer, specifying the stride length\n        of the transposed convolution. `strides > 1` is incompatible with\n        `dilation_rate > 1`.\n    padding: string, either `\"valid\"` or `\"same\"` (case-insensitive).\n        `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n        the left/right or up/down of the input such that output has the same\n        height/width dimension as the input.\n    output_padding: An integer tuple/list of 1 integer specifying the\n        amount of padding along the time dimension of the output tensor.\n        The amount of output padding must be lower than the stride.\n        If set to `None` (default), the output shape is inferred.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, steps, features)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, features, steps)`. It defaults to the `image_data_format`\n        value found in your Keras config file at `~/.keras/keras.json`.\n        If you never set it, then it will be `\"channels_last\"`.\n    dilation_rate: An integer tuple/list of 1 integer, specifying\n        the dilation rate to use for dilated convolution.\n        Currently, specifying a `dilation_rate` value != 1 is\n        incompatible with specifying a stride value != 1.\n        Also dilation rate larger than 1 is not currently supported.\n    activation: Activation function. If `None`, no activation is applied.\n    use_bias: bool, if `True`, bias will be added to the output.\n    kernel_initializer: Initializer for the convolution kernel. If `None`,\n        the default initializer (`\"glorot_uniform\"`) will be used.\n    bias_initializer: Initializer for the bias vector. If `None`, the\n        default initializer (`\"zeros\"`) will be used.\n    kernel_regularizer: Optional regularizer for the convolution kernel.\n    bias_regularizer: Optional regularizer for the bias vector.\n    activity_regularizer: Optional regularizer function for the output.\n    kernel_constraint: Optional projection function to be applied to the\n        kernel after being updated by an `Optimizer` (e.g. used to implement\n        norm constraints or value constraints for layer weights). The\n        function must take as input the unprojected variable and must return\n        the projected variable (which must have the same shape). Constraints\n        are not safe to use when doing asynchronous distributed training.\n    bias_constraint: Optional projection function to be applied to the\n        bias after being updated by an `Optimizer`.\n\nInput shape:\n\n- If `data_format=\"channels_last\"`:\n    A 3D tensor with shape: `(batch_shape, steps, channels)`\n- If `data_format=\"channels_first\"`:\n    A 3D tensor with shape: `(batch_shape, channels, steps)`\n\nOutput shape:\n\n- If `data_format=\"channels_last\"`:\n    A 3D tensor with shape: `(batch_shape, new_steps, filters)`\n- If `data_format=\"channels_first\"`:\n    A 3D tensor with shape: `(batch_shape, filters, new_steps)`\n\nReturns:\n    A 3D tensor representing\n    `activation(conv1d_transpose(inputs, kernel) + bias)`.\n\nRaises:\n    ValueError: when both `strides > 1` and `dilation_rate > 1`.\n\nReferences:\n- [A guide to convolution arithmetic for deep learning](\n    https://arxiv.org/abs/1603.07285v1)\n- [Deconvolutional Networks](\n    https://www.matthewzeiler.com/mattzeiler/deconvolutionalnetworks.pdf)\n\nExample:\n\n>>> x = np.random.rand(4, 10, 128)\n>>> y = keras.layers.Conv1DTranspose(32, 3, 2, activation='relu')(x)\n>>> print(y.shape)\n(4, 21, 32)",
    "std_args": [
      "filters",
      "kernel_size",
      "strides",
      "padding",
      "output_padding",
      "data_format",
      "dilation_rate",
      "activation",
      "use_bias",
      "kernel_initializer",
      "bias_initializer",
      "kernel_regularizer",
      "bias_regularizer",
      "activity_regularizer",
      "kernel_constraint",
      "bias_constraint",
      "kwargs"
    ],
    "type": "class"
  },
  "Convolution2D": {
    "description": "2D convolution layer.\n\nThis layer creates a convolution kernel that is convolved with the layer\ninput over a 2D spatial (or temporal) dimension (height and width) to\nproduce a tensor of outputs. If `use_bias` is True, a bias vector is created\nand added to the outputs. Finally, if `activation` is not `None`, it is\napplied to the outputs as well.\n\nNote on numerical precision: While in general Keras operation execution\nresults are identical across backends up to 1e-7 precision in float32,\n`Conv2D` operations may show larger variations. Due to the large\nnumber of element-wise multiplications and additions in convolution\noperations, especially with large inputs or kernel sizes, accumulated\nfloating-point differences can exceed this 1e-7 threshold. These variations\nare particularly noticeable when using different backends (e.g., TensorFlow\nvs JAX) or different hardware.\n\nArgs:\n    filters: int, the dimension of the output space (the number of filters\n        in the convolution).\n    kernel_size: int or tuple/list of 2 integer, specifying the size of the\n        convolution window.\n    strides: int or tuple/list of 2 integer, specifying the stride length\n        of the convolution. `strides > 1` is incompatible with\n        `dilation_rate > 1`.\n    padding: string, either `\"valid\"` or `\"same\"` (case-insensitive).\n        `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n        the left/right or up/down of the input. When `padding=\"same\"` and\n        `strides=1`, the output has the same size as the input.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape\n        `(batch_size, height, width, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch_size, channels, height, width)`. It defaults to the\n        `image_data_format` value found in your Keras config file at\n        `~/.keras/keras.json`. If you never set it, then it will be\n        `\"channels_last\"`.\n    dilation_rate: int or tuple/list of 2 integers, specifying the dilation\n        rate to use for dilated convolution.\n    groups: A positive int specifying the number of groups in which the\n        input is split along the channel axis. Each group is convolved\n        separately with `filters // groups` filters. The output is the\n        concatenation of all the `groups` results along the channel axis.\n        Input channels and `filters` must both be divisible by `groups`.\n    activation: Activation function. If `None`, no activation is applied.\n    use_bias: bool, if `True`, bias will be added to the output.\n    kernel_initializer: Initializer for the convolution kernel. If `None`,\n        the default initializer (`\"glorot_uniform\"`) will be used.\n    bias_initializer: Initializer for the bias vector. If `None`, the\n        default initializer (`\"zeros\"`) will be used.\n    kernel_regularizer: Optional regularizer for the convolution kernel.\n    bias_regularizer: Optional regularizer for the bias vector.\n    activity_regularizer: Optional regularizer function for the output.\n    kernel_constraint: Optional projection function to be applied to the\n        kernel after being updated by an `Optimizer` (e.g. used to implement\n        norm constraints or value constraints for layer weights). The\n        function must take as input the unprojected variable and must return\n        the projected variable (which must have the same shape). Constraints\n        are not safe to use when doing asynchronous distributed training.\n    bias_constraint: Optional projection function to be applied to the\n        bias after being updated by an `Optimizer`.\n\nInput shape:\n\n- If `data_format=\"channels_last\"`:\n    A 4D tensor with shape: `(batch_size, height, width, channels)`\n- If `data_format=\"channels_first\"`:\n    A 4D tensor with shape: `(batch_size, channels, height, width)`\n\nOutput shape:\n\n- If `data_format=\"channels_last\"`:\n    A 4D tensor with shape: `(batch_size, new_height, new_width, filters)`\n- If `data_format=\"channels_first\"`:\n    A 4D tensor with shape: `(batch_size, filters, new_height, new_width)`\n\nReturns:\n    A 4D tensor representing `activation(conv2d(inputs, kernel) + bias)`.\n\nRaises:\n    ValueError: when both `strides > 1` and `dilation_rate > 1`.\n\nExample:\n\n>>> x = np.random.rand(4, 10, 10, 128)\n>>> y = keras.layers.Conv2D(32, 3, activation='relu')(x)\n>>> print(y.shape)\n(4, 8, 8, 32)",
    "std_args": [
      "filters",
      "kernel_size",
      "strides",
      "padding",
      "data_format",
      "dilation_rate",
      "groups",
      "activation",
      "use_bias",
      "kernel_initializer",
      "bias_initializer",
      "kernel_regularizer",
      "bias_regularizer",
      "activity_regularizer",
      "kernel_constraint",
      "bias_constraint",
      "kwargs"
    ],
    "type": "class"
  },
  "Convolution2DTranspose": {
    "description": "2D transposed convolution layer.\n\nThe need for transposed convolutions generally arise from the desire to use\na transformation going in the opposite direction of a normal convolution,\ni.e., from something that has the shape of the output of some convolution\nto something that has the shape of its input while maintaining a\nconnectivity pattern that is compatible with said convolution.\n\nArgs:\n    filters: int, the dimension of the output space (the number of filters\n        in the transposed convolution).\n    kernel_size: int or tuple/list of 1 integer, specifying the size of the\n        transposed convolution window.\n    strides: int or tuple/list of 1 integer, specifying the stride length\n        of the transposed convolution. `strides > 1` is incompatible with\n        `dilation_rate > 1`.\n    padding: string, either `\"valid\"` or `\"same\"` (case-insensitive).\n        `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n        the left/right or up/down of the input. When `padding=\"same\"` and\n        `strides=1`, the output has the same size as the input.\n    output_padding: An integer or tuple/list of 2 integers,\n        specifying the amount of padding along the height and width\n        of the output tensor.\n        Can be a single integer to specify the same value for all\n        spatial dimensions.\n        The amount of output padding along a given dimension must be\n        lower than the stride along that same dimension.\n        If set to `None` (default), the output shape is inferred.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape\n        `(batch_size, height, width, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch_size, channels, height, width)`. It defaults to the\n        `image_data_format` value found in your Keras config file at\n        `~/.keras/keras.json`. If you never set it, then it will be\n        `\"channels_last\"`.\n     dilation_rate: An integer or tuple/list of 2 integers,\n        specifying the dilation rate for\n        all spatial dimensions for dilated convolution.\n        Specifying different dilation rates\n        for different dimensions is not supported.\n        Currently, specifying any `dilation_rate` value != 1 is\n        incompatible with specifying any stride value != 1.\n    activation: Activation function. If `None`, no activation is applied.\n    use_bias: bool, if `True`, bias will be added to the output.\n    kernel_initializer: Initializer for the convolution kernel. If `None`,\n        the default initializer (`\"glorot_uniform\"`) will be used.\n    bias_initializer: Initializer for the bias vector. If `None`, the\n        default initializer (`\"zeros\"`) will be used.\n    kernel_regularizer: Optional regularizer for the convolution kernel.\n    bias_regularizer: Optional regularizer for the bias vector.\n    activity_regularizer: Optional regularizer function for the output.\n    kernel_constraint: Optional projection function to be applied to the\n        kernel after being updated by an `Optimizer` (e.g. used to implement\n        norm constraints or value constraints for layer weights). The\n        function must take as input the unprojected variable and must return\n        the projected variable (which must have the same shape). Constraints\n        are not safe to use when doing asynchronous distributed training.\n    bias_constraint: Optional projection function to be applied to the\n        bias after being updated by an `Optimizer`.\n\nInput shape:\n\n- If `data_format=\"channels_last\"`:\n    A 4D tensor with shape: `(batch_size, height, width, channels)`\n- If `data_format=\"channels_first\"`:\n    A 4D tensor with shape: `(batch_size, channels, height, width)`\n\nOutput shape:\n\n- If `data_format=\"channels_last\"`:\n    A 4D tensor with shape: `(batch_size, new_height, new_width, filters)`\n- If `data_format=\"channels_first\"`:\n    A 4D tensor with shape: `(batch_size, filters, new_height, new_width)`\n\nReturns:\n    A 4D tensor representing\n    `activation(conv2d_transpose(inputs, kernel) + bias)`.\n\nRaises:\n    ValueError: when both `strides > 1` and `dilation_rate > 1`.\n\nReferences:\n- [A guide to convolution arithmetic for deep learning](\n    https://arxiv.org/abs/1603.07285v1)\n- [Deconvolutional Networks](\n    https://www.matthewzeiler.com/mattzeiler/deconvolutionalnetworks.pdf)\n\nExample:\n\n>>> x = np.random.rand(4, 10, 8, 128)\n>>> y = keras.layers.Conv2DTranspose(32, 2, 2, activation='relu')(x)\n>>> print(y.shape)\n(4, 20, 16, 32)",
    "std_args": [
      "filters",
      "kernel_size",
      "strides",
      "padding",
      "output_padding",
      "data_format",
      "dilation_rate",
      "activation",
      "use_bias",
      "kernel_initializer",
      "bias_initializer",
      "kernel_regularizer",
      "bias_regularizer",
      "activity_regularizer",
      "kernel_constraint",
      "bias_constraint",
      "kwargs"
    ],
    "type": "class"
  },
  "Convolution3D": {
    "description": "3D convolution layer.\n\nThis layer creates a convolution kernel that is convolved with the layer\ninput over a 3D spatial (or temporal) dimension (width,height and depth) to\nproduce a tensor of outputs. If `use_bias` is True, a bias vector is created\nand added to the outputs. Finally, if `activation` is not `None`, it is\napplied to the outputs as well.\n\nArgs:\n    filters: int, the dimension of the output space (the number of filters\n        in the convolution).\n    kernel_size: int or tuple/list of 3 integer, specifying the size of the\n        convolution window.\n    strides: int or tuple/list of 3 integer, specifying the stride length\n        of the convolution. `strides > 1` is incompatible with\n        `dilation_rate > 1`.\n    padding: string, either `\"valid\"` or `\"same\"` (case-insensitive).\n        `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n        the left/right or up/down of the input. When `padding=\"same\"` and\n        `strides=1`, the output has the same size as the input.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape\n        `(batch_size, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch_size, channels, spatial_dim1, spatial_dim2, spatial_dim3)`.\n        It defaults to the `image_data_format` value found in your Keras\n        config file at `~/.keras/keras.json`. If you never set it, then it\n        will be `\"channels_last\"`.\n    dilation_rate: int or tuple/list of 3 integers, specifying the dilation\n        rate to use for dilated convolution.\n    groups: A positive int specifying the number of groups in which the\n        input is split along the channel axis. Each group is convolved\n        separately with `filters // groups` filters. The output is the\n        concatenation of all the `groups` results along the channel axis.\n        Input channels and `filters` must both be divisible by `groups`.\n    activation: Activation function. If `None`, no activation is applied.\n    use_bias: bool, if `True`, bias will be added to the output.\n    kernel_initializer: Initializer for the convolution kernel. If `None`,\n        the default initializer (`\"glorot_uniform\"`) will be used.\n    bias_initializer: Initializer for the bias vector. If `None`, the\n        default initializer (`\"zeros\"`) will be used.\n    kernel_regularizer: Optional regularizer for the convolution kernel.\n    bias_regularizer: Optional regularizer for the bias vector.\n    activity_regularizer: Optional regularizer function for the output.\n    kernel_constraint: Optional projection function to be applied to the\n        kernel after being updated by an `Optimizer` (e.g. used to implement\n        norm constraints or value constraints for layer weights). The\n        function must take as input the unprojected variable and must return\n        the projected variable (which must have the same shape). Constraints\n        are not safe to use when doing asynchronous distributed training.\n    bias_constraint: Optional projection function to be applied to the\n        bias after being updated by an `Optimizer`.\n\nInput shape:\n\n- If `data_format=\"channels_last\"`:\n    5D tensor with shape:\n    `(batch_size, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n- If `data_format=\"channels_first\"`:\n    5D tensor with shape:\n    `(batch_size, channels, spatial_dim1, spatial_dim2, spatial_dim3)`\n\nOutput shape:\n\n- If `data_format=\"channels_last\"`:\n    5D tensor with shape:\n    `(batch_size, new_spatial_dim1, new_spatial_dim2, new_spatial_dim3,\n    filters)`\n- If `data_format=\"channels_first\"`:\n    5D tensor with shape:\n    `(batch_size, filters, new_spatial_dim1, new_spatial_dim2,\n    new_spatial_dim3)`\n\nReturns:\n    A 5D tensor representing `activation(conv3d(inputs, kernel) + bias)`.\n\nRaises:\n    ValueError: when both `strides > 1` and `dilation_rate > 1`.\n\nExample:\n\n>>> x = np.random.rand(4, 10, 10, 10, 128)\n>>> y = keras.layers.Conv3D(32, 3, activation='relu')(x)\n>>> print(y.shape)\n(4, 8, 8, 8, 32)",
    "std_args": [
      "filters",
      "kernel_size",
      "strides",
      "padding",
      "data_format",
      "dilation_rate",
      "groups",
      "activation",
      "use_bias",
      "kernel_initializer",
      "bias_initializer",
      "kernel_regularizer",
      "bias_regularizer",
      "activity_regularizer",
      "kernel_constraint",
      "bias_constraint",
      "kwargs"
    ],
    "type": "class"
  },
  "Convolution3DTranspose": {
    "description": "3D transposed convolution layer.\n\nThe need for transposed convolutions generally arise from the desire to use\na transformation going in the opposite direction of a normal convolution,\ni.e., from something that has the shape of the output of some convolution\nto something that has the shape of its input while maintaining a\nconnectivity pattern that is compatible with said convolution.\n\nArgs:\n    filters: int, the dimension of the output space (the number of filters\n        in the transposed convolution).\n    kernel_size: int or tuple/list of 1 integer, specifying the size of the\n        transposed convolution window.\n    strides: int or tuple/list of 1 integer, specifying the stride length\n        of the transposed convolution. `strides > 1` is incompatible with\n        `dilation_rate > 1`.\n    padding: string, either `\"valid\"` or `\"same\"` (case-insensitive).\n        `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n        the left/right or up/down of the input. When `padding=\"same\"` and\n        `strides=1`, the output has the same size as the input.\n     output_padding: An integer or tuple/list of 3 integers,\n        specifying the amount of padding along the depth, height, and\n        width.\n        Can be a single integer to specify the same value for all\n        spatial dimensions.\n        The amount of output padding along a given dimension must be\n        lower than the stride along that same dimension.\n        If set to `None` (default), the output shape is inferred.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape\n        `(batch_size, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch_size, channels, spatial_dim1, spatial_dim2, spatial_dim3)`.\n        It defaults to the `image_data_format` value found in your Keras\n        config file at `~/.keras/keras.json`. If you never set it, then it\n        will be `\"channels_last\"`.\n    dilation_rate: an integer or tuple/list of 3 integers, specifying\n        the dilation rate to use for dilated convolution.\n        Can be a single integer to specify the same value for\n        all spatial dimensions.\n        Currently, specifying any `dilation_rate` value != 1 is\n        incompatible with specifying any stride value != 1.\n    activation: Activation function. If `None`, no activation is applied.\n    use_bias: bool, if `True`, bias will be added to the output.\n    kernel_initializer: Initializer for the convolution kernel. If `None`,\n        the default initializer (`\"glorot_uniform\"`) will be used.\n    bias_initializer: Initializer for the bias vector. If `None`, the\n        default initializer (`\"zeros\"`) will be used.\n    kernel_regularizer: Optional regularizer for the convolution kernel.\n    bias_regularizer: Optional regularizer for the bias vector.\n    activity_regularizer: Optional regularizer function for the output.\n    kernel_constraint: Optional projection function to be applied to the\n        kernel after being updated by an `Optimizer` (e.g. used to implement\n        norm constraints or value constraints for layer weights). The\n        function must take as input the unprojected variable and must return\n        the projected variable (which must have the same shape). Constraints\n        are not safe to use when doing asynchronous distributed training.\n    bias_constraint: Optional projection function to be applied to the\n        bias after being updated by an `Optimizer`.\n\nInput shape:\n\n- If `data_format=\"channels_last\"`:\n    5D tensor with shape:\n    `(batch_size, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n- If `data_format=\"channels_first\"`:\n    5D tensor with shape:\n    `(batch_size, channels, spatial_dim1, spatial_dim2, spatial_dim3)`\n\nOutput shape:\n\n- If `data_format=\"channels_last\"`:\n    5D tensor with shape:\n    `(batch_size, new_spatial_dim1, new_spatial_dim2, new_spatial_dim3,\n    filters)`\n- If `data_format=\"channels_first\"`:\n    5D tensor with shape:\n    `(batch_size, filters, new_spatial_dim1, new_spatial_dim2,\n    new_spatial_dim3)`\n\nReturns:\n    A 5D tensor representing `activation(conv3d(inputs, kernel) + bias)`.\n\nRaises:\n    ValueError: when both `strides > 1` and `dilation_rate > 1`.\n\nReferences:\n- [A guide to convolution arithmetic for deep learning](\n    https://arxiv.org/abs/1603.07285v1)\n- [Deconvolutional Networks](\n    https://www.matthewzeiler.com/mattzeiler/deconvolutionalnetworks.pdf)\n\nExample:\n\n>>> x = np.random.rand(4, 10, 8, 12, 128)\n>>> y = keras.layers.Conv3DTranspose(32, 2, 2, activation='relu')(x)\n>>> print(y.shape)\n(4, 20, 16, 24, 32)",
    "std_args": [
      "filters",
      "kernel_size",
      "strides",
      "padding",
      "data_format",
      "output_padding",
      "dilation_rate",
      "activation",
      "use_bias",
      "kernel_initializer",
      "bias_initializer",
      "kernel_regularizer",
      "bias_regularizer",
      "activity_regularizer",
      "kernel_constraint",
      "bias_constraint",
      "kwargs"
    ],
    "type": "class"
  },
  "CosineAnnealingLR": {
    "description": "Set the learning rate of each parameter group using a cosine annealing schedule.",
    "std_args": [
      "optimizer",
      "T_max"
    ]
  },
  "CosineEmbeddingLoss": {
    "description": "Creates a criterion that measures the loss given input tensors",
    "std_args": [
      "self",
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "Counts": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CreateValueHook": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Cropping1D": {
    "description": "Cropping layer for 1D input (e.g. temporal sequence).\n\nIt crops along the time dimension (axis 1).\n\nExample:\n\n>>> input_shape = (2, 3, 2)\n>>> x = np.arange(np.prod(input_shape)).reshape(input_shape)\n>>> x\n[[[ 0  1]\n  [ 2  3]\n  [ 4  5]]\n [[ 6  7]\n  [ 8  9]\n  [10 11]]]\n>>> y = keras.layers.Cropping1D(cropping=1)(x)\n>>> y\n[[[2 3]]\n [[8 9]]]\n\nArgs:\n    cropping: Int, or tuple of int (length 2), or dictionary.\n        - If int: how many units should be trimmed off at the beginning and\n          end of the cropping dimension (axis 1).\n        - If tuple of 2 ints: how many units should be trimmed off at the\n          beginning and end of the cropping dimension\n          (`(left_crop, right_crop)`).\n\nInput shape:\n    3D tensor with shape `(batch_size, axis_to_crop, features)`\n\nOutput shape:\n    3D tensor with shape `(batch_size, cropped_axis, features)`",
    "std_args": [
      "cropping",
      "kwargs"
    ],
    "type": "class"
  },
  "Cropping2D": {
    "description": "Cropping layer for 2D input (e.g. picture).\n\nIt crops along spatial dimensions, i.e. height and width.\n\nExample:\n\n>>> input_shape = (2, 28, 28, 3)\n>>> x = np.arange(np.prod(input_shape)).reshape(input_shape)\n>>> y = keras.layers.Cropping2D(cropping=((2, 2), (4, 4)))(x)\n>>> y.shape\n(2, 24, 20, 3)\n\nArgs:\n    cropping: Int, or tuple of 2 ints, or tuple of 2 tuples of 2 ints.\n        - If int: the same symmetric cropping is applied to height and\n          width.\n        - If tuple of 2 ints: interpreted as two different symmetric\n          cropping values for height and width:\n          `(symmetric_height_crop, symmetric_width_crop)`.\n        - If tuple of 2 tuples of 2 ints: interpreted as\n          `((top_crop, bottom_crop), (left_crop, right_crop))`.\n    data_format: A string, one of `\"channels_last\"` (default) or\n        `\"channels_first\"`. The ordering of the dimensions in the inputs.\n        `\"channels_last\"` corresponds to inputs with shape\n        `(batch_size, height, width, channels)` while `\"channels_first\"`\n        corresponds to inputs with shape\n        `(batch_size, channels, height, width)`.\n        When unspecified, uses `image_data_format` value found in your Keras\n        config file at `~/.keras/keras.json` (if exists). Defaults to\n        `\"channels_last\"`.\n\nInput shape:\n    4D tensor with shape:\n    - If `data_format` is `\"channels_last\"`:\n      `(batch_size, height, width, channels)`\n    - If `data_format` is `\"channels_first\"`:\n      `(batch_size, channels, height, width)`\n\nOutput shape:\n    4D tensor with shape:\n    - If `data_format` is `\"channels_last\"`:\n      `(batch_size, cropped_height, cropped_width, channels)`\n    - If `data_format` is `\"channels_first\"`:\n      `(batch_size, channels, cropped_height, cropped_width)`",
    "std_args": [
      "cropping",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "Cropping3D": {
    "description": "Cropping layer for 3D data (e.g. spatial or spatio-temporal).\n\nExample:\n\n>>> input_shape = (2, 28, 28, 10, 3)\n>>> x = np.arange(np.prod(input_shape)).reshape(input_shape)\n>>> y = keras.layers.Cropping3D(cropping=(2, 4, 2))(x)\n>>> y.shape\n(2, 24, 20, 6, 3)\n\nArgs:\n    cropping: Int, or tuple of 3 ints, or tuple of 3 tuples of 2 ints.\n        - If int: the same symmetric cropping is applied to depth, height,\n          and width.\n        - If tuple of 3 ints: interpreted as three different symmetric\n          cropping values for depth, height, and width:\n          `(symmetric_dim1_crop, symmetric_dim2_crop, symmetric_dim3_crop)`.\n        - If tuple of 3 tuples of 2 ints: interpreted as\n          `((left_dim1_crop, right_dim1_crop), (left_dim2_crop,\n          right_dim2_crop), (left_dim3_crop, right_dim3_crop))`.\n    data_format: A string, one of `\"channels_last\"` (default) or\n        `\"channels_first\"`. The ordering of the dimensions in the inputs.\n        `\"channels_last\"` corresponds to inputs with shape\n        `(batch_size, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch_size, channels, spatial_dim1, spatial_dim2, spatial_dim3)`.\n        When unspecified, uses `image_data_format` value found in your Keras\n        config file at `~/.keras/keras.json` (if exists). Defaults to\n        `\"channels_last\"`.\n\nInput shape:\n    5D tensor with shape:\n    - If `data_format` is `\"channels_last\"`:\n      `(batch_size, first_axis_to_crop, second_axis_to_crop,\n      third_axis_to_crop, channels)`\n    - If `data_format` is `\"channels_first\"`:\n      `(batch_size, channels, first_axis_to_crop, second_axis_to_crop,\n      third_axis_to_crop)`\n\nOutput shape:\n    5D tensor with shape:\n    - If `data_format` is `\"channels_last\"`:\n      `(batch_size, first_cropped_axis, second_cropped_axis,\n      third_cropped_axis, channels)`\n    - If `data_format` is `\"channels_first\"`:\n      `(batch_size, channels, first_cropped_axis, second_cropped_axis,\n      third_cropped_axis)`",
    "std_args": [
      "cropping",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "CrossMapLRN2d": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "size",
      "alpha",
      "beta",
      "k"
    ],
    "type": "class"
  },
  "CudaAvailable": {
    "description": "Checks if a CUDA device is available.",
    "return_type": "bool",
    "std_args": []
  },
  "CustomFromMask": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "mask"
    ],
    "type": "class"
  },
  "CustomVjp": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "fun",
      "nondiff_argnums"
    ],
    "type": "class"
  },
  "CustomVjpFnWrapper": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "f",
      "jax_nondiff_argnums",
      "ctxtag",
      "nondiff_states",
      "nodedefs"
    ],
    "type": "class"
  },
  "CutMix": {
    "description": "CutMix data augmentation technique.\n\nCutMix is a data augmentation method where patches are cut and pasted\nbetween two images in the dataset, while the labels are also mixed\nproportionally to the area of the patches.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nReferences:\n   - [CutMix paper]( https://arxiv.org/abs/1905.04899).\n\nArgs:\n    factor: A single float or a tuple of two floats between 0 and 1.\n        If a tuple of numbers is passed, a `factor` is sampled\n        between the two values.\n        If a single float is passed, a value between 0 and the passed\n        float is sampled. These values define the range from which the\n        mixing weight is sampled. A higher factor increases the variability\n        in patch sizes, leading to more diverse and larger mixed patches.\n        Defaults to 1.\n    seed: Integer. Used to create a random seed.",
    "std_args": [
      "factor",
      "seed",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "CvExpectedValue": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "CvState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DATA_DIR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DATA_REGISTRY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DECIMAL_RE": {
    "description": "Compiled regular expression object.",
    "std_args": [],
    "type": "attribute"
  },
  "DEFAULT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DEREF": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DTYPES_BOOL_INT_UINT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DTypePromotionError": {
    "description": "Multiple DTypes could not be converted to a common one.",
    "std_args": [],
    "type": "class"
  },
  "DataAnnotation": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DataLoader": {
    "description": "Foundational PyTorch Data Loader. Mapped to GenericDataLoader shim via Plugin.",
    "std_args": [
      "dataset",
      "batch_size",
      "shuffle",
      "sampler",
      "batch_sampler",
      "num_workers",
      "collate_fn",
      "pin_memory",
      "drop_last",
      "timeout",
      "worker_init_fn",
      "multiprocessing_context",
      "generator",
      "prefetch_factor",
      "persistent_workers",
      "pin_memory_device"
    ]
  },
  "DataParallel": {
    "description": "Implements data parallelism at the module level.",
    "std_args": [
      "self",
      "module",
      "device_ids",
      "output_device",
      "dim"
    ],
    "type": "class"
  },
  "DateTime64DType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "DelayedAccessor": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "actions"
    ],
    "type": "class"
  },
  "Dense": {
    "description": "Just your regular densely-connected NN layer.\n\n`Dense` implements the operation:\n`output = activation(dot(input, kernel) + bias)`\nwhere `activation` is the element-wise activation function\npassed as the `activation` argument, `kernel` is a weights matrix\ncreated by the layer, and `bias` is a bias vector created by the layer\n(only applicable if `use_bias` is `True`). When this layer is\nfollowed by a `BatchNormalization` layer, it is recommended to set\n`use_bias=False` as `BatchNormalization` has its own bias term.\n\nNote: If the input to the layer has a rank greater than 2, `Dense`\ncomputes the dot product between the `inputs` and the `kernel` along the\nlast axis of the `inputs` and axis 0 of the `kernel` (using `tf.tensordot`).\nFor example, if input has dimensions `(batch_size, d0, d1)`, then we create\na `kernel` with shape `(d1, units)`, and the `kernel` operates along axis 2\nof the `input`, on every sub-tensor of shape `(1, 1, d1)` (there are\n`batch_size * d0` such sub-tensors). The output in this case will have\nshape `(batch_size, d0, units)`.\n\nArgs:\n    units: Positive integer, dimensionality of the output space.\n    activation: Activation function to use.\n        If you don't specify anything, no activation is applied\n        (ie. \"linear\" activation: `a(x) = x`).\n    use_bias: Boolean, whether the layer uses a bias vector.\n    kernel_initializer: Initializer for the `kernel` weights matrix.\n    bias_initializer: Initializer for the bias vector.\n    kernel_regularizer: Regularizer function applied to\n        the `kernel` weights matrix.\n    bias_regularizer: Regularizer function applied to the bias vector.\n    activity_regularizer: Regularizer function applied to\n        the output of the layer (its \"activation\").\n    kernel_constraint: Constraint function applied to\n        the `kernel` weights matrix.\n    bias_constraint: Constraint function applied to the bias vector.\n    lora_rank: Optional integer. If set, the layer's forward pass\n        will implement LoRA (Low-Rank Adaptation)\n        with the provided rank. LoRA sets the layer's kernel\n        to non-trainable and replaces it with a delta over the\n        original kernel, obtained via multiplying two lower-rank\n        trainable matrices. This can be useful to reduce the\n        computation cost of fine-tuning large dense layers.\n        You can also enable LoRA on an existing\n        `Dense` layer by calling `layer.enable_lora(rank)`.\n    lora_alpha: Optional integer. If set, this parameter scales the\n        low-rank adaptation delta (computed as the product of two lower-rank\n        trainable matrices) during the forward pass. The delta is scaled by\n        `lora_alpha / lora_rank`, allowing you to fine-tune the strength of\n        the LoRA adjustment independently of `lora_rank`.\n\nInput shape:\n    N-D tensor with shape: `(batch_size, ..., input_dim)`.\n    The most common situation would be\n    a 2D input with shape `(batch_size, input_dim)`.\n\nOutput shape:\n    N-D tensor with shape: `(batch_size, ..., units)`.\n    For instance, for a 2D input with shape `(batch_size, input_dim)`,\n    the output would have shape `(batch_size, units)`.",
    "std_args": [
      "units",
      "activation",
      "use_bias",
      "kernel_initializer",
      "bias_initializer",
      "kernel_regularizer",
      "bias_regularizer",
      "activity_regularizer",
      "kernel_constraint",
      "bias_constraint",
      "lora_rank",
      "lora_alpha",
      "quantization_config",
      "kwargs"
    ],
    "type": "class"
  },
  "DepthwiseConv1D": {
    "description": "1D depthwise convolution layer.\n\nDepthwise convolution is a type of convolution in which each input channel\nis convolved with a different kernel (called a depthwise kernel). You can\nunderstand depthwise convolution as the first step in a depthwise separable\nconvolution.\n\nIt is implemented via the following steps:\n\n- Split the input into individual channels.\n- Convolve each channel with an individual depthwise kernel with\n  `depth_multiplier` output channels.\n- Concatenate the convolved outputs along the channels axis.\n\nUnlike a regular 1D convolution, depthwise convolution does not mix\ninformation across different input channels.\n\nThe `depth_multiplier` argument determines how many filters are applied to\none input channel. As such, it controls the amount of output channels that\nare generated per input channel in the depthwise step.\n\nArgs:\n    kernel_size: int or tuple/list of 1 integer, specifying the size of the\n        depthwise convolution window.\n    strides: int or tuple/list of 1 integer, specifying the stride length\n        of the convolution. `strides > 1` is incompatible with\n        `dilation_rate > 1`.\n    padding: string, either `\"valid\"` or `\"same\"` (case-insensitive).\n        `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n        the left/right or up/down of the input. When `padding=\"same\"` and\n        `strides=1`, the output has the same size as the input.\n    depth_multiplier: The number of depthwise convolution output channels\n        for each input channel. The total number of depthwise convolution\n        output channels will be equal to `input_channel * depth_multiplier`.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, steps, features)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, features, steps)`. It defaults to the `image_data_format`\n        value found in your Keras config file at `~/.keras/keras.json`.\n        If you never set it, then it will be `\"channels_last\"`.\n    dilation_rate: int or tuple/list of 1 integers, specifying the dilation\n        rate to use for dilated convolution.\n    activation: Activation function. If `None`, no activation is applied.\n    use_bias: bool, if `True`, bias will be added to the output.\n    depthwise_initializer: Initializer for the convolution kernel.\n        If `None`, the default initializer (`\"glorot_uniform\"`)\n        will be used.\n    bias_initializer: Initializer for the bias vector. If `None`, the\n        default initializer (`\"zeros\"`) will be used.\n    depthwise_regularizer: Optional regularizer for the convolution kernel.\n    bias_regularizer: Optional regularizer for the bias vector.\n    activity_regularizer: Optional regularizer function for the output.\n    depthwise_constraint: Optional projection function to be applied to the\n        kernel after being updated by an `Optimizer` (e.g. used to implement\n        norm constraints or value constraints for layer weights). The\n        function must take as input the unprojected variable and must return\n        the projected variable (which must have the same shape). Constraints\n        are not safe to use when doing asynchronous distributed training.\n    bias_constraint: Optional projection function to be applied to the\n        bias after being updated by an `Optimizer`.\n\nInput shape:\n\n- If `data_format=\"channels_last\"`:\n    A 3D tensor with shape: `(batch_shape, steps, channels)`\n- If `data_format=\"channels_first\"`:\n    A 3D tensor with shape: `(batch_shape, channels, steps)`\n\nOutput shape:\n\n- If `data_format=\"channels_last\"`:\n    A 3D tensor with shape:\n    `(batch_shape, new_steps, channels * depth_multiplier)`\n- If `data_format=\"channels_first\"`:\n    A 3D tensor with shape:\n    `(batch_shape, channels * depth_multiplier, new_steps)`\n\nReturns:\n    A 3D tensor representing\n    `activation(depthwise_conv1d(inputs, kernel) + bias)`.\n\nRaises:\n    ValueError: when both `strides > 1` and `dilation_rate > 1`.\n\nExample:\n\n>>> x = np.random.rand(4, 10, 12)\n>>> y = keras.layers.DepthwiseConv1D(3, 3, 2, activation='relu')(x)\n>>> print(y.shape)\n(4, 4, 36)",
    "std_args": [
      "kernel_size",
      "strides",
      "padding",
      "depth_multiplier",
      "data_format",
      "dilation_rate",
      "activation",
      "use_bias",
      "depthwise_initializer",
      "bias_initializer",
      "depthwise_regularizer",
      "bias_regularizer",
      "activity_regularizer",
      "depthwise_constraint",
      "bias_constraint",
      "kwargs"
    ],
    "type": "class"
  },
  "DepthwiseConv2D": {
    "description": "2D depthwise convolution layer.\n\nDepthwise convolution is a type of convolution in which each input channel\nis convolved with a different kernel (called a depthwise kernel). You can\nunderstand depthwise convolution as the first step in a depthwise separable\nconvolution.\n\nIt is implemented via the following steps:\n\n- Split the input into individual channels.\n- Convolve each channel with an individual depthwise kernel with\n  `depth_multiplier` output channels.\n- Concatenate the convolved outputs along the channels axis.\n\nUnlike a regular 2D convolution, depthwise convolution does not mix\ninformation across different input channels.\n\nThe `depth_multiplier` argument determines how many filters are applied to\none input channel. As such, it controls the amount of output channels that\nare generated per input channel in the depthwise step.\n\nArgs:\n    kernel_size: int or tuple/list of 2 integer, specifying the size of the\n        depthwise convolution window.\n    strides: int or tuple/list of 2 integer, specifying the stride length\n        of the depthwise convolution. `strides > 1` is incompatible with\n        `dilation_rate > 1`.\n    padding: string, either `\"valid\"` or `\"same\"` (case-insensitive).\n        `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n        the left/right or up/down of the input. When `padding=\"same\"` and\n        `strides=1`, the output has the same size as the input.\n    depth_multiplier: The number of depthwise convolution output channels\n        for each input channel. The total number of depthwise convolution\n        output channels will be equal to `input_channel * depth_multiplier`.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, height, width, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, channels, height, width)`. It defaults to the\n        `image_data_format` value found in your Keras config file\n        at `~/.keras/keras.json`.\n        If you never set it, then it will be `\"channels_last\"`.\n    dilation_rate: int or tuple/list of 2 integers, specifying the dilation\n        rate to use for dilated convolution.\n    activation: Activation function. If `None`, no activation is applied.\n    use_bias: bool, if `True`, bias will be added to the output.\n    depthwise_initializer: Initializer for the convolution kernel.\n        If `None`, the default initializer (`\"glorot_uniform\"`)\n        will be used.\n    bias_initializer: Initializer for the bias vector. If `None`, the\n        default initializer (`\"zeros\"`) will be used.\n    depthwise_regularizer: Optional regularizer for the convolution kernel.\n    bias_regularizer: Optional regularizer for the bias vector.\n    activity_regularizer: Optional regularizer function for the output.\n    depthwise_constraint: Optional projection function to be applied to the\n        kernel after being updated by an `Optimizer` (e.g. used to implement\n        norm constraints or value constraints for layer weights). The\n        function must take as input the unprojected variable and must return\n        the projected variable (which must have the same shape). Constraints\n        are not safe to use when doing asynchronous distributed training.\n    bias_constraint: Optional projection function to be applied to the\n        bias after being updated by an `Optimizer`.\n\nInput shape:\n\n- If `data_format=\"channels_last\"`:\n    A 4D tensor with shape: `(batch_size, height, width, channels)`\n- If `data_format=\"channels_first\"`:\n    A 4D tensor with shape: `(batch_size, channels, height, width)`\n\nOutput shape:\n\n- If `data_format=\"channels_last\"`:\n    A 4D tensor with shape:\n    `(batch_size, new_height, new_width, channels * depth_multiplier)`\n- If `data_format=\"channels_first\"`:\n    A 4D tensor with shape:\n    `(batch_size, channels * depth_multiplier, new_height, new_width)`\n\nReturns:\n    A 4D tensor representing\n    `activation(depthwise_conv2d(inputs, kernel) + bias)`.\n\nRaises:\n    ValueError: when both `strides > 1` and `dilation_rate > 1`.\n\nExample:\n\n>>> x = np.random.rand(4, 10, 10, 12)\n>>> y = keras.layers.DepthwiseConv2D(kernel_size=3, activation='relu')(x)\n>>> print(y.shape)\n(4, 8, 8, 12)",
    "std_args": [
      "kernel_size",
      "strides",
      "padding",
      "depth_multiplier",
      "data_format",
      "dilation_rate",
      "activation",
      "use_bias",
      "depthwise_initializer",
      "bias_initializer",
      "depthwise_regularizer",
      "bias_regularizer",
      "activity_regularizer",
      "depthwise_constraint",
      "bias_constraint",
      "kwargs"
    ],
    "type": "class"
  },
  "DetCases": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Device": {
    "description": "Abstract Device placement context.",
    "std_args": [
      "type",
      "index"
    ],
    "type": "attribute"
  },
  "DeviceType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Dict": {
    "description": "A Module that implements a mutable mapping.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "DiffState": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "argnum",
      "filter"
    ],
    "type": "class"
  },
  "Discretization": {
    "description": "A preprocessing layer which buckets continuous features by ranges.\n\nThis layer will place each element of its input data into one of several\ncontiguous ranges and output an integer index indicating which range each\nelement was placed in.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nInput shape:\n    Any array of dimension 2 or higher.\n\nOutput shape:\n    Same as input shape.\n\nArguments:\n    bin_boundaries: A list of bin boundaries.\n        The leftmost and rightmost bins\n        will always extend to `-inf` and `inf`,\n        so `bin_boundaries=[0., 1., 2.]`\n        generates bins `(-inf, 0.)`, `[0., 1.)`, `[1., 2.)`,\n        and `[2., +inf)`.\n        If this option is set, `adapt()` should not be called.\n    num_bins: The integer number of bins to compute.\n        If this option is set, `bin_boundaries` should not be set and\n        `adapt()` should be called to learn the bin boundaries.\n    epsilon: Error tolerance, typically a small fraction\n        close to zero (e.g. 0.01). Higher values of epsilon increase\n        the quantile approximation, and hence result in more\n        unequal buckets, but could improve performance\n        and resource consumption.\n    output_mode: Specification for the output of the layer.\n        Values can be `\"int\"`, `\"one_hot\"`, `\"multi_hot\"`, or\n        `\"count\"` configuring the layer as follows:\n        - `\"int\"`: Return the discretized bin indices directly.\n        - `\"one_hot\"`: Encodes each individual element in the\n            input into an array the same size as `num_bins`,\n            containing a 1 at the input's bin\n            index. If the last dimension is size 1, will encode on that\n            dimension.  If the last dimension is not size 1,\n            will append a new dimension for the encoded output.\n        - `\"multi_hot\"`: Encodes each sample in the input into a\n            single array the same size as `num_bins`,\n            containing a 1 for each bin index\n            index present in the sample.\n            Treats the last dimension as the sample\n            dimension, if input shape is `(..., sample_length)`,\n            output shape will be `(..., num_tokens)`.\n        - `\"count\"`: As `\"multi_hot\"`, but the int array contains\n            a count of the number of times the bin index appeared\n            in the sample.\n        Defaults to `\"int\"`.\n    sparse: Boolean. Only applicable to `\"one_hot\"`, `\"multi_hot\"`,\n        and `\"count\"` output modes. Only supported with TensorFlow\n        backend. If `True`, returns a `SparseTensor` instead of\n        a dense `Tensor`. Defaults to `False`.\n\nExamples:\n\nDiscretize float values based on provided buckets.\n>>> input = np.array([[-1.5, 1.0, 3.4, .5], [0.0, 3.0, 1.3, 0.0]])\n>>> layer = Discretization(bin_boundaries=[0., 1., 2.])\n>>> layer(input)\narray([[0, 2, 3, 1],\n       [1, 3, 2, 1]])\n\nDiscretize float values based on a number of buckets to compute.\n>>> input = np.array([[-1.5, 1.0, 3.4, .5], [0.0, 3.0, 1.3, 0.0]])\n>>> layer = Discretization(num_bins=4, epsilon=0.01)\n>>> layer.adapt(input)\n>>> layer(input)\narray([[0, 2, 3, 2],\n       [1, 3, 3, 1]])",
    "std_args": [
      "bin_boundaries",
      "num_bins",
      "epsilon",
      "output_mode",
      "sparse",
      "dtype",
      "name"
    ],
    "type": "class"
  },
  "DistributedDataParallel": {
    "description": "Implement distributed data parallelism based on ``torch.distributed`` at module level.",
    "std_args": [
      "self",
      "module",
      "device_ids",
      "output_device",
      "dim",
      "broadcast_buffers",
      "init_sync",
      "process_group",
      "bucket_cap_mb",
      "find_unused_parameters",
      "check_reduction",
      "gradient_as_bucket_view",
      "static_graph",
      "delay_all_reduce_named_params",
      "param_to_hook_all_reduce",
      "mixed_precision",
      "device_mesh",
      "skip_all_reduce_unused_params"
    ],
    "type": "class"
  },
  "DistributedDataParallelCPU": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "module",
      "device_ids",
      "output_device",
      "dim",
      "broadcast_buffers",
      "init_sync",
      "process_group",
      "bucket_cap_mb",
      "find_unused_parameters",
      "check_reduction",
      "gradient_as_bucket_view",
      "static_graph",
      "delay_all_reduce_named_params",
      "param_to_hook_all_reduce",
      "mixed_precision",
      "device_mesh",
      "skip_all_reduce_unused_params"
    ],
    "type": "class"
  },
  "Dropout1d": {
    "description": "Randomly zero out entire channels.",
    "std_args": [
      "self",
      "p",
      "inplace"
    ],
    "type": "class"
  },
  "Dropout2d": {
    "description": "Randomly zero out entire channels.",
    "std_args": [
      "self",
      "p",
      "inplace"
    ],
    "type": "class"
  },
  "Dropout3d": {
    "description": "Randomly zero out entire channels.",
    "std_args": [
      "self",
      "p",
      "inplace"
    ],
    "type": "class"
  },
  "DtypeCategory": {
    "description": "Type to hold categories of :class:`dtypes <Dtype>`.",
    "std_args": [],
    "type": "class"
  },
  "DtypeLikeInexact": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "END": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "EQ": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "EigCases": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "EigvalsCases": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "EinsumDense": {
    "description": "A layer that uses `einsum` as the backing computation.\n\nThis layer can perform einsum calculations of arbitrary dimensionality.\n\nArgs:\n    equation: An equation describing the einsum to perform.\n        This equation must be a valid einsum string of the form\n        `ab,bc->ac`, `...ab,bc->...ac`, or\n        `ab...,bc->ac...` where 'ab', 'bc', and 'ac' can be any valid einsum\n        axis expression sequence.\n    output_shape: The expected shape of the output tensor\n        (excluding the batch dimension and any dimensions\n        represented by ellipses). You can specify `None` for any dimension\n        that is unknown or can be inferred from the input shape.\n    activation: Activation function to use. If you don't specify anything,\n        no activation is applied\n        (that is, a \"linear\" activation: `a(x) = x`).\n    bias_axes: A string containing the output dimension(s)\n        to apply a bias to. Each character in the `bias_axes` string\n        should correspond to a character in the output portion\n        of the `equation` string.\n    kernel_initializer: Initializer for the `kernel` weights matrix.\n    bias_initializer: Initializer for the bias vector.\n    kernel_regularizer: Regularizer function applied to the `kernel` weights\n        matrix.\n    bias_regularizer: Regularizer function applied to the bias vector.\n    kernel_constraint: Constraint function applied to the `kernel` weights\n        matrix.\n    bias_constraint: Constraint function applied to the bias vector.\n    lora_rank: Optional integer. If set, the layer's forward pass\n        will implement LoRA (Low-Rank Adaptation)\n        with the provided rank. LoRA sets the layer's kernel\n        to non-trainable and replaces it with a delta over the\n        original kernel, obtained via multiplying two lower-rank\n        trainable matrices\n        (the factorization happens on the last dimension).\n        This can be useful to reduce the\n        computation cost of fine-tuning large dense layers.\n        You can also enable LoRA on an existing\n        `EinsumDense` layer by calling `layer.enable_lora(rank)`.\n     lora_alpha: Optional integer. If set, this parameter scales the\n        low-rank adaptation delta (computed as the product of two lower-rank\n        trainable matrices) during the forward pass. The delta is scaled by\n        `lora_alpha / lora_rank`, allowing you to fine-tune the strength of\n        the LoRA adjustment independently of `lora_rank`.\n    **kwargs: Base layer keyword arguments, such as `name` and `dtype`.\n\nExamples:\n\n**Biased dense layer with einsums**\n\nThis example shows how to instantiate a standard Keras dense layer using\neinsum operations. This example is equivalent to\n`keras.layers.Dense(64, use_bias=True)`.\n\n>>> layer = keras.layers.EinsumDense(\"ab,bc->ac\",\n...                                       output_shape=64,\n...                                       bias_axes=\"c\")\n>>> input_tensor = keras.Input(shape=[32])\n>>> output_tensor = layer(input_tensor)\n>>> output_tensor.shape\n(None, 64)\n\n**Applying a dense layer to a sequence**\n\nThis example shows how to instantiate a layer that applies the same dense\noperation to every element in a sequence. Here, the `output_shape` has two\nvalues (since there are two non-batch dimensions in the output); the first\ndimension in the `output_shape` is `None`, because the sequence dimension\n`b` has an unknown shape.\n\n>>> layer = keras.layers.EinsumDense(\"abc,cd->abd\",\n...                                       output_shape=(None, 64),\n...                                       bias_axes=\"d\")\n>>> input_tensor = keras.Input(shape=[32, 128])\n>>> output_tensor = layer(input_tensor)\n>>> output_tensor.shape\n(None, 32, 64)\n\n**Applying a dense layer to a sequence using ellipses**\n\nThis example shows how to instantiate a layer that applies the same dense\noperation to every element in a sequence, but uses the ellipsis notation\ninstead of specifying the batch and sequence dimensions.\n\nBecause we are using ellipsis notation and have specified only one axis, the\n`output_shape` arg is a single value. When instantiated in this way, the\nlayer can handle any number of sequence dimensions - including the case\nwhere no sequence dimension exists.\n\n>>> layer = keras.layers.EinsumDense(\"...x,xy->...y\",\n...                                       output_shape=64,\n...                                       bias_axes=\"y\")\n>>> input_tensor = keras.Input(shape=[32, 128])\n>>> output_tensor = layer(input_tensor)\n>>> output_tensor.shape\n(None, 32, 64)",
    "std_args": [
      "equation",
      "output_shape",
      "activation",
      "bias_axes",
      "kernel_initializer",
      "bias_initializer",
      "kernel_regularizer",
      "bias_regularizer",
      "kernel_constraint",
      "bias_constraint",
      "lora_rank",
      "lora_alpha",
      "gptq_unpacked_column_size",
      "quantization_config",
      "kwargs"
    ],
    "type": "class"
  },
  "EmaState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Embed": {
    "description": "Embedding Module.",
    "std_args": [
      "self",
      "num_embeddings",
      "features",
      "dtype",
      "param_dtype",
      "embedding_init",
      "promote_dtype",
      "rngs",
      "embedding_metadata"
    ],
    "type": "class"
  },
  "EmbeddingBag": {
    "description": "Compute sums or means of 'bags' of embeddings, without instantiating the intermediate embeddings.",
    "std_args": [
      "self",
      "num_embeddings",
      "embedding_dim",
      "max_norm",
      "norm_type",
      "scale_grad_by_freq",
      "mode",
      "sparse",
      "_weight",
      "include_last_offset",
      "padding_idx",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "Equalization": {
    "description": "Preprocessing layer for histogram equalization on image channels.\n\nHistogram equalization is a technique to adjust image intensities to\nenhance contrast by effectively spreading out the most frequent\nintensity values. This layer applies equalization on a channel-wise\nbasis, which can improve the visibility of details in images.\n\nThis layer works with both grayscale and color images, performing\nequalization independently on each color channel. At inference time,\nthe equalization is consistently applied.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nArgs:\n    value_range: Optional list/tuple of 2 floats specifying the lower\n        and upper limits of the input data values. Defaults to `[0, 255]`.\n        If the input image has been scaled, use the appropriate range\n        (e.g., `[0.0, 1.0]`). The equalization will be scaled to this\n        range, and output values will be clipped accordingly.\n    bins: Integer specifying the number of histogram bins to use for\n        equalization. Defaults to 256, which is suitable for 8-bit images.\n        Larger values can provide more granular intensity redistribution.\n\nInput shape:\n    3D (unbatched) or 4D (batched) tensor with shape:\n    `(..., height, width, channels)`, in `\"channels_last\"` format,\n    or `(..., channels, height, width)`, in `\"channels_first\"` format.\n\nOutput shape:\n    3D (unbatched) or 4D (batched) tensor with shape:\n    `(..., target_height, target_width, channels)`,\n    or `(..., channels, target_height, target_width)`,\n    in `\"channels_first\"` format.\n\nExample:\n\n```python\n# Create an equalization layer for standard 8-bit images\nequalizer = keras.layers.Equalization()\n\n# An image with uneven intensity distribution\nimage = [...] # your input image\n\n# Apply histogram equalization\nequalized_image = equalizer(image)\n\n# For images with custom value range\ncustom_equalizer = keras.layers.Equalization(\n    value_range=[0.0, 1.0],  # for normalized images\n    bins=128  # fewer bins for more subtle equalization\n)\ncustom_equalized = custom_equalizer(normalized_image)\n```",
    "std_args": [
      "value_range",
      "bins",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "Everything": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Expr": {
    "description": "Represents a Fortran expression as an op-data pair.",
    "std_args": [
      "self",
      "op",
      "data"
    ],
    "type": "class"
  },
  "ExprWarning": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "ExtractValueFn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "F": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "F2PYError": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "F2PyTest": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "FACTORS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FAIL_DIR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FILES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FORCE_USE_FLEX_ATTENTION": {
    "description": "If True, forces the use of the flex attention kernel instead of potentially using",
    "std_args": [],
    "type": "attribute"
  },
  "Fargs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FeatureAlphaDropout": {
    "description": "Randomly masks out entire channels.",
    "std_args": [
      "self",
      "p",
      "inplace"
    ],
    "type": "class"
  },
  "Filter": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FilterLiteral": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FindFuncs": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "filename"
    ],
    "type": "class"
  },
  "FlatState": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "items",
      "sort"
    ],
    "type": "class"
  },
  "FlexKernelOptions": {
    "description": "Options for controlling the behavior of FlexAttention kernels.",
    "std_args": [],
    "type": "class"
  },
  "Float16DType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Float32DType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Float64DType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Fold": {
    "description": "Combines an array of sliding local blocks into a large containing tensor.",
    "std_args": [
      "self",
      "output_size",
      "kernel_size",
      "dilation",
      "padding",
      "stride"
    ],
    "type": "class"
  },
  "ForiLoopBodyFn": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "f"
    ],
    "type": "class"
  },
  "Fortran": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "FractionalMaxPool2d": {
    "description": "Applies a 2D fractional max pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "kernel_size",
      "output_size",
      "output_ratio",
      "return_indices",
      "_random_samples"
    ],
    "type": "class"
  },
  "FractionalMaxPool3d": {
    "description": "Applies a 3D fractional max pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "kernel_size",
      "output_size",
      "output_ratio",
      "return_indices",
      "_random_samples"
    ],
    "type": "class"
  },
  "FunctionExporter": {
    "description": "A context managing class for exporting multiple traces of the same",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "Functional": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "module_type",
      "graphdef",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "FwdFn": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "fwd",
      "nondiff_argnums",
      "ctxtag",
      "nondiff_states",
      "nodedefs"
    ],
    "type": "class"
  },
  "G": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "GE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "GRAPH_CONTEXT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "GRAPH_REGISTRY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "GRID_SAMPLE_INTERPOLATION_MODES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "GRID_SAMPLE_PADDING_MODES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "GT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "GaussianDropout": {
    "description": "Apply multiplicative 1-centered Gaussian noise.\n\nAs it is a regularization layer, it is only active at training time.\n\nArgs:\n    rate: Float, drop probability (as with `Dropout`).\n        The multiplicative noise will have\n        standard deviation `sqrt(rate / (1 - rate))`.\n    seed: Integer, optional random seed to enable deterministic behavior.\n\nCall arguments:\n    inputs: Input tensor (of any rank).\n    training: Python boolean indicating whether the layer should behave in\n        training mode (adding dropout) or in inference mode (doing nothing).",
    "std_args": [
      "rate",
      "seed",
      "kwargs"
    ],
    "type": "class"
  },
  "GaussianNLLLoss": {
    "description": "Gaussian negative log likelihood loss.",
    "std_args": [
      "self",
      "full",
      "eps",
      "reduction"
    ],
    "type": "class"
  },
  "GaussianNoise": {
    "description": "Apply additive zero-centered Gaussian noise.\n\nThis is useful to mitigate overfitting\n(you could see it as a form of random data augmentation).\nGaussian Noise (GS) is a natural choice as corruption process\nfor real valued inputs.\n\nAs it is a regularization layer, it is only active at training time.\n\nArgs:\n    stddev: Float, standard deviation of the noise distribution.\n    seed: Integer, optional random seed to enable deterministic behavior.\n\nCall arguments:\n    inputs: Input tensor (of any rank).\n    training: Python boolean indicating whether the layer should behave in\n        training mode (adding noise) or in inference mode (doing nothing).",
    "std_args": [
      "stddev",
      "seed",
      "kwargs"
    ],
    "type": "class"
  },
  "GenericObject": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "v"
    ],
    "type": "class"
  },
  "GenericPytree": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "GetAttr": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "name"
    ],
    "type": "class"
  },
  "GetItem": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "key"
    ],
    "type": "class"
  },
  "GetValueHook": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "GetVariable": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "GlobalAveragePooling1D": {
    "description": "Global average pooling operation for temporal data.\n\nArgs:\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, steps, features)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, features, steps)`. It defaults to the `image_data_format`\n        value found in your Keras config file at `~/.keras/keras.json`.\n        If you never set it, then it will be `\"channels_last\"`.\n    keepdims: A boolean, whether to keep the temporal dimension or not.\n        If `keepdims` is `False` (default), the rank of the tensor is\n        reduced for spatial dimensions. If `keepdims` is `True`, the\n        temporal dimension are retained with length 1.\n        The behavior is the same as for `tf.reduce_mean` or `np.mean`.\n\nCall arguments:\n    inputs: A 3D tensor.\n    mask: Binary tensor of shape `(batch_size, steps)` indicating whether\n        a given step should be masked (excluded from the average).\n\nInput shape:\n\n- If `data_format='channels_last'`:\n    3D tensor with shape:\n    `(batch_size, steps, features)`\n- If `data_format='channels_first'`:\n    3D tensor with shape:\n    `(batch_size, features, steps)`\n\nOutput shape:\n\n- If `keepdims=False`:\n    2D tensor with shape `(batch_size, features)`.\n- If `keepdims=True`:\n    - If `data_format=\"channels_last\"`:\n        3D tensor with shape `(batch_size, 1, features)`\n    - If `data_format=\"channels_first\"`:\n        3D tensor with shape `(batch_size, features, 1)`\n\nExample:\n\n>>> x = np.random.rand(2, 3, 4)\n>>> y = keras.layers.GlobalAveragePooling1D()(x)\n>>> y.shape\n(2, 4)",
    "std_args": [
      "data_format",
      "keepdims",
      "kwargs"
    ],
    "type": "class"
  },
  "GlobalAveragePooling2D": {
    "description": "Global average pooling operation for 2D data.\n\nArgs:\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, height, width, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, features, height, weight)`. It defaults to the\n        `image_data_format` value found in your Keras config file at\n        `~/.keras/keras.json`. If you never set it, then it will be\n        `\"channels_last\"`.\n    keepdims: A boolean, whether to keep the temporal dimension or not.\n        If `keepdims` is `False` (default), the rank of the tensor is\n        reduced for spatial dimensions. If `keepdims` is `True`, the\n        spatial dimension are retained with length 1.\n        The behavior is the same as for `tf.reduce_mean` or `np.mean`.\n\nInput shape:\n\n- If `data_format='channels_last'`:\n    4D tensor with shape:\n    `(batch_size, height, width, channels)`\n- If `data_format='channels_first'`:\n    4D tensor with shape:\n    `(batch_size, channels, height, width)`\n\nOutput shape:\n\n- If `keepdims=False`:\n    2D tensor with shape `(batch_size, channels)`.\n- If `keepdims=True`:\n    - If `data_format=\"channels_last\"`:\n        4D tensor with shape `(batch_size, 1, 1, channels)`\n    - If `data_format=\"channels_first\"`:\n        4D tensor with shape `(batch_size, channels, 1, 1)`\n\nExample:\n\n>>> x = np.random.rand(2, 4, 5, 3)\n>>> y = keras.layers.GlobalAveragePooling2D()(x)\n>>> y.shape\n(2, 3)",
    "std_args": [
      "data_format",
      "keepdims",
      "kwargs"
    ],
    "type": "class"
  },
  "GlobalAveragePooling3D": {
    "description": "Global average pooling operation for 3D data.\n\nArgs:\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape\n        `(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3)`.\n        It defaults to the `image_data_format` value found in your Keras\n        config file at `~/.keras/keras.json`. If you never set it, then it\n        will be `\"channels_last\"`.\n    keepdims: A boolean, whether to keep the temporal dimension or not.\n        If `keepdims` is `False` (default), the rank of the tensor is\n        reduced for spatial dimensions. If `keepdims` is `True`, the\n        spatial dimension are retained with length 1.\n        The behavior is the same as for `tf.reduce_mean` or `np.mean`.\n\nInput shape:\n\n- If `data_format='channels_last'`:\n    5D tensor with shape:\n    `(batch_size, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n- If `data_format='channels_first'`:\n    5D tensor with shape:\n    `(batch_size, channels, spatial_dim1, spatial_dim2, spatial_dim3)`\n\nOutput shape:\n\n- If `keepdims=False`:\n    2D tensor with shape `(batch_size, channels)`.\n- If `keepdims=True`:\n    - If `data_format=\"channels_last\"`:\n        5D tensor with shape `(batch_size, 1, 1, 1, channels)`\n    - If `data_format=\"channels_first\"`:\n        5D tensor with shape `(batch_size, channels, 1, 1, 1)`\n\nExample:\n\n>>> x = np.random.rand(2, 4, 5, 4, 3)\n>>> y = keras.layers.GlobalAveragePooling3D()(x)\n>>> y.shape\n(2, 3)",
    "std_args": [
      "data_format",
      "keepdims",
      "kwargs"
    ],
    "type": "class"
  },
  "GlobalAvgPool1D": {
    "description": "Global average pooling operation for temporal data.\n\nArgs:\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, steps, features)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, features, steps)`. It defaults to the `image_data_format`\n        value found in your Keras config file at `~/.keras/keras.json`.\n        If you never set it, then it will be `\"channels_last\"`.\n    keepdims: A boolean, whether to keep the temporal dimension or not.\n        If `keepdims` is `False` (default), the rank of the tensor is\n        reduced for spatial dimensions. If `keepdims` is `True`, the\n        temporal dimension are retained with length 1.\n        The behavior is the same as for `tf.reduce_mean` or `np.mean`.\n\nCall arguments:\n    inputs: A 3D tensor.\n    mask: Binary tensor of shape `(batch_size, steps)` indicating whether\n        a given step should be masked (excluded from the average).\n\nInput shape:\n\n- If `data_format='channels_last'`:\n    3D tensor with shape:\n    `(batch_size, steps, features)`\n- If `data_format='channels_first'`:\n    3D tensor with shape:\n    `(batch_size, features, steps)`\n\nOutput shape:\n\n- If `keepdims=False`:\n    2D tensor with shape `(batch_size, features)`.\n- If `keepdims=True`:\n    - If `data_format=\"channels_last\"`:\n        3D tensor with shape `(batch_size, 1, features)`\n    - If `data_format=\"channels_first\"`:\n        3D tensor with shape `(batch_size, features, 1)`\n\nExample:\n\n>>> x = np.random.rand(2, 3, 4)\n>>> y = keras.layers.GlobalAveragePooling1D()(x)\n>>> y.shape\n(2, 4)",
    "std_args": [
      "data_format",
      "keepdims",
      "kwargs"
    ],
    "type": "class"
  },
  "GlobalAvgPool2D": {
    "description": "Global average pooling operation for 2D data.\n\nArgs:\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, height, width, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, features, height, weight)`. It defaults to the\n        `image_data_format` value found in your Keras config file at\n        `~/.keras/keras.json`. If you never set it, then it will be\n        `\"channels_last\"`.\n    keepdims: A boolean, whether to keep the temporal dimension or not.\n        If `keepdims` is `False` (default), the rank of the tensor is\n        reduced for spatial dimensions. If `keepdims` is `True`, the\n        spatial dimension are retained with length 1.\n        The behavior is the same as for `tf.reduce_mean` or `np.mean`.\n\nInput shape:\n\n- If `data_format='channels_last'`:\n    4D tensor with shape:\n    `(batch_size, height, width, channels)`\n- If `data_format='channels_first'`:\n    4D tensor with shape:\n    `(batch_size, channels, height, width)`\n\nOutput shape:\n\n- If `keepdims=False`:\n    2D tensor with shape `(batch_size, channels)`.\n- If `keepdims=True`:\n    - If `data_format=\"channels_last\"`:\n        4D tensor with shape `(batch_size, 1, 1, channels)`\n    - If `data_format=\"channels_first\"`:\n        4D tensor with shape `(batch_size, channels, 1, 1)`\n\nExample:\n\n>>> x = np.random.rand(2, 4, 5, 3)\n>>> y = keras.layers.GlobalAveragePooling2D()(x)\n>>> y.shape\n(2, 3)",
    "std_args": [
      "data_format",
      "keepdims",
      "kwargs"
    ],
    "type": "class"
  },
  "GlobalAvgPool3D": {
    "description": "Global average pooling operation for 3D data.\n\nArgs:\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape\n        `(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3)`.\n        It defaults to the `image_data_format` value found in your Keras\n        config file at `~/.keras/keras.json`. If you never set it, then it\n        will be `\"channels_last\"`.\n    keepdims: A boolean, whether to keep the temporal dimension or not.\n        If `keepdims` is `False` (default), the rank of the tensor is\n        reduced for spatial dimensions. If `keepdims` is `True`, the\n        spatial dimension are retained with length 1.\n        The behavior is the same as for `tf.reduce_mean` or `np.mean`.\n\nInput shape:\n\n- If `data_format='channels_last'`:\n    5D tensor with shape:\n    `(batch_size, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n- If `data_format='channels_first'`:\n    5D tensor with shape:\n    `(batch_size, channels, spatial_dim1, spatial_dim2, spatial_dim3)`\n\nOutput shape:\n\n- If `keepdims=False`:\n    2D tensor with shape `(batch_size, channels)`.\n- If `keepdims=True`:\n    - If `data_format=\"channels_last\"`:\n        5D tensor with shape `(batch_size, 1, 1, 1, channels)`\n    - If `data_format=\"channels_first\"`:\n        5D tensor with shape `(batch_size, channels, 1, 1, 1)`\n\nExample:\n\n>>> x = np.random.rand(2, 4, 5, 4, 3)\n>>> y = keras.layers.GlobalAveragePooling3D()(x)\n>>> y.shape\n(2, 3)",
    "std_args": [
      "data_format",
      "keepdims",
      "kwargs"
    ],
    "type": "class"
  },
  "GlobalMaxPool1D": {
    "description": "Global max pooling operation for temporal data.\n\nArgs:\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, steps, features)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, features, steps)`. It defaults to the `image_data_format`\n        value found in your Keras config file at `~/.keras/keras.json`.\n        If you never set it, then it will be `\"channels_last\"`.\n    keepdims: A boolean, whether to keep the temporal dimension or not.\n        If `keepdims` is `False` (default), the rank of the tensor is\n        reduced for spatial dimensions. If `keepdims` is `True`, the\n        temporal dimension are retained with length 1.\n        The behavior is the same as for `tf.reduce_mean` or `np.mean`.\n\nInput shape:\n\n- If `data_format='channels_last'`:\n    3D tensor with shape:\n    `(batch_size, steps, features)`\n- If `data_format='channels_first'`:\n    3D tensor with shape:\n    `(batch_size, features, steps)`\n\nOutput shape:\n\n- If `keepdims=False`:\n    2D tensor with shape `(batch_size, features)`.\n- If `keepdims=True`:\n    - If `data_format=\"channels_last\"`:\n        3D tensor with shape `(batch_size, 1, features)`\n    - If `data_format=\"channels_first\"`:\n        3D tensor with shape `(batch_size, features, 1)`\n\nExample:\n\n>>> x = np.random.rand(2, 3, 4)\n>>> y = keras.layers.GlobalMaxPooling1D()(x)\n>>> y.shape\n(2, 4)",
    "std_args": [
      "data_format",
      "keepdims",
      "kwargs"
    ],
    "type": "class"
  },
  "GlobalMaxPool2D": {
    "description": "Global max pooling operation for 2D data.\n\nArgs:\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, height, width, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, features, height, weight)`. It defaults to the\n        `image_data_format` value found in your Keras config file at\n        `~/.keras/keras.json`. If you never set it, then it will be\n        `\"channels_last\"`.\n    keepdims: A boolean, whether to keep the temporal dimension or not.\n        If `keepdims` is `False` (default), the rank of the tensor is\n        reduced for spatial dimensions. If `keepdims` is `True`, the\n        spatial dimension are retained with length 1.\n        The behavior is the same as for `tf.reduce_mean` or `np.mean`.\n\nInput shape:\n\n- If `data_format='channels_last'`:\n    4D tensor with shape:\n    `(batch_size, height, width, channels)`\n- If `data_format='channels_first'`:\n    4D tensor with shape:\n    `(batch_size, channels, height, width)`\n\nOutput shape:\n\n- If `keepdims=False`:\n    2D tensor with shape `(batch_size, channels)`.\n- If `keepdims=True`:\n    - If `data_format=\"channels_last\"`:\n        4D tensor with shape `(batch_size, 1, 1, channels)`\n    - If `data_format=\"channels_first\"`:\n        4D tensor with shape `(batch_size, channels, 1, 1)`\n\nExample:\n\n>>> x = np.random.rand(2, 4, 5, 3)\n>>> y = keras.layers.GlobalMaxPooling2D()(x)\n>>> y.shape\n(2, 3)",
    "std_args": [
      "data_format",
      "keepdims",
      "kwargs"
    ],
    "type": "class"
  },
  "GlobalMaxPool3D": {
    "description": "Global max pooling operation for 3D data.\n\nArgs:\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape\n        `(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3)`.\n        It defaults to the `image_data_format` value found in your Keras\n        config file at `~/.keras/keras.json`. If you never set it, then it\n        will be `\"channels_last\"`.\n    keepdims: A boolean, whether to keep the temporal dimension or not.\n        If `keepdims` is `False` (default), the rank of the tensor is\n        reduced for spatial dimensions. If `keepdims` is `True`, the\n        spatial dimension are retained with length 1.\n        The behavior is the same as for `tf.reduce_mean` or `np.mean`.\n\nInput shape:\n\n- If `data_format='channels_last'`:\n    5D tensor with shape:\n    `(batch_size, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n- If `data_format='channels_first'`:\n    5D tensor with shape:\n    `(batch_size, channels, spatial_dim1, spatial_dim2, spatial_dim3)`\n\nOutput shape:\n\n- If `keepdims=False`:\n    2D tensor with shape `(batch_size, channels)`.\n- If `keepdims=True`:\n    - If `data_format=\"channels_last\"`:\n        5D tensor with shape `(batch_size, 1, 1, 1, channels)`\n    - If `data_format=\"channels_first\"`:\n        5D tensor with shape `(batch_size, channels, 1, 1, 1)`\n\nExample:\n\n>>> x = np.random.rand(2, 4, 5, 4, 3)\n>>> y = keras.layers.GlobalMaxPooling3D()(x)\n>>> y.shape\n(2, 3)",
    "std_args": [
      "data_format",
      "keepdims",
      "kwargs"
    ],
    "type": "class"
  },
  "GlobalMaxPooling1D": {
    "description": "Global max pooling operation for temporal data.\n\nArgs:\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, steps, features)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, features, steps)`. It defaults to the `image_data_format`\n        value found in your Keras config file at `~/.keras/keras.json`.\n        If you never set it, then it will be `\"channels_last\"`.\n    keepdims: A boolean, whether to keep the temporal dimension or not.\n        If `keepdims` is `False` (default), the rank of the tensor is\n        reduced for spatial dimensions. If `keepdims` is `True`, the\n        temporal dimension are retained with length 1.\n        The behavior is the same as for `tf.reduce_mean` or `np.mean`.\n\nInput shape:\n\n- If `data_format='channels_last'`:\n    3D tensor with shape:\n    `(batch_size, steps, features)`\n- If `data_format='channels_first'`:\n    3D tensor with shape:\n    `(batch_size, features, steps)`\n\nOutput shape:\n\n- If `keepdims=False`:\n    2D tensor with shape `(batch_size, features)`.\n- If `keepdims=True`:\n    - If `data_format=\"channels_last\"`:\n        3D tensor with shape `(batch_size, 1, features)`\n    - If `data_format=\"channels_first\"`:\n        3D tensor with shape `(batch_size, features, 1)`\n\nExample:\n\n>>> x = np.random.rand(2, 3, 4)\n>>> y = keras.layers.GlobalMaxPooling1D()(x)\n>>> y.shape\n(2, 4)",
    "std_args": [
      "data_format",
      "keepdims",
      "kwargs"
    ],
    "type": "class"
  },
  "GlobalMaxPooling2D": {
    "description": "Global max pooling operation for 2D data.\n\nArgs:\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, height, width, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, features, height, weight)`. It defaults to the\n        `image_data_format` value found in your Keras config file at\n        `~/.keras/keras.json`. If you never set it, then it will be\n        `\"channels_last\"`.\n    keepdims: A boolean, whether to keep the temporal dimension or not.\n        If `keepdims` is `False` (default), the rank of the tensor is\n        reduced for spatial dimensions. If `keepdims` is `True`, the\n        spatial dimension are retained with length 1.\n        The behavior is the same as for `tf.reduce_mean` or `np.mean`.\n\nInput shape:\n\n- If `data_format='channels_last'`:\n    4D tensor with shape:\n    `(batch_size, height, width, channels)`\n- If `data_format='channels_first'`:\n    4D tensor with shape:\n    `(batch_size, channels, height, width)`\n\nOutput shape:\n\n- If `keepdims=False`:\n    2D tensor with shape `(batch_size, channels)`.\n- If `keepdims=True`:\n    - If `data_format=\"channels_last\"`:\n        4D tensor with shape `(batch_size, 1, 1, channels)`\n    - If `data_format=\"channels_first\"`:\n        4D tensor with shape `(batch_size, channels, 1, 1)`\n\nExample:\n\n>>> x = np.random.rand(2, 4, 5, 3)\n>>> y = keras.layers.GlobalMaxPooling2D()(x)\n>>> y.shape\n(2, 3)",
    "std_args": [
      "data_format",
      "keepdims",
      "kwargs"
    ],
    "type": "class"
  },
  "GlobalMaxPooling3D": {
    "description": "Global max pooling operation for 3D data.\n\nArgs:\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape\n        `(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3)`.\n        It defaults to the `image_data_format` value found in your Keras\n        config file at `~/.keras/keras.json`. If you never set it, then it\n        will be `\"channels_last\"`.\n    keepdims: A boolean, whether to keep the temporal dimension or not.\n        If `keepdims` is `False` (default), the rank of the tensor is\n        reduced for spatial dimensions. If `keepdims` is `True`, the\n        spatial dimension are retained with length 1.\n        The behavior is the same as for `tf.reduce_mean` or `np.mean`.\n\nInput shape:\n\n- If `data_format='channels_last'`:\n    5D tensor with shape:\n    `(batch_size, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n- If `data_format='channels_first'`:\n    5D tensor with shape:\n    `(batch_size, channels, spatial_dim1, spatial_dim2, spatial_dim3)`\n\nOutput shape:\n\n- If `keepdims=False`:\n    2D tensor with shape `(batch_size, channels)`.\n- If `keepdims=True`:\n    - If `data_format=\"channels_last\"`:\n        5D tensor with shape `(batch_size, 1, 1, 1, channels)`\n    - If `data_format=\"channels_first\"`:\n        5D tensor with shape `(batch_size, channels, 1, 1, 1)`\n\nExample:\n\n>>> x = np.random.rand(2, 4, 5, 4, 3)\n>>> y = keras.layers.GlobalMaxPooling3D()(x)\n>>> y.shape\n(2, 3)",
    "std_args": [
      "data_format",
      "keepdims",
      "kwargs"
    ],
    "type": "class"
  },
  "Glu": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "dim"
    ],
    "type": "class"
  },
  "GradFn": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "f",
      "has_aux",
      "nondiff_states"
    ],
    "type": "class"
  },
  "GraphContext": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "update_context_stacks",
      "ref_index_stack",
      "index_ref_stack",
      "tmp_static_cache",
      "caching"
    ],
    "type": "class"
  },
  "GraphDef": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "nodes",
      "attributes",
      "num_leaves"
    ],
    "type": "class"
  },
  "GraphDefState": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "GraphFlatState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "GraphNodeImpl": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "type",
      "flatten",
      "set_key",
      "pop_key",
      "create_empty",
      "clear",
      "init"
    ],
    "type": "class"
  },
  "GraphState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Grayscale": {
    "description": "Convert image to grayscale.",
    "std_args": [
      "num_output_channels"
    ]
  },
  "Group": {
    "description": "An :class:`mlx.core.distributed.Group` represents a group of independent mlx",
    "std_args": [],
    "type": "class"
  },
  "GroupQueryAttention": {
    "description": "Grouped Query Attention layer.\n\nThis is an implementation of grouped-query attention introduced by\n[Ainslie et al., 2023](https://arxiv.org/abs/2305.13245). Here\n`num_key_value_heads` denotes number of groups, setting\n`num_key_value_heads` to 1 is equivalent to multi-query attention, and\nwhen `num_key_value_heads` is equal to `num_query_heads` it is equivalent\nto multi-head attention.\n\nThis layer first projects `query`, `key`, and `value` tensors. Then, `key`\nand `value` are repeated to match the number of heads of `query`.\n\nThen, the `query` is scaled and dot-producted with `key` tensors. These are\nsoftmaxed to obtain attention probabilities. The value tensors are then\ninterpolated by these probabilities and concatenated back to a single\ntensor.\n\nArgs:\n    head_dim: Size of each attention head.\n    num_query_heads: Number of query attention heads.\n    num_key_value_heads: Number of key and value attention heads.\n    dropout: Dropout probability.\n    use_bias: Boolean, whether the dense layers use bias vectors/matrices.\n    flash_attention: If `None`, the layer attempts to use flash\n        attention for faster and more memory-efficient attention\n        computations when possible. This behavior can be configured using\n        `keras.config.enable_flash_attention()` or\n        `keras.config.disable_flash_attention()`.\n    kernel_initializer: Initializer for dense layer kernels.\n    bias_initializer: Initializer for dense layer biases.\n    kernel_regularizer: Regularizer for dense layer kernels.\n    bias_regularizer: Regularizer for dense layer biases.\n    activity_regularizer: Regularizer for dense layer activity.\n    kernel_constraint: Constraint for dense layer kernels.\n    bias_constraint: Constraint for dense layer kernels.\n    seed: Optional integer to seed the dropout layer.\n\nCall arguments:\n    query: Query tensor of shape `(batch_dim, target_seq_len, feature_dim)`,\n        where `batch_dim` is batch size, `target_seq_len` is the length of\n        target sequence, and `feature_dim` is dimension of feature.\n    value: Value tensor of shape `(batch_dim, source_seq_len, feature_dim)`,\n        where `batch_dim` is batch size, `source_seq_len` is the length of\n        source sequence, and `feature_dim` is dimension of feature.\n    key: Optional key tensor of shape\n        `(batch_dim, source_seq_len, feature_dim)`. If not given, will use\n        `value` for both `key` and `value`, which is most common case.\n    attention_mask: A boolean mask of shape\n        `(batch_dim, target_seq_len, source_seq_len)`, that prevents\n        attention to certain positions. The boolean mask specifies which\n        query elements can attend to which key elements, where 1 indicates\n        attention and 0 indicates no attention. Broadcasting can happen for\n        the missing batch dimensions and the head dimension.\n    return_attention_scores: A boolean to indicate whether the output\n        should be `(attention_output, attention_scores)` if `True`, or\n        `attention_output` if `False`. Defaults to `False`.\n    training: Python boolean indicating whether the layer should behave in\n        training mode (adding dropout) or in inference mode (no dropout).\n        Will go with either using the training mode of the parent\n        layer/model or `False` (inference) if there is no parent layer.\n    use_causal_mask: A boolean to indicate whether to apply a causal mask to\n        prevent tokens from attending to future tokens (e.g., used in a\n        decoder Transformer).\n\nReturns:\n    attention_output: Result of the computation, of shape\n        `(batch_dim, target_seq_len, feature_dim)`, where `target_seq_len`\n        is for target sequence length and `feature_dim` is the query input\n        last dim.\n    attention_scores: (Optional) attention coefficients of shape\n        `(batch_dim, num_query_heads, target_seq_len, source_seq_len)`.",
    "std_args": [
      "head_dim",
      "num_query_heads",
      "num_key_value_heads",
      "dropout",
      "use_bias",
      "flash_attention",
      "kernel_initializer",
      "bias_initializer",
      "kernel_regularizer",
      "bias_regularizer",
      "activity_regularizer",
      "kernel_constraint",
      "bias_constraint",
      "seed",
      "kwargs"
    ],
    "type": "class"
  },
  "Groupnorm": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "dtype",
      "eps",
      "num_groups"
    ],
    "type": "class"
  },
  "Grucell": {
    "description": "Auto-discovered via Consensus (Score: 3.0)",
    "std_args": [
      "dtype"
    ],
    "type": "class"
  },
  "H": {
    "description": "Returns the (complex) conjugate transpose of `self`.",
    "std_args": [],
    "type": "attribute"
  },
  "H0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "H1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "H2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "H3": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "H4": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "H5": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "H6": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "H7": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "H8": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "H9": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "HA": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "HAS_BZ2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "HAS_LZMA": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "HAVE_SCPDT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "HB": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "HIGH": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "H_F_TYPE_CODES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Hardtanh": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "class"
  },
  "HasTag": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "HashableMapping": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "mapping",
      "copy"
    ],
    "type": "class"
  },
  "HashedCrossing": {
    "description": "A preprocessing layer which crosses features using the \"hashing trick\".\n\nThis layer performs crosses of categorical features using the \"hashing\ntrick\". Conceptually, the transformation can be thought of as:\n`hash(concatenate(features)) % num_bins`.\n\nThis layer currently only performs crosses of scalar inputs and batches of\nscalar inputs. Valid input shapes are `(batch_size, 1)`, `(batch_size,)` and\n`()`.\n\n**Note:** This layer wraps `tf.keras.layers.HashedCrossing`. It cannot\nbe used as part of the compiled computation graph of a model with\nany backend other than TensorFlow.\nIt can however be used with any backend when running eagerly.\nIt can also always be used as part of an input preprocessing pipeline\nwith any backend (outside the model itself), which is how we recommend\nto use this layer.\n\n**Note:** This layer is safe to use inside a `tf.data` pipeline\n(independently of which backend you're using).\n\nArgs:\n    num_bins: Number of hash bins.\n    output_mode: Specification for the output of the layer. Values can be\n        `\"int\"`, or `\"one_hot\"` configuring the layer as follows:\n        - `\"int\"`: Return the integer bin indices directly.\n        - `\"one_hot\"`: Encodes each individual element in the input into an\n            array the same size as `num_bins`, containing a 1 at the input's\n            bin index. Defaults to `\"int\"`.\n    sparse: Boolean. Only applicable to `\"one_hot\"` mode and only valid\n        when using the TensorFlow backend. If `True`, returns\n        a `SparseTensor` instead of a dense `Tensor`. Defaults to `False`.\n    **kwargs: Keyword arguments to construct a layer.\n\nExamples:\n\n**Crossing two scalar features.**\n\n>>> layer = keras.layers.HashedCrossing(\n...     num_bins=5)\n>>> feat1 = np.array(['A', 'B', 'A', 'B', 'A'])\n>>> feat2 = np.array([101, 101, 101, 102, 102])\n>>> layer((feat1, feat2))\narray([1, 4, 1, 1, 3])\n\n**Crossing and one-hotting two scalar features.**\n\n>>> layer = keras.layers.HashedCrossing(\n...     num_bins=5, output_mode='one_hot')\n>>> feat1 = np.array(['A', 'B', 'A', 'B', 'A'])\n>>> feat2 = np.array([101, 101, 101, 102, 102])\n>>> layer((feat1, feat2))\narray([[0., 1., 0., 0., 0.],\n        [0., 0., 0., 0., 1.],\n        [0., 1., 0., 0., 0.],\n        [0., 1., 0., 0., 0.],\n        [0., 0., 0., 1., 0.]], dtype=float32)",
    "std_args": [
      "num_bins",
      "output_mode",
      "sparse",
      "name",
      "dtype",
      "kwargs"
    ],
    "type": "class"
  },
  "Hashing": {
    "description": "A preprocessing layer which hashes and bins categorical features.\n\nThis layer transforms categorical inputs to hashed output. It element-wise\nconverts a ints or strings to ints in a fixed range. The stable hash\nfunction uses `tensorflow::ops::Fingerprint` to produce the same output\nconsistently across all platforms.\n\nThis layer uses [FarmHash64](https://github.com/google/farmhash) by default,\nwhich provides a consistent hashed output across different platforms and is\nstable across invocations, regardless of device and context, by mixing the\ninput bits thoroughly.\n\nIf you want to obfuscate the hashed output, you can also pass a random\n`salt` argument in the constructor. In that case, the layer will use the\n[SipHash64](https://github.com/google/highwayhash) hash function, with\nthe `salt` value serving as additional input to the hash function.\n\n**Note:** This layer internally uses TensorFlow. It cannot\nbe used as part of the compiled computation graph of a model with\nany backend other than TensorFlow.\nIt can however be used with any backend when running eagerly.\nIt can also always be used as part of an input preprocessing pipeline\nwith any backend (outside the model itself), which is how we recommend\nto use this layer.\n\n**Note:** This layer is safe to use inside a `tf.data` pipeline\n(independently of which backend you're using).\n\n**Example (FarmHash64)**\n\n>>> layer = keras.layers.Hashing(num_bins=3)\n>>> inp = [['A'], ['B'], ['C'], ['D'], ['E']]\n>>> layer(inp)\narray([[1],\n        [0],\n        [1],\n        [1],\n        [2]])>\n\n**Example (FarmHash64) with a mask value**\n\n>>> layer = keras.layers.Hashing(num_bins=3, mask_value='')\n>>> inp = [['A'], ['B'], [''], ['C'], ['D']]\n>>> layer(inp)\narray([[1],\n        [1],\n        [0],\n        [2],\n        [2]])\n\n**Example (SipHash64)**\n\n>>> layer = keras.layers.Hashing(num_bins=3, salt=[133, 137])\n>>> inp = [['A'], ['B'], ['C'], ['D'], ['E']]\n>>> layer(inp)\narray([[1],\n        [2],\n        [1],\n        [0],\n        [2]])\n\n**Example (Siphash64 with a single integer, same as `salt=[133, 133]`)**\n\n>>> layer = keras.layers.Hashing(num_bins=3, salt=133)\n>>> inp = [['A'], ['B'], ['C'], ['D'], ['E']]\n>>> layer(inp)\narray([[0],\n        [0],\n        [2],\n        [1],\n        [0]])\n\nArgs:\n    num_bins: Number of hash bins. Note that this includes the `mask_value`\n        bin, so the effective number of bins is `(num_bins - 1)`\n        if `mask_value` is set.\n    mask_value: A value that represents masked inputs, which are mapped to\n        index 0. `None` means no mask term will be added and the\n        hashing will start at index 0. Defaults to `None`.\n    salt: A single unsigned integer or None.\n        If passed, the hash function used will be SipHash64,\n        with these values used as an additional input\n        (known as a \"salt\" in cryptography).\n        These should be non-zero. If `None`, uses the FarmHash64 hash\n        function. It also supports tuple/list of 2 unsigned\n        integer numbers, see reference paper for details.\n        Defaults to `None`.\n    output_mode: Specification for the output of the layer. Values can be\n        `\"int\"`, `\"one_hot\"`, `\"multi_hot\"`, or\n        `\"count\"` configuring the layer as follows:\n        - `\"int\"`: Return the integer bin indices directly.\n        - `\"one_hot\"`: Encodes each individual element in the input into an\n            array the same size as `num_bins`, containing a 1\n            at the input's bin index. If the last dimension is size 1,\n            will encode on that dimension.\n            If the last dimension is not size 1, will append a new\n            dimension for the encoded output.\n        - `\"multi_hot\"`: Encodes each sample in the input into a\n            single array the same size as `num_bins`,\n            containing a 1 for each bin index\n            index present in the sample. Treats the last dimension\n            as the sample dimension, if input shape is\n            `(..., sample_length)`, output shape will be\n            `(..., num_tokens)`.\n        - `\"count\"`: As `\"multi_hot\"`, but the int array contains a count of\n            the number of times the bin index appeared in the sample.\n        Defaults to `\"int\"`.\n    sparse: Boolean. Only applicable to `\"one_hot\"`, `\"multi_hot\"`,\n        and `\"count\"` output modes. Only supported with TensorFlow\n        backend. If `True`, returns a `SparseTensor` instead of\n        a dense `Tensor`. Defaults to `False`.\n    **kwargs: Keyword arguments to construct a layer.\n\nInput shape:\n    A single string, a list of strings, or an `int32` or `int64` tensor\n    of shape `(batch_size, ...,)`.\n\nOutput shape:\n    An `int32` tensor of shape `(batch_size, ...)`.\n\nReference:\n\n- [SipHash with salt](https://www.131002.net/siphash/siphash.pdf)",
    "std_args": [
      "num_bins",
      "mask_value",
      "salt",
      "output_mode",
      "sparse",
      "kwargs"
    ],
    "type": "class"
  },
  "He0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "He1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "He2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "He3": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "He4": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "He5": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "He6": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "He7": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "He8": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "He9": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Helist": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Hermite": {
    "description": "A Hermite series class.",
    "std_args": [
      "self",
      "coef",
      "domain",
      "window",
      "symbol"
    ],
    "type": "class"
  },
  "HermiteE": {
    "description": "A HermiteE series class.",
    "std_args": [
      "self",
      "coef",
      "domain",
      "window",
      "symbol"
    ],
    "type": "class"
  },
  "HermitianGeneralizedTestCase": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "HermitianTestCase": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "HijaxVariable": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "HijaxVariableMeta": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "HingeEmbeddingLoss": {
    "description": "Measures the loss given an input tensor :math:`x` and a labels tensor :math:`y`",
    "std_args": [
      "self",
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "Hlist": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "HuberLoss": {
    "description": "Creates a criterion that uses a squared term if the absolute",
    "std_args": [
      "self",
      "reduction",
      "delta"
    ],
    "type": "class"
  },
  "I": {
    "description": "Returns the (multiplicative) inverse of invertible `self`.",
    "std_args": [],
    "type": "attribute"
  },
  "IDS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "INCLUDE_DIR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "INDEXING": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "INIT_PARENT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "INTEGER": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "INT_FUNCS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "INT_FUNC_HASHES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "IS_64BIT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "IS_PPC_OR_AIX": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "IS_S390X": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ISeedSequence": {
    "description": "Abstract base class for seed sequences.",
    "std_args": [],
    "type": "class"
  },
  "ISpawnableSeedSequence": {
    "description": "Abstract base class for seed sequences that can spawn.",
    "std_args": [],
    "type": "class"
  },
  "Index": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "IndexMap": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "IndexesPytreeDef": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "InjectHyperparamsState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "InjectStatefulHyperparamsState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Input": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "batch_shape",
      "batch_size",
      "dtype",
      "kwargs",
      "name",
      "optional",
      "ragged",
      "shape",
      "sparse",
      "x"
    ],
    "type": "function"
  },
  "InputSpec": {
    "description": "Specifies the rank, dtype and shape of every input to a layer.\n\nLayers can expose (if appropriate) an `input_spec` attribute:\nan instance of `InputSpec`, or a nested structure of `InputSpec` instances\n(one per input tensor). These objects enable the layer to run input\ncompatibility checks for input structure, input rank, input shape, and\ninput dtype for the first argument of `Layer.__call__`.\n\nA `None` entry in a shape is compatible with any dimension.\n\nArgs:\n    dtype: Expected dtype of the input.\n    shape: Shape tuple, expected shape of the input\n        (may include `None` for dynamic axes).\n        Includes the batch size.\n    ndim: Integer, expected rank of the input.\n    max_ndim: Integer, maximum rank of the input.\n    min_ndim: Integer, minimum rank of the input.\n    axes: Dictionary mapping integer axes to\n        a specific dimension value.\n    allow_last_axis_squeeze: If `True`, allow inputs of rank N+1 as long\n        as the last axis of the input is 1, as well as inputs of rank N-1\n        as long as the last axis of the spec is 1.\n    name: Expected key corresponding to this input when passing data as\n        a dictionary.\n    optional: Boolean, whether the input is optional or not.\n        An optional input can accept `None` values.\n\nExample:\n\n```python\nclass MyLayer(Layer):\n    def __init__(self):\n        super().__init__()\n        # The layer will accept inputs with\n        # shape (*, 28, 28) & (*, 28, 28, 1)\n        # and raise an appropriate error message otherwise.\n        self.input_spec = InputSpec(\n            shape=(None, 28, 28, 1),\n            allow_last_axis_squeeze=True)\n```",
    "std_args": [
      "dtype",
      "shape",
      "ndim",
      "max_ndim",
      "min_ndim",
      "axes",
      "allow_last_axis_squeeze",
      "name",
      "optional"
    ],
    "type": "class"
  },
  "InstanceNorm1d": {
    "description": "Applies Instance Normalization.",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "InstanceNorm2d": {
    "description": "Applies Instance Normalization.",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "InstanceNorm3d": {
    "description": "Applies Instance Normalization.",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "Instancenorm": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "dtype",
      "eps",
      "num_features"
    ],
    "type": "class"
  },
  "Int16DType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Int32DType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Int64DType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Int8DType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "IntDType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "IntegerLookup": {
    "description": "A preprocessing layer that maps integers to (possibly encoded) indices.\n\nThis layer maps a set of arbitrary integer input tokens into indexed integer\noutput via a table-based vocabulary lookup. The layer's output indices will\nbe contiguously arranged up to the maximum vocab size, even if the input\ntokens are non-continguous or unbounded. The layer supports multiple options\nfor encoding the output via `output_mode`, and has optional support for\nout-of-vocabulary (OOV) tokens and masking.\n\nThe vocabulary for the layer must be either supplied on construction or\nlearned via `adapt()`. During `adapt()`, the layer will analyze a data set,\ndetermine the frequency of individual integer tokens, and create a\nvocabulary from them. If the vocabulary is capped in size, the most frequent\ntokens will be used to create the vocabulary and all others will be treated\nas OOV.\n\nThere are two possible output modes for the layer.  When `output_mode` is\n`\"int\"`, input integers are converted to their index in the vocabulary (an\ninteger).  When `output_mode` is `\"multi_hot\"`, `\"count\"`, or `\"tf_idf\"`,\ninput integers are encoded into an array where each dimension corresponds to\nan element in the vocabulary.\n\nThe vocabulary can optionally contain a mask token as well as an OOV token\n(which can optionally occupy multiple indices in the vocabulary, as set\nby `num_oov_indices`).\nThe position of these tokens in the vocabulary is fixed. When `output_mode`\nis `\"int\"`, the vocabulary will begin with the mask token at index 0,\nfollowed by OOV indices, followed by the rest of the vocabulary. When\n`output_mode` is `\"multi_hot\"`, `\"count\"`, or `\"tf_idf\"` the vocabulary will\nbegin with OOV indices and instances of the mask token will be dropped.\n\n**Note:** This layer uses TensorFlow internally. It cannot\nbe used as part of the compiled computation graph of a model with\nany backend other than TensorFlow.\nIt can however be used with any backend when running eagerly.\nIt can also always be used as part of an input preprocessing pipeline\nwith any backend (outside the model itself), which is how we recommend\nto use this layer.\n\n**Note:** This layer is safe to use inside a `tf.data` pipeline\n(independently of which backend you're using).\n\nArgs:\n    max_tokens: Maximum size of the vocabulary for this layer. This should\n        only be specified when adapting the vocabulary or when setting\n        `pad_to_max_tokens=True`. If None, there is no cap on the size of\n        the vocabulary. Note that this size includes the OOV\n        and mask tokens. Defaults to `None`.\n    num_oov_indices: The number of out-of-vocabulary tokens to use.\n        If this value is more than 1, OOV inputs are modulated to\n        determine their OOV value.\n        If this value is 0, OOV inputs will cause an error when calling\n        the layer. Defaults to `1`.\n    mask_token: An integer token that represents masked inputs. When\n        `output_mode` is `\"int\"`, the token is included in vocabulary\n        and mapped to index 0. In other output modes,\n        the token will not appear in the vocabulary and instances\n        of the mask token in the input will be dropped.\n        If set to None, no mask term will be added. Defaults to `None`.\n    oov_token: Only used when `invert` is `True`. The token to return\n        for OOV indices. Defaults to `-1`.\n    vocabulary: Optional. Either an array of integers or a string path to a\n        text file. If passing an array, can pass a tuple, list,\n        1D NumPy array, or 1D tensor containing the integer vocbulary terms.\n        If passing a file path, the file should contain one line per term\n        in the vocabulary. If this argument is set,\n        there is no need to `adapt()` the layer.\n    vocabulary_dtype: The dtype of the vocabulary terms.\n        Only `vocabulary_dtype='int64'` is supported at this time.\n        Defaults to `\"int64\"`.\n    idf_weights: Only valid when `output_mode` is `\"tf_idf\"`.\n        A tuple, list, 1D NumPy array, or 1D tensor or the same length\n        as the vocabulary, containing the floating point inverse document\n        frequency weights, which will be multiplied by per sample term\n        counts for the final TF-IDF weight.\n        If the `vocabulary` argument is set, and `output_mode` is\n        `\"tf_idf\"`, this argument must be supplied.\n    invert: Only valid when `output_mode` is `\"int\"`.\n        If `True`, this layer will map indices to vocabulary items\n        instead of mapping vocabulary items to indices.\n        Defaults to `False`.\n    output_mode: Specification for the output of the layer. Values can be\n        `\"int\"`, `\"one_hot\"`, `\"multi_hot\"`, `\"count\"`, or `\"tf_idf\"`\n        configuring the layer as follows:\n        - `\"int\"`: Return the vocabulary indices of the input tokens.\n        - `\"one_hot\"`: Encodes each individual element in the input into an\n            array the same size as the vocabulary,\n            containing a 1 at the element index. If the last dimension\n            is size 1, will encode on that dimension.\n            If the last dimension is not size 1, will append a new\n            dimension for the encoded output.\n        - `\"multi_hot\"`: Encodes each sample in the input into a single\n            array the same size as the vocabulary,\n            containing a 1 for each vocabulary term present in the sample.\n            Treats the last dimension as the sample dimension,\n            if input shape is `(..., sample_length)`,\n            output shape will be `(..., num_tokens)`.\n        - `\"count\"`: As `\"multi_hot\"`, but the int array contains\n            a count of the number of times the token at that index\n            appeared in the sample.\n        - `\"tf_idf\"`: As `\"multi_hot\"`, but the TF-IDF algorithm is\n            applied to find the value in each token slot.\n        For `\"int\"` output, the output shape matches the input shape.\n        For `\"one_hot\"` output, the output shape is\n        `input_shape + (vocabulary_size,)`, where `input_shape` may\n        have arbitrary rank. For other output modes (`\"multi_hot\"`,\n        `\"count\"`, `\"tf_idf\"`), the output shape is `(batch_size,\n        vocabulary_size)`. Defaults to `\"int\"`.\n    pad_to_max_tokens: Only applicable when `output_mode` is `\"multi_hot\"`,\n        `\"count\"`, or `\"tf_idf\"`. If `True`, the output will have\n        its feature axis padded to `max_tokens` even if the number\n        of unique tokens in the vocabulary is less than `max_tokens`,\n        resulting in a tensor of shape `(batch_size, max_tokens)`\n        regardless of vocabulary size. Defaults to `False`.\n    sparse: Boolean. Only applicable to `\"multi_hot\"`, `\"count\"`, and\n        `\"tf_idf\"` output modes. Only supported with TensorFlow\n        backend. If `True`, returns a `SparseTensor`\n        instead of a dense `Tensor`. Defaults to `False`.\n\nExamples:\n\n**Creating a lookup layer with a known vocabulary**\n\nThis example creates a lookup layer with a pre-existing vocabulary.\n\n>>> vocab = [12, 36, 1138, 42]\n>>> data = np.array([[12, 1138, 42], [42, 1000, 36]])  # Note OOV tokens\n>>> layer = IntegerLookup(vocabulary=vocab)\n>>> layer(data)\narray([[1, 3, 4],\n       [4, 0, 2]])\n\n**Creating a lookup layer with an adapted vocabulary**\n\nThis example creates a lookup layer and generates the vocabulary by\nanalyzing the dataset.\n\n>>> data = np.array([[12, 1138, 42], [42, 1000, 36]])\n>>> layer = IntegerLookup()\n>>> layer.adapt(data)\n>>> layer.get_vocabulary()\n[-1, 42, 1138, 1000, 36, 12]\n\nNote that the OOV token -1 have been added to the vocabulary. The remaining\ntokens are sorted by frequency (42, which has 2 occurrences, is first) then\nby inverse sort order.\n\n>>> data = np.array([[12, 1138, 42], [42, 1000, 36]])\n>>> layer = IntegerLookup()\n>>> layer.adapt(data)\n>>> layer(data)\narray([[5, 2, 1],\n       [1, 3, 4]])\n\n**Lookups with multiple OOV indices**\n\nThis example demonstrates how to use a lookup layer with multiple OOV\nindices.  When a layer is created with more than one OOV index, any OOV\ntokens are hashed into the number of OOV buckets, distributing OOV tokens in\na deterministic fashion across the set.\n\n>>> vocab = [12, 36, 1138, 42]\n>>> data = np.array([[12, 1138, 42], [37, 1000, 36]])\n>>> layer = IntegerLookup(vocabulary=vocab, num_oov_indices=2)\n>>> layer(data)\narray([[2, 4, 5],\n       [1, 0, 3]])\n\nNote that the output for OOV token 37 is 1, while the output for OOV token\n1000 is 0. The in-vocab terms have their output index increased by 1 from\nearlier examples (12 maps to 2, etc) in order to make space for the extra\nOOV token.\n\n**One-hot output**\n\nConfigure the layer with `output_mode='one_hot'`. Note that the first\n`num_oov_indices` dimensions in the ont_hot encoding represent OOV values.\n\n>>> vocab = [12, 36, 1138, 42]\n>>> data = np.array([12, 36, 1138, 42, 7])  # Note OOV tokens\n>>> layer = IntegerLookup(vocabulary=vocab, output_mode='one_hot')\n>>> layer(data)\narray([[0., 1., 0., 0., 0.],\n        [0., 0., 1., 0., 0.],\n        [0., 0., 0., 1., 0.],\n        [0., 0., 0., 0., 1.],\n        [1., 0., 0., 0., 0.]], dtype=float32)\n\n**Multi-hot output**\n\nConfigure the layer with `output_mode='multi_hot'`. Note that the first\n`num_oov_indices` dimensions in the multi_hot encoding represent OOV tokens\n\n>>> vocab = [12, 36, 1138, 42]\n>>> data = np.array([[12, 1138, 42, 42],\n...                  [42,    7, 36,  7]])  # Note OOV tokens\n>>> layer = IntegerLookup(vocabulary=vocab, output_mode='multi_hot')\n>>> layer(data)\narray([[0., 1., 0., 1., 1.],\n       [1., 0., 1., 0., 1.]], dtype=float32)\n\n**Token count output**\n\nConfigure the layer with `output_mode='count'`. As with multi_hot output,\nthe first `num_oov_indices` dimensions in the output represent OOV tokens.\n\n>>> vocab = [12, 36, 1138, 42]\n>>> data = np.array([[12, 1138, 42, 42],\n...                  [42,    7, 36,  7]])  # Note OOV tokens\n>>> layer = IntegerLookup(vocabulary=vocab, output_mode='count')\n>>> layer(data)\narray([[0., 1., 0., 1., 2.],\n       [2., 0., 1., 0., 1.]], dtype=float32)\n\n**TF-IDF output**\n\nConfigure the layer with `output_mode='tf_idf'`. As with multi_hot output,\nthe first `num_oov_indices` dimensions in the output represent OOV tokens.\n\nEach token bin will output `token_count * idf_weight`, where the idf weights\nare the inverse document frequency weights per token. These should be\nprovided along with the vocabulary. Note that the `idf_weight` for OOV\ntokens will default to the average of all idf weights passed in.\n\n>>> vocab = [12, 36, 1138, 42]\n>>> idf_weights = [0.25, 0.75, 0.6, 0.4]\n>>> data = np.array([[12, 1138, 42, 42],\n...                  [42,    7, 36,  7]])  # Note OOV tokens\n>>> layer = IntegerLookup(\n...     output_mode='tf_idf', vocabulary=vocab, idf_weights=idf_weights)\n>>> layer(data)\narray([[0.  , 0.25, 0.  , 0.6 , 0.8 ],\n        [1.0 , 0.  , 0.75, 0.  , 0.4 ]], dtype=float32)\n\nTo specify the idf weights for oov tokens, you will need to pass the entire\nvocabulary including the leading oov token.\n\n>>> vocab = [-1, 12, 36, 1138, 42]\n>>> idf_weights = [0.9, 0.25, 0.75, 0.6, 0.4]\n>>> data = np.array([[12, 1138, 42, 42],\n...                  [42,    7, 36,  7]])  # Note OOV tokens\n>>> layer = IntegerLookup(\n...     output_mode='tf_idf', vocabulary=vocab, idf_weights=idf_weights)\n>>> layer(data)\narray([[0.  , 0.25, 0.  , 0.6 , 0.8 ],\n        [1.8 , 0.  , 0.75, 0.  , 0.4 ]], dtype=float32)\n\nWhen adapting the layer in `\"tf_idf\"` mode, each input sample will\nbe considered a document, and IDF weight per token will be\ncalculated as:\n`log(1 + num_documents / (1 + token_document_count))`.\n\n**Inverse lookup**\n\nThis example demonstrates how to map indices to tokens using this layer.\n(You can also use `adapt()` with `inverse=True`, but for simplicity we'll\npass the vocab in this example.)\n\n>>> vocab = [12, 36, 1138, 42]\n>>> data = np.array([[1, 3, 4], [4, 0, 2]])\n>>> layer = IntegerLookup(vocabulary=vocab, invert=True)\n>>> layer(data)\narray([[  12, 1138,   42],\n       [  42,   -1,   36]])\n\nNote that the first index correspond to the oov token by default.\n\n**Forward and inverse lookup pairs**\n\nThis example demonstrates how to use the vocabulary of a standard lookup\nlayer to create an inverse lookup layer.\n\n>>> vocab = [12, 36, 1138, 42]\n>>> data = np.array([[12, 1138, 42], [42, 1000, 36]])\n>>> layer = IntegerLookup(vocabulary=vocab)\n>>> i_layer = IntegerLookup(\n...     vocabulary=layer.get_vocabulary(), invert=True)\n>>> int_data = layer(data)\n>>> i_layer(int_data)\narray([[  12, 1138,   42],\n       [  42,   -1,   36]])\n\nIn this example, the input token 1000 resulted in an output of -1, since\n1000 was not in the vocabulary - it got represented as an OOV, and all OOV\ntokens are returned as -1 in the inverse layer. Also, note that for the\ninverse to work, you must have already set the forward layer vocabulary\neither directly or via `adapt()` before calling `get_vocabulary()`.",
    "std_args": [
      "max_tokens",
      "num_oov_indices",
      "mask_token",
      "oov_token",
      "vocabulary",
      "vocabulary_dtype",
      "idf_weights",
      "invert",
      "output_mode",
      "sparse",
      "pad_to_max_tokens",
      "name",
      "kwargs"
    ],
    "type": "class"
  },
  "Intent": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "intent_list"
    ],
    "type": "class"
  },
  "Intermediate": {
    "description": ":class:`Variable` type that is typically used for",
    "std_args": [
      "self",
      "value",
      "is_hijax",
      "has_ref",
      "is_mutable",
      "eager_sharding",
      "metadata"
    ],
    "type": "class"
  },
  "InvCases": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "IsLeafCallable": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "JUMP_TEST_DATA": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "JitFn": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "f",
      "in_shardings",
      "out_shardings",
      "kwarg_shardings",
      "ctxtag"
    ],
    "type": "class"
  },
  "JitWrapped": {
    "description": "A function ready to be traced, lowered, and compiled.",
    "std_args": [
      "self",
      "fun",
      "in_shardings",
      "out_shardings",
      "static_argnums",
      "static_argnames",
      "donate_argnums",
      "donate_argnames",
      "keep_unused",
      "device",
      "backend",
      "inline"
    ],
    "type": "class"
  },
  "JustReader": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "base"
    ],
    "type": "class"
  },
  "JustWriter": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "base"
    ],
    "type": "class"
  },
  "KLDivLoss": {
    "description": "The Kullback-Leibler divergence loss.",
    "std_args": [
      "self",
      "size_average",
      "reduce",
      "reduction",
      "log_target"
    ],
    "type": "class"
  },
  "KeyEntry": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "KeyPath": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "KeyT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "KeylessInitializer": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "L0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "L1Loss": {
    "description": "Creates a criterion that measures the mean absolute error (MAE) between each element in",
    "std_args": [
      "self",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "L1Unstructured": {
    "description": "Prune (currently unpruned) units in a tensor by zeroing out the ones with the lowest L1-norm.",
    "std_args": [
      "self",
      "amount"
    ],
    "type": "class"
  },
  "L2": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "predictions",
      "targets"
    ],
    "type": "attribute"
  },
  "L3": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "L4": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "L5": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "L6": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "L7": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "L8": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "L9": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "LAND": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "LE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "LOR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "LOW": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "LOWER_RIGHT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "LPPool1d": {
    "description": "Applies a 1D power-average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "norm_type",
      "kernel_size",
      "stride",
      "ceil_mode"
    ],
    "type": "class"
  },
  "LPPool2d": {
    "description": "Applies a 2D power-average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "norm_type",
      "kernel_size",
      "stride",
      "ceil_mode"
    ],
    "type": "class"
  },
  "LPPool3d": {
    "description": "Applies a 3D power-average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "norm_type",
      "kernel_size",
      "stride",
      "ceil_mode"
    ],
    "type": "class"
  },
  "LT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Laguerre": {
    "description": "A Laguerre series class.",
    "std_args": [
      "self",
      "coef",
      "domain",
      "window",
      "symbol"
    ],
    "type": "class"
  },
  "Lambda": {
    "description": "Wraps arbitrary expressions as a `Layer` object.\n\nThe `Lambda` layer exists so that arbitrary expressions can be used\nas a `Layer` when constructing Sequential\nand Functional API models. `Lambda` layers are best suited for simple\noperations or quick experimentation. For more advanced use cases,\nprefer writing new subclasses of `Layer`.\n\nWARNING: `Lambda` layers have (de)serialization limitations!\n\nThe main reason to subclass `Layer` instead of using a\n`Lambda` layer is saving and inspecting a model. `Lambda` layers\nare saved by serializing the Python bytecode, which is fundamentally\nnon-portable and potentially unsafe.\nThey should only be loaded in the same environment where\nthey were saved. Subclassed layers can be saved in a more portable way\nby overriding their `get_config()` method. Models that rely on\nsubclassed Layers are also often easier to visualize and reason about.\n\nExample:\n\n```python\n# add a x -> x^2 layer\nmodel.add(Lambda(lambda x: x ** 2))\n```\n\nArgs:\n    function: The function to be evaluated. Takes input tensor as first\n        argument.\n    output_shape: Expected output shape from function. This argument\n        can usually be inferred if not explicitly provided.\n        Can be a tuple or function. If a tuple, it only specifies\n        the first dimension onward; sample dimension is assumed\n        either the same as the input:\n        `output_shape = (input_shape[0], ) + output_shape` or,\n        the input is `None` and the sample dimension is also `None`:\n        `output_shape = (None, ) + output_shape`.\n        If a function, it specifies the\n        entire shape as a function of the input shape:\n        `output_shape = f(input_shape)`.\n    mask: Either None (indicating no masking) or a callable with the same\n        signature as the `compute_mask` layer method, or a tensor\n        that will be returned as output mask regardless\n        of what the input is.\n    arguments: Optional dictionary of keyword arguments to be passed to the\n        function.",
    "std_args": [
      "function",
      "output_shape",
      "mask",
      "arguments",
      "kwargs"
    ],
    "type": "class"
  },
  "Language": {
    "description": "Used as Expr.tostring language argument.",
    "std_args": [],
    "type": "class"
  },
  "LapackError": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "LazyBatchNorm1d": {
    "description": "A :class:`torch.nn.BatchNorm1d` module with lazy initialization.",
    "std_args": [
      "self",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyBatchNorm2d": {
    "description": "A :class:`torch.nn.BatchNorm2d` module with lazy initialization.",
    "std_args": [
      "self",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyBatchNorm3d": {
    "description": "A :class:`torch.nn.BatchNorm3d` module with lazy initialization.",
    "std_args": [
      "self",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyConv1d": {
    "description": "A :class:`torch.nn.Conv1d` module with lazy initialization of the ``in_channels`` argument.",
    "std_args": [
      "self",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyConv2d": {
    "description": "A :class:`torch.nn.Conv2d` module with lazy initialization of the ``in_channels`` argument.",
    "std_args": [
      "self",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyConv3d": {
    "description": "A :class:`torch.nn.Conv3d` module with lazy initialization of the ``in_channels`` argument.",
    "std_args": [
      "self",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyConvTranspose1d": {
    "description": "A :class:`torch.nn.ConvTranspose1d` module with lazy initialization of the ``in_channels`` argument.",
    "std_args": [
      "self",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "output_padding",
      "groups",
      "bias",
      "dilation",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyConvTranspose2d": {
    "description": "A :class:`torch.nn.ConvTranspose2d` module with lazy initialization of the ``in_channels`` argument.",
    "std_args": [
      "self",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "output_padding",
      "groups",
      "bias",
      "dilation",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyConvTranspose3d": {
    "description": "A :class:`torch.nn.ConvTranspose3d` module with lazy initialization of the ``in_channels`` argument.",
    "std_args": [
      "self",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "output_padding",
      "groups",
      "bias",
      "dilation",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyInstanceNorm1d": {
    "description": "A :class:`torch.nn.InstanceNorm1d` module with lazy initialization of the ``num_features`` argument.",
    "std_args": [
      "self",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyInstanceNorm2d": {
    "description": "A :class:`torch.nn.InstanceNorm2d` module with lazy initialization of the ``num_features`` argument.",
    "std_args": [
      "self",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyInstanceNorm3d": {
    "description": "A :class:`torch.nn.InstanceNorm3d` module with lazy initialization of the ``num_features`` argument.",
    "std_args": [
      "self",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyLinear": {
    "description": "A :class:`torch.nn.Linear` module where `in_features` is inferred.",
    "std_args": [
      "self",
      "out_features",
      "bias",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "Leaf": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "LeafType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Leaves": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Legendre": {
    "description": "A Legendre series class.",
    "std_args": [
      "self",
      "coef",
      "domain",
      "window",
      "symbol"
    ],
    "type": "class"
  },
  "LinalgCase": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "name",
      "a",
      "b",
      "tags"
    ],
    "type": "class"
  },
  "LinalgGeneralizedNonsquareTestCase": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "LinalgGeneralizedSquareTestCase": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "LinalgNonsquareTestCase": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "LinalgSquareTestCase": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "LinalgTestCase": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "LinearGeneral": {
    "description": "A linear transformation with flexible axes.",
    "std_args": [
      "self",
      "in_features",
      "out_features",
      "axis",
      "batch_axis",
      "use_bias",
      "dtype",
      "param_dtype",
      "kernel_init",
      "bias_init",
      "precision",
      "promote_dtype",
      "dot_general",
      "dot_general_cls",
      "preferred_element_type",
      "rngs",
      "kernel_metadata",
      "bias_metadata"
    ],
    "type": "class"
  },
  "LinearT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Lion": {
    "description": "Auto-discovered via Consensus (Score: 3.0)",
    "std_args": [
      "b1",
      "b2",
      "lr",
      "mask",
      "mu_dtype",
      "weight_decay"
    ],
    "type": "class"
  },
  "List": {
    "description": "A Module that implements a mutable sequence.",
    "std_args": [
      "self",
      "it"
    ],
    "type": "class"
  },
  "Llist": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "LnStructured": {
    "description": "Prune entire (currently unpruned) channels in a tensor based on their L\\ ``n``-norm.",
    "std_args": [
      "self",
      "amount",
      "n",
      "dim"
    ],
    "type": "class"
  },
  "LoRA": {
    "description": "A standalone LoRA layer.",
    "std_args": [
      "self",
      "in_features",
      "lora_rank",
      "out_features",
      "base_module",
      "dtype",
      "param_dtype",
      "a_initializer",
      "b_initializer",
      "lora_param_type",
      "promote_dtype",
      "rngs",
      "a_metadata",
      "b_metadata"
    ],
    "type": "class"
  },
  "LoRALinear": {
    "description": "An `nnx.Linear` layer in which the output will be LoRAified.",
    "std_args": [
      "self",
      "in_features",
      "out_features",
      "lora_rank",
      "lora_dtype",
      "lora_param_dtype",
      "a_initializer",
      "b_initializer",
      "lora_param_type",
      "lora_promote_dtype",
      "rngs",
      "a_metadata",
      "b_metadata",
      "kwargs"
    ],
    "type": "class"
  },
  "LoRAParam": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "value",
      "is_hijax",
      "has_ref",
      "is_mutable",
      "eager_sharding",
      "metadata"
    ],
    "type": "class"
  },
  "Load": {
    "description": "Deserialize object from disk.",
    "std_args": [
      "f"
    ],
    "type": "function"
  },
  "LoadTxtBase": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "LocalResponseNorm": {
    "description": "Applies local response normalization over an input signal.",
    "std_args": [
      "self",
      "size",
      "alpha",
      "beta",
      "k"
    ],
    "type": "class"
  },
  "Logsumexp": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "b",
      "dim",
      "keepdim",
      "return_sign",
      "where",
      "x"
    ],
    "type": "function"
  },
  "LongDType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "LongDoubleDType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "LongLongDType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Lowered": {
    "description": "Lowering of a function specialized to argument types and values.",
    "std_args": [
      "self",
      "lowered",
      "jit_wrapped"
    ],
    "type": "class"
  },
  "Lstmcell": {
    "description": "Auto-discovered via Consensus (Score: 3.0)",
    "std_args": [
      "dtype"
    ],
    "type": "class"
  },
  "LstsqCases": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "M": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MA": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MAError": {
    "description": "Class for masked array related errors.",
    "std_args": [],
    "type": "class"
  },
  "MAxisConcatenator": {
    "description": "Translate slice objects to concatenation along an axis.",
    "std_args": [
      "self",
      "axis",
      "matrix",
      "ndmin",
      "trans1d"
    ],
    "type": "class"
  },
  "MESON_ONLY_VER": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MISC_DIR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MISSING": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MISSING_CFFI": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MISSING_CTYPES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MMatrix": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "MODULE_CONTEXT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MSubArray": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "MUTABLE_ARRAY_ATTR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MYPY_INI": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MappingReprMixin": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "MarginRankingLoss": {
    "description": "Creates a criterion that measures the loss given",
    "std_args": [
      "self",
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "MaskError": {
    "description": "Class for mask related errors.",
    "std_args": [],
    "type": "class"
  },
  "MaskType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MaskedArray": {
    "description": "An array class with possibly masked values.",
    "std_args": [],
    "type": "class"
  },
  "MaskedArrayFutureWarning": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "MaskedConstant": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "MaskedIterator": {
    "description": "Flat iterator object to iterate over masked arrays.",
    "std_args": [
      "self",
      "ma"
    ],
    "type": "class"
  },
  "MaskedNode": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MaskedRecords": {
    "description": "Attributes",
    "std_args": [],
    "type": "class"
  },
  "MaskedState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Masking": {
    "description": "Masks a sequence by using a mask value to skip timesteps.\n\nFor each timestep in the input tensor (dimension #1 in the tensor),\nif all values in the input tensor at that timestep\nare equal to `mask_value`, then the timestep will be masked (skipped)\nin all downstream layers (as long as they support masking).\n\nIf any downstream layer does not support masking yet receives such\nan input mask, an exception will be raised.\n\nExample:\n\nConsider a NumPy data array `x` of shape `(samples, timesteps, features)`,\nto be fed to an LSTM layer. You want to mask timestep #3 and #5 because you\nlack data for these timesteps. You can:\n\n- Set `x[:, 3, :] = 0.` and `x[:, 5, :] = 0.`\n- Insert a `Masking` layer with `mask_value=0.` before the LSTM layer:\n\n```python\nsamples, timesteps, features = 32, 10, 8\ninputs = np.random.random([samples, timesteps, features]).astype(np.float32)\ninputs[:, 3, :] = 0.\ninputs[:, 5, :] = 0.\n\nmodel = keras.models.Sequential()\nmodel.add(keras.layers.Masking(mask_value=0.0))\nmodel.add(keras.layers.LSTM(32))\noutput = model(inputs)\n# The time step 3 and 5 will be skipped from LSTM calculation.\n```\n\nNote: in the Keras masking convention, a masked timestep is denoted by\na mask value of `False`, while a non-masked (i.e. usable) timestep\nis denoted by a mask value of `True`.",
    "std_args": [
      "mask_value",
      "kwargs"
    ],
    "type": "class"
  },
  "MatrixTestCase": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "MaxNumBoundingBoxes": {
    "description": "Ensure the maximum number of bounding boxes.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nArgs:\n    max_number: Desired output number of bounding boxes.\n    padding_value: The padding value of the `boxes` and `labels` in\n        `bounding_boxes`. Defaults to `-1`.",
    "std_args": [
      "max_number",
      "fill_value",
      "kwargs"
    ],
    "type": "class"
  },
  "MaxPool1d": {
    "description": "Applies a 1D max pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "return_indices",
      "ceil_mode"
    ],
    "type": "class"
  },
  "MaxPool3d": {
    "description": "Applies a 3D max pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "return_indices",
      "ceil_mode"
    ],
    "type": "class"
  },
  "MaxPooling1D": {
    "description": "Max pooling operation for 1D temporal data.\n\nDownsamples the input representation by taking the maximum value over a\nspatial window of size `pool_size`. The window is shifted by `strides`.\n\nThe resulting output when using the `\"valid\"` padding option has a shape of:\n`output_shape = (input_shape - pool_size + 1) / strides)`.\n\nThe resulting output shape when using the `\"same\"` padding option is:\n`output_shape = input_shape / strides`\n\nArgs:\n    pool_size: int, size of the max pooling window.\n    strides: int or None. Specifies how much the pooling window moves\n        for each pooling step. If None, it will default to `pool_size`.\n    padding: string, either `\"valid\"` or `\"same\"` (case-insensitive).\n        `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n        the left/right or up/down of the input such that output has the same\n        height/width dimension as the input.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, steps, features)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, features, steps)`. It defaults to the `image_data_format`\n        value found in your Keras config file at `~/.keras/keras.json`.\n        If you never set it, then it will be `\"channels_last\"`.\n\nInput shape:\n\n- If `data_format=\"channels_last\"`:\n    3D tensor with shape `(batch_size, steps, features)`.\n- If `data_format=\"channels_first\"`:\n    3D tensor with shape `(batch_size, features, steps)`.\n\nOutput shape:\n\n- If `data_format=\"channels_last\"`:\n    3D tensor with shape `(batch_size, downsampled_steps, features)`.\n- If `data_format=\"channels_first\"`:\n    3D tensor with shape `(batch_size, features, downsampled_steps)`.\n\nExamples:\n\n`strides=1` and `padding=\"valid\"`:\n\n>>> x = np.array([1., 2., 3., 4., 5.])\n>>> x = np.reshape(x, [1, 5, 1])\n>>> max_pool_1d = keras.layers.MaxPooling1D(pool_size=2,\n...    strides=1, padding=\"valid\")\n>>> max_pool_1d(x)\n\n`strides=2` and `padding=\"valid\"`:\n\n>>> x = np.array([1., 2., 3., 4., 5.])\n>>> x = np.reshape(x, [1, 5, 1])\n>>> max_pool_1d = keras.layers.MaxPooling1D(pool_size=2,\n...    strides=2, padding=\"valid\")\n>>> max_pool_1d(x)\n\n`strides=1` and `padding=\"same\"`:\n\n>>> x = np.array([1., 2., 3., 4., 5.])\n>>> x = np.reshape(x, [1, 5, 1])\n>>> max_pool_1d = keras.layers.MaxPooling1D(pool_size=2,\n...    strides=1, padding=\"same\")\n>>> max_pool_1d(x)",
    "std_args": [
      "pool_size",
      "strides",
      "padding",
      "data_format",
      "name",
      "kwargs"
    ],
    "type": "class"
  },
  "MaxPooling2D": {
    "description": "Max pooling operation for 2D spatial data.\n\nDownsamples the input along its spatial dimensions (height and width)\nby taking the maximum value over an input window\n(of size defined by `pool_size`) for each channel of the input.\nThe window is shifted by `strides` along each dimension.\n\nThe resulting output when using the `\"valid\"` padding option has a spatial\nshape (number of rows or columns) of:\n`output_shape = math.floor((input_shape - pool_size) / strides) + 1`\n(when `input_shape >= pool_size`)\n\nThe resulting output shape when using the `\"same\"` padding option is:\n`output_shape = math.floor((input_shape - 1) / strides) + 1`\n\nArgs:\n    pool_size: int or tuple of 2 integers, factors by which to downscale\n        (dim1, dim2). If only one integer is specified, the same\n        window length will be used for all dimensions.\n    strides: int or tuple of 2 integers, or None. Strides values. If None,\n        it will default to `pool_size`. If only one int is specified, the\n        same stride size will be used for all dimensions.\n    padding: string, either `\"valid\"` or `\"same\"` (case-insensitive).\n        `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n        the left/right or up/down of the input such that output has the same\n        height/width dimension as the input.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, height, width, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, channels, height, width)`. It defaults to the\n        `image_data_format` value found in your Keras config file at\n        `~/.keras/keras.json`. If you never set it, then it will be\n        `\"channels_last\"`.\n\nInput shape:\n\n- If `data_format=\"channels_last\"`:\n    4D tensor with shape `(batch_size, height, width, channels)`.\n- If `data_format=\"channels_first\"`:\n    4D tensor with shape `(batch_size, channels, height, width)`.\n\nOutput shape:\n\n- If `data_format=\"channels_last\"`:\n    4D tensor with shape\n    `(batch_size, pooled_height, pooled_width, channels)`.\n- If `data_format=\"channels_first\"`:\n    4D tensor with shape\n    `(batch_size, channels, pooled_height, pooled_width)`.\n\nExamples:\n\n`strides=(1, 1)` and `padding=\"valid\"`:\n\n>>> x = np.array([[1., 2., 3.],\n...               [4., 5., 6.],\n...               [7., 8., 9.]])\n>>> x = np.reshape(x, [1, 3, 3, 1])\n>>> max_pool_2d = keras.layers.MaxPooling2D(pool_size=(2, 2),\n...    strides=(1, 1), padding=\"valid\")\n>>> max_pool_2d(x)\n\n`strides=(2, 2)` and `padding=\"valid\"`:\n\n>>> x = np.array([[1., 2., 3., 4.],\n...               [5., 6., 7., 8.],\n...               [9., 10., 11., 12.]])\n>>> x = np.reshape(x, [1, 3, 4, 1])\n>>> max_pool_2d = keras.layers.MaxPooling2D(pool_size=(2, 2),\n...    strides=(2, 2), padding=\"valid\")\n>>> max_pool_2d(x)\n\n`stride=(1, 1)` and `padding=\"same\"`:\n\n>>> x = np.array([[1., 2., 3.],\n...               [4., 5., 6.],\n...               [7., 8., 9.]])\n>>> x = np.reshape(x, [1, 3, 3, 1])\n>>> max_pool_2d = keras.layers.MaxPooling2D(pool_size=(2, 2),\n...    strides=(1, 1), padding=\"same\")\n>>> max_pool_2d(x)",
    "std_args": [
      "pool_size",
      "strides",
      "padding",
      "data_format",
      "name",
      "kwargs"
    ],
    "type": "class"
  },
  "MaxPooling3D": {
    "description": "Max pooling operation for 3D data (spatial or spatio-temporal).\n\nDownsamples the input along its spatial dimensions (depth, height, and\nwidth) by taking the maximum value over an input window (of size defined by\n`pool_size`) for each channel of the input. The window is shifted by\n`strides` along each dimension.\n\nArgs:\n    pool_size: int or tuple of 3 integers, factors by which to downscale\n        (dim1, dim2, dim3). If only one integer is specified, the same\n        window length will be used for all dimensions.\n    strides: int or tuple of 3 integers, or None. Strides values. If None,\n        it will default to `pool_size`. If only one int is specified, the\n        same stride size will be used for all dimensions.\n    padding: string, either `\"valid\"` or `\"same\"` (case-insensitive).\n        `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n        the left/right or up/down of the input such that output has the same\n        height/width dimension as the input.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape\n        `(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)` while\n        `\"channels_first\"` corresponds to inputs with shape\n        `(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3)`.\n        It defaults to the `image_data_format` value found in your Keras\n        config file at `~/.keras/keras.json`. If you never set it, then it\n        will be `\"channels_last\"`.\n\nInput shape:\n\n- If `data_format=\"channels_last\"`:\n    5D tensor with shape:\n    `(batch_size, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n- If `data_format=\"channels_first\"`:\n    5D tensor with shape:\n    `(batch_size, channels, spatial_dim1, spatial_dim2, spatial_dim3)`\n\nOutput shape:\n\n- If `data_format=\"channels_last\"`:\n    5D tensor with shape:\n    `(batch_size, pooled_dim1, pooled_dim2, pooled_dim3, channels)`\n- If `data_format=\"channels_first\"`:\n    5D tensor with shape:\n    `(batch_size, channels, pooled_dim1, pooled_dim2, pooled_dim3)`\n\nExample:\n\n```python\ndepth = 30\nheight = 30\nwidth = 30\nchannels = 3\n\ninputs = keras.layers.Input(shape=(depth, height, width, channels))\nlayer = keras.layers.MaxPooling3D(pool_size=3)\noutputs = layer(inputs)  # Shape: (batch_size, 10, 10, 10, 3)\n```",
    "std_args": [
      "pool_size",
      "strides",
      "padding",
      "data_format",
      "name",
      "kwargs"
    ],
    "type": "class"
  },
  "MaxUnpool1d": {
    "description": "Computes a partial inverse of :class:`MaxPool1d`.",
    "std_args": [
      "self",
      "kernel_size",
      "stride",
      "padding"
    ],
    "type": "class"
  },
  "MaxUnpool2d": {
    "description": "Computes a partial inverse of :class:`MaxPool2d`.",
    "std_args": [
      "self",
      "kernel_size",
      "stride",
      "padding"
    ],
    "type": "class"
  },
  "MaxUnpool3d": {
    "description": "Computes a partial inverse of :class:`MaxPool3d`.",
    "std_args": [
      "self",
      "kernel_size",
      "stride",
      "padding"
    ],
    "type": "class"
  },
  "MelSpectrogram": {
    "description": "A preprocessing layer to convert raw audio signals to Mel spectrograms.\n\nThis layer takes `float32`/`float64` single or batched audio signal as\ninputs and computes the Mel spectrogram using Short-Time Fourier Transform\nand Mel scaling. The input should be a 1D (unbatched) or 2D (batched) tensor\nrepresenting audio signals. The output will be a 2D or 3D tensor\nrepresenting Mel spectrograms.\n\nA spectrogram is an image-like representation that shows the frequency\nspectrum of a signal over time. It uses x-axis to represent time, y-axis to\nrepresent frequency, and each pixel to represent intensity.\nMel spectrograms are a special type of spectrogram that use the mel scale,\nwhich approximates how humans perceive sound. They are commonly used in\nspeech and music processing tasks like speech recognition, speaker\nidentification, and music genre classification.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nReferences:\n- [Spectrogram](https://en.wikipedia.org/wiki/Spectrogram),\n- [Mel scale](https://en.wikipedia.org/wiki/Mel_scale).\n\nArgs:\n    fft_length: Integer, size of the FFT window.\n    sequence_stride: Integer, number of samples between successive STFT\n        columns.\n    sequence_length: Integer, size of the window used for applying\n        `window` to each audio frame. If `None`, defaults to `fft_length`.\n    window: String, name of the window function to use. Available values\n        are `\"hann\"` and `\"hamming\"`. If `window` is a tensor, it will be\n        used directly as the window and its length must be\n        `sequence_length`. If `window` is `None`, no windowing is\n        used. Defaults to `\"hann\"`.\n    sampling_rate: Integer, sample rate of the input signal.\n    num_mel_bins: Integer, number of mel bins to generate.\n    min_freq: Float, minimum frequency of the mel bins.\n    max_freq: Float, maximum frequency of the mel bins.\n        If `None`, defaults to `sampling_rate / 2`.\n    power_to_db: If True, convert the power spectrogram to decibels.\n    top_db: Float, minimum negative cut-off `max(10 * log10(S)) - top_db`.\n    mag_exp: Float, exponent for the magnitude spectrogram.\n        1 for magnitude, 2 for power, etc. Default is 2.\n    ref_power: Float, the power is scaled relative to it\n        `10 * log10(S / ref_power)`.\n    min_power: Float, minimum value for power and `ref_power`.\n\nExamples:\n\n**Unbatched audio signal**\n\n>>> layer = keras.layers.MelSpectrogram(num_mel_bins=64,\n...                                     sampling_rate=8000,\n...                                     sequence_stride=256,\n...                                     fft_length=2048)\n>>> layer(keras.random.uniform(shape=(16000,))).shape\n(64, 63)\n\n**Batched audio signal**\n\n>>> layer = keras.layers.MelSpectrogram(num_mel_bins=80,\n...                                     sampling_rate=8000,\n...                                     sequence_stride=128,\n...                                     fft_length=2048)\n>>> layer(keras.random.uniform(shape=(2, 16000))).shape\n(2, 80, 125)\n\nInput shape:\n    1D (unbatched) or 2D (batched) tensor with shape:`(..., samples)`.\n\nOutput shape:\n    2D (unbatched) or 3D (batched) tensor with\n    shape:`(..., num_mel_bins, time)`.",
    "std_args": [
      "fft_length",
      "sequence_stride",
      "sequence_length",
      "window",
      "sampling_rate",
      "num_mel_bins",
      "min_freq",
      "max_freq",
      "power_to_db",
      "top_db",
      "mag_exp",
      "min_power",
      "ref_power",
      "kwargs"
    ],
    "type": "class"
  },
  "MergeContext": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "ctxtag",
      "index_ref",
      "is_inner"
    ],
    "type": "class"
  },
  "Metric": {
    "description": "Base class for metrics. Any class that subclasses ``Metric`` should",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "MetricState": {
    "description": "Wrapper class for Metric Variables.",
    "std_args": [
      "self",
      "value",
      "is_hijax",
      "has_ref",
      "is_mutable",
      "eager_sharding",
      "metadata"
    ],
    "type": "class"
  },
  "MixUp": {
    "description": "MixUp implements the MixUp data augmentation technique.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nReferences:\n    - [MixUp paper](https://arxiv.org/abs/1710.09412).\n    - [MixUp for Object Detection paper](https://arxiv.org/pdf/1902.04103).\n\nArgs:\n    alpha: Float between 0 and 1. Controls the blending strength.\n           Smaller values mean less mixing, while larger values allow\n           for more  blending between images. Defaults to 0.2,\n           recommended for ImageNet1k classification.\n    seed: Integer. Used to create a random seed.\n\nExample:\n```python\n(images, labels), _ = keras.datasets.cifar10.load_data()\nimages, labels = images[:8], labels[:8]\nlabels = keras.ops.cast(keras.ops.one_hot(labels.flatten(), 10), \"float32\")\nmix_up = keras.layers.MixUp(alpha=0.2)\noutput = mix_up({\"images\": images, \"labels\": labels})\n```",
    "std_args": [
      "alpha",
      "data_format",
      "seed",
      "kwargs"
    ],
    "type": "class"
  },
  "ModelAndOptimizer": {
    "description": "A convenience class that combines a model and an optimizer.",
    "std_args": [
      "self",
      "model",
      "tx",
      "wrt"
    ],
    "type": "class"
  },
  "MultiLabelMarginLoss": {
    "description": "Creates a criterion that optimizes a multi-class multi-classification",
    "std_args": [
      "self",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "MultiLabelSoftMarginLoss": {
    "description": "Creates a criterion that optimizes a multi-label one-versus-all",
    "std_args": [
      "self",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "MultiMarginLoss": {
    "description": "Creates a criterion that optimizes a multi-class classification hinge",
    "std_args": [
      "self",
      "p",
      "margin",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "MultiMetric": {
    "description": "MultiMetric class to store multiple metrics and update them in a single call.",
    "std_args": [
      "self",
      "metrics"
    ],
    "type": "class"
  },
  "MultiOptimizer": {
    "description": "Wraps a list of optimizers with corresponding weight predicates/filters",
    "std_args": [
      "self",
      "optimizers",
      "filters"
    ],
    "type": "class"
  },
  "MultiSteps": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MultiStepsState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "MultiTransformState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Muon": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "eps",
      "lr",
      "momentum",
      "nesterov",
      "ns_steps",
      "weight_decay"
    ],
    "type": "class"
  },
  "MutableArrayAttr": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "MutableArrayRepr": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "shape",
      "dtype"
    ],
    "type": "class"
  },
  "NANFUNCS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NDArrayOperatorsMixin": {
    "description": "Mixin defining all operator special methods using __array_ufunc__.",
    "std_args": [],
    "type": "class"
  },
  "NDArrayTup": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NLLLoss": {
    "description": "The negative log likelihood loss. It is useful to train a classification",
    "std_args": [
      "self",
      "weight",
      "size_average",
      "ignore_index",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "NLLLoss2d": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "weight",
      "size_average",
      "ignore_index",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "NNXMeta": {
    "description": "Default Flax metadata class for `nnx.Variable`.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "NODE_ATTR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NONE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NO_COLOR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NO_MYPY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NO_UPDATE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NUMPY_INSTALL_ROOT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NamedShape": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Names": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NbufferT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Ndescr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NestedStateRepr": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "state"
    ],
    "type": "class"
  },
  "NewVariable": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "NoUpdate": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "Node": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NodeAttr": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "NodeDef": {
    "description": "A dataclass that denotes the tree structure of a",
    "std_args": [
      "self",
      "type",
      "index",
      "outer_index",
      "num_attributes",
      "metadata"
    ],
    "type": "class"
  },
  "NodeDefType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NodeImpl": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NodeImplBase": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "type",
      "flatten"
    ],
    "type": "class"
  },
  "NodeRef": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "index"
    ],
    "type": "class"
  },
  "NodeStates": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "NodeStats": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NonDynamicallyQuantizableLinear": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "in_features",
      "out_features",
      "bias",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "NonNegativeParamsState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NoneDumper": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Normalization": {
    "description": "A preprocessing layer that normalizes continuous features.\n\nThis layer will shift and scale inputs into a distribution centered around\n0 with standard deviation 1. It accomplishes this by precomputing the mean\nand variance of the data, and calling `(input - mean) / sqrt(var)` at\nruntime.\n\nThe mean and variance values for the layer must be either supplied on\nconstruction or learned via `adapt()`. `adapt()` will compute the mean and\nvariance of the data and store them as the layer's weights. `adapt()` should\nbe called before `fit()`, `evaluate()`, or `predict()`.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nArgs:\n    axis: Integer, tuple of integers, or None. The axis or axes that should\n        have a separate mean and variance for each index in the shape.\n        For example, if shape is `(None, 5)` and `axis=1`, the layer will\n        track 5 separate mean and variance values for the last axis.\n        If `axis` is set to `None`, the layer will normalize\n        all elements in the input by a scalar mean and variance.\n        When `-1`, the last axis of the input is assumed to be a\n        feature dimension and is normalized per index.\n        Note that in the specific case of batched scalar inputs where\n        the only axis is the batch axis, the default will normalize\n        each index in the batch separately.\n        In this case, consider passing `axis=None`. Defaults to `-1`.\n    mean: The mean value(s) to use during normalization. The passed value(s)\n        will be broadcast to the shape of the kept axes above;\n        if the value(s) cannot be broadcast, an error will be raised when\n        this layer's `build()` method is called.\n        `mean` and `variance` must be specified together.\n    variance: The variance value(s) to use during normalization. The passed\n        value(s) will be broadcast to the shape of the kept axes above;\n        if the value(s) cannot be broadcast, an error will be raised when\n        this layer's `build()` method is called.\n        `mean` and `variance` must be specified together.\n    invert: If `True`, this layer will apply the inverse transformation\n        to its inputs: it would turn a normalized input back into its\n        original form.\n\nExamples:\n\nCalculate a global mean and variance by analyzing the dataset in `adapt()`.\n\n>>> adapt_data = np.array([1., 2., 3., 4., 5.], dtype='float32')\n>>> input_data = np.array([1., 2., 3.], dtype='float32')\n>>> layer = keras.layers.Normalization(axis=None)\n>>> layer.adapt(adapt_data)\n>>> layer(input_data)\narray([-1.4142135, -0.70710677, 0.], dtype=float32)\n\nCalculate a mean and variance for each index on the last axis.\n\n>>> adapt_data = np.array([[0., 7., 4.],\n...                        [2., 9., 6.],\n...                        [0., 7., 4.],\n...                        [2., 9., 6.]], dtype='float32')\n>>> input_data = np.array([[0., 7., 4.]], dtype='float32')\n>>> layer = keras.layers.Normalization(axis=-1)\n>>> layer.adapt(adapt_data)\n>>> layer(input_data)\narray([-1., -1., -1.], dtype=float32)\n\nPass the mean and variance directly.\n\n>>> input_data = np.array([[1.], [2.], [3.]], dtype='float32')\n>>> layer = keras.layers.Normalization(mean=3., variance=2.)\n>>> layer(input_data)\narray([[-1.4142135 ],\n       [-0.70710677],\n       [ 0.        ]], dtype=float32)\n\nUse the layer to de-normalize inputs (after adapting the layer).\n\n>>> adapt_data = np.array([[0., 7., 4.],\n...                        [2., 9., 6.],\n...                        [0., 7., 4.],\n...                        [2., 9., 6.]], dtype='float32')\n>>> input_data = np.array([[1., 2., 3.]], dtype='float32')\n>>> layer = keras.layers.Normalization(axis=-1, invert=True)\n>>> layer.adapt(adapt_data)\n>>> layer(input_data)\narray([2., 10., 8.], dtype=float32)",
    "std_args": [
      "axis",
      "mean",
      "variance",
      "invert",
      "kwargs"
    ],
    "type": "class"
  },
  "Normalize": {
    "description": "Normalize a tensor image with mean and standard deviation.",
    "std_args": [
      "mean",
      "std",
      "inplace"
    ],
    "type": "function"
  },
  "NotKey": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Nothing": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "OBJECT_CONTEXT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "OUTPUT_MYPY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Object": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "type",
      "start",
      "end",
      "kv_sep",
      "indent",
      "empty_repr",
      "comment",
      "same_line"
    ],
    "type": "class"
  },
  "ObjectContext": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "seen_modules_repr",
      "node_stats"
    ],
    "type": "class"
  },
  "ObjectDType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "ObjectInfo": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "ObjectMeta": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "OfType": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "type"
    ],
    "type": "class"
  },
  "Op": {
    "description": "Used as Expr op attribute.",
    "std_args": [],
    "type": "class"
  },
  "OpError": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "OptArray": {
    "description": "Optimizer state for an array.",
    "std_args": [
      "self",
      "value",
      "is_hijax",
      "has_ref",
      "is_mutable",
      "eager_sharding",
      "metadata"
    ],
    "type": "class"
  },
  "OptState": {
    "description": "Any optimizer state",
    "std_args": [
      "self",
      "value",
      "is_hijax",
      "has_ref",
      "is_mutable",
      "eager_sharding",
      "metadata"
    ],
    "type": "class"
  },
  "OptVariable": {
    "description": "Optimizer state for a Variable.",
    "std_args": [
      "self",
      "value",
      "is_hijax",
      "has_ref",
      "is_mutable",
      "eager_sharding",
      "metadata"
    ],
    "type": "class"
  },
  "OptaxTest": {
    "description": "Test optax can be imported correctly.",
    "std_args": [],
    "type": "class"
  },
  "OptimizedLSTMCell": {
    "description": "More efficient LSTM Cell that concatenates state components before matmul.",
    "std_args": [
      "self",
      "in_features",
      "hidden_features",
      "gate_fn",
      "activation_fn",
      "kernel_init",
      "recurrent_kernel_init",
      "bias_init",
      "dtype",
      "param_dtype",
      "carry_init",
      "promote_dtype",
      "keep_rngs",
      "rngs",
      "kernel_metadata",
      "recurrent_kernel_metadata",
      "bias_metadata"
    ],
    "type": "class"
  },
  "Optimizer": {
    "description": "Simple train state for the common case with a single Optax optimizer.",
    "std_args": [
      "self",
      "model",
      "tx",
      "wrt"
    ],
    "type": "class"
  },
  "OrderedDictWrapper": {
    "description": "A wrapper around a C++ OrderedDict.",
    "std_args": [
      "self",
      "cpp_module",
      "attr"
    ],
    "type": "class"
  },
  "OutShardingType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Output": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PARALLEL_RUN_AVALIABLE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PAREN": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PARTITION_NAME": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PASS_DIR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PKG_CONFIG_DIR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "POS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PPaths": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PRESCALE_QK": {
    "description": "Whether to pre-scale QK by 1/sqrt(d) and change of base. This is slightly faster but",
    "std_args": [],
    "type": "attribute"
  },
  "PRIVATE_BUT_PRESENT_MODULES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PRODUCT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PROTOCOLS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PRUNING_TYPE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PUBLIC_ALIASED_MODULES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PUBLIC_MODULES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PYTREE_NODE_IMPL": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PYTREE_REGISTRY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PackedSequence": {
    "description": "Holds the data and list of :attr:`batch_sizes` of a packed sequence.",
    "std_args": [],
    "type": "class"
  },
  "PackedSequence_": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "PairwiseDistance": {
    "description": "Computes the pairwise distance between input vectors, or between columns of input matrices.",
    "std_args": [
      "self",
      "p",
      "eps",
      "keepdim"
    ],
    "type": "class"
  },
  "Parameter": {
    "description": "A kind of Tensor that is to be considered a module parameter.",
    "std_args": [
      "self",
      "data",
      "requires_grad"
    ],
    "type": "class"
  },
  "ParameterDict": {
    "description": "Holds parameters in a dictionary.",
    "std_args": [
      "self",
      "parameters"
    ],
    "type": "class"
  },
  "ParameterList": {
    "description": "Holds parameters in a list.",
    "std_args": [
      "self",
      "values"
    ],
    "type": "class"
  },
  "ParametrizationList": {
    "description": "A sequential container that holds and manages the original parameters or buffers of a parametrized :class:`torch.nn.Module`.",
    "std_args": [
      "self",
      "modules",
      "original",
      "unsafe"
    ],
    "type": "class"
  },
  "ParseCall": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "PartitionState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PathContains": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "key",
      "exact"
    ],
    "type": "class"
  },
  "PathIn": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "paths"
    ],
    "type": "class"
  },
  "PbufferT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Pdescr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Permute": {
    "description": "Permutes the dimensions of the input according to a given pattern.\n\nUseful e.g. connecting RNNs and convnets.\n\nArgs:\n    dims: Tuple of integers. Permutation pattern does not include the\n        batch dimension. Indexing starts at 1.\n        For instance, `(1, 3, 2)` permutes the second and third dimensions\n        of the input.\n\nInput shape:\n    Arbitrary.\n\nOutput shape:\n    Same as the input shape, but with the dimensions re-ordered according\n    to the specified pattern.\n\nExample:\n\n>>> x = keras.Input(shape=(10, 64))\n>>> y = keras.layers.Permute((2, 1))(x)\n>>> y.shape\n(None, 64, 10)",
    "std_args": [
      "dims",
      "kwargs"
    ],
    "type": "class"
  },
  "Perturbation": {
    "description": ":class:`Variable` type that is typically used for",
    "std_args": [
      "self",
      "value",
      "is_hijax",
      "has_ref",
      "is_mutable",
      "eager_sharding",
      "metadata"
    ],
    "type": "class"
  },
  "PinvCases": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "PinvHermitianCases": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Pipeline": {
    "description": "Applies a series of layers to an input.\n\nThis class is useful to build a preprocessing pipeline,\nin particular an image data augmentation pipeline.\nCompared to a `Sequential` model, `Pipeline` features\na few important differences:\n\n- It's not a `Model`, just a plain layer.\n- When the layers in the pipeline are compatible\n    with `tf.data`, the pipeline will also\n    remain `tf.data` compatible. That is to say,\n    the pipeline will not attempt to convert\n    its inputs to backend-native tensors\n    when in a tf.data context (unlike a `Sequential`\n    model).\n\nExample:\n\n```python\nfrom keras import layers\npreprocessing_pipeline = layers.Pipeline([\n    layers.AutoContrast(),\n    layers.RandomZoom(0.2),\n    layers.RandomRotation(0.2),\n])\n\n# `ds` is a tf.data.Dataset\npreprocessed_ds = ds.map(\n    preprocessing_pipeline,\n    num_parallel_calls=4,\n)\n```",
    "std_args": [
      "layers",
      "name"
    ],
    "type": "class"
  },
  "PixelShuffle": {
    "description": "Rearrange elements in a tensor according to an upscaling factor.",
    "std_args": [
      "self",
      "upscale_factor"
    ],
    "type": "class"
  },
  "PixelUnshuffle": {
    "description": "Reverse the PixelShuffle operation.",
    "std_args": [
      "self",
      "downscale_factor"
    ],
    "type": "class"
  },
  "PmapFn": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "f",
      "transform_metadata",
      "in_axes",
      "out_axes"
    ],
    "type": "class"
  },
  "PoissonNLLLoss": {
    "description": "Negative log likelihood loss with Poisson distribution of target.",
    "std_args": [
      "self",
      "log_input",
      "full",
      "size_average",
      "eps",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "Poly": {
    "description": "The class representing a Python function.",
    "std_args": [
      "request"
    ],
    "type": "function"
  },
  "Poly1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Poly2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Polynomial": {
    "description": "A power series class.",
    "std_args": [
      "self",
      "coef",
      "domain",
      "window",
      "symbol"
    ],
    "type": "class"
  },
  "Precedence": {
    "description": "Used as Expr.tostring precedence argument.",
    "std_args": [],
    "type": "class"
  },
  "Predicate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Prefix": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PrefixMapping": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "PrettyMapping": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "mapping"
    ],
    "type": "class"
  },
  "PrettySequence": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "sequence"
    ],
    "type": "class"
  },
  "PriorityStr": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "PruningContainer": {
    "description": "Container holding a sequence of pruning methods for iterative pruning.",
    "std_args": [
      "self",
      "args"
    ],
    "type": "class"
  },
  "PureState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PyTreeDef": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Python": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PythonRefMap": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Pytree": {
    "description": "Base class for all NNX objects.",
    "std_args": [],
    "type": "class"
  },
  "PytreeMeta": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "PytreeNodeImpl": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "type",
      "flatten",
      "unflatten",
      "set_key",
      "pop_key"
    ],
    "type": "class"
  },
  "PytreeState": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "initializing",
      "is_setup"
    ],
    "type": "class"
  },
  "QuantizedAllToShardedLinear": {
    "description": "Each member of the group applies part of the affine transformation with",
    "std_args": [
      "self",
      "input_dims",
      "output_dims",
      "bias",
      "group_size",
      "bits",
      "group"
    ],
    "type": "class"
  },
  "QuantizedEmbedding": {
    "description": "The same as :obj:`Embedding` but with a  quantized weight matrix.",
    "std_args": [
      "self",
      "num_embeddings",
      "dims",
      "group_size",
      "bits",
      "mode"
    ],
    "type": "class"
  },
  "QuantizedShardedToAllLinear": {
    "description": "Each member of the group applies part of the affine transformation using",
    "std_args": [
      "self",
      "input_dims",
      "output_dims",
      "bias",
      "group_size",
      "bits",
      "group"
    ],
    "type": "class"
  },
  "R": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "REF": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RELATIONAL": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "REPEATED": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "REPR_CONTEXT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "REQUIRED_CONFIG_KEYS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "REVEAL_DIR": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RMSprop": {
    "description": "Root Mean Square Propagation optimizer.",
    "std_args": [
      "params",
      "lr",
      "rho",
      "eps",
      "weight_decay",
      "momentum",
      "centered"
    ],
    "type": "class"
  },
  "RNG": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "RNGData": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "bit_generator",
      "advance",
      "seed",
      "rg",
      "seed_vector_bits"
    ],
    "type": "class"
  },
  "RNNBase": {
    "description": "Base class for RNN modules (RNN, LSTM, GRU).",
    "std_args": [
      "self",
      "mode",
      "input_size",
      "hidden_size",
      "num_layers",
      "bias",
      "batch_first",
      "dropout",
      "bidirectional",
      "proj_size",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "RNNCell": {
    "description": "An Elman RNN cell with tanh or ReLU non-linearity.",
    "std_args": [
      "self",
      "input_size",
      "hidden_size",
      "bias",
      "nonlinearity",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "ROOT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ROWS_GUARANTEED_SAFE": {
    "description": "If True, guarantees that at least one value in each row is not masked out.",
    "std_args": [],
    "type": "attribute"
  },
  "RPC_AVAILABLE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RReLU": {
    "description": "Applies the randomized leaky rectified linear unit function, element-wise.",
    "std_args": [
      "self",
      "lower",
      "upper",
      "inplace"
    ],
    "type": "class"
  },
  "RUN_MYPY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RandAugment": {
    "description": "RandAugment performs the Rand Augment operation on input images.\n\nThis layer can be thought of as an all-in-one image augmentation layer. The\npolicy implemented by this layer has been benchmarked extensively and is\neffective on a wide variety of datasets.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nReferences:\n    - [RandAugment](https://arxiv.org/abs/1909.13719)\n\nArgs:\n    value_range: The range of values the input image can take.\n        Default is `(0, 255)`. Typically, this would be `(0, 1)`\n        for normalized images or `(0, 255)` for raw images.\n    num_ops: The number of augmentation operations to apply sequentially\n        to each image. Default is 2.\n    factor: The strength of the augmentation as a normalized value\n        between 0 and 1. Default is 0.5.\n    interpolation: The interpolation method to use for resizing operations.\n        Options include `nearest`, `bilinear`. Default is `bilinear`.\n    seed: Integer. Used to create a random seed.",
    "std_args": [
      "value_range",
      "num_ops",
      "factor",
      "interpolation",
      "seed",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "RandomBrightness": {
    "description": "A preprocessing layer which randomly adjusts brightness during training.\n\nThis layer will randomly increase/reduce the brightness for the input RGB\nimages. At inference time, the output will be identical to the input.\nCall the layer with `training=True` to adjust the brightness of the input.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nArgs:\n    factor: Float or a list/tuple of 2 floats between -1.0 and 1.0. The\n        factor is used to determine the lower bound and upper bound of the\n        brightness adjustment. A float value will be chosen randomly between\n        the limits. When -1.0 is chosen, the output image will be black, and\n        when 1.0 is chosen, the image will be fully white.\n        When only one float is provided, eg, 0.2,\n        then -0.2 will be used for lower bound and 0.2\n        will be used for upper bound.\n    value_range: Optional list/tuple of 2 floats\n        for the lower and upper limit\n        of the values of the input data.\n        To make no change, use `[0.0, 1.0]`, e.g., if the image input\n        has been scaled before this layer. Defaults to `[0.0, 255.0]`.\n        The brightness adjustment will be scaled to this range, and the\n        output values will be clipped to this range.\n    seed: optional integer, for fixed RNG behavior.\n\nInputs: 3D (HWC) or 4D (NHWC) tensor, with float or int dtype. Input pixel\n    values can be of any range (e.g. `[0., 1.)` or `[0, 255]`)\n\nOutput: 3D (HWC) or 4D (NHWC) tensor with brightness adjusted based on the\n    `factor`. By default, the layer will output floats.\n    The output value will be clipped to the range `[0, 255]`,\n    the valid range of RGB colors, and\n    rescaled based on the `value_range` if needed.\n\nExample:\n\n```python\nrandom_bright = keras.layers.RandomBrightness(factor=0.2)\n\n# An image with shape [2, 2, 3]\nimage = [[[1, 2, 3], [4 ,5 ,6]], [[7, 8, 9], [10, 11, 12]]]\n\n# Assume we randomly select the factor to be 0.1, then it will apply\n# 0.1 * 255 to all the channel\noutput = random_bright(image, training=True)\n\n# output will be int64 with 25.5 added to each channel and round down.\n>>> array([[[26.5, 27.5, 28.5]\n            [29.5, 30.5, 31.5]]\n           [[32.5, 33.5, 34.5]\n            [35.5, 36.5, 37.5]]],\n          shape=(2, 2, 3), dtype=int64)\n```",
    "std_args": [
      "factor",
      "value_range",
      "seed",
      "kwargs"
    ],
    "type": "class"
  },
  "RandomColorDegeneration": {
    "description": "Randomly performs the color degeneration operation on given images.\n\nThe sharpness operation first converts an image to gray scale, then back to\ncolor. It then takes a weighted average between original image and the\ndegenerated image. This makes colors appear more dull.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nArgs:\n    factor: A tuple of two floats or a single float.\n        `factor` controls the extent to which the\n        image sharpness is impacted. `factor=0.0` makes this layer perform a\n        no-op operation, while a value of 1.0 uses the degenerated result\n        entirely. Values between 0 and 1 result in linear interpolation\n        between the original image and the sharpened image.\n        Values should be between `0.0` and `1.0`. If a tuple is used, a\n        `factor` is sampled between the two values for every image\n        augmented. If a single float is used, a value between `0.0` and the\n        passed float is sampled. In order to ensure the value is always the\n        same, please pass a tuple with two identical floats: `(0.5, 0.5)`.\n    seed: Integer. Used to create a random seed.",
    "std_args": [
      "factor",
      "value_range",
      "data_format",
      "seed",
      "kwargs"
    ],
    "type": "class"
  },
  "RandomColorJitter": {
    "description": "RandomColorJitter class randomly apply brightness, contrast, saturation\nand hue image processing operation sequentially and randomly on the\ninput.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nArgs:\n    value_range: the range of values the incoming images will have.\n        Represented as a two number tuple written [low, high].\n        This is typically either `[0, 1]` or `[0, 255]` depending\n        on how your preprocessing pipeline is set up.\n    brightness_factor: Float or a list/tuple of 2 floats between -1.0\n        and 1.0. The factor is used to determine the lower bound and\n        upper bound of the brightness adjustment. A float value will\n        be chosen randomly between the limits. When -1.0 is chosen,\n        the output image will be black, and when 1.0 is chosen, the\n        image will be fully white. When only one float is provided,\n        eg, 0.2, then -0.2 will be used for lower bound and 0.2 will\n        be used for upper bound.\n    contrast_factor: a positive float represented as fraction of value,\n        or a tuple of size 2 representing lower and upper bound. When\n        represented as a single float, lower = upper. The contrast\n        factor will be randomly picked between `[1.0 - lower, 1.0 +\n        upper]`. For any pixel x in the channel, the output will be\n        `(x - mean) * factor + mean` where `mean` is the mean value\n        of the channel.\n    saturation_factor: A tuple of two floats or a single float. `factor`\n        controls the extent to which the image saturation is impacted.\n        `factor=0.5` makes this layer perform a no-op operation.\n        `factor=0.0` makes the image fully grayscale. `factor=1.0`\n        makes the image fully saturated. Values should be between\n        `0.0` and `1.0`. If a tuple is used, a `factor` is sampled\n        between the two values for every image augmented. If a single\n        float is used, a value between `0.0` and the passed float is\n        sampled. To ensure the value is always the same, pass a tuple\n        with two identical floats: `(0.5, 0.5)`.\n    hue_factor: A single float or a tuple of two floats. `factor`\n        controls the extent to which the image hue is impacted.\n        `factor=0.0` makes this layer perform a no-op operation,\n        while a value of `1.0` performs the most aggressive contrast\n        adjustment available. If a tuple is used, a `factor` is\n        sampled between the two values for every image augmented.\n        If a single float is used, a value between `0.0` and the\n        passed float is sampled. In order to ensure the value is\n        always the same, please pass a tuple with two identical\n        floats: `(0.5, 0.5)`.\n    seed: Integer. Used to create a random seed.",
    "std_args": [
      "value_range",
      "brightness_factor",
      "contrast_factor",
      "saturation_factor",
      "hue_factor",
      "seed",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "RandomContrast": {
    "description": "A preprocessing layer which randomly adjusts contrast during training.\n\nThis layer will randomly adjust the contrast of an image or images\nby a random factor. Contrast is adjusted independently\nfor each channel of each image during training.\n\nFor each channel, this layer computes the mean of the image pixels in the\nchannel and then adjusts each component `x` of each pixel to\n`(x - mean) * contrast_factor + mean`.\n\nInput pixel values can be of any range (e.g. `[0., 1.)` or `[0, 255]`) and\nin integer or floating point dtype.\nBy default, the layer will output floats.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nInput shape:\n    3D (unbatched) or 4D (batched) tensor with shape:\n    `(..., height, width, channels)`, in `\"channels_last\"` format.\n\nOutput shape:\n    3D (unbatched) or 4D (batched) tensor with shape:\n    `(..., height, width, channels)`, in `\"channels_last\"` format.\n\nArgs:\n    factor: a positive float represented as fraction of value, or a tuple of\n        size 2 representing lower and upper bound.\n        When represented as a single float, lower = upper.\n        The contrast factor will be randomly picked between\n        `[1.0 - lower, 1.0 + upper]`. For any pixel x in the channel,\n        the output will be `(x - mean) * factor + mean`\n        where `mean` is the mean value of the channel.\n    value_range: the range of values the incoming images will have.\n        Represented as a two-number tuple written `[low, high]`. This is\n        typically either `[0, 1]` or `[0, 255]` depending on how your\n        preprocessing pipeline is set up.\n    seed: Integer. Used to create a random seed.",
    "std_args": [
      "factor",
      "value_range",
      "seed",
      "kwargs"
    ],
    "type": "class"
  },
  "RandomCrop": {
    "description": "Crop the given image at a random location.",
    "std_args": [
      "size",
      "padding",
      "pad_if_needed",
      "fill",
      "padding_mode"
    ],
    "type": "class"
  },
  "RandomElasticTransform": {
    "description": "A preprocessing layer that applies random elastic transformations.\n\nThis layer distorts input images by applying elastic deformations,\nsimulating a physically realistic transformation. The magnitude of the\ndistortion is controlled by the `scale` parameter, while the `factor`\ndetermines the probability of applying the transformation.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nArgs:\n    factor: A single float or a tuple of two floats.\n        `factor` controls the probability of applying the transformation.\n        - `factor=0.0` ensures no erasing is applied.\n        - `factor=1.0` means erasing is always applied.\n        - If a tuple `(min, max)` is provided, a probability value\n          is sampled between `min` and `max` for each image.\n        - If a single float is provided, a probability is sampled\n          between `0.0` and the given float.\n        Default is 1.0.\n    scale: A float or a tuple of two floats defining the magnitude of\n        the distortion applied.\n        - If a tuple `(min, max)` is provided, a random scale value is\n          sampled within this range.\n        - If a single float is provided, a random scale value is sampled\n          between `0.0` and the given float.\n        Default is 1.0.\n    interpolation: Interpolation mode. Supported values: `\"nearest\"`,\n        `\"bilinear\"`.\n    fill_mode: Points outside the boundaries of the input are filled\n        according to the given mode. Available methods are `\"constant\"`,\n        `\"nearest\"`, `\"wrap\"` and `\"reflect\"`. Defaults to `\"constant\"`.\n        - `\"reflect\"`: `(d c b a | a b c d | d c b a)`\n            The input is extended by reflecting about the edge of the last\n            pixel.\n        - `\"constant\"`: `(k k k k | a b c d | k k k k)`\n            The input is extended by filling all values beyond\n            the edge with the same constant value k specified by\n            `fill_value`.\n        - `\"wrap\"`: `(a b c d | a b c d | a b c d)`\n            The input is extended by wrapping around to the opposite edge.\n        - `\"nearest\"`: `(a a a a | a b c d | d d d d)`\n            The input is extended by the nearest pixel.\n        Note that when using torch backend, `\"reflect\"` is redirected to\n        `\"mirror\"` `(c d c b | a b c d | c b a b)` because torch does not\n        support `\"reflect\"`.\n        Note that torch backend does not support `\"wrap\"`.\n    fill_value: a float represents the value to be filled outside the\n        boundaries when `fill_mode=\"constant\"`.\n    value_range: the range of values the incoming images will have.\n        Represented as a two-number tuple written `[low, high]`. This is\n        typically either `[0, 1]` or `[0, 255]` depending on how your\n        preprocessing pipeline is set up.\n    seed: Integer. Used to create a random seed.",
    "std_args": [
      "factor",
      "scale",
      "interpolation",
      "fill_mode",
      "fill_value",
      "value_range",
      "seed",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "RandomErasing": {
    "description": "Random Erasing data augmentation technique.\n\nRandom Erasing is a data augmentation method where random patches of\nan image are erased (replaced by a constant value or noise)\nduring training to improve generalization.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nReferences:\n   - [Random Erasing paper](https://arxiv.org/abs/1708.04896).\n\nArgs:\n    factor: A single float or a tuple of two floats.\n        `factor` controls the probability of applying the transformation.\n        - `factor=0.0` ensures no erasing is applied.\n        - `factor=1.0` means erasing is always applied.\n        - If a tuple `(min, max)` is provided, a probability value\n          is sampled between `min` and `max` for each image.\n        - If a single float is provided, a probability is sampled\n          between `0.0` and the given float.\n        Default is 1.0.\n    scale: A tuple of two floats representing the aspect ratio range of\n        the erased patch. This defines the width-to-height ratio of\n        the patch to be erased. It can help control the rw shape of\n        the erased region. Default is (0.02, 0.33).\n    fill_value: A value to fill the erased region with. This can be set to\n        a constant value or `None` to sample a random value\n        from a normal distribution. Default is `None`.\n    value_range: the range of values the incoming images will have.\n        Represented as a two-number tuple written `[low, high]`. This is\n        typically either `[0, 1]` or `[0, 255]` depending on how your\n        preprocessing pipeline is set up.\n    seed: Integer. Used to create a random seed.",
    "std_args": [
      "factor",
      "scale",
      "fill_value",
      "value_range",
      "seed",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "RandomFlip": {
    "description": "A preprocessing layer which randomly flips images during training.\n\nThis layer will flip the images horizontally and or vertically based on the\n`mode` attribute. During inference time, the output will be identical to\ninput. Call the layer with `training=True` to flip the input.\nInput pixel values can be of any range (e.g. `[0., 1.)` or `[0, 255]`) and\nof integer or floating point dtype.\nBy default, the layer will output floats.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nInput shape:\n    3D (unbatched) or 4D (batched) tensor with shape:\n    `(..., height, width, channels)`, in `\"channels_last\"` format.\n\nOutput shape:\n    3D (unbatched) or 4D (batched) tensor with shape:\n    `(..., height, width, channels)`, in `\"channels_last\"` format.\n\nArgs:\n    mode: String indicating which flip mode to use. Can be `\"horizontal\"`,\n        `\"vertical\"`, or `\"horizontal_and_vertical\"`. `\"horizontal\"` is a\n        left-right flip and `\"vertical\"` is a top-bottom flip. Defaults to\n        `\"horizontal_and_vertical\"`\n    seed: Integer. Used to create a random seed.\n    **kwargs: Base layer keyword arguments, such as\n        `name` and `dtype`.",
    "std_args": [
      "mode",
      "seed",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "RandomGaussianBlur": {
    "description": "Applies random Gaussian blur to images for data augmentation.\n\nThis layer performs a Gaussian blur operation on input images with a\nrandomly selected degree of blurring, controlled by the `factor` and\n`sigma` arguments.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nArgs:\n    factor: A single float or a tuple of two floats.\n        `factor` controls the extent to which the image hue is impacted.\n        `factor=0.0` makes this layer perform a no-op operation,\n        while a value of `1.0` performs the most aggressive\n        blurring available. If a tuple is used, a `factor` is\n        sampled between the two values for every image augmented. If a\n        single float is used, a value between `0.0` and the passed float is\n        sampled. Default is 1.0.\n    kernel_size: Integer. Size of the Gaussian kernel used for blurring.\n        Must be an odd integer. Default is 3.\n    sigma: Float or tuple of two floats. Standard deviation of the Gaussian\n        kernel. Controls the intensity of the blur. If a tuple is provided,\n        a value is sampled between the two for each image. Default is 1.0.\n    value_range: the range of values the incoming images will have.\n        Represented as a two-number tuple written `[low, high]`. This is\n        typically either `[0, 1]` or `[0, 255]` depending on how your\n        preprocessing pipeline is set up.\n    seed: Integer. Used to create a random seed.",
    "std_args": [
      "factor",
      "kernel_size",
      "sigma",
      "value_range",
      "data_format",
      "seed",
      "kwargs"
    ],
    "type": "class"
  },
  "RandomGrayscale": {
    "description": "Preprocessing layer for random conversion of RGB images to grayscale.\n\nThis layer randomly converts input images to grayscale with a specified\nfactor. When applied, it maintains the original number of channels\nbut sets all channels to the same grayscale value. This can be useful\nfor data augmentation and training models to be robust to color\nvariations.\n\nThe conversion preserves the perceived luminance of the original color\nimage using standard RGB to grayscale conversion coefficients. Images\nthat are not selected for conversion remain unchanged.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nArgs:\n    factor: Float between 0 and 1, specifying the factor of\n        converting each image to grayscale. Defaults to 0.5. A value of\n        1.0 means all images will be converted, while 0.0 means no images\n        will be converted.\n    data_format: String, one of `\"channels_last\"` (default) or\n        `\"channels_first\"`. The ordering of the dimensions in the inputs.\n        `\"channels_last\"` corresponds to inputs with shape\n        `(batch, height, width, channels)` while `\"channels_first\"`\n        corresponds to inputs with shape\n        `(batch, channels, height, width)`.\n\nInput shape:\n    3D (unbatched) or 4D (batched) tensor with shape:\n    `(..., height, width, channels)`, in `\"channels_last\"` format,\n    or `(..., channels, height, width)`, in `\"channels_first\"` format.\n\nOutput shape:\n    Same as input shape. The output maintains the same number of channels\n    as the input, even for grayscale-converted images where all channels\n    will have the same value.",
    "std_args": [
      "factor",
      "data_format",
      "seed",
      "kwargs"
    ],
    "type": "class"
  },
  "RandomHorizontalFlip": {
    "description": "Horizontally flip the image randomly with a given probability.",
    "std_args": [
      "p"
    ]
  },
  "RandomHue": {
    "description": "Randomly adjusts the hue on given images.\n\nThis layer will randomly increase/reduce the hue for the input RGB\nimages.\n\nThe image hue is adjusted by converting the image(s) to HSV and rotating the\nhue channel (H) by delta. The image is then converted back to RGB.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nArgs:\n    factor: A single float or a tuple of two floats.\n        `factor` controls the extent to which the\n        image hue is impacted. `factor=0.0` makes this layer perform a\n        no-op operation, while a value of `1.0` performs the most aggressive\n        contrast adjustment available. If a tuple is used, a `factor` is\n        sampled between the two values for every image augmented. If a\n        single float is used, a value between `0.0` and the passed float is\n        sampled. In order to ensure the value is always the same, please\n        pass a tuple with two identical floats: `(0.5, 0.5)`.\n    value_range: the range of values the incoming images will have.\n        Represented as a two-number tuple written `[low, high]`. This is\n        typically either `[0, 1]` or `[0, 255]` depending on how your\n        preprocessing pipeline is set up.\n    seed: Integer. Used to create a random seed.\n\nExample:\n\n```python\n(images, labels), _ = keras.datasets.cifar10.load_data()\nrandom_hue = keras.layers.RandomHue(factor=0.5, value_range=[0, 1])\nimages = keras.ops.cast(images, \"float32\")\naugmented_images_batch = random_hue(images[:8])\n```",
    "std_args": [
      "factor",
      "value_range",
      "data_format",
      "seed",
      "kwargs"
    ],
    "type": "class"
  },
  "RandomInvert": {
    "description": "Preprocessing layer for random inversion of image colors.\n\nThis layer randomly inverts the colors of input images with a specified\nprobability range. When applied, each image has a chance of having its\ncolors inverted, where the pixel values are transformed to their\ncomplementary values. Images that are not selected for inversion\nremain unchanged.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nArgs:\n    factor: A single float or a tuple of two floats.\n        `factor` controls the probability of inverting the image colors.\n        If a tuple is provided, the value is sampled between the two values\n        for each image, where `factor[0]` is the minimum and `factor[1]` is\n        the maximum probability. If a single float is provided, a value\n        between `0.0` and the provided float is sampled.\n        Defaults to `(0, 1)`.\n    value_range: a tuple or a list of two elements. The first value\n        represents the lower bound for values in passed images, the second\n        represents the upper bound. Images passed to the layer should have\n        values within `value_range`. Defaults to `(0, 255)`.\n    seed: Integer. Used to create a random seed.",
    "std_args": [
      "factor",
      "value_range",
      "seed",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "RandomPerspective": {
    "description": "A preprocessing layer that applies random perspective transformations.\n\nThis layer distorts the perspective of input images by shifting their\ncorner points, simulating a 3D-like transformation. The amount of distortion\nis controlled by the `factor` and `scale` parameters.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nArgs:\n    factor: A float or a tuple of two floats.\n        Represents the probability of applying the perspective\n        transformation to each image in the batch.\n        - `factor=0.0` ensures no transformation is applied.\n        - `factor=1.0` means the transformation is always applied.\n        - If a tuple `(min, max)` is provided, a probability is randomly\n          sampled between `min` and `max` for each image.\n        - If a single float is given, the probability is sampled between\n          `0.0` and the provided float.\n        Default is 1.0.\n    scale: A float defining the relative amount of perspective shift.\n        Determines how much the image corners are displaced, affecting\n        the intensity of the perspective effect.\n    interpolation: Interpolation mode. Supported values: `\"nearest\"`,\n        `\"bilinear\"`.\n    fill_value: a float represents the value to be filled outside the\n        boundaries when `fill_mode=\"constant\"`.\n    seed: Integer. Used to create a random seed.",
    "std_args": [
      "factor",
      "scale",
      "interpolation",
      "fill_value",
      "seed",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "RandomPosterization": {
    "description": "Reduces the number of bits for each color channel.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nReferences:\n- [AutoAugment: Learning Augmentation Policies from Data](https://arxiv.org/abs/1805.09501)\n- [RandAugment: Practical automated data augmentation with a reduced search space](https://arxiv.org/abs/1909.13719)\n\nArgs:\n    value_range: a tuple or a list of two elements. The first value\n        represents the lower bound for values in passed images, the second\n        represents the upper bound. Images passed to the layer should have\n        values within `value_range`. Defaults to `(0, 255)`.\n    factor: integer, the number of bits to keep for each channel. Must be a\n        value between 1-8.",
    "std_args": [
      "factor",
      "value_range",
      "data_format",
      "seed",
      "kwargs"
    ],
    "type": "class"
  },
  "RandomRotation": {
    "description": "A preprocessing layer which randomly rotates images during training.\n\nThis layer will apply random rotations to each image, filling empty space\naccording to `fill_mode`.\n\nBy default, random rotations are only applied during training.\nAt inference time, the layer does nothing. If you need to apply random\nrotations at inference time, pass `training=True` when calling the layer.\n\nInput pixel values can be of any range (e.g. `[0., 1.)` or `[0, 255]`) and\nof integer or floating point dtype.\nBy default, the layer will output floats.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nInput shape:\n    3D (unbatched) or 4D (batched) tensor with shape:\n    `(..., height, width, channels)`, in `\"channels_last\"` format\n\nOutput shape:\n    3D (unbatched) or 4D (batched) tensor with shape:\n    `(..., height, width, channels)`, in `\"channels_last\"` format\n\nArgs:\n    factor: a float represented as fraction of 2 Pi, or a tuple of size 2\n        representing lower and upper bound for rotating clockwise and\n        counter-clockwise. A positive values means rotating\n        counter clock-wise,\n        while a negative value means clock-wise.\n        When represented as a single\n        float, this value is used for both the upper and lower bound.\n        For instance, `factor=(-0.2, 0.3)`\n        results in an output rotation by a random\n        amount in the range `[-20% * 360, 30% * 360]`.\n        `factor=0.2` results in an\n        output rotating by a random amount\n        in the range `[-20% * 360, 20% * 360]`.\n    fill_mode: Points outside the boundaries of the input are filled\n        according to the given mode\n        (one of `{\"constant\", \"reflect\", \"wrap\", \"nearest\"}`).\n        - *reflect*: `(d c b a | a b c d | d c b a)`\n            The input is extended by reflecting about\n            the edge of the last pixel.\n        - *constant*: `(k k k k | a b c d | k k k k)`\n            The input is extended by\n            filling all values beyond the edge with\n            the same constant value k = 0.\n        - *wrap*: `(a b c d | a b c d | a b c d)` The input is extended by\n            wrapping around to the opposite edge.\n        - *nearest*: `(a a a a | a b c d | d d d d)`\n            The input is extended by the nearest pixel.\n    interpolation: Interpolation mode. Supported values: `\"nearest\"`,\n        `\"bilinear\"`.\n    seed: Integer. Used to create a random seed.\n    fill_value: a float represents the value to be filled outside\n        the boundaries when `fill_mode=\"constant\"`.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, height, width, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, channels, height, width)`. It defaults to the\n        `image_data_format` value found in your Keras config file at\n        `~/.keras/keras.json`. If you never set it, then it will be\n        `\"channels_last\"`.",
    "std_args": [
      "factor",
      "fill_mode",
      "interpolation",
      "seed",
      "fill_value",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "RandomSaturation": {
    "description": "Randomly adjusts the saturation on given images.\n\nThis layer will randomly increase/reduce the saturation for the input RGB\nimages.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nArgs:\n    factor: A tuple of two floats or a single float.\n        `factor` controls the extent to which the image saturation\n        is impacted. `factor=0.5` makes this layer perform a no-op\n        operation. `factor=0.0` makes the image fully grayscale.\n        `factor=1.0` makes the image fully saturated. Values should\n        be between `0.0` and `1.0`. If a tuple is used, a `factor`\n        is sampled between the two values for every image augmented.\n        If a single float is used, a value between `0.0` and the passed\n        float is sampled. To ensure the value is always the same,\n        pass a tuple with two identical floats: `(0.5, 0.5)`.\n    value_range: the range of values the incoming images will have.\n        Represented as a two-number tuple written `[low, high]`. This is\n        typically either `[0, 1]` or `[0, 255]` depending on how your\n        preprocessing pipeline is set up.\n    seed: Integer. Used to create a random seed.\n\nExample:\n```python\n(images, labels), _ = keras.datasets.cifar10.load_data()\nimages = images.astype(\"float32\")\nrandom_saturation = keras.layers.RandomSaturation(factor=0.2)\naugmented_images = random_saturation(images)\n```",
    "std_args": [
      "factor",
      "value_range",
      "data_format",
      "seed",
      "kwargs"
    ],
    "type": "class"
  },
  "RandomSharpness": {
    "description": "Randomly performs the sharpness operation on given images.\n\nThe sharpness operation first performs a blur, then blends between the\noriginal image and the processed image. This operation adjusts the clarity\nof the edges in an image, ranging from blurred to enhanced sharpness.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nArgs:\n    factor: A tuple of two floats or a single float.\n        `factor` controls the extent to which the image sharpness\n        is impacted. `factor=0.0` results in a fully blurred image,\n        `factor=0.5` applies no operation (preserving the original image),\n        and `factor=1.0` enhances the sharpness beyond the original. Values\n        should be between `0.0` and `1.0`. If a tuple is used, a `factor`\n        is sampled between the two values for every image augmented.\n        If a single float is used, a value between `0.0` and the passed\n        float is sampled. To ensure the value is always the same,\n        pass a tuple with two identical floats: `(0.5, 0.5)`.\n    value_range: the range of values the incoming images will have.\n        Represented as a two-number tuple written `[low, high]`. This is\n        typically either `[0, 1]` or `[0, 255]` depending on how your\n        preprocessing pipeline is set up.\n    seed: Integer. Used to create a random seed.",
    "std_args": [
      "factor",
      "value_range",
      "data_format",
      "seed",
      "kwargs"
    ],
    "type": "class"
  },
  "RandomShear": {
    "description": "A preprocessing layer that randomly applies shear transformations to\nimages.\n\nThis layer shears the input images along the x-axis and/or y-axis by a\nrandomly selected factor within the specified range. The shear\ntransformation is applied to each image independently in a batch. Empty\nregions created during the transformation are filled according to the\n`fill_mode` and `fill_value` parameters.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nArgs:\n    x_factor: A tuple of two floats. For each augmented image, a value\n        is sampled from the provided range. If a float is passed, the\n        range is interpreted as `(0, x_factor)`. Values represent a\n        percentage of the image to shear over. For example, 0.3 shears\n        pixels up to 30% of the way across the image. All provided values\n        should be positive.\n    y_factor: A tuple of two floats. For each augmented image, a value\n        is sampled from the provided range. If a float is passed, the\n        range is interpreted as `(0, y_factor)`. Values represent a\n        percentage of the image to shear over. For example, 0.3 shears\n        pixels up to 30% of the way across the image. All provided values\n        should be positive.\n    interpolation: Interpolation mode. Supported values: `\"nearest\"`,\n        `\"bilinear\"`.\n    fill_mode: Points outside the boundaries of the input are filled\n        according to the given mode. Available methods are `\"constant\"`,\n        `\"nearest\"`, `\"wrap\"` and `\"reflect\"`. Defaults to `\"constant\"`.\n        - `\"reflect\"`: `(d c b a | a b c d | d c b a)`\n            The input is extended by reflecting about the edge of the\n            last pixel.\n        - `\"constant\"`: `(k k k k | a b c d | k k k k)`\n            The input is extended by filling all values beyond the edge\n            with the same constant value `k` specified by `fill_value`.\n        - `\"wrap\"`: `(a b c d | a b c d | a b c d)`\n            The input is extended by wrapping around to the opposite edge.\n        - `\"nearest\"`: `(a a a a | a b c d | d d d d)`\n            The input is extended by the nearest pixel.\n        Note that when using torch backend, `\"reflect\"` is redirected to\n        `\"mirror\"` `(c d c b | a b c d | c b a b)` because torch does\n        not support `\"reflect\"`.\n        Note that torch backend does not support `\"wrap\"`.\n    fill_value: A float representing the value to be filled outside the\n        boundaries when `fill_mode=\"constant\"`.\n    seed: Integer. Used to create a random seed.",
    "std_args": [
      "x_factor",
      "y_factor",
      "interpolation",
      "fill_mode",
      "fill_value",
      "data_format",
      "seed",
      "kwargs"
    ],
    "type": "class"
  },
  "RandomState": {
    "description": "Container for the slow Mersenne Twister pseudo-random number generator.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "RandomStructured": {
    "description": "Prune entire (currently unpruned) channels in a tensor at random.",
    "std_args": [
      "self",
      "amount",
      "dim"
    ],
    "type": "class"
  },
  "RandomTranslation": {
    "description": "A preprocessing layer which randomly translates images during training.\n\nThis layer will apply random translations to each image during training,\nfilling empty space according to `fill_mode`.\n\nInput pixel values can be of any range (e.g. `[0., 1.)` or `[0, 255]`) and\nof integer or floating point dtype. By default, the layer will output\nfloats.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nInput shape:\n    3D (unbatched) or 4D (batched) tensor with shape:\n    `(..., height, width, channels)`, in `\"channels_last\"` format,\n    or `(..., channels, height, width)`, in `\"channels_first\"` format.\n\nOutput shape:\n    3D (unbatched) or 4D (batched) tensor with shape:\n    `(..., target_height, target_width, channels)`,\n    or `(..., channels, target_height, target_width)`,\n    in `\"channels_first\"` format.\n\nArgs:\n    height_factor: a float represented as fraction of value, or a tuple of\n        size 2 representing lower and upper bound for shifting vertically. A\n        negative value means shifting image up, while a positive value means\n        shifting image down. When represented as a single positive float,\n        this value is used for both the upper and lower bound. For instance,\n        `height_factor=(-0.2, 0.3)` results in an output shifted by a random\n        amount in the range `[-20%, +30%]`. `height_factor=0.2` results in\n        an output height shifted by a random amount in the range\n        `[-20%, +20%]`.\n    width_factor: a float represented as fraction of value, or a tuple of\n        size 2 representing lower and upper bound for shifting horizontally.\n        A negative value means shifting image left, while a positive value\n        means shifting image right. When represented as a single positive\n        float, this value is used for both the upper and lower bound. For\n        instance, `width_factor=(-0.2, 0.3)` results in an output shifted\n        left by 20%, and shifted right by 30%. `width_factor=0.2` results\n        in an output height shifted left or right by 20%.\n    fill_mode: Points outside the boundaries of the input are filled\n        according to the given mode. Available methods are `\"constant\"`,\n        `\"nearest\"`, `\"wrap\"` and `\"reflect\"`. Defaults to `\"constant\"`.\n        - `\"reflect\"`: `(d c b a | a b c d | d c b a)`\n            The input is extended by reflecting about the edge of the last\n            pixel.\n        - `\"constant\"`: `(k k k k | a b c d | k k k k)`\n            The input is extended by filling all values beyond\n            the edge with the same constant value k specified by\n            `fill_value`.\n        - `\"wrap\"`: `(a b c d | a b c d | a b c d)`\n            The input is extended by wrapping around to the opposite edge.\n        - `\"nearest\"`: `(a a a a | a b c d | d d d d)`\n            The input is extended by the nearest pixel.\n        Note that when using torch backend, `\"reflect\"` is redirected to\n        `\"mirror\"` `(c d c b | a b c d | c b a b)` because torch does not\n        support `\"reflect\"`.\n        Note that torch backend does not support `\"wrap\"`.\n    interpolation: Interpolation mode. Supported values: `\"nearest\"`,\n        `\"bilinear\"`.\n    seed: Integer. Used to create a random seed.\n    fill_value: a float represents the value to be filled outside the\n        boundaries when `fill_mode=\"constant\"`.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, height, width, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, channels, height, width)`. It defaults to the\n        `image_data_format` value found in your Keras config file at\n        `~/.keras/keras.json`. If you never set it, then it will be\n        `\"channels_last\"`.\n    **kwargs: Base layer keyword arguments, such as `name` and `dtype`.",
    "std_args": [
      "height_factor",
      "width_factor",
      "fill_mode",
      "interpolation",
      "seed",
      "fill_value",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "RandomUnstructured": {
    "description": "Prune (currently unpruned) units in a tensor at random.",
    "std_args": [
      "self",
      "amount"
    ],
    "type": "class"
  },
  "RandomVerticalFlip": {
    "description": "Vertically flip the image randomly with a given probability.",
    "std_args": [
      "p"
    ]
  },
  "RandomZoom": {
    "description": "A preprocessing layer which randomly zooms images during training.\n\nThis layer will randomly zoom in or out on each axis of an image\nindependently, filling empty space according to `fill_mode`.\n\nInput pixel values can be of any range (e.g. `[0., 1.)` or `[0, 255]`) and\nof integer or floating point dtype.\nBy default, the layer will output floats.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nInput shape:\n    3D (unbatched) or 4D (batched) tensor with shape:\n    `(..., height, width, channels)`, in `\"channels_last\"` format,\n    or `(..., channels, height, width)`, in `\"channels_first\"` format.\n\nOutput shape:\n    3D (unbatched) or 4D (batched) tensor with shape:\n    `(..., target_height, target_width, channels)`,\n    or `(..., channels, target_height, target_width)`,\n    in `\"channels_first\"` format.\n\nArgs:\n    height_factor: a float represented as fraction of value, or a tuple of\n        size 2 representing lower and upper bound for zooming vertically.\n        When represented as a single float, this value is used for both the\n        upper and lower bound. A positive value means zooming out, while a\n        negative value means zooming in. For instance,\n        `height_factor=(0.2, 0.3)` result in an output zoomed out by a\n        random amount in the range `[+20%, +30%]`.\n        `height_factor=(-0.3, -0.2)` result in an output zoomed in by a\n        random amount in the range `[+20%, +30%]`.\n    width_factor: a float represented as fraction of value, or a tuple of\n        size 2 representing lower and upper bound for zooming horizontally.\n        When represented as a single float, this value is used for both the\n        upper and lower bound. For instance, `width_factor=(0.2, 0.3)`\n        result in an output zooming out between 20% to 30%.\n        `width_factor=(-0.3, -0.2)` result in an output zooming in between\n        20% to 30%. `None` means i.e., zooming vertical and horizontal\n        directions by preserving the aspect ratio. Defaults to `None`.\n    fill_mode: Points outside the boundaries of the input are filled\n        according to the given mode. Available methods are `\"constant\"`,\n        `\"nearest\"`, `\"wrap\"` and `\"reflect\"`. Defaults to `\"reflect\"`.\n        - `\"reflect\"`: `(d c b a | a b c d | d c b a)`\n            The input is extended by reflecting about the edge of the last\n            pixel.\n        - `\"constant\"`: `(k k k k | a b c d | k k k k)`\n            The input is extended by filling all values beyond\n            the edge with the same constant value k specified by\n            `fill_value`.\n        - `\"wrap\"`: `(a b c d | a b c d | a b c d)`\n            The input is extended by wrapping around to the opposite edge.\n        - `\"nearest\"`: `(a a a a | a b c d | d d d d)`\n            The input is extended by the nearest pixel.\n        Note that when using torch backend, `\"reflect\"` is redirected to\n        `\"mirror\"` `(c d c b | a b c d | c b a b)` because torch does not\n        support `\"reflect\"`.\n        Note that torch backend does not support `\"wrap\"`.\n    interpolation: Interpolation mode. Supported values: `\"nearest\"`,\n        `\"bilinear\"`.\n    seed: Integer. Used to create a random seed.\n    fill_value: a float that represents the value to be filled outside\n        the boundaries when `fill_mode=\"constant\"`.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, height, width, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, channels, height, width)`. It defaults to the\n        `image_data_format` value found in your Keras config file at\n        `~/.keras/keras.json`. If you never set it, then it will be\n        `\"channels_last\"`.\n    **kwargs: Base layer keyword arguments, such as `name` and `dtype`.\n\nExample:\n\n>>> input_img = np.random.random((32, 224, 224, 3))\n>>> layer = keras.layers.RandomZoom(.5, .2)\n>>> out_img = layer(input_img)",
    "std_args": [
      "height_factor",
      "width_factor",
      "fill_mode",
      "interpolation",
      "seed",
      "fill_value",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "RankWarning": {
    "description": "Matrix rank warning.",
    "std_args": [],
    "type": "class"
  },
  "ReLU2": {
    "description": "Applies the ReLU\u00b2 activation function.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "Reduction": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RefMap": {
    "description": "A mapping that hashes keys by their identity.",
    "std_args": [
      "self",
      "mapping"
    ],
    "type": "class"
  },
  "ReflectionPad1d": {
    "description": "Pads the input tensor using the reflection of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ReflectionPad2d": {
    "description": "Pads the input tensor using the reflection of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ReflectionPad3d": {
    "description": "Pads the input tensor using the reflection of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "RelOp": {
    "description": "Used in Op.RELATIONAL expression to specify the function part.",
    "std_args": [],
    "type": "class"
  },
  "Relu6": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "class"
  },
  "RemoveAxisHook": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RepeatVector": {
    "description": "Repeats the input n times.\n\nExample:\n\n>>> x = keras.Input(shape=(32,))\n>>> y = keras.layers.RepeatVector(3)(x)\n>>> y.shape\n(None, 3, 32)\n\nArgs:\n    n: Integer, repetition factor.\n\nInput shape:\n    2D tensor with shape `(batch_size, features)`.\n\nOutput shape:\n    3D tensor with shape `(batch_size, n, features)`.",
    "std_args": [
      "n",
      "kwargs"
    ],
    "type": "class"
  },
  "Repeated": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "ReplicationPad1d": {
    "description": "Pads the input tensor using replication of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ReplicationPad2d": {
    "description": "Pads the input tensor using replication of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ReplicationPad3d": {
    "description": "Pads the input tensor using replication of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ReprContext": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "current_color",
      "depth"
    ],
    "type": "class"
  },
  "Representable": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Rescaling": {
    "description": "A preprocessing layer which rescales input values to a new range.\n\nThis layer rescales every value of an input (often an image) by multiplying\nby `scale` and adding `offset`.\n\nFor instance:\n\n1. To rescale an input in the `[0, 255]` range\nto be in the `[0, 1]` range, you would pass `scale=1./255`.\n\n2. To rescale an input in the `[0, 255]` range to be in the `[-1, 1]` range,\nyou would pass `scale=1./127.5, offset=-1`.\n\nThe rescaling is applied both during training and inference. Inputs can be\nof integer or floating point dtype, and by default the layer will output\nfloats.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nArgs:\n    scale: Float, the scale to apply to the inputs.\n    offset: Float, the offset to apply to the inputs.\n    **kwargs: Base layer keyword arguments, such as `name` and `dtype`.",
    "std_args": [
      "scale",
      "offset",
      "kwargs"
    ],
    "type": "class"
  },
  "Resize": {
    "description": "Resize the input image to the given size.",
    "std_args": [
      "size"
    ]
  },
  "Resizing": {
    "description": "A preprocessing layer which resizes images.\n\nThis layer resizes an image input to a target height and width. The input\nshould be a 4D (batched) or 3D (unbatched) tensor in `\"channels_last\"`\nformat. Input pixel values can be of any range\n(e.g. `[0., 1.)` or `[0, 255]`).\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nInput shape:\n    3D (unbatched) or 4D (batched) tensor with shape:\n    `(..., height, width, channels)`, in `\"channels_last\"` format,\n    or `(..., channels, height, width)`, in `\"channels_first\"` format.\n\nOutput shape:\n    3D (unbatched) or 4D (batched) tensor with shape:\n    `(..., target_height, target_width, channels)`,\n    or `(..., channels, target_height, target_width)`,\n    in `\"channels_first\"` format.\n\nArgs:\n    height: Integer, the height of the output shape.\n    width: Integer, the width of the output shape.\n    interpolation: String, the interpolation method.\n        Supports `\"bilinear\"`, `\"nearest\"`, `\"bicubic\"`,\n        `\"lanczos3\"`, `\"lanczos5\"`. Defaults to `\"bilinear\"`.\n    crop_to_aspect_ratio: If `True`, resize the images without aspect\n        ratio distortion. When the original aspect ratio differs\n        from the target aspect ratio, the output image will be\n        cropped so as to return the\n        largest possible window in the image (of size `(height, width)`)\n        that matches the target aspect ratio. By default\n        (`crop_to_aspect_ratio=False`), aspect ratio may not be preserved.\n    pad_to_aspect_ratio: If `True`, pad the images without aspect\n        ratio distortion. When the original aspect ratio differs\n        from the target aspect ratio, the output image will be\n        evenly padded on the short side.\n    fill_mode: When using `pad_to_aspect_ratio=True`, padded areas\n        are filled according to the given mode. Only `\"constant\"` is\n        supported at this time\n        (fill with constant value, equal to `fill_value`).\n    fill_value: Float. Padding value to use when `pad_to_aspect_ratio=True`.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, height, width, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, channels, height, width)`. It defaults to the\n        `image_data_format` value found in your Keras config file at\n        `~/.keras/keras.json`. If you never set it, then it will be\n        `\"channels_last\"`.\n    **kwargs: Base layer keyword arguments, such as `name` and `dtype`.",
    "std_args": [
      "height",
      "width",
      "interpolation",
      "crop_to_aspect_ratio",
      "pad_to_aspect_ratio",
      "fill_mode",
      "fill_value",
      "antialias",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "ReversibleEmbedding": {
    "description": "An embedding layer which can project backwards to the input dim.\n\nThis layer is an extension of `keras.layers.Embedding` for language models.\nThis layer can be called \"in reverse\" with `reverse=True`, in which case the\nlayer will linearly project from `output_dim` back to `input_dim`.\n\nBy default, the reverse projection will use the transpose of the\n`embeddings` weights to project to `input_dim` (weights are \"tied\"). If\n`tie_weights=False`, the model will use a separate, trainable variable for\nreverse projection.\n\nThis layer has no bias terms.\n\nArgs:\n    input_dim: Integer. Size of the vocabulary,\n        i.e. maximum integer index + 1.\n    output_dim: Integer. Dimension of the dense embedding.\n    tie_weights: Boolean, whether or not the matrix for embedding and\n        the matrix for the `reverse` projection should share the same\n        weights.\n    embeddings_initializer: Initializer for the `embeddings`\n        matrix (see `keras.initializers`).\n    embeddings_regularizer: Regularizer function applied to\n        the `embeddings` matrix (see `keras.regularizers`).\n    embeddings_constraint: Constraint function applied to\n        the `embeddings` matrix (see `keras.constraints`).\n    mask_zero: Boolean, whether or not the input value 0 is a special\n        \"padding\" value that should be masked out.\n    reverse_dtype: The dtype for the reverse projection computation.\n        Defaults to the `compute_dtype` of the layer.\n    logit_soft_cap: If `logit_soft_cap` is set and `reverse=True`, the\n        output logits will be scaled by\n        `tanh(logits / logit_soft_cap) * logit_soft_cap`. This narrows the\n        range of output logits and can improve training.\n    **kwargs: other keyword arguments passed to `keras.layers.Embedding`,\n        including `name`, `trainable`, `dtype` etc.\n\nCall arguments:\n    inputs: The tensor inputs to the layer.\n    reverse: Boolean. If `True` the layer will perform a linear projection\n        from `output_dim` to `input_dim`, instead of a normal embedding\n        call. Default to `False`.\n\nExample:\n```python\nbatch_size = 16\nvocab_size = 100\nhidden_dim = 32\nseq_length = 50\n\n# Generate random inputs.\ntoken_ids = np.random.randint(vocab_size, size=(batch_size, seq_length))\n\nembedding = keras.layers.ReversibleEmbedding(vocab_size, hidden_dim)\n# Embed tokens to shape `(batch_size, seq_length, hidden_dim)`.\nhidden_states = embedding(token_ids)\n# Project hidden states to shape `(batch_size, seq_length, vocab_size)`.\nlogits = embedding(hidden_states, reverse=True)\n```\n\nReferences:\n- [Vaswani et al., 2017](https://arxiv.org/abs/1706.03762)\n- [Press and Wolf, 2016](https://arxiv.org/abs/1608.05859)",
    "std_args": [
      "input_dim",
      "output_dim",
      "tie_weights",
      "embeddings_initializer",
      "embeddings_regularizer",
      "embeddings_constraint",
      "mask_zero",
      "reverse_dtype",
      "logit_soft_cap",
      "kwargs"
    ],
    "type": "class"
  },
  "Rmsnorm": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "dtype",
      "eps"
    ],
    "type": "class"
  },
  "RngCount": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "value",
      "is_hijax",
      "has_ref",
      "is_mutable",
      "eager_sharding",
      "metadata"
    ],
    "type": "class"
  },
  "RngKey": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "value",
      "is_hijax",
      "has_ref",
      "is_mutable",
      "eager_sharding",
      "metadata"
    ],
    "type": "class"
  },
  "RngState": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "value",
      "is_hijax",
      "has_ref",
      "is_mutable",
      "eager_sharding",
      "metadata"
    ],
    "type": "class"
  },
  "RngStream": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "key",
      "tag"
    ],
    "type": "class"
  },
  "RngValue": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Rngs": {
    "description": "A small abstraction to manage RNG state.",
    "std_args": [
      "self",
      "default",
      "rngs"
    ],
    "type": "class"
  },
  "Rnncellbase": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "class"
  },
  "RoPE": {
    "description": "Implements the rotary positional encoding.",
    "std_args": [
      "self",
      "dims",
      "traditional",
      "base",
      "scale"
    ],
    "type": "class"
  },
  "RoundtripTest": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "S": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SDPBackend": {
    "description": "An enum-like class that contains the different backends for scaled dot product attention.",
    "std_args": [],
    "type": "attribute"
  },
  "SEP": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SGD": {
    "description": "Stochastic Gradient Descent optimizer.",
    "std_args": [
      "params",
      "lr",
      "momentum",
      "dampening",
      "weight_decay",
      "nesterov"
    ],
    "type": "class"
  },
  "SKIP_LIST": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SKIP_LIST_2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "STFTSpectrogram": {
    "description": "Layer to compute the Short-Time Fourier Transform (STFT) on a 1D signal.\n\nA layer that computes Spectrograms of the input signal to produce\na spectrogram. This layers utilizes Short-Time Fourier Transform (STFT) by\nThe layer computes Spectrograms based on STFT by utilizing convolution\nkernels, which allows parallelization on GPUs and trainable kernels for\nfine-tuning support. This layer allows different modes of output\n(e.g., log-scaled magnitude, phase, power spectral density, etc.) and\nprovides flexibility in windowing, padding, and scaling options for the\nSTFT calculation.\n\nExamples:\n\nApply it as a non-trainable preprocessing layer on 3 audio tracks of\n1 channel, 10 seconds and sampled at 16 kHz.\n\n>>> layer = keras.layers.STFTSpectrogram(\n...     mode='log',\n...     frame_length=256,\n...     frame_step=128,   # 50% overlap\n...     fft_length=512,\n...     window=\"hann\",\n...     padding=\"valid\",\n...     trainable=False,  # non-trainable, preprocessing only\n... )\n>>> layer(keras.random.uniform(shape=(3, 160000, 1))).shape\n(3, 1249, 257)\n\nApply it as a trainable processing layer on 3 stereo audio tracks of\n2 channels, 10 seconds and sampled at 16 kHz. This is initialized as the\nnon-trainable layer, but then can be trained jointly within a model.\n\n>>> layer = keras.layers.STFTSpectrogram(\n...     mode='log',\n...     frame_length=256,\n...     frame_step=128,    # 50% overlap\n...     fft_length=512,\n...     window=\"hamming\",  # hamming windowing function\n...     padding=\"same\",    # padding to preserve the time dimension\n...     trainable=True,    # trainable, this is the default in keras\n... )\n>>> layer(keras.random.uniform(shape=(3, 160000, 2))).shape\n(3, 1250, 514)\n\nSimilar to the last example, but add an extra dimension so the output is\nan image to be used with image models. We apply this here on a signal of\n3 input channels to output an image tensor, hence is directly applicable\nwith an image model.\n\n>>> layer = keras.layers.STFTSpectrogram(\n...     mode='log',\n...     frame_length=256,\n...     frame_step=128,\n...     fft_length=512,\n...     padding=\"same\",\n...     expand_dims=True,  # this adds the extra dimension\n... )\n>>> layer(keras.random.uniform(shape=(3, 160000, 3))).shape\n(3, 1250, 257, 3)\n\nArgs:\n    mode: String, the output type of the spectrogram. Can be one of\n        `\"log\"`, `\"magnitude`\", `\"psd\"`, `\"real`\", `\"imag`\", `\"angle`\",\n        `\"stft`\". Defaults to `\"log`\".\n    frame_length: Integer, The length of each frame (window) for STFT in\n        samples. Defaults to 256.\n    frame_step: Integer, the step size (hop length) between\n        consecutive frames. If not provided, defaults to half the\n        frame_length. Defaults to `frame_length // 2`.\n    fft_length: Integer, the size of frequency bins used in the Fast-Fourier\n        Transform (FFT) to apply to each frame. Should be greater than or\n        equal to `frame_length`.  Recommended to be a power of two. Defaults\n        to the smallest power of two that is greater than or equal\n        to `frame_length`.\n    window: (String or array_like), the windowing function to apply to each\n        frame. Can be `\"hann`\" (default), `\"hamming`\", or a custom window\n        provided as an array_like.\n    periodic: Boolean, if True, the window function will be treated as\n        periodic. Defaults to `False`.\n    scaling: String, type of scaling applied to the window. Can be\n        `\"density`\", `\"spectrum`\", or None. Default is `\"density`\".\n    padding: String, padding strategy. Can be `\"valid`\" or `\"same`\".\n        Defaults to `\"valid\"`.\n    expand_dims: Boolean, if True, will expand the output into spectrograms\n        into two dimensions to be compatible with image models.\n        Defaults to `False`.\n    data_format: String, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, height, width, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, channels, height, weight)`. Defaults to `\"channels_last\"`.\n\nRaises:\n    ValueError: If an invalid value is provided for `\"mode`\", `\"scaling`\",\n        `\"padding`\", or other input arguments.\n    TypeError: If the input data type is not one of `\"float16`\",\n        `\"float32`\", or `\"float64`\".\n\nInput shape:\n    A 3D tensor of shape `(batch_size, time_length, input_channels)`, if\n    `data_format==\"channels_last\"`, and of shape\n    `(batch_size, input_channels, time_length)` if\n    `data_format==\"channels_first\"`, where `time_length` is the length of\n    the input signal, and `input_channels` is the number of input channels.\n    The same kernels are applied to each channel independently.\n\nOutput shape:\n    If `data_format==\"channels_first\" and not expand_dims`, a 3D tensor:\n        `(batch_size, input_channels * freq_channels, new_time_length)`\n    If `data_format==\"channels_last\" and not expand_dims`, a 3D tensor:\n        `(batch_size, new_time_length, input_channels * freq_channels)`\n    If `data_format==\"channels_first\" and expand_dims`, a 4D tensor:\n        `(batch_size, input_channels, new_time_length, freq_channels)`\n    If `data_format==\"channels_last\" and expand_dims`, a 4D tensor:\n        `(batch_size, new_time_length, freq_channels, input_channels)`\n\n    where `new_time_length` depends on the padding, and `freq_channels` is\n    the number of FFT bins `(fft_length // 2 + 1)`.",
    "std_args": [
      "mode",
      "frame_length",
      "frame_step",
      "fft_length",
      "window",
      "periodic",
      "scaling",
      "padding",
      "expand_dims",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "STRING": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SVDBaseTests": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "SVDCases": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "SVDHermitianCases": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "SWITCH_TO_EXP": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SYMBOL": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Save": {
    "description": "Serialize object to disk.",
    "std_args": [
      "obj",
      "f"
    ],
    "type": "function"
  },
  "ScaleByTrustRatioState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ScaleState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ScanFn": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "f",
      "input_carry_argnum",
      "output_carry_argnum",
      "in_axes",
      "out_axes",
      "transform_metadata"
    ],
    "type": "class"
  },
  "Scope": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "rngs",
      "mutable"
    ],
    "type": "class"
  },
  "SeedGenerator": {
    "description": "Generates variable seeds upon each call to a function generating\nrandom numbers.\n\nIn Keras, all random number generators (such as\n`keras.random.normal()`) are stateless, meaning that if you pass an\ninteger seed to them (such as `seed=42`), they will return the same\nvalues for repeated calls. To get different values for each\ncall, a `SeedGenerator` providing the state of the random generator\nhas to be used.\n\nNote that all the random number generators have a default seed of None,\nwhich implies that an internal global SeedGenerator is used.\nIf you need to decouple the RNG from the global state you can provide\na local `StateGenerator` with either a deterministic or random initial\nstate.\n\nRemark concerning the JAX backen: Note that the use of a local\n`StateGenerator` as seed argument is required for JIT compilation of\nRNG with the JAX backend, because the use of global state is not\nsupported.\n\nExample:\n\n```python\nseed_gen = keras.random.SeedGenerator(seed=42)\nvalues = keras.random.normal(shape=(2, 3), seed=seed_gen)\nnew_values = keras.random.normal(shape=(2, 3), seed=seed_gen)\n```\n\nUsage in a layer:\n\n```python\nclass Dropout(keras.Layer):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.seed_generator = keras.random.SeedGenerator(1337)\n\n    def call(self, x, training=False):\n        if training:\n            return keras.random.dropout(\n                x, rate=0.5, seed=self.seed_generator\n            )\n        return x\n```",
    "std_args": [
      "seed",
      "name",
      "kwargs"
    ],
    "type": "class"
  },
  "SeedSequence": {
    "description": "SeedSequence mixes sources of entropy in a reproducible way to set the",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "SeedlessSeedSequence": {
    "description": "A seed sequence for BitGenerators with no need for seed state.",
    "std_args": [],
    "type": "class"
  },
  "SeparableConv1D": {
    "description": "1D separable convolution layer.\n\nThis layer performs a depthwise convolution that acts separately on\nchannels, followed by a pointwise convolution that mixes channels.\nIf `use_bias` is True and a bias initializer is provided,\nit adds a bias vector to the output. It then optionally applies an\nactivation function to produce the final output.\n\nArgs:\n    filters: int, the dimensionality of the output space (i.e. the number\n        of filters in the pointwise convolution).\n    kernel_size: int or tuple/list of 1 integers, specifying the size of the\n        depthwise convolution window.\n    strides: int or tuple/list of 1 integers, specifying the stride length\n        of the depthwise convolution. If only one int is specified, the same\n        stride size will be used for all dimensions. `strides > 1` is\n        incompatible with `dilation_rate > 1`.\n    padding: string, either `\"valid\"` or `\"same\"` (case-insensitive).\n        `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n        the left/right or up/down of the input. When `padding=\"same\"` and\n        `strides=1`, the output has the same size as the input.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, steps, features)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, features, steps)`. It defaults to the `image_data_format`\n        value found in your Keras config file at `~/.keras/keras.json`.\n        If you never set it, then it will be `\"channels_last\"`.\n    dilation_rate: int or tuple/list of 1 integers, specifying the dilation\n        rate to use for dilated convolution. If only one int is specified,\n        the same dilation rate will be used for all dimensions.\n    depth_multiplier: The number of depthwise convolution output channels\n        for each input channel. The total number of depthwise convolution\n        output channels will be equal to `input_channel * depth_multiplier`.\n    activation: Activation function. If `None`, no activation is applied.\n    use_bias: bool, if `True`, bias will be added to the output.\n    depthwise_initializer: An initializer for the depthwise convolution\n        kernel. If None, then the default initializer (`\"glorot_uniform\"`)\n        will be used.\n    pointwise_initializer: An initializer for the pointwise convolution\n        kernel. If None, then the default initializer (`\"glorot_uniform\"`)\n        will be used.\n    bias_initializer: An initializer for the bias vector. If None, the\n        default initializer ('\"zeros\"') will be used.\n    depthwise_regularizer: Optional regularizer for the depthwise\n        convolution kernel.\n    pointwise_regularizer: Optional regularizer for the pointwise\n        convolution kernel.\n    bias_regularizer: Optional regularizer for the bias vector.\n    activity_regularizer: Optional regularizer function for the output.\n    depthwise_constraint: Optional projection function to be applied to the\n        depthwise kernel after being updated by an `Optimizer` (e.g. used\n        for norm constraints or value constraints for layer weights). The\n        function must take as input the unprojected variable and must return\n        the projected variable (which must have the same shape).\n    pointwise_constraint: Optional projection function to be applied to the\n        pointwise kernel after being updated by an `Optimizer`.\n    bias_constraint: Optional projection function to be applied to the\n        bias after being updated by an `Optimizer`.\n\nInput shape:\n\n- If `data_format=\"channels_last\"`:\n    A 3D tensor with shape: `(batch_shape, steps, channels)`\n- If `data_format=\"channels_first\"`:\n    A 3D tensor with shape: `(batch_shape, channels, steps)`\n\nOutput shape:\n\n- If `data_format=\"channels_last\"`:\n    A 3D tensor with shape: `(batch_shape, new_steps, filters)`\n- If `data_format=\"channels_first\"`:\n    A 3D tensor with shape: `(batch_shape, filters, new_steps)`\n\nReturns:\n    A 3D tensor representing\n    `activation(separable_conv1d(inputs, kernel) + bias)`.\n\nExample:\n\n>>> x = np.random.rand(4, 10, 12)\n>>> y = keras.layers.SeparableConv1D(3, 4, 3, 2, activation='relu')(x)\n>>> print(y.shape)\n(4, 4, 4)",
    "std_args": [
      "filters",
      "kernel_size",
      "strides",
      "padding",
      "data_format",
      "dilation_rate",
      "depth_multiplier",
      "activation",
      "use_bias",
      "depthwise_initializer",
      "pointwise_initializer",
      "bias_initializer",
      "depthwise_regularizer",
      "pointwise_regularizer",
      "bias_regularizer",
      "activity_regularizer",
      "depthwise_constraint",
      "pointwise_constraint",
      "bias_constraint",
      "kwargs"
    ],
    "type": "class"
  },
  "SeparableConv2D": {
    "description": "2D separable convolution layer.\n\nThis layer performs a depthwise convolution that acts separately on\nchannels, followed by a pointwise convolution that mixes channels.\nIf `use_bias` is True and a bias initializer is provided,\nit adds a bias vector to the output. It then optionally applies an\nactivation function to produce the final output.\n\nArgs:\n    filters: int, the dimensionality of the output space (i.e. the number\n        of filters in the pointwise convolution).\n    kernel_size: int or tuple/list of 2 integers, specifying the size of the\n        depthwise convolution window.\n    strides: int or tuple/list of 2 integers, specifying the stride length\n        of the depthwise convolution. If only one int is specified, the same\n        stride size will be used for all dimensions. `strides > 1` is\n        incompatible with `dilation_rate > 1`.\n    padding: string, either `\"valid\"` or `\"same\"` (case-insensitive).\n        `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n        the left/right or up/down of the input. When `padding=\"same\"` and\n        `strides=1`, the output has the same size as the input.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, height, width, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, channels, height, width)`. It defaults to the\n        `image_data_format` value found in your Keras config file\n        at `~/.keras/keras.json`.\n        If you never set it, then it will be `\"channels_last\"`.\n    dilation_rate: int or tuple/list of 2 integers, specifying the dilation\n        rate to use for dilated convolution. If only one int is specified,\n        the same dilation rate will be used for all dimensions.\n    depth_multiplier: The number of depthwise convolution output channels\n        for each input channel. The total number of depthwise convolution\n        output channels will be equal to `input_channel * depth_multiplier`.\n    activation: Activation function. If `None`, no activation is applied.\n    use_bias: bool, if `True`, bias will be added to the output.\n    depthwise_initializer: An initializer for the depthwise convolution\n        kernel. If None, then the default initializer (`\"glorot_uniform\"`)\n        will be used.\n    pointwise_initializer: An initializer for the pointwise convolution\n        kernel. If None, then the default initializer (`\"glorot_uniform\"`)\n        will be used.\n    bias_initializer: An initializer for the bias vector. If None, the\n        default initializer ('\"zeros\"') will be used.\n    depthwise_regularizer: Optional regularizer for the depthwise\n        convolution kernel.\n    pointwise_regularizer: Optional regularizer for the pointwise\n        convolution kernel.\n    bias_regularizer: Optional regularizer for the bias vector.\n    activity_regularizer: Optional regularizer function for the output.\n    depthwise_constraint: Optional projection function to be applied to the\n        depthwise kernel after being updated by an `Optimizer` (e.g. used\n        for norm constraints or value constraints for layer weights). The\n        function must take as input the unprojected variable and must return\n        the projected variable (which must have the same shape).\n    pointwise_constraint: Optional projection function to be applied to the\n        pointwise kernel after being updated by an `Optimizer`.\n    bias_constraint: Optional projection function to be applied to the\n        bias after being updated by an `Optimizer`.\n\nInput shape:\n\n- If `data_format=\"channels_last\"`:\n    A 4D tensor with shape: `(batch_size, height, width, channels)`\n- If `data_format=\"channels_first\"`:\n    A 4D tensor with shape: `(batch_size, channels, height, width)`\n\nOutput shape:\n\n- If `data_format=\"channels_last\"`:\n    A 4D tensor with shape: `(batch_size, new_height, new_width, filters)`\n- If `data_format=\"channels_first\"`:\n    A 4D tensor with shape: `(batch_size, filters, new_height, new_width)`\n\nReturns:\n    A 4D tensor representing\n    `activation(separable_conv2d(inputs, kernel) + bias)`.\n\nExample:\n\n>>> x = np.random.rand(4, 10, 10, 12)\n>>> y = keras.layers.SeparableConv2D(3, 4, 3, 2, activation='relu')(x)\n>>> print(y.shape)\n(4, 4, 4, 4)",
    "std_args": [
      "filters",
      "kernel_size",
      "strides",
      "padding",
      "data_format",
      "dilation_rate",
      "depth_multiplier",
      "activation",
      "use_bias",
      "depthwise_initializer",
      "pointwise_initializer",
      "bias_initializer",
      "depthwise_regularizer",
      "pointwise_regularizer",
      "bias_regularizer",
      "activity_regularizer",
      "depthwise_constraint",
      "pointwise_constraint",
      "bias_constraint",
      "kwargs"
    ],
    "type": "class"
  },
  "SeparableConvolution1D": {
    "description": "1D separable convolution layer.\n\nThis layer performs a depthwise convolution that acts separately on\nchannels, followed by a pointwise convolution that mixes channels.\nIf `use_bias` is True and a bias initializer is provided,\nit adds a bias vector to the output. It then optionally applies an\nactivation function to produce the final output.\n\nArgs:\n    filters: int, the dimensionality of the output space (i.e. the number\n        of filters in the pointwise convolution).\n    kernel_size: int or tuple/list of 1 integers, specifying the size of the\n        depthwise convolution window.\n    strides: int or tuple/list of 1 integers, specifying the stride length\n        of the depthwise convolution. If only one int is specified, the same\n        stride size will be used for all dimensions. `strides > 1` is\n        incompatible with `dilation_rate > 1`.\n    padding: string, either `\"valid\"` or `\"same\"` (case-insensitive).\n        `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n        the left/right or up/down of the input. When `padding=\"same\"` and\n        `strides=1`, the output has the same size as the input.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, steps, features)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, features, steps)`. It defaults to the `image_data_format`\n        value found in your Keras config file at `~/.keras/keras.json`.\n        If you never set it, then it will be `\"channels_last\"`.\n    dilation_rate: int or tuple/list of 1 integers, specifying the dilation\n        rate to use for dilated convolution. If only one int is specified,\n        the same dilation rate will be used for all dimensions.\n    depth_multiplier: The number of depthwise convolution output channels\n        for each input channel. The total number of depthwise convolution\n        output channels will be equal to `input_channel * depth_multiplier`.\n    activation: Activation function. If `None`, no activation is applied.\n    use_bias: bool, if `True`, bias will be added to the output.\n    depthwise_initializer: An initializer for the depthwise convolution\n        kernel. If None, then the default initializer (`\"glorot_uniform\"`)\n        will be used.\n    pointwise_initializer: An initializer for the pointwise convolution\n        kernel. If None, then the default initializer (`\"glorot_uniform\"`)\n        will be used.\n    bias_initializer: An initializer for the bias vector. If None, the\n        default initializer ('\"zeros\"') will be used.\n    depthwise_regularizer: Optional regularizer for the depthwise\n        convolution kernel.\n    pointwise_regularizer: Optional regularizer for the pointwise\n        convolution kernel.\n    bias_regularizer: Optional regularizer for the bias vector.\n    activity_regularizer: Optional regularizer function for the output.\n    depthwise_constraint: Optional projection function to be applied to the\n        depthwise kernel after being updated by an `Optimizer` (e.g. used\n        for norm constraints or value constraints for layer weights). The\n        function must take as input the unprojected variable and must return\n        the projected variable (which must have the same shape).\n    pointwise_constraint: Optional projection function to be applied to the\n        pointwise kernel after being updated by an `Optimizer`.\n    bias_constraint: Optional projection function to be applied to the\n        bias after being updated by an `Optimizer`.\n\nInput shape:\n\n- If `data_format=\"channels_last\"`:\n    A 3D tensor with shape: `(batch_shape, steps, channels)`\n- If `data_format=\"channels_first\"`:\n    A 3D tensor with shape: `(batch_shape, channels, steps)`\n\nOutput shape:\n\n- If `data_format=\"channels_last\"`:\n    A 3D tensor with shape: `(batch_shape, new_steps, filters)`\n- If `data_format=\"channels_first\"`:\n    A 3D tensor with shape: `(batch_shape, filters, new_steps)`\n\nReturns:\n    A 3D tensor representing\n    `activation(separable_conv1d(inputs, kernel) + bias)`.\n\nExample:\n\n>>> x = np.random.rand(4, 10, 12)\n>>> y = keras.layers.SeparableConv1D(3, 4, 3, 2, activation='relu')(x)\n>>> print(y.shape)\n(4, 4, 4)",
    "std_args": [
      "filters",
      "kernel_size",
      "strides",
      "padding",
      "data_format",
      "dilation_rate",
      "depth_multiplier",
      "activation",
      "use_bias",
      "depthwise_initializer",
      "pointwise_initializer",
      "bias_initializer",
      "depthwise_regularizer",
      "pointwise_regularizer",
      "bias_regularizer",
      "activity_regularizer",
      "depthwise_constraint",
      "pointwise_constraint",
      "bias_constraint",
      "kwargs"
    ],
    "type": "class"
  },
  "SeparableConvolution2D": {
    "description": "2D separable convolution layer.\n\nThis layer performs a depthwise convolution that acts separately on\nchannels, followed by a pointwise convolution that mixes channels.\nIf `use_bias` is True and a bias initializer is provided,\nit adds a bias vector to the output. It then optionally applies an\nactivation function to produce the final output.\n\nArgs:\n    filters: int, the dimensionality of the output space (i.e. the number\n        of filters in the pointwise convolution).\n    kernel_size: int or tuple/list of 2 integers, specifying the size of the\n        depthwise convolution window.\n    strides: int or tuple/list of 2 integers, specifying the stride length\n        of the depthwise convolution. If only one int is specified, the same\n        stride size will be used for all dimensions. `strides > 1` is\n        incompatible with `dilation_rate > 1`.\n    padding: string, either `\"valid\"` or `\"same\"` (case-insensitive).\n        `\"valid\"` means no padding. `\"same\"` results in padding evenly to\n        the left/right or up/down of the input. When `padding=\"same\"` and\n        `strides=1`, the output has the same size as the input.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs. `\"channels_last\"`\n        corresponds to inputs with shape `(batch, height, width, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch, channels, height, width)`. It defaults to the\n        `image_data_format` value found in your Keras config file\n        at `~/.keras/keras.json`.\n        If you never set it, then it will be `\"channels_last\"`.\n    dilation_rate: int or tuple/list of 2 integers, specifying the dilation\n        rate to use for dilated convolution. If only one int is specified,\n        the same dilation rate will be used for all dimensions.\n    depth_multiplier: The number of depthwise convolution output channels\n        for each input channel. The total number of depthwise convolution\n        output channels will be equal to `input_channel * depth_multiplier`.\n    activation: Activation function. If `None`, no activation is applied.\n    use_bias: bool, if `True`, bias will be added to the output.\n    depthwise_initializer: An initializer for the depthwise convolution\n        kernel. If None, then the default initializer (`\"glorot_uniform\"`)\n        will be used.\n    pointwise_initializer: An initializer for the pointwise convolution\n        kernel. If None, then the default initializer (`\"glorot_uniform\"`)\n        will be used.\n    bias_initializer: An initializer for the bias vector. If None, the\n        default initializer ('\"zeros\"') will be used.\n    depthwise_regularizer: Optional regularizer for the depthwise\n        convolution kernel.\n    pointwise_regularizer: Optional regularizer for the pointwise\n        convolution kernel.\n    bias_regularizer: Optional regularizer for the bias vector.\n    activity_regularizer: Optional regularizer function for the output.\n    depthwise_constraint: Optional projection function to be applied to the\n        depthwise kernel after being updated by an `Optimizer` (e.g. used\n        for norm constraints or value constraints for layer weights). The\n        function must take as input the unprojected variable and must return\n        the projected variable (which must have the same shape).\n    pointwise_constraint: Optional projection function to be applied to the\n        pointwise kernel after being updated by an `Optimizer`.\n    bias_constraint: Optional projection function to be applied to the\n        bias after being updated by an `Optimizer`.\n\nInput shape:\n\n- If `data_format=\"channels_last\"`:\n    A 4D tensor with shape: `(batch_size, height, width, channels)`\n- If `data_format=\"channels_first\"`:\n    A 4D tensor with shape: `(batch_size, channels, height, width)`\n\nOutput shape:\n\n- If `data_format=\"channels_last\"`:\n    A 4D tensor with shape: `(batch_size, new_height, new_width, filters)`\n- If `data_format=\"channels_first\"`:\n    A 4D tensor with shape: `(batch_size, filters, new_height, new_width)`\n\nReturns:\n    A 4D tensor representing\n    `activation(separable_conv2d(inputs, kernel) + bias)`.\n\nExample:\n\n>>> x = np.random.rand(4, 10, 10, 12)\n>>> y = keras.layers.SeparableConv2D(3, 4, 3, 2, activation='relu')(x)\n>>> print(y.shape)\n(4, 4, 4, 4)",
    "std_args": [
      "filters",
      "kernel_size",
      "strides",
      "padding",
      "data_format",
      "dilation_rate",
      "depth_multiplier",
      "activation",
      "use_bias",
      "depthwise_initializer",
      "pointwise_initializer",
      "bias_initializer",
      "depthwise_regularizer",
      "pointwise_regularizer",
      "bias_regularizer",
      "activity_regularizer",
      "depthwise_constraint",
      "pointwise_constraint",
      "bias_constraint",
      "kwargs"
    ],
    "type": "class"
  },
  "SequenceReprMixin": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "SetValueFn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SetValueHook": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SetVariable": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "ShardMapFn": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "f",
      "in_specs",
      "out_specs",
      "kwarg_specs",
      "ctxtag"
    ],
    "type": "class"
  },
  "ShardedToAllLinear": {
    "description": "Each member of the group applies part of the affine transformation and",
    "std_args": [
      "self",
      "input_dims",
      "output_dims",
      "bias",
      "group"
    ],
    "type": "class"
  },
  "SharedNanFunctionsTestsMixin": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "ShortDType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ShouldSkipUpdateFunction": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SimpleCell": {
    "description": "Simple cell.",
    "std_args": [
      "self",
      "in_features",
      "hidden_features",
      "dtype",
      "param_dtype",
      "carry_init",
      "residual",
      "activation_fn",
      "kernel_init",
      "recurrent_kernel_init",
      "bias_init",
      "promote_dtype",
      "keep_rngs",
      "rngs",
      "kernel_metadata",
      "recurrent_kernel_metadata",
      "bias_metadata"
    ],
    "type": "class"
  },
  "SimpleObjectRepr": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "obj"
    ],
    "type": "class"
  },
  "SimpleRNN": {
    "description": "Fully-connected RNN where the output is to be fed back as the new input.\n\nArgs:\n    units: Positive integer, dimensionality of the output space.\n    activation: Activation function to use.\n        Default: hyperbolic tangent (`tanh`).\n        If you pass None, no activation is applied\n        (ie. \"linear\" activation: `a(x) = x`).\n    use_bias: Boolean, (default `True`), whether the layer uses\n        a bias vector.\n    kernel_initializer: Initializer for the `kernel` weights matrix,\n        used for the linear transformation of the inputs. Default:\n        `\"glorot_uniform\"`.\n    recurrent_initializer: Initializer for the `recurrent_kernel`\n        weights matrix, used for the linear transformation of the recurrent\n        state.  Default: `\"orthogonal\"`.\n    bias_initializer: Initializer for the bias vector. Default: `\"zeros\"`.\n    kernel_regularizer: Regularizer function applied to the `kernel` weights\n        matrix. Default: `None`.\n    recurrent_regularizer: Regularizer function applied to the\n        `recurrent_kernel` weights matrix. Default: `None`.\n    bias_regularizer: Regularizer function applied to the bias vector.\n        Default: `None`.\n    activity_regularizer: Regularizer function applied to the output of the\n        layer (its \"activation\"). Default: `None`.\n    kernel_constraint: Constraint function applied to the `kernel` weights\n        matrix. Default: `None`.\n    recurrent_constraint: Constraint function applied to the\n        `recurrent_kernel` weights matrix.  Default: `None`.\n    bias_constraint: Constraint function applied to the bias vector.\n        Default: `None`.\n    dropout: Float between 0 and 1.\n        Fraction of the units to drop for the linear transformation\n        of the inputs. Default: 0.\n    recurrent_dropout: Float between 0 and 1.\n        Fraction of the units to drop for the linear transformation of the\n        recurrent state. Default: 0.\n    return_sequences: Boolean. Whether to return the last output\n        in the output sequence, or the full sequence. Default: `False`.\n    return_state: Boolean. Whether to return the last state\n        in addition to the output. Default: `False`.\n    go_backwards: Boolean (default: `False`).\n        If `True`, process the input sequence backwards and return the\n        reversed sequence.\n    stateful: Boolean (default: `False`). If `True`, the last state\n        for each sample at index i in a batch will be used as the\n        initial state for the sample of index i in the following batch.\n    unroll: Boolean (default: `False`).\n        If `True`, the network will be unrolled,\n        else a symbolic loop will be used.\n        Unrolling can speed-up an RNN,\n        although it tends to be more memory-intensive.\n        Unrolling is only suitable for short sequences.\n\nCall arguments:\n    sequence: A 3D tensor, with shape `[batch, timesteps, feature]`.\n    mask: Binary tensor of shape `[batch, timesteps]` indicating whether\n        a given timestep should be masked. An individual `True` entry\n        indicates that the corresponding timestep should be utilized,\n        while a `False` entry indicates that the corresponding timestep\n        should be ignored.\n    training: Python boolean indicating whether the layer should behave in\n        training mode or in inference mode.\n        This argument is passed to the cell when calling it.\n        This is only relevant if `dropout` or `recurrent_dropout` is used.\n    initial_state: List of initial state tensors to be passed to the first\n        call of the cell.\n\nExample:\n\n```python\ninputs = np.random.random((32, 10, 8))\nsimple_rnn = keras.layers.SimpleRNN(4)\noutput = simple_rnn(inputs)  # The output has shape `(32, 4)`.\nsimple_rnn = keras.layers.SimpleRNN(\n    4, return_sequences=True, return_state=True\n)\n# whole_sequence_output has shape `(32, 10, 4)`.\n# final_state has shape `(32, 4)`.\nwhole_sequence_output, final_state = simple_rnn(inputs)\n```",
    "std_args": [
      "units",
      "activation",
      "use_bias",
      "kernel_initializer",
      "recurrent_initializer",
      "bias_initializer",
      "kernel_regularizer",
      "recurrent_regularizer",
      "bias_regularizer",
      "activity_regularizer",
      "kernel_constraint",
      "recurrent_constraint",
      "bias_constraint",
      "dropout",
      "recurrent_dropout",
      "return_sequences",
      "return_state",
      "go_backwards",
      "stateful",
      "unroll",
      "seed",
      "kwargs"
    ],
    "type": "class"
  },
  "SimpleRNNCell": {
    "description": "Cell class for SimpleRNN.\n\nThis class processes one step within the whole time sequence input, whereas\n`keras.layer.SimpleRNN` processes the whole sequence.\n\nArgs:\n    units: Positive integer, dimensionality of the output space.\n    activation: Activation function to use.\n        Default: hyperbolic tangent (`tanh`).\n        If you pass `None`, no activation is applied\n        (ie. \"linear\" activation: `a(x) = x`).\n    use_bias: Boolean, (default `True`), whether the layer\n        should use a bias vector.\n    kernel_initializer: Initializer for the `kernel` weights matrix,\n        used for the linear transformation of the inputs. Default:\n        `\"glorot_uniform\"`.\n    recurrent_initializer: Initializer for the `recurrent_kernel`\n        weights matrix, used for the linear transformation\n        of the recurrent state. Default: `\"orthogonal\"`.\n    bias_initializer: Initializer for the bias vector. Default: `\"zeros\"`.\n    kernel_regularizer: Regularizer function applied to the `kernel` weights\n        matrix. Default: `None`.\n    recurrent_regularizer: Regularizer function applied to the\n        `recurrent_kernel` weights matrix. Default: `None`.\n    bias_regularizer: Regularizer function applied to the bias vector.\n        Default: `None`.\n    kernel_constraint: Constraint function applied to the `kernel` weights\n        matrix. Default: `None`.\n    recurrent_constraint: Constraint function applied to the\n        `recurrent_kernel` weights matrix. Default: `None`.\n    bias_constraint: Constraint function applied to the bias vector.\n        Default: `None`.\n    dropout: Float between 0 and 1. Fraction of the units to drop for the\n        linear transformation of the inputs. Default: 0.\n    recurrent_dropout: Float between 0 and 1. Fraction of the units to drop\n        for the linear transformation of the recurrent state. Default: 0.\n    seed: Random seed for dropout.\n\nCall arguments:\n    sequence: A 2D tensor, with shape `(batch, features)`.\n    states: A 2D tensor with shape `(batch, units)`, which is the state\n        from the previous time step.\n    training: Python boolean indicating whether the layer should behave in\n        training mode or in inference mode. Only relevant when `dropout` or\n        `recurrent_dropout` is used.\n\nExample:\n\n```python\ninputs = np.random.random([32, 10, 8]).astype(np.float32)\nrnn = keras.layers.RNN(keras.layers.SimpleRNNCell(4))\noutput = rnn(inputs)  # The output has shape `(32, 4)`.\nrnn = keras.layers.RNN(\n    keras.layers.SimpleRNNCell(4),\n    return_sequences=True,\n    return_state=True\n)\n# whole_sequence_output has shape `(32, 10, 4)`.\n# final_state has shape `(32, 4)`.\nwhole_sequence_output, final_state = rnn(inputs)\n```",
    "std_args": [
      "units",
      "activation",
      "use_bias",
      "kernel_initializer",
      "recurrent_initializer",
      "bias_initializer",
      "kernel_regularizer",
      "recurrent_regularizer",
      "bias_regularizer",
      "kernel_constraint",
      "recurrent_constraint",
      "bias_constraint",
      "dropout",
      "recurrent_dropout",
      "seed",
      "kwargs"
    ],
    "type": "class"
  },
  "SimpleSubClass": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "SimplifiedMesonBackend": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "SinusoidalPositionalEncoding": {
    "description": "Implements sinusoidal positional encoding.",
    "std_args": [
      "self",
      "dims",
      "min_freq",
      "max_freq",
      "scale",
      "cos_first",
      "full_turns"
    ],
    "type": "class"
  },
  "SizeBytes": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "size",
      "bytes"
    ],
    "type": "class"
  },
  "SmoothL1Loss": {
    "description": "Creates a criterion that uses a squared term if the absolute",
    "std_args": [
      "self",
      "size_average",
      "reduce",
      "reduction",
      "beta"
    ],
    "type": "class"
  },
  "SnapshotState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SoftMarginLoss": {
    "description": "Creates a criterion that optimizes a two-class classification",
    "std_args": [
      "self",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "Softmax2d": {
    "description": "Applies SoftMax over features to each spatial location.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "Softshrink": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "class"
  },
  "Solarization": {
    "description": "Applies `(max_value - pixel + min_value)` for each pixel in the image.\n\nWhen created without `threshold` parameter, the layer performs solarization\nto all values. When created with specified `threshold` the layer only\naugments pixels that are above the `threshold` value.\n\n**Note:** This layer is safe to use inside a `tf.data` or `grain` pipeline\n(independently of which backend you're using).\n\nArgs:\n    addition_factor: (Optional)  A tuple of two floats or a single float,\n        between 0 and 1.\n        For each augmented image a value is\n        sampled from the provided range. If a float is passed, the range is\n        interpreted as `(0, addition_factor)`. If specified, this value\n        (times the value range of input images, e.g. 255), is\n        added to each pixel before solarization and thresholding.\n        Defaults to 0.0.\n    threshold_factor: (Optional)  A tuple of two floats or a single float.\n        For each augmented image a value is\n        sampled from the provided range. If a float is passed, the range is\n        interpreted as `(0, threshold_factor)`. If specified, only pixel\n        values above this threshold will be solarized.\n    value_range: a tuple or a list of two elements. The first value\n        represents the lower bound for values in input images, the second\n        represents the upper bound. Images passed to the layer should have\n        values within `value_range`. Typical values to pass\n        are `(0, 255)` (RGB image) or `(0., 1.)` (scaled image).\n    seed: Integer. Used to create a random seed.\n    **kwargs: Base layer keyword arguments, such as `name` and `dtype`.\n\nExample:\n\n```python\n(images, labels), _ = keras.datasets.cifar10.load_data()\nprint(images[0, 0, 0])\n# [59 62 63]\n# Note that images are Tensor with values in the range [0, 255]\nsolarization = Solarization(value_range=(0, 255))\nimages = solarization(images)\nprint(images[0, 0, 0])\n# [196, 193, 192]\n```",
    "std_args": [
      "addition_factor",
      "threshold_factor",
      "value_range",
      "seed",
      "kwargs"
    ],
    "type": "class"
  },
  "SolveCases": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Sparsemax": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "labels",
      "logits"
    ],
    "type": "function"
  },
  "SpatialDropout1D": {
    "description": "Spatial 1D version of Dropout.\n\nThis layer performs the same function as Dropout, however, it drops\nentire 1D feature maps instead of individual elements. If adjacent frames\nwithin feature maps are strongly correlated (as is normally the case in\nearly convolution layers) then regular dropout will not regularize the\nactivations and will otherwise just result in an effective learning rate\ndecrease. In this case, `SpatialDropout1D` will help promote independence\nbetween feature maps and should be used instead.\n\nArgs:\n    rate: Float between 0 and 1. Fraction of the input units to drop.\n\nCall arguments:\n    inputs: A 3D tensor.\n    training: Python boolean indicating whether the layer\n        should behave in training mode (applying dropout)\n        or in inference mode (pass-through).\n\nInput shape:\n    3D tensor with shape: `(samples, timesteps, channels)`\n\nOutput shape: Same as input.\n\nReference:\n\n- [Tompson et al., 2014](https://arxiv.org/abs/1411.4280)",
    "std_args": [
      "rate",
      "seed",
      "name",
      "dtype"
    ],
    "type": "class"
  },
  "SpatialDropout2D": {
    "description": "Spatial 2D version of Dropout.\n\nThis version performs the same function as Dropout, however, it drops\nentire 2D feature maps instead of individual elements. If adjacent pixels\nwithin feature maps are strongly correlated (as is normally the case in\nearly convolution layers) then regular dropout will not regularize the\nactivations and will otherwise just result in an effective learning rate\ndecrease. In this case, `SpatialDropout2D` will help promote independence\nbetween feature maps and should be used instead.\n\nArgs:\n    rate: Float between 0 and 1. Fraction of the input units to drop.\n    data_format: `\"channels_first\"` or `\"channels_last\"`.\n        In `\"channels_first\"` mode, the channels dimension (the depth)\n        is at index 1, in `\"channels_last\"` mode is it at index 3.\n        It defaults to the `image_data_format` value found in your\n        Keras config file at `~/.keras/keras.json`.\n        If you never set it, then it will be `\"channels_last\"`.\n\nCall arguments:\n    inputs: A 4D tensor.\n    training: Python boolean indicating whether the layer\n        should behave in training mode (applying dropout)\n        or in inference mode (pass-through).\n\nInput shape:\n    4D tensor with shape: `(samples, channels, rows, cols)` if\n        data_format='channels_first'\n    or 4D tensor with shape: `(samples, rows, cols, channels)` if\n        data_format='channels_last'.\n\nOutput shape: Same as input.\n\nReference:\n\n- [Tompson et al., 2014](https://arxiv.org/abs/1411.4280)",
    "std_args": [
      "rate",
      "data_format",
      "seed",
      "name",
      "dtype"
    ],
    "type": "class"
  },
  "SpatialDropout3D": {
    "description": "Spatial 3D version of Dropout.\n\nThis version performs the same function as Dropout, however, it drops\nentire 3D feature maps instead of individual elements. If adjacent voxels\nwithin feature maps are strongly correlated (as is normally the case in\nearly convolution layers) then regular dropout will not regularize the\nactivations and will otherwise just result in an effective learning rate\ndecrease. In this case, SpatialDropout3D will help promote independence\nbetween feature maps and should be used instead.\n\nArgs:\n    rate: Float between 0 and 1. Fraction of the input units to drop.\n    data_format: `\"channels_first\"` or `\"channels_last\"`.\n        In `\"channels_first\"` mode, the channels dimension (the depth)\n        is at index 1, in `\"channels_last\"` mode is it at index 4.\n        It defaults to the `image_data_format` value found in your\n        Keras config file at `~/.keras/keras.json`.\n        If you never set it, then it will be `\"channels_last\"`.\n\nCall arguments:\n    inputs: A 5D tensor.\n    training: Python boolean indicating whether the layer\n            should behave in training mode (applying dropout)\n            or in inference mode (pass-through).\n\nInput shape:\n    5D tensor with shape: `(samples, channels, dim1, dim2, dim3)` if\n        data_format='channels_first'\n    or 5D tensor with shape: `(samples, dim1, dim2, dim3, channels)` if\n        data_format='channels_last'.\n\nOutput shape: Same as input.\n\nReference:\n\n- [Tompson et al., 2014](https://arxiv.org/abs/1411.4280)",
    "std_args": [
      "rate",
      "data_format",
      "seed",
      "name",
      "dtype"
    ],
    "type": "class"
  },
  "Specs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "SpectralNorm": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "name",
      "n_power_iterations",
      "dim",
      "eps"
    ],
    "type": "class"
  },
  "SpectralNormLoadStateDictPreHook": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "fn"
    ],
    "type": "class"
  },
  "SpectralNormStateDictHook": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "fn"
    ],
    "type": "class"
  },
  "SpectralNormalization": {
    "description": "Performs spectral normalization on the weights of a target layer.\n\nThis wrapper controls the Lipschitz constant of the weights of a layer by\nconstraining their spectral norm, which can stabilize the training of GANs.\n\nArgs:\n    layer: A `keras.layers.Layer` instance that\n        has either a `kernel` (e.g. `Conv2D`, `Dense`...)\n        or an `embeddings` attribute (`Embedding` layer).\n    power_iterations: int, the number of iterations during normalization.\n    **kwargs: Base wrapper keyword arguments.\n\nExamples:\n\nWrap `keras.layers.Conv2D`:\n>>> x = np.random.rand(1, 10, 10, 1)\n>>> conv2d = SpectralNormalization(keras.layers.Conv2D(2, 2))\n>>> y = conv2d(x)\n>>> y.shape\n(1, 9, 9, 2)\n\nWrap `keras.layers.Dense`:\n>>> x = np.random.rand(1, 10, 10, 1)\n>>> dense = SpectralNormalization(keras.layers.Dense(10))\n>>> y = dense(x)\n>>> y.shape\n(1, 10, 10, 10)\n\nReference:\n\n- [Spectral Normalization for GAN](https://arxiv.org/abs/1802.05957).",
    "std_args": [
      "layer",
      "power_iterations",
      "kwargs"
    ],
    "type": "class"
  },
  "SplitBackups": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "SplitContext": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "ctxtag",
      "ref_index",
      "is_inner"
    ],
    "type": "class"
  },
  "SplitPattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "StackedRNNCells": {
    "description": "Wrapper allowing a stack of RNN cells to behave as a single cell.\n\nUsed to implement efficient stacked RNNs.\n\nArgs:\n  cells: List of RNN cell instances.\n\nExample:\n\n```python\nbatch_size = 3\nsentence_length = 5\nnum_features = 2\nnew_shape = (batch_size, sentence_length, num_features)\nx = np.reshape(np.arange(30), new_shape)\n\nrnn_cells = [keras.layers.LSTMCell(128) for _ in range(2)]\nstacked_lstm = keras.layers.StackedRNNCells(rnn_cells)\nlstm_layer = keras.layers.RNN(stacked_lstm)\n\nresult = lstm_layer(x)\n```",
    "std_args": [
      "cells",
      "kwargs"
    ],
    "type": "class"
  },
  "Stage": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "State": {
    "description": "A pytree-like ``Mapping`` with hashable and comparable keys.",
    "std_args": [
      "self",
      "mapping",
      "_copy"
    ],
    "type": "class"
  },
  "StateAxes": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "filter_axes"
    ],
    "type": "class"
  },
  "StateMapping": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "StateSharding": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "filter_sharding"
    ],
    "type": "class"
  },
  "Static": {
    "description": "An empty pytree node that treats its inner value as static.",
    "std_args": [
      "self",
      "value"
    ],
    "type": "class"
  },
  "StaticAnnotation": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "StaticCache": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Statistics": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "StepLR": {
    "description": "Decays the learning rate of each parameter group by gamma every step_size epochs.",
    "std_args": [
      "optimizer",
      "step_size",
      "gamma"
    ]
  },
  "StrDType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "StrInt": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Stream": {
    "description": "A stream for running operations on a given device.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "StreamBackup": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "StreamContext": {
    "description": "A context manager for setting the current device and stream.",
    "std_args": [],
    "type": "class"
  },
  "StringDType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "StringLookup": {
    "description": "A preprocessing layer that maps strings to (possibly encoded) indices.\n\nThis layer translates a set of arbitrary strings into integer output via a\ntable-based vocabulary lookup. This layer will perform no splitting or\ntransformation of input strings. For a layer that can split and tokenize\nnatural language, see the `keras.layers.TextVectorization` layer.\n\nThe vocabulary for the layer must be either supplied on construction or\nlearned via `adapt()`. During `adapt()`, the layer will analyze a data set,\ndetermine the frequency of individual strings tokens, and create a\nvocabulary from them. If the vocabulary is capped in size, the most frequent\ntokens will be used to create the vocabulary and all others will be treated\nas out-of-vocabulary (OOV).\n\nThere are two possible output modes for the layer. When `output_mode` is\n`\"int\"`, input strings are converted to their index in the vocabulary (an\ninteger).\nWhen `output_mode` is `\"multi_hot\"`, `\"count\"`, or `\"tf_idf\"`, input strings\nare encoded into an array where each dimension corresponds to an element in\nthe vocabulary.\n\nThe vocabulary can optionally contain a mask token as well as an OOV token\n(which can optionally occupy multiple indices in the vocabulary, as set\nby `num_oov_indices`).\nThe position of these tokens in the vocabulary is fixed. When `output_mode`\nis `\"int\"`, the vocabulary will begin with the mask token (if set), followed\nby OOV indices, followed by the rest of the vocabulary. When `output_mode`\nis `\"multi_hot\"`, `\"count\"`, or `\"tf_idf\"` the vocabulary will begin with\nOOV indices and instances of the mask token will be dropped.\n\n**Note:** This layer uses TensorFlow internally. It cannot\nbe used as part of the compiled computation graph of a model with\nany backend other than TensorFlow.\nIt can however be used with any backend when running eagerly.\nIt can also always be used as part of an input preprocessing pipeline\nwith any backend (outside the model itself), which is how we recommend\nusing this layer.\n\n**Note:** This layer is safe to use inside a `tf.data` pipeline\n(independently of which backend you're using).\n\nArgs:\n    max_tokens: Maximum size of the vocabulary for this layer. This should\n        only be specified when adapting the vocabulary or when setting\n        `pad_to_max_tokens=True`. If None, there is no cap on the size of\n        the vocabulary. Note that this size includes the OOV\n        and mask tokens. Defaults to `None`.\n    num_oov_indices: The number of out-of-vocabulary tokens to use.\n        If this value is more than 1, OOV inputs are modulated to\n        determine their OOV value.\n        If this value is 0, OOV inputs will cause an error when calling\n        the layer. Defaults to `1`.\n    mask_token: A token that represents masked inputs. When `output_mode` is\n        `\"int\"`, the token is included in the vocabulary and mapped to index\n        0.\n        In other output modes, the token will not appear in the vocabulary\n        and instances of the mask token in the input will be dropped.\n        If set to `None`, no mask term will be added. Defaults to `None`.\n    oov_token: Only used when `invert` is True. The token to return for OOV\n        indices. Defaults to `\"[UNK]\"`.\n    vocabulary: Optional. Either an array of strings or a string path to a\n        text file. If passing an array, you can pass a tuple, list, 1D NumPy\n        array, or 1D tensor containing the string vocabulary terms.\n        If passing a file path, the file should contain one line per term in\n        the vocabulary. If this argument is set, there is no need to\n        `adapt()` the layer.\n    idf_weights: Only valid when `output_mode` is `\"tf_idf\"`.\n        A tuple, list, 1D NumPy array, or 1D tensor or the same length\n        as the vocabulary, containing the floating point inverse document\n        frequency weights, which will be multiplied by per sample term\n        counts for the final TF-IDF weight.\n        If the `vocabulary` argument is set and `output_mode` is `\"tf_idf\"`,\n        this argument must be supplied.\n    invert: Only valid when `output_mode` is `\"int\"`.\n        If `True`, this layer will map indices to vocabulary items\n        instead of mapping vocabulary items to indices.\n        Defaults to `False`.\n    output_mode: Specification for the output of the layer. Values can be\n        `\"int\"`, `\"one_hot\"`, `\"multi_hot\"`, `\"count\"`, or `\"tf_idf\"`\n        configuring the layer as follows:\n        - `\"int\"`: Return the vocabulary indices of the input tokens.\n        - `\"one_hot\"`: Encodes each individual element in the input into an\n            array the same size as the vocabulary,\n            containing a 1 at the element index. If the last dimension\n            is size 1, will encode on that dimension.\n            If the last dimension is not size 1, will append a new\n            dimension for the encoded output.\n        - `\"multi_hot\"`: Encodes each sample in the input into a single\n            array the same size as the vocabulary containing a 1 for each\n            vocabulary term present in the sample.\n            Treats the last dimension as the sample dimension, if the input\n            shape is `(..., sample_length)`, the output shape will be\n            `(..., num_tokens)`.\n        - `\"count\"`: As `\"multi_hot\"`, but the int array contains\n            a count of the number of times the token at that index\n            appeared in the sample.\n        - `\"tf_idf\"`: As `\"multi_hot\"`, but the TF-IDF algorithm is\n            applied to find the value in each token slot.\n        For `\"int\"` output, any shape of input and output is supported.\n        For all other output modes, currently only output up to rank 2\n        is supported. Defaults to `\"int\"`.\n    pad_to_max_tokens: Only applicable when `output_mode` is `\"multi_hot\"`,\n        `\"count\"`, or `\"tf_idf\"`. If `True`, the output will have\n        its feature axis padded to `max_tokens` even if the number\n        of unique tokens in the vocabulary is less than `max_tokens`,\n        resulting in a tensor of shape `(batch_size, max_tokens)`\n        regardless of vocabulary size. Defaults to `False`.\n    sparse: Boolean. Only applicable to `\"multi_hot\"`, `\"count\"`, and\n        `\"tf_idf\"` output modes. Only supported with TensorFlow\n        backend. If `True`, returns a `SparseTensor`\n        instead of a dense `Tensor`. Defaults to `False`.\n    encoding: Optional. The text encoding to use to interpret the input\n        strings. Defaults to `\"utf-8\"`.\n\nExamples:\n\n**Creating a lookup layer with a known vocabulary**\n\nThis example creates a lookup layer with a pre-existing vocabulary.\n\n>>> vocab = [\"a\", \"b\", \"c\", \"d\"]\n>>> data = [[\"a\", \"c\", \"d\"], [\"d\", \"z\", \"b\"]]\n>>> layer = StringLookup(vocabulary=vocab)\n>>> layer(data)\narray([[1, 3, 4],\n       [4, 0, 2]])\n\n**Creating a lookup layer with an adapted vocabulary**\n\nThis example creates a lookup layer and generates the vocabulary by\nanalyzing the dataset.\n\n>>> data = [[\"a\", \"c\", \"d\"], [\"d\", \"z\", \"b\"]]\n>>> layer = StringLookup()\n>>> layer.adapt(data)\n>>> layer.get_vocabulary()\n['[UNK]', 'd', 'z', 'c', 'b', 'a']\n\nNote that the OOV token `\"[UNK]\"` has been added to the vocabulary.\nThe remaining tokens are sorted by frequency\n(`\"d\"`, which has 2 occurrences, is first) then by inverse sort order.\n\n>>> data = [[\"a\", \"c\", \"d\"], [\"d\", \"z\", \"b\"]]\n>>> layer = StringLookup()\n>>> layer.adapt(data)\n>>> layer(data)\narray([[5, 3, 1],\n       [1, 2, 4]])\n\n**Lookups with multiple OOV indices**\n\nThis example demonstrates how to use a lookup layer with multiple OOV\nindices.  When a layer is created with more than one OOV index, any OOV\nvalues are hashed into the number of OOV buckets, distributing OOV values in\na deterministic fashion across the set.\n\n>>> vocab = [\"a\", \"b\", \"c\", \"d\"]\n>>> data = [[\"a\", \"c\", \"d\"], [\"m\", \"z\", \"b\"]]\n>>> layer = StringLookup(vocabulary=vocab, num_oov_indices=2)\n>>> layer(data)\narray([[2, 4, 5],\n       [0, 1, 3]])\n\nNote that the output for OOV value 'm' is 0, while the output for OOV value\n`\"z\"` is 1. The in-vocab terms have their output index increased by 1 from\nearlier examples (a maps to 2, etc) in order to make space for the extra OOV\nvalue.\n\n**One-hot output**\n\nConfigure the layer with `output_mode='one_hot'`. Note that the first\n`num_oov_indices` dimensions in the ont_hot encoding represent OOV values.\n\n>>> vocab = [\"a\", \"b\", \"c\", \"d\"]\n>>> data = [\"a\", \"b\", \"c\", \"d\", \"z\"]\n>>> layer = StringLookup(vocabulary=vocab, output_mode='one_hot')\n>>> layer(data)\narray([[0., 1., 0., 0., 0.],\n       [0., 0., 1., 0., 0.],\n       [0., 0., 0., 1., 0.],\n       [0., 0., 0., 0., 1.],\n       [1., 0., 0., 0., 0.]], dtype=int64)\n\n**Multi-hot output**\n\nConfigure the layer with `output_mode='multi_hot'`. Note that the first\n`num_oov_indices` dimensions in the multi_hot encoding represent OOV values.\n\n>>> vocab = [\"a\", \"b\", \"c\", \"d\"]\n>>> data = [[\"a\", \"c\", \"d\", \"d\"], [\"d\", \"z\", \"b\", \"z\"]]\n>>> layer = StringLookup(vocabulary=vocab, output_mode='multi_hot')\n>>> layer(data)\narray([[0., 1., 0., 1., 1.],\n       [1., 0., 1., 0., 1.]], dtype=int64)\n\n**Token count output**\n\nConfigure the layer with `output_mode='count'`. As with multi_hot output,\nthe first `num_oov_indices` dimensions in the output represent OOV values.\n\n>>> vocab = [\"a\", \"b\", \"c\", \"d\"]\n>>> data = [[\"a\", \"c\", \"d\", \"d\"], [\"d\", \"z\", \"b\", \"z\"]]\n>>> layer = StringLookup(vocabulary=vocab, output_mode='count')\n>>> layer(data)\narray([[0., 1., 0., 1., 2.],\n       [2., 0., 1., 0., 1.]], dtype=int64)\n\n**TF-IDF output**\n\nConfigure the layer with `output_mode=\"tf_idf\"`. As with multi_hot output,\nthe first `num_oov_indices` dimensions in the output represent OOV values.\n\nEach token bin will output `token_count * idf_weight`, where the idf weights\nare the inverse document frequency weights per token. These should be\nprovided along with the vocabulary. Note that the `idf_weight` for OOV\nvalues will default to the average of all idf weights passed in.\n\n>>> vocab = [\"a\", \"b\", \"c\", \"d\"]\n>>> idf_weights = [0.25, 0.75, 0.6, 0.4]\n>>> data = [[\"a\", \"c\", \"d\", \"d\"], [\"d\", \"z\", \"b\", \"z\"]]\n>>> layer = StringLookup(output_mode=\"tf_idf\")\n>>> layer.set_vocabulary(vocab, idf_weights=idf_weights)\n>>> layer(data)\narray([[0.  , 0.25, 0.  , 0.6 , 0.8 ],\n       [1.0 , 0.  , 0.75, 0.  , 0.4 ]], dtype=float32)\n\nTo specify the idf weights for OOV values, you will need to pass the entire\nvocabulary including the leading OOV token.\n\n>>> vocab = [\"[UNK]\", \"a\", \"b\", \"c\", \"d\"]\n>>> idf_weights = [0.9, 0.25, 0.75, 0.6, 0.4]\n>>> data = [[\"a\", \"c\", \"d\", \"d\"], [\"d\", \"z\", \"b\", \"z\"]]\n>>> layer = StringLookup(output_mode=\"tf_idf\")\n>>> layer.set_vocabulary(vocab, idf_weights=idf_weights)\n>>> layer(data)\narray([[0.  , 0.25, 0.  , 0.6 , 0.8 ],\n       [1.8 , 0.  , 0.75, 0.  , 0.4 ]], dtype=float32)\n\nWhen adapting the layer in `\"tf_idf\"` mode, each input sample will be\nconsidered a document, and IDF weight per token will be calculated as\n`log(1 + num_documents / (1 + token_document_count))`.\n\n**Inverse lookup**\n\nThis example demonstrates how to map indices to strings using this layer.\n(You can also use `adapt()` with `inverse=True`, but for simplicity we'll\npass the vocab in this example.)\n\n>>> vocab = [\"a\", \"b\", \"c\", \"d\"]\n>>> data = [[1, 3, 4], [4, 0, 2]]\n>>> layer = StringLookup(vocabulary=vocab, invert=True)\n>>> layer(data)\narray([[b'a', b'c', b'd'],\n       [b'd', b'[UNK]', b'b']], dtype=object)\n\nNote that the first index corresponds to the OOV token by default.\n\n\n**Forward and inverse lookup pairs**\n\nThis example demonstrates how to use the vocabulary of a standard lookup\nlayer to create an inverse lookup layer.\n\n>>> vocab = [\"a\", \"b\", \"c\", \"d\"]\n>>> data = [[\"a\", \"c\", \"d\"], [\"d\", \"z\", \"b\"]]\n>>> layer = StringLookup(vocabulary=vocab)\n>>> i_layer = StringLookup(vocabulary=vocab, invert=True)\n>>> int_data = layer(data)\n>>> i_layer(int_data)\narray([[b'a', b'c', b'd'],\n       [b'd', b'[UNK]', b'b']], dtype=object)\n\nIn this example, the input value `\"z\"` resulted in an output of `\"[UNK]\"`,\nsince 1000 was not in the vocabulary - it got represented as an OOV, and all\nOOV values are returned as `\"[UNK]\"` in the inverse layer. Also, note that\nfor the inverse to work, you must have already set the forward layer\nvocabulary either directly or via `adapt()` before calling\n`get_vocabulary()`.",
    "std_args": [
      "max_tokens",
      "num_oov_indices",
      "mask_token",
      "oov_token",
      "vocabulary",
      "idf_weights",
      "invert",
      "output_mode",
      "pad_to_max_tokens",
      "sparse",
      "encoding",
      "name",
      "kwargs"
    ],
    "type": "class"
  },
  "SubArray": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "SubMaskedArray": {
    "description": "Pure subclass of MaskedArray, keeping some info on subclass.",
    "std_args": [],
    "type": "class"
  },
  "SyncBatchNorm": {
    "description": "Applies Batch Normalization over a N-Dimensional input.",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "process_group",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "Synchronize": {
    "description": "Execution Barrier.",
    "std_args": [],
    "type": "function"
  },
  "T": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "T0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "T1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "T2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "T3": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "T4": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "T5": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "T6": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "T7": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "T8": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "T9": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TERMS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TERNARY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TEST_CASES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TUPLE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TYPES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TYPE_CODES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "T_destination": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Tanhshrink": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "class"
  },
  "Tensor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "TestAbstractInterface": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestAlgebra": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestAll": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestAlmostEqual": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestAmax": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestAmin": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestAngle": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestAny": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestAppendFields": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestAppendFieldsObj": {
    "description": "Test append_fields with arrays containing objects",
    "std_args": [],
    "type": "class"
  },
  "TestApplyAlongAxis": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestApplyOverAxes": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestApproxEqual": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestArgsort": {
    "description": "gh-8701",
    "std_args": [],
    "type": "class"
  },
  "TestArithmetic": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestArrayAlmostEqual": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestArrayAlmostEqualNulp": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestArrayAssertLess": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestArrayEqual": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestArrayMethods": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestArraySetOps": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestArraySplit": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestAsArray": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestAsCtypesType": {
    "description": "Test conversion from dtypes to ctypes types",
    "std_args": [],
    "type": "class"
  },
  "TestAsPairs": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestAssertAllclose": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestAssertNoGcCycles": {
    "description": "Test assert_no_gc_cycles",
    "std_args": [],
    "type": "class"
  },
  "TestAssumedShapeSumExample": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestAverage": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestBCCharHandling": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestBinaryOperatorsDifferentSymbol": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestBinaryOperatorsSameSymbol": {
    "description": "Ensure symbol is preserved for numeric operations on polynomials with",
    "std_args": [],
    "type": "class"
  },
  "TestBincount": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestBinomial": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestBlockDocString": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestBroadcast": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestBuildErrorMessage": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestByteBounds": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestCBFortranCallstatement": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestCReaderUnitTests": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestCReturnReal": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestCallstatement": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestCasting": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestCharacter": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestCharacterString": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestCheckFinite": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestCholesky": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestClassWrapping": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestColumnStack": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestCommonBlock": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestCommonType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestCommonWithUse": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestCompanion": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestCompressFunctions": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestConcatenator": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestConcatenatorMatrix": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestCond": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestCondMatrix": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestConditionalShortcuts": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestConstant": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestConstants": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestCopy": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestCorrCoef": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestCorrcoef": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestCount": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestCov": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestCrackFortran": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestCtor": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestCumprod": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestCumsum": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestData": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestDataF77": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestDataMultiplierF77": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestDataSourceAbspath": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestDataSourceExists": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestDataSourceOpen": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestDataWithCommentsF77": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestDefaultRNG": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestDelete": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestDerivative": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestDet": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestDetMatrix": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestDiag": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestDiagIndicesFrom": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestDiff": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestDigitize": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestDimSpec": {
    "description": "This test suite tests various expressions that are used as dimension",
    "std_args": [],
    "type": "class"
  },
  "TestDocAdvanced": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestDocStringArguments": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestDomain": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestDot": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestDsplit": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestDstack": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestEdge": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestEig": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestEigMatrix": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestEigh": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestEighCases": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestEigvals": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestEigvalsMatrix": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestEigvalsh": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestEigvalshCases": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestEmpty": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestEmptyArray": {
    "description": "Check how padding behaves on arrays with an empty dimension.",
    "std_args": [],
    "type": "class"
  },
  "TestEqual": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestEquality": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestEval": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestEvaluation": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestExpandDims": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestExternal": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestExtins": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestExtraMethods": {
    "description": "Test other methods for manipulating/creating polynomial objects.",
    "std_args": [],
    "type": "class"
  },
  "TestEye": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestF2Cmap": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestF2cmapOption": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestF77Callback": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestF77CallbackPythonTLS": {
    "description": "Callback tests using Python thread-local storage instead of",
    "std_args": [],
    "type": "class"
  },
  "TestF77Comments": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestF77CommonBlockReader": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestF90Callback": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestF90Contiuation": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestFFT1D": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestFFTFreq": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestFFTShift": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestFFTThreadSafe": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestFReturnCharacter": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestFReturnComplex": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestFReturnInteger": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestFReturnLogical": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestFReturnReal": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestFillDiagonal": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestFillingValues": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestFilterwindows": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestFitting": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestFixedString": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestFlip": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestFliplr": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestFlipud": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestFormat": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestFortranGroupCounters": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestFortranReader": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestFraction": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestFromTxt": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestFunctionReturn": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestGH18335": {
    "description": "The reproduction of the reported issue requires specific input that",
    "std_args": [],
    "type": "class"
  },
  "TestGH25211": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestGauss": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestGeneric": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestGradient": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestGrid": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestHistogram": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestHistogram2d": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestHistogramOptimBinNums": {
    "description": "Provide test coverage when using provided estimators for optimal number of",
    "std_args": [],
    "type": "class"
  },
  "TestHistogramdd": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestHsplit": {
    "description": "Only testing for integer splits.",
    "std_args": [],
    "type": "class"
  },
  "TestIRFFTN": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestISOC": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestImag": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestIncludeFiles": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestIndexExpression": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestIndexing": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestInit": {
    "description": "Test polynomial creation with symbol kwarg.",
    "std_args": [],
    "type": "class"
  },
  "TestInsert": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestIntegers": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestIntegral": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestIntent": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestIntentInOut": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestInterp": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestInterpolate": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestInv": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestInvMatrix": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestIsFile": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestIscomplex": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestIscomplexobj": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestIsfinite": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestIsinf": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestIsnan": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestIsneginf": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestIsposinf": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestIsreal": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestIsrealobj": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestIsscalar": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestIx_": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestJoinBy": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestJoinBy2": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestKaiser": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestKind": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestKron": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestLatexRepr": {
    "description": "Test the latex repr used by Jupyter",
    "std_args": [],
    "type": "class"
  },
  "TestLeaks": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestLerp": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestLineSplitter": {
    "description": "Tests the LineSplitter class.",
    "std_args": [],
    "type": "class"
  },
  "TestLinearRamp": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestLinebreaking": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestLoadLibrary": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestLoadTxt": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestLowerF2PYDirective": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestLowerF2PYDirectives": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestLstsq": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestLstsqMatrix": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMRecords": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMRecordsImport": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMT19937": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMa": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMarkinnerspaces": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMaskedArray": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMaskedArrayArithmetic": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMaskedArrayAttributes": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMaskedArrayFunctions": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMaskedArrayInPlaceArithmetic": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMaskedArrayMathMethods": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMaskedArrayMathMethodsComplex": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMaskedArrayMethods": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMaskedConstant": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMaskedFields": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMaskedMatrix": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMaskedObjectArray": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMaskedView": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMaskedWhereAliases": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMatrixPower": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMatrixRank": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMatrixReturn": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMayShareMemory": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMedian": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMergeArrays": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMeshgrid": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMinimumMaximum": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMintypecode": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMisc": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMiscCharacter": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMiscFunctions": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMixed": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMultiDot": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMultiline": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMultinomial": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestMultivariateHypergeometric": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNDArrayOperatorsMixin": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNDEnumerate": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNameArgsPatternBacktracking": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNameValidator": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNanFunctions_ArgminArgmax": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNanFunctions_CumSumProd": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNanFunctions_MeanVarStd": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNanFunctions_Median": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNanFunctions_MinMax": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNanFunctions_NumberTypes": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNanFunctions_Percentile": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNanFunctions_Quantile": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNanFunctions_SumProd": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNanToNum": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNdenumerate": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNdpointer": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNdpointerCFunc": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNegativeBounds": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNewCharHandling": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNewScalarIndexing": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNoSpace": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNormDouble": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNormDoubleMatrix": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNormInt64": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNormInt64Matrix": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNormSingle": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNormSingleMatrix": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNorm_NonSystematic": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNotMasked": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNumPyConfigs": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNumpyConfig": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestNumpyVersionAttribute": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestOpenFunc": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestOptionalArgs": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestOuter": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestPCG64": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestPCG64DXSM": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestPadWidth": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestParamEval": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestParameters": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestPathUsage": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestPercentile": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestPhilox": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestPiecewise": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestPinv": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestPinvHermitian": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestPinvMatrix": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestPolynomial": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestPower": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestPrintOptions": {
    "description": "Test the output is properly configured via printoptions.",
    "std_args": [],
    "type": "class"
  },
  "TestPrivate": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestProd": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestProperties": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestPtp": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestPublicPrivate": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestPutAlongAxis": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestQR": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestQRMatrix": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestQuantile": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestQuotedCharacter": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestRFFTFreq": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestRandint": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestRandomDist": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestRavelUnravelIndex": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestReal": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestRealIfClose": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestRecFunctions": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestRecursiveFillFields": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestReflect": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestRegression": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestRenamedFunc": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestRenamedSubroutine": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestRepositoryAbspath": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestRepositoryExists": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestRepr": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestReturnCharacter": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestReturnComplex": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestReturnInteger": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestReturnLogical": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestReturnReal": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestRot90": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestRuntimeProtocol": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestSFC64": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestSVD": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestSVDHermitian": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestSVDMatrix": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestSaveLoad": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestSaveTxt": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestSavezLoad": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestSeed": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestSelect": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestSetOps": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestSetState": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestShape": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestShapeBase": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestSharedMemory": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestSignatureMatch": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestSinc": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestSingleEltArrayInput": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestSizeSumExample": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestSlidingWindowView": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestSolve": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestSolveMatrix": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestSortComplex": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestSplit": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestSqueeze": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestStack": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestStackArrays": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestStatistic": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestStrAscii": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestStrUnicodeSuperSubscripts": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestString": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestStringAssumedLength": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestStringConverter": {
    "description": "Test StringConverter",
    "std_args": [],
    "type": "class"
  },
  "TestStringEqual": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestStringOptionalInOut": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestStringScalarArr": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestSubclassing": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestSymbolic": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestSymmetric": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestTakeAlongAxis": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestTensorinv": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestTensorsolve": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestThread": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestTile": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestTrapezoid": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestTri": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestTrilIndicesFrom": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestTrimZeros": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestTriuIndices": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestTriuIndicesFrom": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestULP": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestUfunclike": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestUfuncs": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestUnaryOperators": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestUnicodeComment": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestUnique": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestUnwrap": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestValueAttr": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestVander": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestVectorize": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestView": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestVsplit": {
    "description": "Only testing for integer splits.",
    "std_args": [],
    "type": "class"
  },
  "TestWarns": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestWrap": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Test_I0": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Testfromregex": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TextIO": {
    "description": "Helper IO class.",
    "std_args": [
      "self",
      "s"
    ],
    "type": "class"
  },
  "TextVectorization": {
    "description": "A preprocessing layer which maps text features to integer sequences.\n\nThis layer has basic options for managing text in a Keras model. It\ntransforms a batch of strings (one example = one string) into either a list\nof token indices (one example = 1D tensor of integer token indices) or a\ndense representation (one example = 1D tensor of float values representing\ndata about the example's tokens). This layer is meant to handle natural\nlanguage inputs. To handle simple string inputs (categorical strings or\npre-tokenized strings) see `kers_core.layers.StringLookup`.\n\nThe vocabulary for the layer must be either supplied on construction or\nlearned via `adapt()`. When this layer is adapted, it will analyze the\ndataset, determine the frequency of individual string values, and create a\nvocabulary from them. This vocabulary can have unlimited size or be capped,\ndepending on the configuration options for this layer; if there are more\nunique values in the input than the maximum vocabulary size, the most\nfrequent terms will be used to create the vocabulary.\n\nThe processing of each example contains the following steps:\n\n1. Standardize each example (usually lowercasing + punctuation stripping)\n2. Split each example into substrings (usually words)\n3. Recombine substrings into tokens (usually ngrams)\n4. Index tokens (associate a unique int value with each token)\n5. Transform each example using this index, either into a vector of ints or\n   a dense float vector.\n\nSome notes on passing callables to customize splitting and normalization for\nthis layer:\n\n1. Any callable can be passed to this Layer, but if you want to serialize\n   this object you should only pass functions that are registered Keras\n   serializables (see `keras.saving.register_keras_serializable`\n   for more details).\n2. When using a custom callable for `standardize`, the data received\n   by the callable will be exactly as passed to this layer. The callable\n   should return a tensor of the same shape as the input.\n3. When using a custom callable for `split`, the data received by the\n   callable will have the 1st dimension squeezed out - instead of\n   `[[\"string to split\"], [\"another string to split\"]]`, the Callable will\n   see `[\"string to split\", \"another string to split\"]`.\n   The callable should return a `tf.Tensor` of dtype `string`\n   with the first dimension containing the split tokens -\n   in this example, we should see something like `[[\"string\", \"to\",\n   \"split\"], [\"another\", \"string\", \"to\", \"split\"]]`.\n\n**Note:** This layer uses TensorFlow internally. It cannot\nbe used as part of the compiled computation graph of a model with\nany backend other than TensorFlow.\nIt can however be used with any backend when running eagerly.\nIt can also always be used as part of an input preprocessing pipeline\nwith any backend (outside the model itself), which is how we recommend\nto use this layer.\n\n**Note:** This layer is safe to use inside a `tf.data` pipeline\n(independently of which backend you're using).\n\nArgs:\n    max_tokens: Maximum size of the vocabulary for this layer. This should\n        only be specified when adapting a vocabulary or when setting\n        `pad_to_max_tokens=True`. Note that this vocabulary\n        contains 1 OOV token, so the effective number of tokens is\n        `(max_tokens - 1 - (1 if output_mode == \"int\" else 0))`.\n    standardize: Optional specification for standardization to apply to the\n        input text. Values can be:\n        - `None`: No standardization.\n        - `\"lower_and_strip_punctuation\"`: Text will be lowercased and all\n            punctuation removed.\n        - `\"lower\"`: Text will be lowercased.\n        - `\"strip_punctuation\"`: All punctuation will be removed.\n        - Callable: Inputs will passed to the callable function,\n            which should be standardized and returned.\n    split: Optional specification for splitting the input text.\n        Values can be:\n        - `None`: No splitting.\n        - `\"whitespace\"`: Split on whitespace.\n        - `\"character\"`: Split on each unicode character.\n        - Callable: Standardized inputs will passed to the callable\n            function, which should be split and returned.\n    ngrams: Optional specification for ngrams to create from the\n        possibly-split input text. Values can be `None`, an integer\n        or tuple of integers; passing an integer will create ngrams\n        up to that integer, and passing a tuple of integers will\n        create ngrams for the specified values in the tuple.\n        Passing `None` means that no ngrams will be created.\n    output_mode: Optional specification for the output of the layer.\n        Values can be `\"int\"`, `\"multi_hot\"`, `\"count\"` or `\"tf_idf\"`,\n        configuring the layer as follows:\n        - `\"int\"`: Outputs integer indices, one integer index per split\n            string token. When `output_mode == \"int\"`,\n            0 is reserved for masked locations;\n            this reduces the vocab size to `max_tokens - 2`\n            instead of `max_tokens - 1`.\n        - `\"multi_hot\"`: Outputs a single int array per batch, of either\n            vocab_size or max_tokens size, containing 1s in all elements\n            where the token mapped to that index exists at least\n            once in the batch item.\n        - `\"count\"`: Like `\"multi_hot\"`, but the int array contains\n            a count of the number of times the token at that index\n            appeared in the batch item.\n        - `\"tf_idf\"`: Like `\"multi_hot\"`, but the TF-IDF algorithm\n            is applied to find the value in each token slot.\n        For `\"int\"` output, any shape of input and output is supported.\n        For all other output modes, currently only rank 1 inputs\n        (and rank 2 outputs after splitting) are supported.\n    output_sequence_length: Only valid in INT mode. If set, the output will\n        have its time dimension padded or truncated to exactly\n        `output_sequence_length` values, resulting in a tensor of shape\n        `(batch_size, output_sequence_length)` regardless of how many tokens\n        resulted from the splitting step. Defaults to `None`. If `ragged`\n        is `True` then `output_sequence_length` may still truncate the\n        output.\n    pad_to_max_tokens: Only valid in  `\"multi_hot\"`, `\"count\"`,\n        and `\"tf_idf\"` modes. If `True`, the output will have\n        its feature axis padded to `max_tokens` even if the number\n        of unique tokens in the vocabulary is less than `max_tokens`,\n        resulting in a tensor of shape `(batch_size, max_tokens)`\n        regardless of vocabulary size. Defaults to `False`.\n    vocabulary: Optional. Either an array of strings or a string path to a\n        text file. If passing an array, can pass a tuple, list,\n        1D NumPy array, or 1D tensor containing the string vocabulary terms.\n        If passing a file path, the file should contain one line per term\n        in the vocabulary. If this argument is set,\n        there is no need to `adapt()` the layer.\n    idf_weights: Only valid when `output_mode` is `\"tf_idf\"`. A tuple, list,\n        1D NumPy array, or 1D tensor of the same length as the vocabulary,\n        containing the floating point inverse document frequency weights,\n        which will be multiplied by per sample term counts for\n        the final `tf_idf` weight. If the `vocabulary` argument is set,\n        and `output_mode` is `\"tf_idf\"`, this argument must be supplied.\n    ragged: Boolean. Only applicable to `\"int\"` output mode.\n        Only supported with TensorFlow backend.\n        If `True`, returns a `RaggedTensor` instead of a dense `Tensor`,\n        where each sequence may have a different length\n        after string splitting. Defaults to `False`.\n    sparse: Boolean. Only applicable to `\"multi_hot\"`, `\"count\"`, and\n        `\"tf_idf\"` output modes. Only supported with TensorFlow\n        backend. If `True`, returns a `SparseTensor`\n        instead of a dense `Tensor`. Defaults to `False`.\n    encoding: Optional. The text encoding to use to interpret the input\n        strings. Defaults to `\"utf-8\"`.\n\nExamples:\n\nThis example instantiates a `TextVectorization` layer that lowercases text,\nsplits on whitespace, strips punctuation, and outputs integer vocab indices.\n\n>>> max_tokens = 5000  # Maximum vocab size.\n>>> max_len = 4  # Sequence length to pad the outputs to.\n>>> # Create the layer.\n>>> vectorize_layer = TextVectorization(\n...     max_tokens=max_tokens,\n...     output_mode='int',\n...     output_sequence_length=max_len)\n\n>>> # Now that the vocab layer has been created, call `adapt` on the\n>>> # list of strings to create the vocabulary.\n>>> vectorize_layer.adapt([\"foo bar\", \"bar baz\", \"baz bada boom\"])\n\n>>> # Now, the layer can map strings to integers -- you can use an\n>>> # embedding layer to map these integers to learned embeddings.\n>>> input_data = [[\"foo qux bar\"], [\"qux baz\"]]\n>>> vectorize_layer(input_data)\narray([[4, 1, 3, 0],\n       [1, 2, 0, 0]])\n\nThis example instantiates a `TextVectorization` layer by passing a list\nof vocabulary terms to the layer's `__init__()` method.\n\n>>> vocab_data = [\"earth\", \"wind\", \"and\", \"fire\"]\n>>> max_len = 4  # Sequence length to pad the outputs to.\n>>> # Create the layer, passing the vocab directly. You can also pass the\n>>> # vocabulary arg a path to a file containing one vocabulary word per\n>>> # line.\n>>> vectorize_layer = keras.layers.TextVectorization(\n...     max_tokens=max_tokens,\n...     output_mode='int',\n...     output_sequence_length=max_len,\n...     vocabulary=vocab_data)\n\n>>> # Because we've passed the vocabulary directly, we don't need to adapt\n>>> # the layer - the vocabulary is already set. The vocabulary contains the\n>>> # padding token ('') and OOV token ('[UNK]')\n>>> # as well as the passed tokens.\n>>> vectorize_layer.get_vocabulary()\n['', '[UNK]', 'earth', 'wind', 'and', 'fire']",
    "std_args": [
      "max_tokens",
      "standardize",
      "split",
      "ngrams",
      "output_mode",
      "output_sequence_length",
      "pad_to_max_tokens",
      "vocabulary",
      "idf_weights",
      "sparse",
      "ragged",
      "encoding",
      "name",
      "kwargs"
    ],
    "type": "class"
  },
  "Threshold": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "threshold"
    ],
    "type": "attribute"
  },
  "TimeDelta64DType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TimeDistributed": {
    "description": "This wrapper allows to apply a layer to every temporal slice of an input.\n\nEvery input should be at least 3D, and the dimension of index one of the\nfirst input will be considered to be the temporal dimension.\n\nConsider a batch of 32 video samples, where each sample is a 128x128 RGB\nimage with `channels_last` data format, across 10 timesteps.\nThe batch input shape is `(32, 10, 128, 128, 3)`.\n\nYou can then use `TimeDistributed` to apply the same `Conv2D` layer to each\nof the 10 timesteps, independently:\n\n>>> inputs = layers.Input(shape=(10, 128, 128, 3), batch_size=32)\n>>> conv_2d_layer = layers.Conv2D(64, (3, 3))\n>>> outputs = layers.TimeDistributed(conv_2d_layer)(inputs)\n>>> outputs.shape\n(32, 10, 126, 126, 64)\n\nBecause `TimeDistributed` applies the same instance of `Conv2D` to each of\nthe timestamps, the same set of weights are used at each timestamp.\n\nArgs:\n    layer: a `keras.layers.Layer` instance.\n\nCall arguments:\n    inputs: Input tensor of shape (batch, time, ...) or nested tensors,\n        and each of which has shape (batch, time, ...).\n    training: Python boolean indicating whether the layer should behave in\n        training mode or in inference mode. This argument is passed to the\n        wrapped layer (only if the layer supports this argument).\n    mask: Binary tensor of shape `(samples, timesteps)` indicating whether\n        a given timestep should be masked. This argument is passed to the\n        wrapped layer (only if the layer supports this argument).",
    "std_args": [
      "layer",
      "kwargs"
    ],
    "type": "class"
  },
  "Tlist": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ToLinen": {
    "description": "A wrapper to turn any NNX module into a Linen module.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "ToNNX": {
    "description": "A wrapper to turn any Linen module into an NNX module.",
    "std_args": [
      "self",
      "module",
      "rngs"
    ],
    "type": "class"
  },
  "ToTensor": {
    "description": "Convert a PIL Image or numpy.ndarray to tensor.",
    "std_args": []
  },
  "TooHardError": {
    "description": "``max_work`` was exceeded.",
    "std_args": [],
    "type": "class"
  },
  "TraceState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Traced": {
    "description": "Traced form of a function specialized to argument types and values.",
    "std_args": [
      "self",
      "traced",
      "jit_wrapped"
    ],
    "type": "class"
  },
  "TrainState": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "TripletMarginLoss": {
    "description": "Creates a criterion that measures the triplet loss given an input",
    "std_args": [
      "self",
      "margin",
      "p",
      "eps",
      "swap",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "TripletMarginWithDistanceLoss": {
    "description": "Creates a criterion that measures the triplet loss given input",
    "std_args": [
      "self",
      "distance_function",
      "margin",
      "swap",
      "reduction"
    ],
    "type": "class"
  },
  "TypeTup": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "UByteDType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "UInt16DType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "UInt32DType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "UInt64DType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "UInt8DType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "UIntDType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "ULongDType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "ULongLongDType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "UNARY": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "UPPER_LEFT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "USE_TMA": {
    "description": "Whether to use Tensor Memory Accelerator (TMA) on supported hardware.",
    "std_args": [],
    "type": "attribute"
  },
  "UShortDType": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "UUID": {
    "description": "Hashable wrapper for ids that handles uniqueness of copies.",
    "std_args": [
      "self",
      "rawid"
    ],
    "type": "class"
  },
  "UUIDManager": {
    "description": "Globally unique counter-based id manager.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "Unflatten": {
    "description": "Unflattens a tensor dim expanding it to a desired shape. For use with :class:`~nn.Sequential`.",
    "std_args": [
      "self",
      "dim",
      "unflattened_size"
    ],
    "type": "function"
  },
  "Unfold": {
    "description": "Extracts sliding local blocks from a batched input tensor.",
    "std_args": [
      "self",
      "kernel_size",
      "dilation",
      "padding",
      "stride"
    ],
    "type": "class"
  },
  "UninitializedBuffer": {
    "description": "A buffer that is not initialized.",
    "std_args": [
      "self",
      "data",
      "requires_grad",
      "persistent"
    ],
    "type": "class"
  },
  "UninitializedParameter": {
    "description": "A parameter that is not initialized.",
    "std_args": [
      "self",
      "data",
      "requires_grad"
    ],
    "type": "class"
  },
  "UninitializedTensorMixin": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "UnitNormalization": {
    "description": "Unit normalization layer.\n\nNormalize a batch of inputs so that each input in the batch has a L2 norm\nequal to 1 (across the axes specified in `axis`).\n\nExample:\n\n>>> data = np.arange(6).reshape(2, 3)\n>>> normalized_data = keras.layers.UnitNormalization()(data)\n>>> np.sum(normalized_data[0, :] ** 2)\n1.0\n\nArgs:\n    axis: Integer or list/tuple. The axis or axes to normalize across.\n        Typically, this is the features axis or axes. The left-out axes are\n        typically the batch axis or axes. `-1` is the last dimension\n        in the input. Defaults to `-1`.",
    "std_args": [
      "axis",
      "kwargs"
    ],
    "type": "class"
  },
  "UpSampling1D": {
    "description": "Upsampling layer for 1D inputs.\n\nRepeats each temporal step `size` times along the time axis.\n\nExample:\n\n>>> input_shape = (2, 2, 3)\n>>> x = np.arange(np.prod(input_shape)).reshape(input_shape)\n>>> x\n[[[ 0  1  2]\n  [ 3  4  5]]\n [[ 6  7  8]\n  [ 9 10 11]]]\n>>> y = keras.layers.UpSampling1D(size=2)(x)\n>>> y\n[[[ 0.  1.  2.]\n  [ 0.  1.  2.]\n  [ 3.  4.  5.]\n  [ 3.  4.  5.]]\n [[ 6.  7.  8.]\n  [ 6.  7.  8.]\n  [ 9. 10. 11.]\n  [ 9. 10. 11.]]]\n\nArgs:\n    size: Integer. Upsampling factor.\n\nInput shape:\n    3D tensor with shape: `(batch_size, steps, features)`.\n\nOutput shape:\n    3D tensor with shape: `(batch_size, upsampled_steps, features)`.",
    "std_args": [
      "size",
      "kwargs"
    ],
    "type": "class"
  },
  "UpSampling2D": {
    "description": "Upsampling layer for 2D inputs.\n\nThe implementation uses interpolative resizing, given the resize method\n(specified by the `interpolation` argument). Use `interpolation=nearest`\nto repeat the rows and columns of the data.\n\nExample:\n\n>>> input_shape = (2, 2, 1, 3)\n>>> x = np.arange(np.prod(input_shape)).reshape(input_shape)\n>>> print(x)\n[[[[ 0  1  2]]\n  [[ 3  4  5]]]\n [[[ 6  7  8]]\n  [[ 9 10 11]]]]\n>>> y = keras.layers.UpSampling2D(size=(1, 2))(x)\n>>> print(y)\n[[[[ 0  1  2]\n   [ 0  1  2]]\n  [[ 3  4  5]\n   [ 3  4  5]]]\n [[[ 6  7  8]\n   [ 6  7  8]]\n  [[ 9 10 11]\n   [ 9 10 11]]]]\n\nArgs:\n    size: Int, or tuple of 2 integers.\n        The upsampling factors for rows and columns.\n    data_format: A string,\n        one of `\"channels_last\"` (default) or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs.\n        `\"channels_last\"` corresponds to inputs with shape\n        `(batch_size, height, width, channels)` while `\"channels_first\"`\n        corresponds to inputs with shape\n        `(batch_size, channels, height, width)`.\n        When unspecified, uses\n        `image_data_format` value found in your Keras config file at\n        `~/.keras/keras.json` (if exists) else `\"channels_last\"`.\n        Defaults to `\"channels_last\"`.\n    interpolation: A string, one of `\"bicubic\"`, `\"bilinear\"`, `\"lanczos3\"`,\n        `\"lanczos5\"`, `\"nearest\"`.\n\nInput shape:\n    4D tensor with shape:\n    - If `data_format` is `\"channels_last\"`:\n        `(batch_size, rows, cols, channels)`\n    - If `data_format` is `\"channels_first\"`:\n        `(batch_size, channels, rows, cols)`\n\nOutput shape:\n    4D tensor with shape:\n    - If `data_format` is `\"channels_last\"`:\n        `(batch_size, upsampled_rows, upsampled_cols, channels)`\n    - If `data_format` is `\"channels_first\"`:\n        `(batch_size, channels, upsampled_rows, upsampled_cols)`",
    "std_args": [
      "size",
      "data_format",
      "interpolation",
      "kwargs"
    ],
    "type": "class"
  },
  "UpSampling3D": {
    "description": "Upsampling layer for 3D inputs.\n\nRepeats the 1st, 2nd and 3rd dimensions\nof the data by `size[0]`, `size[1]` and `size[2]` respectively.\n\nExample:\n\n>>> input_shape = (2, 1, 2, 1, 3)\n>>> x = np.ones(input_shape)\n>>> y = keras.layers.UpSampling3D(size=(2, 2, 2))(x)\n>>> y.shape\n(2, 2, 4, 2, 3)\n\nArgs:\n    size: Int, or tuple of 3 integers.\n        The upsampling factors for dim1, dim2 and dim3.\n    data_format: A string,\n        one of `\"channels_last\"` (default) or `\"channels_first\"`.\n        The ordering of the dimensions in the inputs.\n        `\"channels_last\"` corresponds to inputs with shape\n        `(batch_size, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch_size, channels, spatial_dim1, spatial_dim2, spatial_dim3)`.\n        When unspecified, uses\n        `image_data_format` value found in your Keras config file at\n         `~/.keras/keras.json` (if exists) else `\"channels_last\"`.\n        Defaults to `\"channels_last\"`.\n\nInput shape:\n    5D tensor with shape:\n    - If `data_format` is `\"channels_last\"`:\n        `(batch_size, dim1, dim2, dim3, channels)`\n    - If `data_format` is `\"channels_first\"`:\n        `(batch_size, channels, dim1, dim2, dim3)`\n\nOutput shape:\n    5D tensor with shape:\n    - If `data_format` is `\"channels_last\"`:\n        `(batch_size, upsampled_dim1, upsampled_dim2, upsampled_dim3,\n        channels)`\n    - If `data_format` is `\"channels_first\"`:\n        `(batch_size, channels, upsampled_dim1, upsampled_dim2,\n        upsampled_dim3)`",
    "std_args": [
      "size",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "UpdateContext": {
    "description": "A context manager for handling complex state updates.",
    "std_args": [
      "self",
      "tag",
      "outer_ref_outer_index",
      "outer_index_inner_ref",
      "outer_index_outer_ref",
      "inner_ref_outer_index",
      "static_cache"
    ],
    "type": "class"
  },
  "UpdateContextManager": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "tag"
    ],
    "type": "class"
  },
  "UpdateCvState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "UpsamplingBilinear2d": {
    "description": "Applies a 2D bilinear upsampling to an input signal composed of several input channels.",
    "std_args": [
      "self",
      "size",
      "scale_factor"
    ],
    "type": "class"
  },
  "UpsamplingNearest2d": {
    "description": "Applies a 2D nearest neighbor upsampling to an input signal composed of several input channels.",
    "std_args": [
      "self",
      "size",
      "scale_factor"
    ],
    "type": "class"
  },
  "UseEagerShardContext": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "prev_value",
      "new_value"
    ],
    "type": "class"
  },
  "UseHijaxContext": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "prev_value",
      "new_value"
    ],
    "type": "class"
  },
  "V": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "VARIABLE_CONTEXT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ValueMetadata": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "var_type",
      "value",
      "metadata"
    ],
    "type": "class"
  },
  "VariableContext": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "variable_hijax_stack",
      "eager_shard_stack"
    ],
    "type": "class"
  },
  "VariableDef": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "type",
      "index",
      "outer_index",
      "metadata",
      "array_refdef"
    ],
    "type": "class"
  },
  "VariableEffect": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "VariableMeta": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "VariableMetadata": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "raw_value",
      "set_value_hooks",
      "get_value_hooks",
      "create_value_hooks",
      "add_axis_hooks",
      "remove_axis_hooks",
      "metadata"
    ],
    "type": "class"
  },
  "VariableQDD": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "leaf_avals",
      "treedef"
    ],
    "type": "class"
  },
  "VariableRepr": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "var_type",
      "value",
      "metadata"
    ],
    "type": "class"
  },
  "VariableState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "VariableTypeCache": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "VerySimpleSubClass": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "VisibleDeprecationWarning": {
    "description": "Visible deprecation warning.",
    "std_args": [],
    "type": "class"
  },
  "VmapFn": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "f",
      "transform_metadata",
      "in_axes",
      "out_axes"
    ],
    "type": "class"
  },
  "VoidDType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "WARNING_MARK_SPEC": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "WARNING_MESSAGE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "WARN_FOR_UNFUSED_KERNELS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "WRITE_DQ": {
    "description": "Controls whether gradient scatters are done in the DQ iteration loop of the backward pass.",
    "std_args": [],
    "type": "attribute"
  },
  "WeightNorm": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "name",
      "dim"
    ],
    "type": "class"
  },
  "Welford": {
    "description": "Uses Welford's algorithm to compute the mean and variance of a stream of data.",
    "std_args": [
      "self",
      "argname"
    ],
    "type": "class"
  },
  "Wh": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Whh": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "WhileLoopBodyFn": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "f"
    ],
    "type": "class"
  },
  "WhileLoopCondFn": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "f"
    ],
    "type": "class"
  },
  "WithTag": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "tag"
    ],
    "type": "class"
  },
  "WrappedArray": {
    "description": "Wrapping a MaskedArray rather than subclassing to test that",
    "std_args": [
      "self",
      "array",
      "attrs"
    ],
    "type": "class"
  },
  "WrappedSchedule": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Wrapper": {
    "description": "Abstract wrapper base class.\n\nWrappers take another layer and augment it in various ways.\nDo not use this class as a layer, it is only an abstract base class.\nTwo usable wrappers are the `TimeDistributed` and `Bidirectional` layers.\n\nArgs:\n    layer: The layer to be wrapped.",
    "std_args": [
      "layer",
      "kwargs"
    ],
    "type": "class"
  },
  "Wx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Wxh": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ZeroNansState": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ZeroPad1d": {
    "description": "Pads the input tensor boundaries with zero.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ZeroPad2d": {
    "description": "Pads the input tensor boundaries with zero.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ZeroPad3d": {
    "description": "Pads the input tensor boundaries with zero.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ZeroPadding1D": {
    "description": "Zero-padding layer for 1D input (e.g. temporal sequence).\n\nExample:\n\n>>> input_shape = (2, 2, 3)\n>>> x = np.arange(np.prod(input_shape)).reshape(input_shape)\n>>> x\n[[[ 0  1  2]\n  [ 3  4  5]]\n [[ 6  7  8]\n  [ 9 10 11]]]\n>>> y = keras.layers.ZeroPadding1D(padding=2)(x)\n>>> y\n[[[ 0  0  0]\n  [ 0  0  0]\n  [ 0  1  2]\n  [ 3  4  5]\n  [ 0  0  0]\n  [ 0  0  0]]\n [[ 0  0  0]\n  [ 0  0  0]\n  [ 6  7  8]\n  [ 9 10 11]\n  [ 0  0  0]\n  [ 0  0  0]]]\n\nArgs:\n    padding: Int, or tuple of int (length 2), or dictionary.\n        - If int: how many zeros to add at the beginning and end of\n          the padding dimension (axis 1).\n        - If tuple of 2 ints: how many zeros to add at the beginning and the\n          end of the padding dimension (`(left_pad, right_pad)`).\n    data_format: A string, one of `\"channels_last\"` (default) or\n        `\"channels_first\"`. The ordering of the dimensions in the inputs.\n        `\"channels_last\"` corresponds to inputs with shape\n        `(batch_size, axis_to_pad, channels)` while `\"channels_first\"`\n        corresponds to inputs with shape\n        `(batch_size, channels, axis_to_pad)`.\n        When unspecified, uses `image_data_format` value found in your Keras\n        config file at `~/.keras/keras.json` (if exists). Defaults to\n        `\"channels_last\"`.\n\nInput shape:\n    3D tensor with shape:\n    - If `data_format` is `\"channels_last\"`:\n      `(batch_size, axis_to_pad, features)`\n    - If `data_format` is `\"channels_first\"`:\n      `(batch_size, features, axis_to_pad)`\n\nOutput shape:\n    3D tensor with shape:\n    - If `data_format` is `\"channels_last\"`:\n      `(batch_size, padded_axis, features)`\n    - If `data_format` is `\"channels_first\"`:\n      `(batch_size, features, padded_axis)`",
    "std_args": [
      "padding",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "ZeroPadding2D": {
    "description": "Zero-padding layer for 2D input (e.g. picture).\n\nThis layer can add rows and columns of zeros at the top, bottom, left and\nright side of an image tensor.\n\nExample:\n\n>>> input_shape = (1, 1, 2, 2)\n>>> x = np.arange(np.prod(input_shape)).reshape(input_shape)\n>>> x\n[[[[0 1]\n   [2 3]]]]\n>>> y = keras.layers.ZeroPadding2D(padding=1)(x)\n>>> y\n[[[[0 0]\n   [0 0]\n   [0 0]\n   [0 0]]\n  [[0 0]\n   [0 1]\n   [2 3]\n   [0 0]]\n  [[0 0]\n   [0 0]\n   [0 0]\n   [0 0]]]]\n\nArgs:\n    padding: Int, or tuple of 2 ints, or tuple of 2 tuples of 2 ints.\n        - If int: the same symmetric padding is applied to height and width.\n        - If tuple of 2 ints: interpreted as two different symmetric padding\n          values for height and width:\n          `(symmetric_height_pad, symmetric_width_pad)`.\n        - If tuple of 2 tuples of 2 ints: interpreted as\n         `((top_pad, bottom_pad), (left_pad, right_pad))`.\n    data_format: A string, one of `\"channels_last\"` (default) or\n        `\"channels_first\"`. The ordering of the dimensions in the inputs.\n        `\"channels_last\"` corresponds to inputs with shape\n        `(batch_size, height, width, channels)` while `\"channels_first\"`\n        corresponds to inputs with shape\n        `(batch_size, channels, height, width)`.\n        When unspecified, uses `image_data_format` value found in your Keras\n        config file at `~/.keras/keras.json` (if exists). Defaults to\n        `\"channels_last\"`.\n\nInput shape:\n    4D tensor with shape:\n    - If `data_format` is `\"channels_last\"`:\n      `(batch_size, height, width, channels)`\n    - If `data_format` is `\"channels_first\"`:\n      `(batch_size, channels, height, width)`\n\nOutput shape:\n    4D tensor with shape:\n    - If `data_format` is `\"channels_last\"`:\n      `(batch_size, padded_height, padded_width, channels)`\n    - If `data_format` is `\"channels_first\"`:\n      `(batch_size, channels, padded_height, padded_width)`",
    "std_args": [
      "padding",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "ZeroPadding3D": {
    "description": "Zero-padding layer for 3D data (spatial or spatio-temporal).\n\nExample:\n\n>>> input_shape = (1, 1, 2, 2, 3)\n>>> x = np.arange(np.prod(input_shape)).reshape(input_shape)\n>>> y = keras.layers.ZeroPadding3D(padding=2)(x)\n>>> y.shape\n(1, 5, 6, 6, 3)\n\nArgs:\n    padding: Int, or tuple of 3 ints, or tuple of 3 tuples of 2 ints.\n        - If int: the same symmetric padding is applied to depth, height,\n          and width.\n        - If tuple of 3 ints: interpreted as three different symmetric\n          padding values for depth, height, and width:\n          `(symmetric_dim1_pad, symmetric_dim2_pad, symmetric_dim3_pad)`.\n        - If tuple of 3 tuples of 2 ints: interpreted as\n          `((left_dim1_pad, right_dim1_pad), (left_dim2_pad,\n          right_dim2_pad), (left_dim3_pad, right_dim3_pad))`.\n    data_format: A string, one of `\"channels_last\"` (default) or\n        `\"channels_first\"`. The ordering of the dimensions in the inputs.\n        `\"channels_last\"` corresponds to inputs with shape\n        `(batch_size, spatial_dim1, spatial_dim2, spatial_dim3, channels)`\n        while `\"channels_first\"` corresponds to inputs with shape\n        `(batch_size, channels, spatial_dim1, spatial_dim2, spatial_dim3)`.\n        When unspecified, uses `image_data_format` value found in your Keras\n        config file at `~/.keras/keras.json` (if exists). Defaults to\n        `\"channels_last\"`.\n\nInput shape:\n    5D tensor with shape:\n    - If `data_format` is `\"channels_last\"`:\n      `(batch_size, first_axis_to_pad, second_axis_to_pad,\n      third_axis_to_pad, depth)`\n    - If `data_format` is `\"channels_first\"`:\n      `(batch_size, depth, first_axis_to_pad, second_axis_to_pad,\n      third_axis_to_pad)`\n\nOutput shape:\n    5D tensor with shape:\n    - If `data_format` is `\"channels_last\"`:\n      `(batch_size, first_padded_axis, second_padded_axis,\n      third_axis_to_pad, depth)`\n    - If `data_format` is `\"channels_first\"`:\n      `(batch_size, depth, first_padded_axis, second_padded_axis,\n      third_axis_to_pad)`",
    "std_args": [
      "padding",
      "data_format",
      "kwargs"
    ],
    "type": "class"
  },
  "__imports__": {},
  "absolute": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "abstract_eval": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "abstract_var",
      "avals"
    ],
    "type": "function"
  },
  "accumulate": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "array",
      "axis",
      "dtype",
      "out"
    ],
    "type": "function"
  },
  "actions": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "activation": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "activation_fn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "activation_relu_or_gelu": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "adapt": {
    "description": "Computes a vocabulary of string terms from tokens in a dataset.\n\nCalling `adapt()` on a `TextVectorization` layer is an alternative to\npassing in a precomputed vocabulary on construction via the `vocabulary`\nargument. A `TextVectorization` layer should always be either adapted\nover a dataset or supplied with a vocabulary.\n\nDuring `adapt()`, the layer will build a vocabulary of all string tokens\nseen in the dataset, sorted by occurrence count, with ties broken by\nsort order of the tokens (high to low). At the end of `adapt()`, if\n`max_tokens` is set, the vocabulary will be truncated to `max_tokens`\nsize. For example, adapting a layer with `max_tokens=1000` will compute\nthe 1000 most frequent tokens occurring in the input dataset. If\n`output_mode='tf-idf'`, `adapt()` will also learn the document\nfrequencies of each token in the input dataset.\n\nArguments:\n    data: The data to train on. It can be passed either as a\n        batched `tf.data.Dataset`, as a list of strings,\n        or as a NumPy array.\n    steps: Integer or `None`.\n        Total number of steps (batches of samples) to process.\n        If `data` is a `tf.data.Dataset`, and `steps` is `None`,\n        `adapt()` will run until the input dataset is exhausted.\n        When passing an infinitely\n        repeating dataset, you must specify the `steps` argument. This\n        argument is not supported with array inputs or list inputs.",
    "std_args": [
      "self",
      "data",
      "batch_size",
      "steps"
    ],
    "type": "function"
  },
  "adaptive_average_pool": {
    "description": "Adaptive average pooling operation.\n\nApplies an adaptive average pooling operation that automatically\ncomputes the kernel size and stride to pool the input to the\nspecified `output_size`. This operation is useful when you want a\nfixed output size regardless of input size, commonly used in models\nlike ResNet for global feature extraction.\n\nArgs:\n    inputs: Tensor of rank 4. Input tensor of shape:\n        - If `data_format=\"channels_last\"`:\n            `(batch_size, height, width, channels)`.\n        - If `data_format=\"channels_first\"`:\n            `(batch_size, channels, height, width)`.\n    output_size: Integer or tuple/list of 2 integers, specifying the target\n        output spatial dimensions `(output_height, output_width)`. If a\n        single\n        integer is provided, the same value is used for both dimensions.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        Defaults to the value found in your Keras config file at\n        `~/.keras/keras.json`. If never set, defaults to `\"channels_last\"`.\n\nReturns:\n    A tensor of rank 4 representing the adaptive average pooled result.\n\nExample:\n\n>>> x = np.random.rand(2, 64, 64, 3)\n>>> y = keras.ops.adaptive_average_pool(x, output_size=(32, 32))\n>>> y.shape\n(2, 32, 32, 3)\n\n>>> # Works with any input size\n>>> x = np.random.rand(2, 100, 80, 3)\n>>> y = keras.ops.adaptive_average_pool(x, output_size=7)\n>>> y.shape\n(2, 7, 7, 3)",
    "std_args": [
      "inputs",
      "output_size",
      "data_format"
    ],
    "type": "function"
  },
  "adaptive_avg_pool1d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "adaptive_avg_pool2d": {
    "description": "Apply a 2D adaptive average pooling over an input signal composed of several input planes.",
    "std_args": [
      "input",
      "output_size"
    ],
    "type": "function"
  },
  "adaptive_avg_pool3d": {
    "description": "Apply a 3D adaptive average pooling over an input signal composed of several input planes.",
    "std_args": [
      "input",
      "output_size"
    ],
    "type": "function"
  },
  "adaptive_grad_clip": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "adaptive_max_pool": {
    "description": "Adaptive max pooling operation.\n\nApplies an adaptive max pooling operation that automatically computes the\nkernel size and stride to pool the input to the specified `output_size`.\nThis operation is useful when you want a fixed output size regardless of\ninput size, commonly used in models like ResNet for global feature\nextraction.\nArgs:\n    inputs: Tensor of rank 4. Input tensor of shape:\n        - If `data_format=\"channels_last\"`:\n            `(batch_size, height, width, channels)`.\n        - If `data_format=\"channels_first\"`:\n            `(batch_size, channels, height, width)`.\n    output_size: Integer or tuple/list of 2 integers, specifying the target\n        output spatial dimensions `(output_height, output_width)`. If a\n        single\n        integer is provided, the same value is used for both dimensions.\n    data_format: string, either `\"channels_last\"` or `\"channels_first\"`.\n        Defaults to the value found in your Keras config file at\n        `~/.keras/keras.json`. If never set, defaults to `\"channels_last\"`.\n\nReturns:\n    A tensor of rank 4 representing the adaptive max pooled result.\n\nExample:\n\n>>> x = np.random.rand(2, 64, 64, 3)\n>>> y = keras.ops.adaptive_max_pool(x, output_size=(32, 32))\n>>> y.shape\n(2, 32, 32, 3)\n\n>>> # Works with any input size\n>>> x = np.random.rand(2, 100, 80, 3)\n>>> y = keras.ops.adaptive_max_pool(x, output_size=7)\n>>> y.shape\n(2, 7, 7, 3)",
    "std_args": [
      "inputs",
      "output_size",
      "data_format"
    ],
    "type": "function"
  },
  "adaptive_max_pool1d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "adaptive_max_pool1d_with_indices": {
    "description": "adaptive_max_pool1d(input, output_size, return_indices=False)",
    "std_args": [
      "input",
      "output_size",
      "return_indices"
    ],
    "type": "function"
  },
  "adaptive_max_pool2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "adaptive_max_pool2d_with_indices": {
    "description": "adaptive_max_pool2d(input, output_size, return_indices=False)",
    "std_args": [
      "input",
      "output_size",
      "return_indices"
    ],
    "type": "function"
  },
  "adaptive_max_pool3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "adaptive_max_pool3d_with_indices": {
    "description": "adaptive_max_pool3d(input, output_size, return_indices=False)",
    "std_args": [
      "input",
      "output_size",
      "return_indices"
    ],
    "type": "function"
  },
  "add_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "index",
      "params"
    ],
    "type": "function"
  },
  "add_axis_hooks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "add_decayed_weights": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "add_loss": {
    "description": "Can be called inside of the `call()` method to add a scalar loss.\n\nExample:\n\n```python\nclass MyLayer(Layer):\n    ...\n    def call(self, x):\n        self.add_loss(ops.sum(x))\n        return x\n```",
    "std_args": [
      "self",
      "loss"
    ],
    "type": "function"
  },
  "add_metric": {
    "description": "",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "add_noise": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "add_np": {
    "description": "The class representing a Python function.",
    "std_args": [
      "doctest_namespace"
    ],
    "type": "function"
  },
  "add_pruning_method": {
    "description": "Add a child pruning ``method`` to the container.",
    "std_args": [
      "self",
      "method"
    ],
    "type": "function"
  },
  "add_scale": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "add_variable": {
    "description": "Add a weight variable to the layer.\n\nAlias of `add_weight()`.",
    "std_args": [
      "self",
      "shape",
      "initializer",
      "dtype",
      "trainable",
      "autocast",
      "regularizer",
      "constraint",
      "name"
    ],
    "type": "function"
  },
  "add_weight": {
    "description": "Add a weight variable to the layer.\n\nArgs:\n    shape: Shape tuple for the variable. Must be fully-defined\n        (no `None` entries). Defaults to `()` (scalar) if unspecified.\n    initializer: Initializer object to use to populate the initial\n        variable value, or string name of a built-in initializer\n        (e.g. `\"random_normal\"`). If unspecified, defaults to\n        `\"glorot_uniform\"` for floating-point variables and to `\"zeros\"`\n        for all other types (e.g. int, bool).\n    dtype: Dtype of the variable to create, e.g. `\"float32\"`. If\n        unspecified, defaults to the layer's variable dtype\n        (which itself defaults to `\"float32\"` if unspecified).\n    trainable: Boolean, whether the variable should be trainable via\n        backprop or whether its updates are managed manually. Defaults\n        to `True`.\n    autocast: Boolean, whether to autocast layers variables when\n        accessing them. Defaults to `True`.\n    regularizer: Regularizer object to call to apply penalty on the\n        weight. These penalties are summed into the loss function\n        during optimization. Defaults to `None`.\n    constraint: Contrainst object to call on the variable after any\n        optimizer update, or string name of a built-in constraint.\n        Defaults to `None`.\n    aggregation: Optional string, one of `None`, `\"none\"`, `\"mean\"`,\n        `\"sum\"` or `\"only_first_replica\"`. Annotates the variable with\n        the type of multi-replica aggregation to be used for this\n        variable when writing custom data parallel training loops.\n        Defaults to `\"none\"`.\n    overwrite_with_gradient: Boolean, whether to overwrite the variable\n        with the computed gradient. This is useful for float8 training.\n        Defaults to `False`.\n    name: String name of the variable. Useful for debugging purposes.",
    "std_args": [
      "self",
      "shape",
      "initializer",
      "dtype",
      "trainable",
      "autocast",
      "regularizer",
      "constraint",
      "aggregation",
      "overwrite_with_gradient",
      "name"
    ],
    "type": "function"
  },
  "add_zero_attn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "addfield": {
    "description": "Adds a new field to the masked record array",
    "std_args": [
      "mrecord",
      "newfield",
      "newfieldname"
    ],
    "type": "function"
  },
  "addmm": {
    "description": "addmm(c: array, a: array, b: array, /, alpha: float = 1.0, beta: float = 1.0,  *, stream: Union[None, Stream, Device] = None) -> array",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "addressable_data": {
    "description": "Return an array of the addressable data at a particular index.",
    "std_args": [
      "self",
      "index"
    ],
    "type": "function"
  },
  "advance": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "affine": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "affine_grid": {
    "description": "Generate 2D or 3D flow field (sampling grid), given a batch of affine matrices :attr:`theta`.",
    "std_args": [
      "theta",
      "size",
      "align_corners"
    ],
    "type": "function"
  },
  "affine_transform": {
    "description": "Applies the given transform(s) to the image(s).\n\nArgs:\n    images: Input image or batch of images. Must be 3D or 4D.\n    transform: Projective transform matrix/matrices. A vector of length 8 or\n        tensor of size N x 8. If one row of transform is\n        `[a0, a1, a2, b0, b1, b2, c0, c1]`, then it maps the output point\n        `(x, y)` to a transformed input point\n        `(x', y') = ((a0 x + a1 y + a2) / k, (b0 x + b1 y + b2) / k)`,\n        where `k = c0 x + c1 y + 1`. The transform is inverted compared to\n        the transform mapping input points to output points. Note that\n        gradients are not backpropagated into transformation parameters.\n        Note that `c0` and `c1` are only effective when using TensorFlow\n        backend and will be considered as `0` when using other backends.\n    interpolation: Interpolation method. Available methods are `\"nearest\"`,\n        and `\"bilinear\"`. Defaults to `\"bilinear\"`.\n    fill_mode: Points outside the boundaries of the input are filled\n        according to the given mode. Available methods are `\"constant\"`,\n        `\"nearest\"`, `\"wrap\"` and `\"reflect\"`. Defaults to `\"constant\"`.\n        - `\"reflect\"`: `(d c b a | a b c d | d c b a)`\n            The input is extended by reflecting about the edge of the last\n            pixel.\n        - `\"constant\"`: `(k k k k | a b c d | k k k k)`\n            The input is extended by filling all values beyond\n            the edge with the same constant value k specified by\n            `fill_value`.\n        - `\"wrap\"`: `(a b c d | a b c d | a b c d)`\n            The input is extended by wrapping around to the opposite edge.\n        - `\"nearest\"`: `(a a a a | a b c d | d d d d)`\n            The input is extended by the nearest pixel.\n    fill_value: Value used for points outside the boundaries of the input if\n        `fill_mode=\"constant\"`. Defaults to `0`.\n    data_format: A string specifying the data format of the input tensor.\n        It can be either `\"channels_last\"` or `\"channels_first\"`.\n        `\"channels_last\"` corresponds to inputs with shape\n        `(batch, height, width, channels)`, while `\"channels_first\"`\n        corresponds to inputs with shape `(batch, channels, height, width)`.\n        If not specified, the value will default to\n        `keras.config.image_data_format`.\n\nReturns:\n    Applied affine transform image or batch of images.\n\nExamples:\n\n>>> x = np.random.random((2, 64, 80, 3)) # batch of 2 RGB images\n>>> transform = np.array(\n...     [\n...         [1.5, 0, -20, 0, 1.5, -16, 0, 0],  # zoom\n...         [1, 0, -20, 0, 1, -16, 0, 0],  # translation\n...     ]\n... )\n>>> y = keras.ops.image.affine_transform(x, transform)\n>>> y.shape\n(2, 64, 80, 3)\n\n>>> x = np.random.random((64, 80, 3)) # single RGB image\n>>> transform = np.array([1.0, 0.5, -20, 0.5, 1.0, -16, 0, 0])  # shear\n>>> y = keras.ops.image.affine_transform(x, transform)\n>>> y.shape\n(64, 80, 3)\n\n>>> x = np.random.random((2, 3, 64, 80)) # batch of 2 RGB images\n>>> transform = np.array(\n...     [\n...         [1.5, 0, -20, 0, 1.5, -16, 0, 0],  # zoom\n...         [1, 0, -20, 0, 1, -16, 0, 0],  # translation\n...     ]\n... )\n>>> y = keras.ops.image.affine_transform(x, transform,\n...     data_format=\"channels_first\")\n>>> y.shape\n(2, 3, 64, 80)",
    "std_args": [
      "images",
      "transform",
      "interpolation",
      "fill_mode",
      "fill_value",
      "data_format"
    ],
    "type": "function"
  },
  "airy_ai": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "align_corners": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "alignment": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "all_dimspecs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "all_gather": {
    "description": "Gather arrays from all processes.",
    "std_args": [
      "x",
      "group",
      "stream"
    ],
    "type": "function"
  },
  "all_max": {
    "description": "All reduce max.",
    "std_args": [
      "x",
      "group",
      "stream"
    ],
    "type": "function"
  },
  "all_min": {
    "description": "All reduce min.",
    "std_args": [
      "x",
      "group",
      "stream"
    ],
    "type": "function"
  },
  "all_sum": {
    "description": "All reduce sum.",
    "std_args": [
      "x",
      "group",
      "stream"
    ],
    "type": "function"
  },
  "all_tags": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "all_types": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "all_weights": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "allclose": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "allequal": {
    "description": "Return True if all entries of a and b are equal, using",
    "std_args": [
      "a",
      "b",
      "fill_value"
    ],
    "type": "function"
  },
  "allows_array_function_override": {
    "description": "Determine if a Numpy function can be overridden via `__array_function__`",
    "std_args": [
      "func"
    ],
    "type": "function"
  },
  "allows_array_ufunc_override": {
    "description": "Determine if a function can be overridden via `__array_ufunc__`",
    "std_args": [
      "func"
    ],
    "type": "function"
  },
  "alltrue": {
    "description": "The class representing a Python function.",
    "std_args": [
      "target",
      "axis",
      "dtype"
    ],
    "type": "function"
  },
  "almost": {
    "description": "Returns True if a and b are equal up to decimal places.",
    "std_args": [
      "a",
      "b",
      "decimal",
      "fill_value"
    ],
    "type": "function"
  },
  "alpha": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "alpha_dropout": {
    "description": "Apply alpha dropout to the input.",
    "std_args": [
      "input",
      "p",
      "training",
      "inplace"
    ],
    "type": "function"
  },
  "amax": {
    "description": "Alias of :func:`jax.numpy.max`.",
    "std_args": [
      "a",
      "axis",
      "out",
      "keepdims",
      "initial",
      "where"
    ],
    "type": "function"
  },
  "amin": {
    "description": "Alias of :func:`jax.numpy.min`.",
    "std_args": [
      "a",
      "axis",
      "out",
      "keepdims",
      "initial",
      "where"
    ],
    "type": "function"
  },
  "amount": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "analyzeargs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "block"
    ],
    "type": "function"
  },
  "analyzeargs_re_1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "analyzebody": {
    "description": "The class representing a Python function.",
    "std_args": [
      "block",
      "args",
      "tab"
    ],
    "type": "function"
  },
  "analyzecommon": {
    "description": "The class representing a Python function.",
    "std_args": [
      "block"
    ],
    "type": "function"
  },
  "analyzeline": {
    "description": "Reads each line in the input file in sequence and updates global vars.",
    "std_args": [
      "m",
      "case",
      "line"
    ],
    "type": "function"
  },
  "analyzevars": {
    "description": "Sets correct dimension information for each variable/parameter",
    "std_args": [
      "block"
    ],
    "type": "function"
  },
  "and_masks": {
    "description": "Returns a mask_mod that's the intersection of provided mask_mods",
    "std_args": [
      "mask_mods"
    ],
    "type": "function"
  },
  "angle": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "anom": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "anomalies": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "append": {
    "description": "Append a given value at the end of the list.",
    "std_args": [
      "self",
      "value"
    ],
    "type": "function"
  },
  "append_fields": {
    "description": "Add new fields to an existing array.",
    "std_args": [
      "base",
      "names",
      "data",
      "dtypes",
      "fill_value",
      "usemask",
      "asrecarray"
    ],
    "type": "function"
  },
  "append_needs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "need",
      "flag"
    ],
    "type": "function"
  },
  "appenddecl": {
    "description": "The class representing a Python function.",
    "std_args": [
      "decl",
      "decl2",
      "force"
    ],
    "type": "function"
  },
  "appendmultiline": {
    "description": "The class representing a Python function.",
    "std_args": [
      "group",
      "context_name",
      "ml"
    ],
    "type": "function"
  },
  "apply": {
    "description": "Apply ``fn`` recursively to every submodule (as returned by ``.children()``) as well as self.",
    "std_args": [
      "self",
      "fn"
    ],
    "type": "function"
  },
  "apply_along_axis": {
    "description": "Apply a function to 1D array slices along an axis.\n\nJAX implementation of :func:`numpy.apply_along_axis`. While NumPy implements\nthis iteratively, JAX implements this via :func:`jax.vmap`, and so ``func1d``\nmust be compatible with ``vmap``.\n\nArgs:\n  func1d: a callable function with signature ``func1d(arr, /, *args, **kwargs)``\n    where ``*args`` and ``**kwargs`` are the additional positional and keyword\n    arguments passed to :func:`apply_along_axis`.\n  axis: integer axis along which to apply the function.\n  arr: the array over which to apply the function.\n  args, kwargs: additional positional and keyword arguments are passed through\n    to ``func1d``.\n\nReturns:\n  The result of ``func1d`` applied along the specified axis.\n\nSee also:\n  - :func:`jax.vmap`: a more direct way to create a vectorized version of a function.\n  - :func:`jax.numpy.apply_over_axes`: repeatedly apply a function over multiple axes.\n  - :func:`jax.numpy.vectorize`: create a vectorized version of a function.\n\nExamples:\n  A simple example in two dimensions, where the function is applied either row-wise\n  or column-wise:\n\n  >>> x = jnp.array([[1, 2, 3],\n  ...                [4, 5, 6]])\n  >>> def func1d(x):\n  ...   return jnp.sum(x ** 2)\n  >>> jnp.apply_along_axis(func1d, 0, x)\n  Array([17, 29, 45], dtype=int32)\n  >>> jnp.apply_along_axis(func1d, 1, x)\n  Array([14, 77], dtype=int32)\n\n  For 2D inputs, this can be equivalently expressed using :func:`jax.vmap`,\n  though note that `vmap` specifies the mapped axis rather than the applied axis:\n\n  >>> jax.vmap(func1d, in_axes=1)(x)  # same as applying along axis 0\n  Array([17, 29, 45], dtype=int32)\n  >>> jax.vmap(func1d, in_axes=0)(x)  # same as applying along axis 1\n  Array([14, 77], dtype=int32)\n\n  For 3D inputs, :func:`apply_along_axis` is equivalent to mapping over two\n  dimensions:\n\n  >>> x_3d = jnp.arange(24).reshape(2, 3, 4)\n  >>> jnp.apply_along_axis(func1d, 2, x_3d)\n  Array([[  14,  126,  366],\n         [ 734, 1230, 1854]], dtype=int32)\n  >>> jax.vmap(jax.vmap(func1d))(x_3d)\n  Array([[  14,  126,  366],\n         [ 734, 1230, 1854]], dtype=int32)\n\n  The applied function may also take arbitrary positional or keyword arguments,\n  which should be passed directly as additional arguments to :func:`apply_along_axis`:\n\n  >>> def func1d(x, exponent):\n  ...   return jnp.sum(x ** exponent)\n  >>> jnp.apply_along_axis(func1d, 0, x, exponent=3)\n  Array([ 65, 133, 243], dtype=int32)",
    "std_args": [
      "func1d",
      "axis",
      "arr",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "apply_along_fields": {
    "description": "Apply function 'func' as a reduction across fields of a structured array.",
    "std_args": [
      "func",
      "arr"
    ],
    "type": "function"
  },
  "apply_gradients": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "grads",
      "kwargs"
    ],
    "type": "function"
  },
  "apply_if_finite": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "apply_mask": {
    "description": "Simply handles the multiplication between the parameter being pruned and the generated mask.",
    "std_args": [
      "self",
      "module"
    ],
    "type": "function"
  },
  "apply_over_axes": {
    "description": "Apply a function repeatedly over specified axes.\n\nJAX implementation of :func:`numpy.apply_over_axes`.\n\nArgs:\n  func: the function to apply, with signature ``func(Array, int) -> Array``, and\n    where ``y = func(x, axis)`` must satisfy ``y.ndim in [x.ndim, x.ndim - 1]``.\n  a: N-dimensional array over which to apply the function.\n  axes: the sequence of axes over which to apply the function.\n\nReturns:\n  An N-dimensional array containing the result of the repeated function application.\n\nSee also:\n  - :func:`jax.numpy.apply_along_axis`: apply a 1D function along a single axis.\n\nExamples:\n  This function is designed to have similar semantics to typical associative\n  :mod:`jax.numpy` reductions over one or more axes with ``keepdims=True``.\n  For example:\n\n  >>> x = jnp.array([[1, 2, 3],\n  ...                [4, 5, 6]])\n\n  >>> jnp.apply_over_axes(jnp.sum, x, [0])\n  Array([[5, 7, 9]], dtype=int32)\n  >>> jnp.sum(x, [0], keepdims=True)\n  Array([[5, 7, 9]], dtype=int32)\n\n  >>> jnp.apply_over_axes(jnp.min, x, [1])\n  Array([[1],\n         [4]], dtype=int32)\n  >>> jnp.min(x, [1], keepdims=True)\n  Array([[1],\n         [4]], dtype=int32)\n\n  >>> jnp.apply_over_axes(jnp.prod, x, [0, 1])\n  Array([[720]], dtype=int32)\n  >>> jnp.prod(x, [0, 1], keepdims=True)\n  Array([[720]], dtype=int32)",
    "std_args": [
      "func",
      "a",
      "axes"
    ],
    "type": "function"
  },
  "apply_permutation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tensor",
      "permutation",
      "dim"
    ],
    "type": "function"
  },
  "apply_single": {
    "description": "Performs the Muon parameter update",
    "std_args": [
      "self",
      "gradient",
      "parameter",
      "state"
    ],
    "type": "function"
  },
  "apply_tag": {
    "description": "Add the given tag (a string) to each of the cases (a list of LinalgCase",
    "std_args": [
      "tag",
      "cases"
    ],
    "type": "function"
  },
  "apply_to_modules": {
    "description": "Apply a function to all the modules in this instance (including this",
    "std_args": [
      "self",
      "apply_fn"
    ],
    "type": "function"
  },
  "applyrules": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rules",
      "d",
      "var"
    ],
    "type": "function"
  },
  "approx": {
    "description": "Returns true if all components of a and b are equal to given tolerances.",
    "std_args": [
      "a",
      "b",
      "fill_value",
      "rtol",
      "atol"
    ],
    "type": "function"
  },
  "approximate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "arccos": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "arccosh": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "arcsin": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "arcsinh": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "arctan": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "arctan2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "arctanh": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "arg_rules": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "argname": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "argnum": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "argpartition": {
    "description": "Return the indices that partially sort the array.\n\nRefer to :func:`jax.numpy.argpartition` for the full documentation.",
    "std_args": [
      "self",
      "kth",
      "axis"
    ],
    "type": "function"
  },
  "args": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "args_info": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "argwhere": {
    "description": "Find the indices of nonzero array elements\n\nJAX implementation of :func:`numpy.argwhere`.\n\n``jnp.argwhere(x)`` is essentially equivalent to ``jnp.column_stack(jnp.nonzero(x))``\nwith special handling for zero-dimensional (i.e. scalar) inputs.\n\nBecause the size of the output of ``argwhere`` is data-dependent, the function is not\ntypically compatible with JIT. The JAX version adds the optional ``size`` argument, which\nspecifies the size of the leading dimension of the output - it must be specified statically\nfor ``jnp.argwhere`` to be compiled with non-static operands. See :func:`jax.numpy.nonzero`\nfor a full discussion of ``size`` and its semantics.\n\nArgs:\n  a: array for which to find nonzero elements\n  size: optional integer specifying statically the number of expected nonzero elements.\n    This must be specified in order to use ``argwhere`` within JAX transformations like\n    :func:`jax.jit`. See :func:`jax.numpy.nonzero` for more information.\n  fill_value: optional array specifying the fill value when ``size`` is specified.\n    See :func:`jax.numpy.nonzero` for more information.\n\nReturns:\n  a two-dimensional array of shape ``[size, x.ndim]``. If ``size`` is not specified as\n  an argument, it is equal to the number of nonzero elements in ``x``.\n\nSee Also:\n  - :func:`jax.numpy.where`\n  - :func:`jax.numpy.nonzero`\n\nExamples:\n  Two-dimensional array:\n\n  >>> x = jnp.array([[1, 0, 2],\n  ...                [0, 3, 0]])\n  >>> jnp.argwhere(x)\n  Array([[0, 0],\n         [0, 2],\n         [1, 1]], dtype=int32)\n\n  Equivalent computation using :func:`jax.numpy.column_stack` and :func:`jax.numpy.nonzero`:\n\n  >>> jnp.column_stack(jnp.nonzero(x))\n  Array([[0, 0],\n         [0, 2],\n         [1, 1]], dtype=int32)\n\n  Special case for zero-dimensional (i.e. scalar) inputs:\n\n  >>> jnp.argwhere(1)\n  Array([], shape=(1, 0), dtype=int32)\n  >>> jnp.argwhere(0)\n  Array([], shape=(0, 0), dtype=int32)",
    "std_args": [
      "a",
      "size",
      "fill_value"
    ],
    "type": "function"
  },
  "around": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "arr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "arr1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "arr2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "arr_attr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "arr_equal": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "arr1",
      "arr2"
    ],
    "type": "function"
  },
  "array_equal": {
    "description": "Check if two arrays are element-wise equal.\n\nJAX implementation of :func:`numpy.array_equal`.\n\nArgs:\n  a1: first input array to compare.\n  a2: second input array to compare.\n  equal_nan: Boolean. If ``True``, NaNs in ``a1`` will be considered\n    equal to NaNs in ``a2``. Default is ``False``.\n\nReturns:\n  Boolean scalar array indicating whether the input arrays are element-wise equal.\n\nSee Also:\n  - :func:`jax.numpy.allclose`\n  - :func:`jax.numpy.array_equiv`\n\nExamples:\n  >>> jnp.array_equal(jnp.array([1, 2, 3]), jnp.array([1, 2, 3]))\n  Array(True, dtype=bool)\n  >>> jnp.array_equal(jnp.array([1, 2, 3]), jnp.array([1, 2]))\n  Array(False, dtype=bool)\n  >>> jnp.array_equal(jnp.array([1, 2, 3]), jnp.array([1, 2, 4]))\n  Array(False, dtype=bool)\n  >>> jnp.array_equal(jnp.array([1, 2, float('nan')]),\n  ...                 jnp.array([1, 2, float('nan')]))\n  Array(False, dtype=bool)\n  >>> jnp.array_equal(jnp.array([1, 2, float('nan')]),\n  ...                 jnp.array([1, 2, float('nan')]), equal_nan=True)\n  Array(True, dtype=bool)",
    "std_args": [
      "a1",
      "a2",
      "equal_nan"
    ],
    "type": "function"
  },
  "array_equiv": {
    "description": "Check if two arrays are element-wise equal.\n\nJAX implementation of :func:`numpy.array_equiv`.\n\nThis function will return ``False`` if the input arrays cannot be broadcasted\nto the same shape.\n\nArgs:\n  a1: first input array to compare.\n  a2: second input array to compare.\n\nReturns:\n  Boolean scalar array indicating whether the input arrays are\n  element-wise equal after broadcasting.\n\nSee Also:\n  - :func:`jax.numpy.allclose`\n  - :func:`jax.numpy.array_equal`\n\nExamples:\n  >>> jnp.array_equiv(jnp.array([1, 2, 3]), jnp.array([1, 2, 3]))\n  Array(True, dtype=bool)\n  >>> jnp.array_equiv(jnp.array([1, 2, 3]), jnp.array([1, 2, 4]))\n  Array(False, dtype=bool)\n  >>> jnp.array_equiv(jnp.array([[1, 2, 3], [1, 2, 3]]),\n  ...                 jnp.array([1, 2, 3]))\n  Array(True, dtype=bool)",
    "std_args": [
      "a1",
      "a2"
    ],
    "type": "function"
  },
  "array_refdef": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "array_split": {
    "description": "Split an array into sub-arrays.\n\nJAX implementation of :func:`numpy.array_split`.\n\nRefer to the documentation of :func:`jax.numpy.split` for details; ``array_split``\nis equivalent to ``split``, but allows integer ``indices_or_sections`` which does\nnot evenly divide the split axis.\n\nExamples:\n  >>> x = jnp.array([1, 2, 3, 4, 5, 6, 7, 8, 9])\n  >>> chunks = jnp.array_split(x, 4)\n  >>> print(*chunks)\n  [1 2 3] [4 5] [6 7] [8 9]\n\nSee also:\n  - :func:`jax.numpy.split`: split an array along any axis.\n  - :func:`jax.numpy.vsplit`: split vertically, i.e. along axis=0\n  - :func:`jax.numpy.hsplit`: split horizontally, i.e. along axis=1\n  - :func:`jax.numpy.dsplit`: split depth-wise, i.e. along axis=2",
    "std_args": [
      "ary",
      "indices_or_sections",
      "axis"
    ],
    "type": "function"
  },
  "as_apply": {
    "description": "Return object as APPLY expression (function call, constructor, etc.)",
    "std_args": [
      "func",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "as_array": {
    "description": "Return object as ARRAY expression (array constant).",
    "std_args": [
      "obj"
    ],
    "type": "function"
  },
  "as_array_vars": {
    "description": "",
    "std_args": [
      "node",
      "only",
      "allow_duplicates"
    ],
    "type": "function"
  },
  "as_complex": {
    "description": "Return object as COMPLEX expression (complex literal constant).",
    "std_args": [
      "real",
      "imag"
    ],
    "type": "function"
  },
  "as_deref": {
    "description": "Return object as dereferencing expression.",
    "std_args": [
      "expr"
    ],
    "type": "function"
  },
  "as_eq": {
    "description": "The class representing a Python function.",
    "std_args": [
      "left",
      "right"
    ],
    "type": "function"
  },
  "as_expr": {
    "description": "Convert non-Expr objects to Expr objects.",
    "std_args": [
      "obj"
    ],
    "type": "function"
  },
  "as_factors": {
    "description": "Return expression as FACTORS expression.",
    "std_args": [
      "obj"
    ],
    "type": "function"
  },
  "as_ge": {
    "description": "The class representing a Python function.",
    "std_args": [
      "left",
      "right"
    ],
    "type": "function"
  },
  "as_gt": {
    "description": "The class representing a Python function.",
    "std_args": [
      "left",
      "right"
    ],
    "type": "function"
  },
  "as_hijax_vars": {
    "description": "",
    "std_args": [
      "node",
      "only",
      "allow_duplicates"
    ],
    "type": "function"
  },
  "as_immutable_vars": {
    "description": "",
    "std_args": [
      "node",
      "only",
      "allow_duplicates"
    ],
    "type": "function"
  },
  "as_integer": {
    "description": "Return object as INTEGER constant.",
    "std_args": [
      "obj",
      "kind"
    ],
    "type": "function"
  },
  "as_integer_ratio": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "as_latex": {
    "description": "The class representing a Python function.",
    "std_args": [
      "obj"
    ],
    "type": "function"
  },
  "as_le": {
    "description": "The class representing a Python function.",
    "std_args": [
      "left",
      "right"
    ],
    "type": "function"
  },
  "as_linear": {
    "description": "Call the embedding layer as a linear layer.",
    "std_args": [
      "self",
      "x"
    ],
    "type": "function"
  },
  "as_lt": {
    "description": "The class representing a Python function.",
    "std_args": [
      "left",
      "right"
    ],
    "type": "function"
  },
  "as_mutable_vars": {
    "description": "",
    "std_args": [
      "node",
      "only",
      "allow_duplicates"
    ],
    "type": "function"
  },
  "as_ne": {
    "description": "The class representing a Python function.",
    "std_args": [
      "left",
      "right"
    ],
    "type": "function"
  },
  "as_number": {
    "description": "Return object as INTEGER or REAL constant.",
    "std_args": [
      "obj",
      "kind"
    ],
    "type": "function"
  },
  "as_numer_denom": {
    "description": "Return expression as numer-denom pair.",
    "std_args": [
      "obj"
    ],
    "type": "function"
  },
  "as_pytree_vars": {
    "description": "",
    "std_args": [
      "node",
      "only",
      "allow_duplicates"
    ],
    "type": "function"
  },
  "as_real": {
    "description": "Return object as REAL constant.",
    "std_args": [
      "obj",
      "kind"
    ],
    "type": "function"
  },
  "as_ref": {
    "description": "Return object as referencing expression.",
    "std_args": [
      "expr"
    ],
    "type": "function"
  },
  "as_ref_vars": {
    "description": "Converts a Variable or structure of Variables to Variables with `has_ref=True`.",
    "std_args": [
      "node",
      "only",
      "allow_duplicates"
    ],
    "type": "function"
  },
  "as_series": {
    "description": "Return argument as a list of 1-d arrays.",
    "std_args": [
      "alist",
      "trim"
    ],
    "type": "function"
  },
  "as_strided": {
    "description": "as_strided(a: array, /, shape: Optional[Sequence[int]] = None, strides: Optional[Sequence[int]] = None, offset: int = 0, *, stream: Union[None, Stream, Device] = None) -> array",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "as_strided_writeable": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "as_string": {
    "description": "Return object as STRING expression (string literal constant).",
    "std_args": [
      "obj",
      "kind"
    ],
    "type": "function"
  },
  "as_symbol": {
    "description": "Return object as SYMBOL expression (variable or unparsed expression).",
    "std_args": [
      "obj"
    ],
    "type": "function"
  },
  "as_term_coeff": {
    "description": "Return expression as term-coefficient pair.",
    "std_args": [
      "obj"
    ],
    "type": "function"
  },
  "as_terms": {
    "description": "Return expression as TERMS expression.",
    "std_args": [
      "obj"
    ],
    "type": "function"
  },
  "as_ternary": {
    "description": "Return object as TERNARY expression (cond?expr1:expr2).",
    "std_args": [
      "cond",
      "expr1",
      "expr2"
    ],
    "type": "function"
  },
  "as_text": {
    "description": "A human-readable text representation of this lowering.",
    "std_args": [
      "self",
      "dialect",
      "debug_info"
    ],
    "type": "function"
  },
  "as_tuple": {
    "description": "Returns a tuple of the attributes of the BlockMask.",
    "std_args": [
      "self",
      "flatten"
    ],
    "type": "function"
  },
  "asanyarray": {
    "description": "Convert the input to a masked array, conserving subclasses.",
    "std_args": [
      "a",
      "dtype",
      "order"
    ],
    "type": "function"
  },
  "asmatrix": {
    "description": "Interpret the input as a matrix.",
    "std_args": [
      "data",
      "dtype"
    ],
    "type": "function"
  },
  "assert_all": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "assert_almost_equal": {
    "description": "Asserts that two items are almost equal.",
    "std_args": [
      "actual",
      "desired",
      "decimal",
      "err_msg",
      "verbose"
    ],
    "type": "function"
  },
  "assert_array_almost_equal": {
    "description": "Checks the equality of two masked arrays, up to given number odecimals.",
    "std_args": [
      "x",
      "y",
      "decimal",
      "err_msg",
      "verbose"
    ],
    "type": "function"
  },
  "assert_array_approx_equal": {
    "description": "Checks the equality of two masked arrays, up to given number odecimals.",
    "std_args": [
      "x",
      "y",
      "decimal",
      "err_msg",
      "verbose"
    ],
    "type": "function"
  },
  "assert_array_compare": {
    "description": "Asserts that comparison between two masked arrays is satisfied.",
    "std_args": [
      "comparison",
      "x",
      "y",
      "err_msg",
      "verbose",
      "header",
      "fill_value"
    ],
    "type": "function"
  },
  "assert_array_equal": {
    "description": "Checks the elementwise equality of two masked arrays.",
    "std_args": [
      "x",
      "y",
      "err_msg",
      "verbose"
    ],
    "type": "function"
  },
  "assert_array_less": {
    "description": "Checks that x is smaller than y elementwise.",
    "std_args": [
      "x",
      "y",
      "err_msg",
      "verbose"
    ],
    "type": "function"
  },
  "assert_close": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "assert_equal": {
    "description": "Asserts that two items are equal.",
    "std_args": [
      "actual",
      "desired",
      "err_msg"
    ],
    "type": "function"
  },
  "assert_equal_": {
    "description": "The class representing a Python function.",
    "std_args": [
      "o1",
      "o2"
    ],
    "type": "function"
  },
  "assert_equal_records": {
    "description": "Asserts that two records are equal.",
    "std_args": [
      "a",
      "b"
    ],
    "type": "function"
  },
  "assert_incompatible_shapes_raise": {
    "description": "The class representing a Python function.",
    "std_args": [
      "input_shapes"
    ],
    "type": "function"
  },
  "assert_int_or_pair": {
    "description": "The class representing a Python function.",
    "std_args": [
      "arg",
      "arg_name",
      "message"
    ],
    "type": "function"
  },
  "assert_mask_equal": {
    "description": "Asserts the equality of two masks.",
    "std_args": [
      "m1",
      "m2",
      "err_msg"
    ],
    "type": "function"
  },
  "assert_mt19937_state_equal": {
    "description": "The class representing a Python function.",
    "std_args": [
      "a",
      "b"
    ],
    "type": "function"
  },
  "assert_not_equal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "assert_poly_almost_equal": {
    "description": "The class representing a Python function.",
    "std_args": [
      "p1",
      "p2",
      "msg"
    ],
    "type": "function"
  },
  "assert_same_as_ufunc": {
    "description": "The class representing a Python function.",
    "std_args": [
      "shape0",
      "shape1",
      "transposed",
      "flipped"
    ],
    "type": "function"
  },
  "assert_shapes_correct": {
    "description": "The class representing a Python function.",
    "std_args": [
      "input_shapes",
      "expected_shape"
    ],
    "type": "function"
  },
  "assert_startswith": {
    "description": "The class representing a Python function.",
    "std_args": [
      "a",
      "b"
    ],
    "type": "function"
  },
  "assert_state_equal": {
    "description": "The class representing a Python function.",
    "std_args": [
      "actual",
      "target"
    ],
    "type": "function"
  },
  "assert_warn_len_equal": {
    "description": "The class representing a Python function.",
    "std_args": [
      "mod",
      "n_in_context"
    ],
    "type": "function"
  },
  "assign_fields_by_name": {
    "description": "Assigns values from one structured array to another by field name.",
    "std_args": [
      "dst",
      "src",
      "zero_unassigned"
    ],
    "type": "function"
  },
  "associative_scan": {
    "description": "Performs a scan with an associative binary operation, in parallel.\n\nThis operation his similar to `scan`, with the key difference that\n`associative_scan` is a parallel implementation with\npotentially significant performance benefits, especially when jit compiled.\nThe catch is that it can only be used when `f` is a binary associative\noperation (i.e. it must verify `f(a, f(b, c)) == f(f(a, b), c)`).\n\nFor an introduction to associative scans, refer to this paper:\nBlelloch, Guy E. 1990.\n[Prefix Sums and Their Applications](\n    https://www.cs.cmu.edu/~guyb/papers/Ble93.pdf).\n\nArgs:\n    f: A Python callable implementing an associative binary operation with\n        signature `r = f(a, b)`. Function `f` must be associative, i.e.,\n        it must satisfy the equation\n        `f(a, f(b, c)) == f(f(a, b), c)`.\n        The inputs and result are (possibly nested Python tree structures\n        of) array(s) matching `elems`. Each array has a dimension in place\n        of the `axis` dimension. `f` should be applied elementwise over\n        the `axis` dimension.\n        The result `r` has the same shape (and structure) as the\n        two inputs `a` and `b`.\n    elems: A (possibly nested Python tree structure of) array(s), each with\n        an `axis` dimension of size `num_elems`.\n    reverse: A boolean stating if the scan should be reversed with respect\n        to the `axis` dimension.\n    axis: an integer identifying the axis over which the scan should occur.\n\nReturns:\n    A (possibly nested Python tree structure of) array(s) of the same shape\n    and structure as `elems`, in which the `k`'th element of `axis` is\n    the result of recursively applying `f` to combine the first `k`\n    elements of `elems` along `axis`. For example, given\n    `elems = [a, b, c, ...]`, the result would be\n    `[a, f(a, b), f(f(a, b), c), ...]`.\n\nExamples:\n\n>>> sum_fn = lambda x, y: x + y\n>>> xs = keras.ops.arange(5)\n>>> ys = keras.ops.associative_scan(sum_fn, xs, axis=0)\n>>> ys\n[0, 1, 3, 6, 10]\n\n>>> sum_fn = lambda x, y: [x[0] + y[0], x[1] + y[1], x[2] + y[2]]\n>>> xs = [keras.ops.array([[1, 2]]) for _ in range(3)]\n>>> ys = keras.ops.associative_scan(sum_fn, xs, axis=0)\n>>> ys\n[[1, 3], [1, 3], [1, 3]]",
    "std_args": [
      "f",
      "elems",
      "reverse",
      "axis"
    ],
    "type": "function"
  },
  "assubr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "async_eval": {
    "description": "async_eval(*args)",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "at": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "a",
      "indices",
      "b"
    ],
    "type": "attribute"
  },
  "atleast_1d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "atleast_2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "atleast_3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "attend": {
    "description": "Attend over the embedding using a query array.",
    "std_args": [
      "self",
      "query"
    ],
    "type": "function"
  },
  "attention_fn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "attr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "class"
  },
  "attr_priorities": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "attributes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "attrs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "aux_rules": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "average": {
    "description": "Compute the weighed average.\n\nJAX Implementation of :func:`numpy.average`.\n\nArgs:\n  a: array to be averaged\n  axis: an optional integer or sequence of integers specifying the axis along which\n    the mean to be computed. If not specified, mean is computed along all the axes.\n  weights: an optional array of weights for a weighted average. This must either exactly\n    match the shape of `a`, or if `axis` is specified, it must have shape ``a.shape[axis]``\n    for a single axis, or shape ``tuple(a.shape[ax] for ax in axis)`` for multiple axes.\n  returned: If False (default) then return only the average. If True then return both\n    the average and the normalization factor (i.e. the sum of weights).\n  keepdims: If True, reduced axes are left in the result with size 1. If False (default)\n    then reduced axes are squeezed out.\n\nReturns:\n  An array ``average`` or tuple of arrays ``(average, normalization)`` if\n  ``returned`` is True.\n\nSee also:\n  - :func:`jax.numpy.mean`: unweighted mean.\n\nExamples:\n  Simple average:\n\n  >>> x = jnp.array([1, 2, 3, 2, 4])\n  >>> jnp.average(x)\n  Array(2.4, dtype=float32)\n\n  Weighted average:\n\n  >>> weights = jnp.array([2, 1, 3, 2, 2])\n  >>> jnp.average(x, weights=weights)\n  Array(2.5, dtype=float32)\n\n  Use ``returned=True`` to optionally return the normalization, i.e. the\n  sum of weights:\n\n  >>> jnp.average(x, returned=True)\n  (Array(2.4, dtype=float32), Array(5., dtype=float32))\n  >>> jnp.average(x, weights=weights, returned=True)\n  (Array(2.5, dtype=float32), Array(10., dtype=float32))\n\n  Weighted average along a specified axis:\n\n  >>> x = jnp.array([[8, 2, 7],\n  ...                [3, 6, 4]])\n  >>> weights = jnp.array([1, 2, 3])\n  >>> jnp.average(x, weights=weights, axis=1)\n  Array([5.5, 4.5], dtype=float32)",
    "std_args": [
      "a",
      "axis",
      "weights",
      "returned",
      "keepdims"
    ],
    "type": "function"
  },
  "average_gradients": {
    "description": "Average the gradients across the distributed processes in the passed group.",
    "std_args": [
      "gradients",
      "group",
      "all_reduce_size",
      "communication_type",
      "communication_stream"
    ],
    "type": "function"
  },
  "average_pool": {
    "description": "Average pooling operation.\n\nArgs:\n    inputs: Tensor of rank N+2. `inputs` has shape\n        `(batch_size,) + inputs_spatial_shape + (num_channels,)` if\n        `data_format=\"channels_last\"`, or\n        `(batch_size, num_channels) + inputs_spatial_shape` if\n        `data_format=\"channels_first\"`. Pooling happens over the spatial\n        dimensions only.\n    pool_size: int or tuple/list of integers of size\n        `len(inputs_spatial_shape)`, specifying the size of the pooling\n        window for each spatial dimension of the input tensor. If\n        `pool_size` is int, then every spatial dimension shares the same\n        `pool_size`.\n    strides: int or tuple/list of integers of size\n        `len(inputs_spatial_shape)`. The stride of the sliding window for\n        each spatial dimension of the input tensor. If `strides` is int,\n        then every spatial dimension shares the same `strides`.\n    padding: string, either `\"valid\"` or `\"same\"`. `\"valid\"` means no\n        padding is applied, and `\"same\"` results in padding evenly to the\n        left/right or up/down of the input such that output has the\n        same height/width dimension as the input when `strides=1`.\n    data_format: A string, either `\"channels_last\"` or `\"channels_first\"`.\n        `data_format` determines the ordering of the dimensions in the\n        inputs. If `data_format=\"channels_last\"`, `inputs` is of shape\n        `(batch_size, ..., channels)` while if\n        `data_format=\"channels_first\"`, `inputs` is of shape\n        `(batch_size, channels, ...)`.\n\nReturns:\n    A tensor of rank N+2, the result of the average pooling operation.",
    "std_args": [
      "inputs",
      "pool_size",
      "strides",
      "padding",
      "data_format"
    ],
    "type": "function"
  },
  "avg_pool1d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "avg_pool2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "avg_pool3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "axes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "axis": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "axis_index_groups": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "axis_name": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "backup_keys": {
    "description": "The class representing a Python function.",
    "std_args": [
      "node"
    ],
    "type": "function"
  },
  "backups": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "backward_rnn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bad_version_magic": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "badnames": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ball": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bartlett": {
    "description": "Return a Bartlett window of size M.\n\nJAX implementation of :func:`numpy.bartlett`.\n\nArgs:\n  M: The window size.\n\nReturns:\n  An array of size M containing the Bartlett window.\n\nExamples:\n  >>> with jnp.printoptions(precision=2, suppress=True):\n  ...   print(jnp.bartlett(4))\n  [0.   0.67 0.67 0.  ]\n\nSee also:\n  - :func:`jax.numpy.blackman`: return a Blackman window of size M.\n  - :func:`jax.numpy.hamming`: return a Hamming window of size M.\n  - :func:`jax.numpy.hanning`: return a Hanning window of size M.\n  - :func:`jax.numpy.kaiser`: return a Kaiser window of size M.",
    "std_args": [
      "M"
    ],
    "type": "function"
  },
  "base": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "baseclass": {
    "description": "Class of the underlying data (read-only).",
    "std_args": [],
    "type": "attribute"
  },
  "basic": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "basic_arrays": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "basis_name": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "batch_axis": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "batch_first": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "batch_norm": {
    "description": "Apply Batch Normalization for each channel across a batch of data.",
    "std_args": [
      "input",
      "running_mean",
      "running_var",
      "weight",
      "bias",
      "training",
      "momentum",
      "eps"
    ],
    "type": "function"
  },
  "batch_normalization": {
    "description": "Normalizes `x` by `mean` and `variance`.\n\nThis op is typically used by the batch normalization step in a neural\nnetwork. It normalizes the input tensor along the given axis.\n\nArgs:\n    x: Input tensor.\n    mean: A mean vector of the same length as the `axis` dimension of the\n        input thensor.\n    variance: A variance vector of the same length as the `axis` dimension\n        of the input tensor.\n    axis: Integer, the axis that should be normalized.\n    offset: An offset vector of the same length as the `axis` dimension of\n        the input tensor. If not `None`, `offset` is added to the normalized\n        tensor. Defaults to `None`.\n    scale: A scale vector of the same length as the `axis` dimension of the\n        input tensor. If not `None`, the normalized tensor is multiplied by\n        `scale`. Defaults to `None`.\n    epsilon: Small float added to variance to avoid dividing by zero.\n        Defaults to 1e-3.\n\nReturns:\n    The normalized tensor.\n\nExample:\n\n>>> x = keras.ops.convert_to_tensor(\n...     [[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]]\n... )\n>>> keras.ops.batch_normalization(\n...     x,\n...     mean=[0.4, 0.5, 0.6],\n...     variance=[0.67, 0.67, 0.67],\n...     axis=-1\n... )\narray([[-3.6624e-01, -3.6624e-01, -3.6624e-01],\n       [-4.6445e-09,  0.0000e+00, -1.8578e-08],\n       [ 3.6624e-01,  3.6624e-01,  3.6624e-01]])",
    "std_args": [
      "x",
      "mean",
      "variance",
      "axis",
      "offset",
      "scale",
      "epsilon"
    ],
    "type": "function"
  },
  "batch_shape": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "batch_sizes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "batch_stats": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "beforethisafter": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "beginpattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "beginpattern77": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "beginpattern90": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bessel_j0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bessel_j1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bessel_y0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bessel_y1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "beta": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "beta_1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "betas": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bfloat16": {
    "description": "Casts all floating point parameters and buffers to ``bfloat16`` datatype.",
    "std_args": [
      "self"
    ],
    "type": "attribute"
  },
  "bhn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bias": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bias_correction": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bias_hh": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bias_ih": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bias_k": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bias_shape": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bias_v": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "biases": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "binary_cross_entropy": {
    "description": "Compute Binary Cross Entropy between the target and input probabilities.",
    "std_args": [
      "input",
      "target",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "binary_cross_entropy_with_logits": {
    "description": "Compute Binary Cross Entropy between target and input logits.",
    "std_args": [
      "input",
      "target",
      "weight",
      "size_average",
      "reduce",
      "reduction",
      "pos_weight"
    ],
    "type": "function"
  },
  "bincount": {
    "description": "Count the number of occurrences of each value in an integer array.\n\nJAX implementation of :func:`numpy.bincount`.\n\nFor an array of non-negative integers ``x``, this function returns an array ``counts``\nof size ``x.max() + 1``, such that ``counts[i]`` contains the number of occurrences\nof the value ``i`` in ``x``.\n\nThe JAX version has a few differences from the NumPy version:\n\n- In NumPy, passing an array ``x`` with negative entries will result in an error.\n  In JAX, negative values are clipped to zero.\n- JAX adds an optional ``length`` parameter which can be used to statically specify\n  the length of the output array so that this function can be used with transformations\n  like :func:`jax.jit`. In this case, items larger than `length + 1` will be dropped.\n\nArgs:\n  x : 1-dimensional array of non-negative integers\n  weights: optional array of weights associated with ``x``. If not specified, the\n    weight for each entry will be ``1``.\n  minlength: the minimum length of the output counts array.\n  length: the length of the output counts array. Must be specified statically for\n    ``bincount`` to be used with :func:`jax.jit` and other JAX transformations.\n\nReturns:\n  An array of counts or summed weights reflecting the number of occurrences of values\n  in ``x``.\n\nSee Also:\n  - :func:`jax.numpy.histogram`\n  - :func:`jax.numpy.digitize`\n  - :func:`jax.numpy.unique_counts`\n\nExamples:\n  Basic bincount:\n\n  >>> x = jnp.array([1, 1, 2, 3, 3, 3])\n  >>> jnp.bincount(x)\n  Array([0, 2, 1, 3], dtype=int32)\n\n  Weighted bincount:\n\n  >>> weights = jnp.array([1, 2, 3, 4, 5, 6])\n  >>> jnp.bincount(x, weights)\n  Array([ 0,  3,  3, 15], dtype=int32)\n\n  Specifying a static ``length`` makes this jit-compatible:\n\n  >>> jit_bincount = jax.jit(jnp.bincount, static_argnames=['length'])\n  >>> jit_bincount(x, length=5)\n  Array([0, 2, 1, 3, 0], dtype=int32)\n\n  Any negative numbers are clipped to the first bin, and numbers beyond the\n  specified ``length`` are dropped:\n\n  >>> x = jnp.array([-1, -1, 1, 3, 10])\n  >>> jnp.bincount(x, length=5)\n  Array([2, 1, 0, 1, 0], dtype=int32)",
    "std_args": [
      "x",
      "weights",
      "minlength",
      "length"
    ],
    "type": "function"
  },
  "bind": {
    "description": "The class representing a Python function.",
    "std_args": [
      "optional",
      "fn"
    ],
    "type": "function"
  },
  "binomial": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "bit_count": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "bit_generator": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bits": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bitwise_count": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bitwise_not": {
    "description": "Compute bit-wise inversion, or bit-wise NOT, element-wise.\n\nComputes the bit-wise NOT of the underlying binary representation of the\nintegers in the input arrays. This ufunc implements the C/Python operator\n`~`.\n\nArgs:\n    x: Input integer tensor.\n\nReturns:\n    Result tensor.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "blackman": {
    "description": "Return a Blackman window of size M.\n\nJAX implementation of :func:`numpy.blackman`.\n\nArgs:\n  M: The window size.\n\nReturns:\n  An array of size M containing the Blackman window.\n\nExamples:\n  >>> with jnp.printoptions(precision=2, suppress=True):\n  ...   print(jnp.blackman(4))\n  [-0.    0.63  0.63 -0.  ]\n\nSee also:\n  - :func:`jax.numpy.bartlett`: return a Bartlett window of size M.\n  - :func:`jax.numpy.hamming`: return a Hamming window of size M.\n  - :func:`jax.numpy.hanning`: return a Hanning window of size M.\n  - :func:`jax.numpy.kaiser`: return a Kaiser window of size M.",
    "std_args": [
      "M"
    ],
    "type": "function"
  },
  "blank": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "blas_fpe_check": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "block_masked_mm": {
    "description": "block_masked_mm(a: array, b: array, /, block_size: int = 64, mask_out: Optional[array] = None, mask_lhs: Optional[array] = None, mask_rhs: Optional[array] = None, *, stream: Union[None, Stream, Device] = None) -> array",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "bmat": {
    "description": "Build a matrix object from a string, nested sequence, or array.",
    "std_args": [
      "obj",
      "ldict",
      "gdict"
    ],
    "type": "function"
  },
  "bool_": {
    "description": "A JAX scalar constructor of type bool.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "attribute"
  },
  "bound": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "args"
    ],
    "type": "function"
  },
  "broadcast": {
    "description": "Broadcasts a tensor to specified GPU devices.",
    "std_args": [
      "tensor",
      "devices",
      "out"
    ],
    "type": "class"
  },
  "broadcast_bucket_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "broadcast_buffers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "broadcast_coalesced": {
    "description": "Broadcast a sequence of tensors to the specified GPUs.",
    "std_args": [
      "tensors",
      "devices",
      "buffer_size"
    ],
    "type": "function"
  },
  "broadcast_dims": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "broadcast_dropout": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "broadcast_prefix": {
    "description": "The class representing a Python function.",
    "std_args": [
      "prefix_tree",
      "full_tree",
      "prefix_is_leaf",
      "tree_is_leaf"
    ],
    "type": "function"
  },
  "broadcast_rngs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "broadcast_shapes": {
    "description": "Broadcast input shapes to a common output shape.\n\nJAX implementation of :func:`numpy.broadcast_shapes`. JAX uses NumPy-style\nbroadcasting rules, which you can read more about at `NumPy broadcasting`_.\n\nArgs:\n  shapes: 0 or more shapes specified as sequences of integers\n\nReturns:\n  The broadcasted shape as a tuple of integers.\n\nSee Also:\n  - :func:`jax.numpy.broadcast_arrays`: broadcast arrays to a common shape.\n  - :func:`jax.numpy.broadcast_to`: broadcast an array to a specified shape.\n\nExamples:\n  Some compatible shapes:\n\n  >>> jnp.broadcast_shapes((1,), (4,))\n  (4,)\n  >>> jnp.broadcast_shapes((3, 1), (4,))\n  (3, 4)\n  >>> jnp.broadcast_shapes((3, 1), (1, 4), (5, 1, 1))\n  (5, 3, 4)\n\n  Incompatible shapes:\n\n  >>> jnp.broadcast_shapes((3, 1), (4, 1))  # doctest: +IGNORE_EXCEPTION_DETAIL\n  Traceback (most recent call last):\n  ValueError: Incompatible shapes for broadcasting: shapes=[(3, 1), (4, 1)]\n\n.. _NumPy broadcasting: https://numpy.org/doc/stable/user/basics.broadcasting.html",
    "std_args": [
      "shapes"
    ],
    "type": "function"
  },
  "bucket_bytes_cap": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bucket_bytes_cap_default": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "buffers": {
    "description": "Return an iterator over module buffers.",
    "std_args": [
      "self",
      "recurse"
    ],
    "type": "function"
  },
  "build": {
    "description": "",
    "std_args": [
      "self",
      "input_shape"
    ],
    "type": "function"
  },
  "build_code": {
    "description": "Compile and import Fortran code using f2py.",
    "std_args": [
      "source_code",
      "options",
      "skip",
      "only",
      "suffix",
      "module_name"
    ],
    "type": "function"
  },
  "build_from_config": {
    "description": "Builds the layer's states with the supplied config dict.\n\nBy default, this method calls the `build(config[\"input_shape\"])` method,\nwhich creates weights based on the layer's input shape in the supplied\nconfig. If your config contains other information needed to load the\nlayer's state, you should override this method.\n\nArgs:\n    config: Dict containing the input shape associated with this layer.",
    "std_args": [
      "self",
      "config"
    ],
    "type": "function"
  },
  "build_meson": {
    "description": "Build a module via Meson and import it.",
    "std_args": [
      "source_files",
      "module_name",
      "kwargs"
    ],
    "type": "function"
  },
  "buildapi": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "buildcallback": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout",
      "um"
    ],
    "type": "function"
  },
  "buildcallbacks": {
    "description": "The class representing a Python function.",
    "std_args": [
      "m"
    ],
    "type": "function"
  },
  "buildcfuncs": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "buildhooks": {
    "description": "The class representing a Python function.",
    "std_args": [
      "m"
    ],
    "type": "function"
  },
  "buildimplicitrules": {
    "description": "The class representing a Python function.",
    "std_args": [
      "block"
    ],
    "type": "function"
  },
  "buildmodules": {
    "description": "The class representing a Python function.",
    "std_args": [
      "lst"
    ],
    "type": "function"
  },
  "buildusevar": {
    "description": "The class representing a Python function.",
    "std_args": [
      "name",
      "realname",
      "vars",
      "usemodulename"
    ],
    "type": "function"
  },
  "buildusevars": {
    "description": "The class representing a Python function.",
    "std_args": [
      "m",
      "r"
    ],
    "type": "function"
  },
  "busdaycalendar": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "weekmask",
      "holidays"
    ],
    "type": "class"
  },
  "bwd": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "byte": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "attribute"
  },
  "byteorder": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bytes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bytes_": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "byteswap": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "inplace"
    ],
    "type": "function"
  },
  "c1d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "c2buildvalue_map": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "c2capi_map": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "c2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "c2py_map": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "c2pycode_map": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "c3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "c_forward_pointer": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "c_names_dict": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cache_index": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cached": {
    "description": "Context manager that enables the caching system within parametrizations registered with :func:`register_parametrization`.",
    "std_args": [],
    "type": "function"
  },
  "cached_key": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cached_partial": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cached_value": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "caching": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "calculate_gain": {
    "description": "Return the recommended gain value for the given nonlinearity function.",
    "std_args": [
      "nonlinearity",
      "param"
    ],
    "type": "function"
  },
  "call_super_init": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "callbacks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "callcrackfortran": {
    "description": "The class representing a Python function.",
    "std_args": [
      "files",
      "options"
    ],
    "type": "function"
  },
  "called": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "callfunpattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "callnameargspattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "callpattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "canonicalize_dtype": {
    "description": "Canonicalize an optional dtype to the definitive dtype.",
    "std_args": [
      "args",
      "dtype",
      "inexact"
    ],
    "type": "function"
  },
  "canonicalize_padding": {
    "description": "\"Canonicalizes conv padding to a jax.lax supported format.",
    "std_args": [
      "padding",
      "rank"
    ],
    "type": "function"
  },
  "capsule": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "carry_init": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cast_like": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cast_types": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "categorical": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "categorical_crossentropy": {
    "description": "Computes categorical cross-entropy loss between target and output tensor.\n\nThe categorical cross-entropy loss is commonly used in multi-class\nclassification tasks where each input sample can belong to one of\nmultiple classes. It measures the dissimilarity\nbetween the target and output probabilities or logits.\n\nArgs:\n    target: The target tensor representing the true categorical labels.\n        Its shape should match the shape of the `output` tensor\n        except for the last dimension.\n    output: The output tensor representing the predicted probabilities\n        or logits. Its shape should match the shape of the `target`\n        tensor except for the last dimension.\n    from_logits: (optional) Whether `output` is a tensor of logits or\n        probabilities.\n        Set it to `True` if `output` represents logits; otherwise,\n        set it to `False` if `output` represents probabilities.\n        Defaults to `False`.\n    axis: (optional) The axis along which the categorical cross-entropy\n        is computed.\n        Defaults to `-1`, which corresponds to the last dimension of\n        the tensors.\n\nReturns:\n    Integer tensor: The computed categorical cross-entropy loss between\n    `target` and `output`.\n\nExample:\n\n>>> target = keras.ops.convert_to_tensor(\n... [[1, 0, 0],\n...  [0, 1, 0],\n...  [0, 0, 1]])\n>>> output = keras.ops.convert_to_tensor(\n... [[0.9, 0.05, 0.05],\n...  [0.1, 0.8, 0.1],\n...  [0.2, 0.3, 0.5]])\n>>> categorical_crossentropy(target, output)\narray([0.10536054 0.22314355 0.6931472 ], shape=(3,), dtype=float32)",
    "std_args": [
      "target",
      "output",
      "from_logits",
      "axis"
    ],
    "type": "function"
  },
  "cauchy": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "causal_lower_right": {
    "description": "Creates a lower-right triangular causal bias.",
    "std_args": [
      "size"
    ],
    "type": "function"
  },
  "causal_upper_left": {
    "description": "Creates an upper-left triangular causal bias.",
    "std_args": [
      "size"
    ],
    "type": "function"
  },
  "cb_arg_rules": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cb_map": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cb_rout_rules": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cb_routine_rules": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cb_routsign2map": {
    "description": "name,begintitle,endtitle,argname",
    "std_args": [
      "rout",
      "um"
    ],
    "type": "function"
  },
  "cb_sign2map": {
    "description": "The class representing a Python function.",
    "std_args": [
      "a",
      "var",
      "index"
    ],
    "type": "function"
  },
  "cbrt": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "cdll": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cdouble": {
    "description": "A JAX scalar constructor of type complex128.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "attribute"
  },
  "ceil_mode": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cell": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "celu_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cffi": {
    "description": "CFFI interface",
    "std_args": [],
    "type": "attribute"
  },
  "cformat_map": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cfuncs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chain": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "channel_shuffle": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "char": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "attribute"
  },
  "character": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "character_backward_compatibility_hook": {
    "description": "Previously, Fortran character was incorrectly treated as",
    "std_args": [
      "item",
      "parents",
      "result",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "charselector": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cheb2poly": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebadd": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebcompanion": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebder": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebdiv": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebdomain": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebfit": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebfromroots": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebgauss": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebgrid2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebgrid3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebint": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebinterpolate": {
    "description": "Interpolate a function at the Chebyshev points of the first kind.",
    "std_args": [
      "func",
      "deg",
      "args"
    ],
    "type": "function"
  },
  "chebline": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebmul": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebmulx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebone": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebpow": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebpts1": {
    "description": "Chebyshev points of the first kind.",
    "std_args": [
      "npts"
    ],
    "type": "function"
  },
  "chebpts2": {
    "description": "Chebyshev points of the second kind.",
    "std_args": [
      "npts"
    ],
    "type": "function"
  },
  "chebroots": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebsub": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebtrim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebval": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebval2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebval3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebvander": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebvander2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebvander3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebweight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebyshev_polynomial_t": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebyshev_polynomial_u": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebyshev_polynomial_v": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebyshev_polynomial_w": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebzero": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "check": {
    "description": "Run the function `do` on this test case, expanding arguments",
    "std_args": [
      "self",
      "do"
    ],
    "type": "function"
  },
  "check_all": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "a",
      "b",
      "i1",
      "i2",
      "c",
      "dt"
    ],
    "type": "function"
  },
  "check_cases": {
    "description": "Run func on each of the cases with all of the tags in require, and none",
    "std_args": [
      "self",
      "require",
      "exclude"
    ],
    "type": "function"
  },
  "check_clump": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "f"
    ],
    "type": "function"
  },
  "check_compilers": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "check_compressed": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "fopen",
      "suffixes"
    ],
    "type": "function"
  },
  "check_consistent_aliasing": {
    "description": "Check for consistent aliasing of nodes when extracting graph.",
    "std_args": [
      "node",
      "prefix",
      "node_prefixes"
    ],
    "type": "function"
  },
  "check_dir": {
    "description": "Returns a mapping of all objects with the wrong __module__ attribute.",
    "std_args": [
      "module",
      "module_name"
    ],
    "type": "function"
  },
  "check_forward_args": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "input",
      "hidden",
      "batch_sizes"
    ],
    "type": "function"
  },
  "check_fpu_mode": {
    "description": "Check FPU precision mode was not changed during the test.",
    "std_args": [
      "request"
    ],
    "type": "function"
  },
  "check_function": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "function",
      "sz"
    ],
    "type": "function"
  },
  "check_hidden_size": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "hx",
      "expected_hidden_size",
      "msg"
    ],
    "type": "function"
  },
  "check_input": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "input",
      "batch_sizes"
    ],
    "type": "function"
  },
  "check_language": {
    "description": "The class representing a Python function.",
    "std_args": [
      "lang",
      "code_snippet"
    ],
    "type": "function"
  },
  "check_numpyconfig": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "arg"
    ],
    "type": "function"
  },
  "check_pytree": {
    "description": "Checks if a pytree is valid.",
    "std_args": [
      "pytree"
    ],
    "type": "function"
  },
  "check_qr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "a"
    ],
    "type": "function"
  },
  "check_qr_stacked": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "a"
    ],
    "type": "function"
  },
  "check_roundtrips": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "a"
    ],
    "type": "function"
  },
  "check_rules": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "checker": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "checkify": {
    "description": "Reference-aware version of `jax.experimental.checkify",
    "std_args": [
      "f",
      "errors"
    ],
    "type": "function"
  },
  "checkpoint": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "children": {
    "description": "Return an iterator over immediate children modules.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "chisquare": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "choice": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "choices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cholesky_ex": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cholesky_inv": {
    "description": "Compute the inverse of a real symmetric positive semi-definite matrix using it's Cholesky decomposition.",
    "std_args": [
      "L",
      "upper",
      "stream"
    ],
    "type": "function"
  },
  "cholesky_inverse": {
    "description": "Computes the inverse of a symmetric positive-definite matrix.\n\nArgs:\n    x: Input tensor of shape `(..., M, M)`.\n    upper (bool): Determines whether to use the upper- or lower-triangular\n        factor for the internal computation. Defaults to False.\n\nReturns:\n    A tensor of shape `(..., M, M)` representing the inverse of `x`.\n\nRaises:\n    ValueError: If `x` is not a symmetric positive-definite matrix.",
    "std_args": [
      "x",
      "upper"
    ],
    "type": "function"
  },
  "choose": {
    "description": "Construct an array choosing from elements of multiple arrays.\n\nRefer to :func:`jax.numpy.choose` for the full documentation.",
    "std_args": [
      "self",
      "choices",
      "out",
      "mode"
    ],
    "type": "function"
  },
  "class_modules": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "classes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "classids": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "clear": {
    "description": "Remove all items from the ParameterDict.",
    "std_args": [
      "self"
    ],
    "type": "attribute"
  },
  "clear_cache": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "clear_non_graph_nodes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tree"
    ],
    "type": "function"
  },
  "clength": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "clip_by_block_rms": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "clip_by_global_norm": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "clip_grad_norm": {
    "description": "Clip the gradient norm of an iterable of parameters.",
    "std_args": [
      "parameters",
      "max_norm",
      "norm_type",
      "error_if_nonfinite",
      "foreach"
    ],
    "type": "function"
  },
  "clip_grad_norm_": {
    "description": "Clip the gradient norm of an iterable of parameters.",
    "std_args": [
      "parameters",
      "max_norm",
      "norm_type",
      "error_if_nonfinite",
      "foreach"
    ],
    "type": "function"
  },
  "clip_grad_value_": {
    "description": "Clip the gradients of an iterable of parameters at specified value.",
    "std_args": [
      "parameters",
      "clip_value",
      "foreach"
    ],
    "type": "function"
  },
  "clip_threshold": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "clone": {
    "description": "Create a deep copy of the given graph node.",
    "std_args": [
      "node",
      "variables"
    ],
    "type": "function"
  },
  "clongdouble": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "close": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "cls_to_become": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "clump_masked": {
    "description": "Returns a list of slices corresponding to the masked clumps of a 1-D array.",
    "std_args": [
      "a"
    ],
    "type": "function"
  },
  "clump_unmasked": {
    "description": "Return list of slices corresponding to the unmasked clumps of a 1-D array.",
    "std_args": [
      "a"
    ],
    "type": "function"
  },
  "code": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "code_template": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "coerce": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "colorized": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "column_stack": {
    "description": "Stack arrays column-wise.\n\nJAX implementation of :func:`numpy.column_stack`.\n\nFor arrays of two or more dimensions, this is equivalent to\n:func:`jax.numpy.concatenate` with ``axis=1``.\n\nArgs:\n  tup: a sequence of arrays to stack; each must have the same leading dimension.\n    Input arrays will be promoted to at least rank 2. If a single array is given\n    it will be treated equivalently to `tup = unstack(tup)`, but the implementation\n    will avoid explicit unstacking.\n  dtype: optional dtype of the resulting array. If not specified, the dtype\n    will be determined via type promotion rules described in :ref:`type-promotion`.\n\nReturns:\n  the stacked result.\n\nSee also:\n  - :func:`jax.numpy.stack`: stack along arbitrary axes\n  - :func:`jax.numpy.concatenate`: concatenation along existing axes.\n  - :func:`jax.numpy.vstack`: stack vertically, i.e. along axis 0.\n  - :func:`jax.numpy.hstack`: stack horizontally, i.e. along axis 1.\n  - :func:`jax.numpy.dstack`: stack depth-wise, i.e. along axis 2.\n\nExamples:\n  Scalar values:\n\n  >>> jnp.column_stack([1, 2, 3])\n  Array([[1, 2, 3]], dtype=int32, weak_type=True)\n\n  1D arrays:\n\n  >>> x = jnp.arange(3)\n  >>> y = jnp.ones(3)\n  >>> jnp.column_stack([x, y])\n  Array([[0., 1.],\n         [1., 1.],\n         [2., 1.]], dtype=float32)\n\n  2D arrays:\n\n  >>> x = x.reshape(3, 1)\n  >>> y = y.reshape(3, 1)\n  >>> jnp.column_stack([x, y])\n  Array([[0., 1.],\n         [1., 1.],\n         [2., 1.]], dtype=float32)",
    "std_args": [
      "tup"
    ],
    "type": "attribute"
  },
  "combine_masks": {
    "description": "Combine attention masks.",
    "std_args": [
      "masks",
      "dtype"
    ],
    "type": "function"
  },
  "comment": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "common2fortran": {
    "description": "The class representing a Python function.",
    "std_args": [
      "common",
      "tab"
    ],
    "type": "function"
  },
  "common_fill_value": {
    "description": "Return the common filling value of two masked arrays, if any.",
    "std_args": [
      "a",
      "b"
    ],
    "type": "function"
  },
  "common_notes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "common_sign2map": {
    "description": "The class representing a Python function.",
    "std_args": [
      "a",
      "var"
    ],
    "type": "function"
  },
  "commonhooks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "commonpattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "comp_state": {
    "description": "The class representing a Python function.",
    "std_args": [
      "state1",
      "state2"
    ],
    "type": "function"
  },
  "compact": {
    "description": "The class representing a Python function.",
    "std_args": [
      "f"
    ],
    "type": "function"
  },
  "compare_results": {
    "description": "Compare lists of arrays.",
    "std_args": [
      "res",
      "desired"
    ],
    "type": "function"
  },
  "compiled": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "compiler_check_f2pycli": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "compiler_ir": {
    "description": "An arbitrary object representation of this lowering.",
    "std_args": [
      "self",
      "dialect"
    ],
    "type": "function"
  },
  "compilers_checked": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "complex128": {
    "description": "A JAX scalar constructor of type complex128.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "class"
  },
  "complex64": {
    "description": "A JAX scalar constructor of type complex64.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "attribute"
  },
  "complex_": {
    "description": "A JAX scalar constructor of type complex128.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "class"
  },
  "complexfloating": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "attribute"
  },
  "compress_cols": {
    "description": "Suppress whole columns of a 2-D array that contain masked values.",
    "std_args": [
      "a"
    ],
    "type": "function"
  },
  "compress_nd": {
    "description": "Suppress slices from multiple dimensions which contain masked values.",
    "std_args": [
      "x",
      "axis"
    ],
    "type": "function"
  },
  "compress_rowcols": {
    "description": "Suppress the rows and/or columns of a 2-D array that contain",
    "std_args": [
      "x",
      "axis"
    ],
    "type": "function"
  },
  "compress_rows": {
    "description": "Suppress whole rows of a 2-D array that contain masked values.",
    "std_args": [
      "a"
    ],
    "type": "function"
  },
  "compressed": {
    "description": "Return all the non-masked data as a 1-D array.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "compute": {
    "description": "Compute and return the value of all underlying ``Metric``'s. This method",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "compute_mask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "t",
      "default_mask"
    ],
    "type": "function"
  },
  "compute_output_shape": {
    "description": "",
    "std_args": [
      "self",
      "input_shape"
    ],
    "type": "function"
  },
  "compute_output_spec": {
    "description": "",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "compute_weight": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "module"
    ],
    "type": "function"
  },
  "cond": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "conditionally_mask": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "conditionally_transform": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "conditions": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "conjugate": {
    "description": "Return the complex conjugate of the array.\n\nRefer to :func:`jax.numpy.conjugate` for the full documentation.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "consistent_subclass": {
    "description": "The class representing a Python function.",
    "std_args": [
      "out",
      "in_"
    ],
    "type": "function"
  },
  "constant_": {
    "description": "Fill the input Tensor with the value :math:`\\text{val}`.",
    "std_args": [
      "tensor",
      "val"
    ],
    "type": "function"
  },
  "constant_schedule": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "construct_input_output": {
    "description": "Construct an input/output test pair for trim_zeros",
    "std_args": [
      "self",
      "rng",
      "shape",
      "axis",
      "trim"
    ],
    "type": "function"
  },
  "consume_prefix_in_state_dict_if_present": {
    "description": "Strip the prefix in state_dict in place, if any.",
    "std_args": [
      "state_dict",
      "prefix"
    ],
    "type": "function"
  },
  "contains": {
    "description": "Check if self contains other.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "function"
  },
  "containscommon": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "containsderivedtypes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "containspattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "contiguous": {
    "description": "contiguous(a: array, /, allow_col_major: bool = False, *, stream: Union[None, Stream, Device] = None) -> array",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "control_delta_method": {
    "description": "The control delta covariant method.",
    "std_args": [
      "function"
    ],
    "type": "function"
  },
  "control_variates_jacobians": {
    "description": "Obtain jacobians using control variates.",
    "std_args": [
      "function",
      "control_variate_from_function",
      "grad_estimator",
      "params",
      "dist_builder",
      "rng",
      "num_samples",
      "control_variate_state",
      "estimate_cv_coeffs",
      "estimate_cv_coeffs_num_samples"
    ],
    "type": "function"
  },
  "conv1d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "conv1d_input": {
    "description": "Compute the gradient of conv1d with respect to the input of the convolution.",
    "std_args": [
      "input_size",
      "weight",
      "grad_output",
      "stride",
      "padding",
      "dilation",
      "groups"
    ],
    "type": "function"
  },
  "conv1d_weight": {
    "description": "Compute the gradient of conv1d with respect to the weight of the convolution.",
    "std_args": [
      "input",
      "weight_size",
      "grad_output",
      "stride",
      "padding",
      "dilation",
      "groups"
    ],
    "type": "function"
  },
  "conv2d_input": {
    "description": "Compute the gradient of conv2d with respect to the input of the convolution.",
    "std_args": [
      "input_size",
      "weight",
      "grad_output",
      "stride",
      "padding",
      "dilation",
      "groups"
    ],
    "type": "function"
  },
  "conv2d_weight": {
    "description": "Compute the gradient of conv2d with respect to the weight of the convolution.",
    "std_args": [
      "input",
      "weight_size",
      "grad_output",
      "stride",
      "padding",
      "dilation",
      "groups"
    ],
    "type": "function"
  },
  "conv3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "conv3d_input": {
    "description": "Compute the gradient of conv3d with respect to the input of the convolution.",
    "std_args": [
      "input_size",
      "weight",
      "grad_output",
      "stride",
      "padding",
      "dilation",
      "groups"
    ],
    "type": "function"
  },
  "conv3d_weight": {
    "description": "Compute the gradient of conv3d with respect to the weight of the convolution.",
    "std_args": [
      "input",
      "weight_size",
      "grad_output",
      "stride",
      "padding",
      "dilation",
      "groups"
    ],
    "type": "function"
  },
  "conv_general": {
    "description": "conv_general(input: array, weight: array, /, stride: Union[int, Sequence[int]] = 1, padding: Union[int, Sequence[int], tuple[Sequence[int], Sequence[int]]] = 0, kernel_dilation: Union[int, Sequence[int]] = 1, input_dilation: Union[int, Sequence[int]] = 1, groups: int = 1, flip: bool = False, *, stream: Union[None, Stream, Device] = None) -> array",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "conv_general_dilated": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "conv_tbc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "conv_transpose": {
    "description": "General N-D convolution transpose.\n\nAlso known as de-convolution. This ops supports 1D, 2D and 3D convolution.\n\nArgs:\n    inputs: Tensor of rank N+2. `inputs` has shape\n        `(batch_size,) + inputs_spatial_shape + (num_channels,)` if\n        `data_format=\"channels_last\"`, or\n        `(batch_size, num_channels) + inputs_spatial_shape` if\n        `data_format=\"channels_first\"`.\n    kernel: Tensor of rank N+2. `kernel` has shape\n        [kernel_spatial_shape, num_output_channels, num_input_channels],\n        `num_input_channels` should match the number of channels in\n        `inputs`.\n    strides: int or int tuple/list of `len(inputs_spatial_shape)`,\n        specifying the strides of the convolution along each spatial\n        dimension. If `strides` is int, then every spatial dimension shares\n        the same `strides`.\n    padding: string, either `\"valid\"` or `\"same\"`. `\"valid\"` means no\n        padding is applied, and `\"same\"` results in padding evenly to the\n        left/right or up/down of the input such that output has the\n        same height/width dimension as the input when `strides=1`.\n    output_padding: int or int tuple/list of `len(inputs_spatial_shape)`,\n        specifying the amount of padding along the height and width of\n        the output tensor. Can be a single integer to specify the same\n        value for all spatial dimensions. The amount of output padding\n        along a given dimension must be lower than the stride along that\n        same dimension. If set to `None` (default), the output shape is\n        inferred.\n    data_format: A string, either `\"channels_last\"` or `\"channels_first\"`.\n        `data_format` determines the ordering of the dimensions in the\n        inputs. If `data_format=\"channels_last\"`, `inputs` is of shape\n        `(batch_size, ..., channels)` while if\n        `data_format=\"channels_first\"`, `inputs` is of shape\n        `(batch_size, channels, ...)`.\n    dilation_rate: int or int tuple/list of `len(inputs_spatial_shape)`,\n        specifying the dilation rate to use for dilated convolution. If\n        `dilation_rate` is int, then every spatial dimension shares\n        the same `dilation_rate`.\n\nReturns:\n    A tensor of rank N+2, the result of the conv operation.",
    "std_args": [
      "inputs",
      "kernel",
      "strides",
      "padding",
      "output_padding",
      "data_format",
      "dilation_rate"
    ],
    "type": "function"
  },
  "conv_transpose1d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "conv_transpose2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "conv_transpose3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "convert_conv2d_weight_memory_format": {
    "description": "Convert ``memory_format`` of ``nn.Conv2d.weight`` to ``memory_format``.",
    "std_args": [
      "module",
      "memory_format"
    ],
    "type": "function"
  },
  "convert_conv3d_weight_memory_format": {
    "description": "Convert ``memory_format`` of ``nn.Conv3d.weight`` to ``memory_format``",
    "std_args": [
      "module",
      "memory_format"
    ],
    "type": "function"
  },
  "convert_sync_batchnorm": {
    "description": "Converts all :attr:`BatchNorm*D` layers in the model to :class:`torch.nn.SyncBatchNorm` layers.",
    "std_args": [
      "cls",
      "module",
      "process_group"
    ],
    "type": "function"
  },
  "convert_to_numpy": {
    "description": "Convert a tensor to a NumPy array.\n\nArgs:\n    x: A tensor.\n\nReturns:\n    A NumPy array.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "convert_to_tensor": {
    "description": "Convert a NumPy array or Python array to a tensor.\n\nNative tensors for the current backend or left unchanged unless the `dtype`,\n`sparse` or `ragged` arguments are set.\n\nArgs:\n    x: A NumPy array, Python array (can be nested) or a backend tensor.\n    dtype: The target type. If `None`, the type of `x` is used.\n    sparse: Whether to keep sparse tensors. `False` will cause sparse\n        tensors to be densified. The default value of `None` means that\n        sparse tensors are kept only if the backend supports them.\n    ragged: Whether to keep ragged tensors. `False` will cause ragged\n        tensors to be densified. The default value of `None` means that\n        ragged tensors are kept only if the backend supports them.\n\nReturns:\n    A backend tensor of the specified `dtype` and sparseness.\n\nExample:\n\n>>> x = np.array([1, 2, 3])\n>>> y = keras.ops.convert_to_tensor(x)",
    "std_args": [
      "x",
      "dtype",
      "sparse",
      "ragged"
    ],
    "type": "function"
  },
  "convert_weight": {
    "description": "Convert the weight if it is from the a different backend.",
    "std_args": [
      "self",
      "weight"
    ],
    "type": "function"
  },
  "convex_kl_divergence": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "convolution_notes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "convolution_op": {
    "description": "",
    "std_args": [
      "self",
      "inputs",
      "kernel"
    ],
    "type": "function"
  },
  "convolve": {
    "description": "Returns the discrete, linear convolution of two one-dimensional sequences.",
    "std_args": [
      "a",
      "v",
      "mode",
      "propagate_mask"
    ],
    "type": "function"
  },
  "coords": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "copy": {
    "description": "Return a copy of this :class:`~torch.nn.ParameterDict` instance.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "copy_from": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "other"
    ],
    "type": "function"
  },
  "copy_to_host_async": {
    "description": "Copies an ``Array`` to the host asynchronously.\n\nFor arrays that live an an accelerator, such as a GPU or a TPU, JAX may\ncache the value of the array on the host. Normally this happens\nbehind the scenes when the value of an on-device array is requested by the\nuser, but waiting to initiate a device-to-host copy until the value is\nrequested requires that JAX block the caller while waiting for the copy to\ncomplete.\n\n``copy_to_host_async`` requests that JAX populate its on-host cache of an\narray, but does not wait for the copy to complete. This may speed up a\nfuture on-host access to the array's contents.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "corrcoef": {
    "description": "Return Pearson product-moment correlation coefficients.",
    "std_args": [
      "x",
      "y",
      "rowvar",
      "allow_masked"
    ],
    "type": "function"
  },
  "correlate": {
    "description": "Cross-correlation of two 1-dimensional sequences.",
    "std_args": [
      "a",
      "v",
      "mode",
      "propagate_mask"
    ],
    "type": "function"
  },
  "cos_first": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cosine_decay": {
    "description": "Make a cosine decay scheduler.",
    "std_args": [
      "init",
      "decay_steps",
      "end"
    ],
    "type": "function"
  },
  "cosine_decay_schedule": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cosine_distance": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cosine_embedding_loss": {
    "description": "Compute the cosine embedding loss.",
    "std_args": [
      "input1",
      "input2",
      "target",
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "cosine_onecycle_schedule": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cosine_similarity": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cosine_similarity_loss": {
    "description": "Computes the cosine similarity between the two inputs.",
    "std_args": [
      "x1",
      "x2",
      "axis",
      "eps",
      "reduction"
    ],
    "type": "function"
  },
  "cost_analysis": {
    "description": "A summary of execution cost estimates.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "count": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "count_include_pad": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "count_masked": {
    "description": "Count the number of masked elements along the given axis.",
    "std_args": [
      "arr",
      "axis"
    ],
    "type": "function"
  },
  "count_params": {
    "description": "Count the total number of scalars composing the weights.\n\nReturns:\n    An integer count.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "cov": {
    "description": "Estimate the covariance matrix.",
    "std_args": [
      "x",
      "y",
      "rowvar",
      "bias",
      "allow_masked",
      "ddof"
    ],
    "type": "function"
  },
  "cpp_dict": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cppmacros": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cpu": {
    "description": "Move all model parameters and buffers to the CPU.",
    "std_args": [
      "self"
    ],
    "type": "attribute"
  },
  "crack2fortran": {
    "description": "The class representing a Python function.",
    "std_args": [
      "block"
    ],
    "type": "function"
  },
  "crack2fortrangen": {
    "description": "The class representing a Python function.",
    "std_args": [
      "block",
      "tab",
      "as_interface"
    ],
    "type": "function"
  },
  "crackfortran": {
    "description": "The class representing a Python function.",
    "std_args": [
      "files"
    ],
    "type": "function"
  },
  "crackline": {
    "description": "reset=-1  --- initialize",
    "std_args": [
      "line",
      "reset"
    ],
    "type": "function"
  },
  "crackline_bind_1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "crackline_bindlang": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "crackline_re_1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cracktypespec": {
    "description": "The class representing a Python function.",
    "std_args": [
      "typespec",
      "selector"
    ],
    "type": "function"
  },
  "cracktypespec0": {
    "description": "The class representing a Python function.",
    "std_args": [
      "typespec",
      "ll"
    ],
    "type": "function"
  },
  "create": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "graphdef",
      "params",
      "tx",
      "step",
      "kwargs"
    ],
    "type": "function"
  },
  "create_additive_causal_mask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "N",
      "dtype"
    ],
    "type": "function"
  },
  "create_alibi_matrix": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "q_sequence_length",
      "k_sequence_length",
      "num_heads",
      "offset",
      "dtype"
    ],
    "type": "function"
  },
  "create_alibi_slope": {
    "description": "The class representing a Python function.",
    "std_args": [
      "num_heads"
    ],
    "type": "function"
  },
  "create_block_mask": {
    "description": "This function creates a block mask tuple from a mask_mod function.",
    "std_args": [
      "mask_mod",
      "B",
      "H",
      "Q_LEN",
      "KV_LEN",
      "device",
      "BLOCK_SIZE",
      "_compile"
    ],
    "type": "function"
  },
  "create_empty": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "create_mask": {
    "description": "This function creates a mask tensor from a mod_fn function.",
    "std_args": [
      "mod_fn",
      "B",
      "H",
      "Q_LEN",
      "KV_LEN",
      "device"
    ],
    "type": "function"
  },
  "create_nested_block_mask": {
    "description": "This function creates a nested tensor compatible block mask tuple from a mask_mod",
    "std_args": [
      "mask_mod",
      "B",
      "H",
      "q_nt",
      "kv_nt",
      "BLOCK_SIZE",
      "_compile"
    ],
    "type": "function"
  },
  "create_path_filters": {
    "description": "The class representing a Python function.",
    "std_args": [
      "state"
    ],
    "type": "function"
  },
  "create_value": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "value"
    ],
    "type": "function"
  },
  "create_value_hooks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "createfuncwrapper": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout",
      "signature"
    ],
    "type": "function"
  },
  "createsubrwrapper": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout",
      "signature"
    ],
    "type": "function"
  },
  "crop_images": {
    "description": "Crop `images` to a specified `height` and `width`.\n\nArgs:\n    images: Input image or batch of images. Must be 3D or 4D.\n    top_cropping: Number of columns to crop from the top.\n    left_cropping: Number of columns to crop from the left.\n    bottom_cropping: Number of columns to crop from the bottom.\n    right_cropping: Number of columns to crop from the right.\n    target_height: Height of the output images.\n    target_width: Width of the output images.\n    data_format: A string specifying the data format of the input tensor.\n        It can be either `\"channels_last\"` or `\"channels_first\"`.\n        `\"channels_last\"` corresponds to inputs with shape\n        `(batch, height, width, channels)`, while `\"channels_first\"`\n        corresponds to inputs with shape `(batch, channels, height, width)`.\n        If not specified, the value will default to\n        `keras.config.image_data_format`.\n\nReturns:\n    Cropped image or batch of images.\n\nExample:\n\n>>> images = np.reshape(np.arange(1, 28, dtype=\"float32\"), [3, 3, 3])\n>>> images[:,:,0] # print the first channel of the images\narray([[ 1.,  4.,  7.],\n       [10., 13., 16.],\n       [19., 22., 25.]], dtype=float32)\n>>> cropped_images = keras.image.crop_images(images, 0, 0, 2, 2)\n>>> cropped_images[:,:,0] # print the first channel of the cropped images\narray([[ 1.,  4.],\n       [10., 13.]], dtype=float32)",
    "std_args": [
      "images",
      "top_cropping",
      "left_cropping",
      "bottom_cropping",
      "right_cropping",
      "target_height",
      "target_width",
      "data_format"
    ],
    "type": "function"
  },
  "cross_attention": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cross_entropy": {
    "description": "Compute the cross entropy loss between input logits and target.",
    "std_args": [
      "input",
      "target",
      "weight",
      "size_average",
      "ignore_index",
      "reduce",
      "reduction",
      "label_smoothing"
    ],
    "type": "function"
  },
  "csingle": {
    "description": "A JAX scalar constructor of type complex64.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "attribute"
  },
  "ctc_decode": {
    "description": "Decodes the output of a CTC model.\n\nArgs:\n    inputs: A tensor of shape `(batch_size, max_length, num_classes)`\n        containing the logits (the output of the model).\n        They should *not* be normalized via softmax.\n    sequence_lengths: A tensor of shape `(batch_size,)` containing the\n        sequence lengths for the batch.\n    strategy: A string for the decoding strategy. Supported values are\n        `\"greedy\"` and `\"beam_search\"`.\n    beam_width: An integer scalar beam width used in beam search.\n        Defaults to 100.\n    top_paths: An integer scalar, the number of top paths to return.\n        Defaults to 1.\n    merge_repeated: A boolean scalar, whether to merge repeated\n        labels in the output. Defaults to `True`.\n    mask_index: An integer scalar, the index of the mask character in\n        the vocabulary. Defaults to `0`.\n\nReturns:\n    A tuple containing:\n    - The tensor representing the list of decoded sequences. If\n        `strategy=\"greedy\"`, the shape is `(1, batch_size, max_length)`. If\n        `strategy=\"beam_search\"`, the shape is\n        `(top_paths, batch_size, max_length)`. Note that: `-1` indicates the\n        blank label.\n    - If `strategy=\"greedy\"`, a tensor of shape `(batch_size, 1)`\n        representing the negative of the sum of the probability logits for\n        each sequence. If `strategy=\"beam_seatch\"`, a tensor of shape\n        `(batch_size, top_paths)` representing the log probability for each\n        sequence.",
    "std_args": [
      "inputs",
      "sequence_lengths",
      "strategy",
      "beam_width",
      "top_paths",
      "merge_repeated",
      "mask_index"
    ],
    "type": "function"
  },
  "ctc_loss": {
    "description": "Compute the Connectionist Temporal Classification loss.",
    "std_args": [
      "log_probs",
      "targets",
      "input_lengths",
      "target_lengths",
      "blank",
      "reduction",
      "zero_infinity"
    ],
    "type": "function"
  },
  "ctc_loss_with_forward_probs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ctxtag": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ctypes": {
    "description": "ctypes interface",
    "std_args": [],
    "type": "attribute"
  },
  "cuda": {
    "description": "Move all model parameters and buffers to the GPU.",
    "std_args": [
      "self",
      "device"
    ],
    "type": "function"
  },
  "cuda_kernel": {
    "description": "A jit-compiled custom CUDA kernel defined from a source string.",
    "std_args": [
      "name",
      "input_names",
      "output_names",
      "source",
      "header",
      "ensure_row_contiguous",
      "shared_memory"
    ],
    "type": "function"
  },
  "cummax": {
    "description": "cummax(a: array, /, axis: Optional[int] = None, *, reverse: bool = False, inclusive: bool = True, stream: Union[None, Stream, Device] = None) -> array",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "cummin": {
    "description": "cummin(a: array, /, axis: Optional[int] = None, *, reverse: bool = False, inclusive: bool = True, stream: Union[None, Stream, Device] = None) -> array",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "cumprod": {
    "description": "Return the cumulative product of the array.\n\nRefer to :func:`jax.numpy.cumprod` for the full documentation.",
    "std_args": [
      "self",
      "axis",
      "dtype",
      "out"
    ],
    "type": "function"
  },
  "cur_qdd": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "current_color": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "current_context": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "current_jax_trace": {
    "description": "Returns the Jax tracing state.",
    "std_args": [],
    "type": "function"
  },
  "current_update_context": {
    "description": "Returns the current active :class:`UpdateContext` for the given tag.",
    "std_args": [
      "tag"
    ],
    "type": "function"
  },
  "currentfilename": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "custom_from_mask": {
    "description": "Prune tensor corresponding to parameter called ``name`` in ``module`` by applying the pre-computed mask in ``mask``.",
    "std_args": [
      "module",
      "name",
      "mask"
    ],
    "type": "function"
  },
  "custom_function": {
    "description": "Set up a function for custom gradient and vmap definitions.",
    "std_args": [],
    "type": "class"
  },
  "custom_gradient": {
    "description": "Decorator to define a function with a custom gradient.\n\nThis decorator allows fine grained control over the gradients of a sequence\nfor operations. This may be useful for multiple reasons, including providing\na more efficient or numerically stable gradient for a sequence of\noperations.\n\nArgs:\n    f: Function `f(*args)` that returns a tuple\n        `(output, grad_fn)`, where:\n        - `args` is a sequence of (nested structures of) tensor inputs to\n            the function.\n        - `output` is a (nested structure of) tensor outputs of applying\n            operations in `forward_fn` to `args`.\n        - `grad_fn` is a function with the signature `grad_fn(*args,\n            upstream)` which returns a tuple of tensors the same size as\n            (flattened) `args`: the derivatives of tensors in `output` with\n            respect to the tensors in `args`. `upstream` is a tensor or\n            sequence of tensors holding the initial value gradients for each\n            tensor in `output`.\n\nReturns:\n    A function `h(*args)` which returns the same value as\n    `f(*args)[0]` and whose gradient is determined by\n    `f(*args)[1]`.\n\n\nExamples:\n\n1. Backend-agnostic example.\n\n```python\n@ops.custom_gradient\ndef log1pexp(x):\n    e = ops.exp(x)\n\n    def grad(*args, upstream=None):\n        if upstream is None:\n            (upstream,) = args\n        return ops.multiply(upstream, 1.0 - 1.0 / ops.add(1, e))\n\n    return ops.log(1 + e), grad\n```\n\nNote that the grad function that returns gradient computation\nrequires `args` as well as an `upstream` keyword argument, depending\non the backend being set. With the JAX and TensorFlow backends,\nit requires only one argument, whereas it might use the `upstream`\nargument in the case of the PyTorch backend.\n\nWhen working with TensorFlow/JAX backend, `grad(upstream)`\nis sufficient. With PyTorch, the `grad` function requires\n`*args` as well as `upstream`, e.g. `def grad(*args, upstream)`.\nFollow the previous example to use `@ops.custom_gradient` in\na way that is compatible with all backends.\n\n2. Here's JAX & TensorFlow-specific example:\n\n```python\n@ops.custom_gradient\ndef log1pexp(x):\n    e = ops.exp(x)\n    def grad(upstream):\n        return ops.multiply(upstream, 1.0 - 1.0 / ops.add(1, e))\n    return ops.log(1 + e), grad\n```\n\n3. Lastly, here's a PyTorch-specific example,\nusing `*args` & `upstream`:\n\n```python\n@ops.custom_gradient\ndef log1pexp(x):\n    e = ops.exp(x)\n    def grad(*args, upstream):\n        return ops.multiply(upstream, 1.0 - 1.0 / ops.add(1, e))\n    return ops.log(1 + e), grad\n```",
    "std_args": [
      "f"
    ],
    "type": "function"
  },
  "custom_vjp": {
    "description": "Reference aware version of",
    "std_args": [
      "fun",
      "nondiff_argnums"
    ],
    "type": "function"
  },
  "cutoffs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dampening": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "data": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "data1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "data2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "data_parallel": {
    "description": "Evaluate module(input) in parallel across the GPUs given in device_ids.",
    "std_args": [
      "module",
      "inputs",
      "device_ids",
      "output_device",
      "dim",
      "module_kwargs"
    ],
    "type": "function"
  },
  "dataclass": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "init",
      "eq",
      "order",
      "unsafe_hash",
      "match_args",
      "kw_only",
      "slots",
      "weakref_slot"
    ],
    "type": "function"
  },
  "dataiter": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "datapattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "datetime64": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "ddtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "debug": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "debug_print": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "debugcapi": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "debugoptions": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "decay_rate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "decode": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "decoder": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_a_initializer": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_b_initializer": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_bias_init": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_embed_init": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_fill_value": {
    "description": "Return the default fill value for the argument object.",
    "std_args": [
      "obj"
    ],
    "type": "function"
  },
  "default_filler": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_kernel_init": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_split_fn": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "path",
      "prefix",
      "leaf"
    ],
    "type": "function"
  },
  "default_stream": {
    "description": "default_stream(device: mlx.core.Device) -> mlx.core.Stream",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "defaultimplicitrules": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "defmod_rules": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "defvjp": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "fwd",
      "bwd",
      "symbolic_zeros"
    ],
    "type": "function"
  },
  "deg2rad": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "degrees": {
    "description": "Alias of :func:`jax.numpy.rad2deg`",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "del_metadata": {
    "description": "Delete a metadata entry for the Variable.",
    "std_args": [
      "self",
      "name"
    ],
    "type": "function"
  },
  "delete": {
    "description": "Delete entry or entries from an array.\n\nJAX implementation of :func:`numpy.delete`.\n\nArgs:\n  arr: array from which entries will be deleted.\n  obj: index, indices, or slice to be deleted.\n  axis: axis along which entries will be deleted.\n  assume_unique_indices: In case of array-like integer (not boolean) indices,\n    assume the indices are unique, and perform the deletion in a way that is\n    compatible with JIT and other JAX transformations.\n\nReturns:\n  Copy of ``arr`` with specified indices deleted.\n\nNote:\n  ``delete()`` usually requires the index specification to be static. If the\n  index is an integer array that is guaranteed to contain unique entries, you\n  may specify ``assume_unique_indices=True`` to perform the operation in a\n  manner that does not require static indices.\n\nSee also:\n  - :func:`jax.numpy.insert`: insert entries into an array.\n\nExamples:\n  Delete entries from a 1D array:\n\n  >>> a = jnp.array([4, 5, 6, 7, 8, 9])\n  >>> jnp.delete(a, 2)\n  Array([4, 5, 7, 8, 9], dtype=int32)\n  >>> jnp.delete(a, slice(1, 4))  # delete a[1:4]\n  Array([4, 8, 9], dtype=int32)\n  >>> jnp.delete(a, slice(None, None, 2))  # delete a[::2]\n  Array([5, 7, 9], dtype=int32)\n\n  Delete entries from a 2D array along a specified axis:\n\n  >>> a2 = jnp.array([[4, 5, 6],\n  ...                 [7, 8, 9]])\n  >>> jnp.delete(a2, 1, axis=1)\n  Array([[4, 6],\n         [7, 9]], dtype=int32)\n\n  Delete multiple entries via a sequence of indices:\n\n  >>> indices = jnp.array([0, 1, 3])\n  >>> jnp.delete(a, indices)\n  Array([6, 8, 9], dtype=int32)\n\n  This will fail under :func:`~jax.jit` and other transformations, because\n  the output shape cannot be known with the possibility of duplicate indices:\n\n  >>> jax.jit(jnp.delete)(a, indices)  # doctest: +IGNORE_EXCEPTION_DETAIL\n  Traceback (most recent call last):\n    ...\n  ConcretizationTypeError: Abstract tracer value encountered where concrete value is expected: traced array with shape int32[3].\n\n  If you can ensure that the indices are unique, pass ``assume_unique_indices``\n  to allow this to be executed under JIT:\n\n  >>> jit_delete = jax.jit(jnp.delete, static_argnames=['assume_unique_indices'])\n  >>> jit_delete(a, indices, assume_unique_indices=True)\n  Array([6, 8, 9], dtype=int32)",
    "std_args": [
      "arr",
      "obj",
      "axis",
      "assume_unique_indices"
    ],
    "type": "function"
  },
  "delta": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "delta_orthogonal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dense_h": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dense_i": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "depargs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "depends": {
    "description": "depends(inputs: Union[array, Sequence[array]], dependencies: Union[array, Sequence[array]])",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "depth": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "depthwise_conv": {
    "description": "General N-D depthwise convolution.\n\nThis ops supports 1D and 2D depthwise convolution.\n\nArgs:\n    inputs: Tensor of rank N+2. `inputs` has shape\n        `(batch_size,) + inputs_spatial_shape + (num_channels,)` if\n        `data_format=\"channels_last\"`, or\n        `(batch_size, num_channels) + inputs_spatial_shape` if\n        `data_format=\"channels_first\"`.\n    kernel: Tensor of rank N+2. `kernel` has shape\n        [kernel_spatial_shape, num_input_channels, num_channels_multiplier],\n        `num_input_channels` should match the number of channels in\n        `inputs`.\n    strides: int or int tuple/list of `len(inputs_spatial_shape)`,\n        specifying the strides of the convolution along each spatial\n        dimension. If `strides` is int, then every spatial dimension shares\n        the same `strides`.\n    padding: string, either `\"valid\"` or `\"same\"`. `\"valid\"` means no\n        padding is applied, and `\"same\"` results in padding evenly to the\n        left/right or up/down of the input such that output has the\n        same height/width dimension as the input when `strides=1`.\n    data_format: A string, either `\"channels_last\"` or `\"channels_first\"`.\n        `data_format` determines the ordering of the dimensions in the\n        inputs. If `data_format=\"channels_last\"`, `inputs` is of shape\n        `(batch_size, ..., channels)` while if\n        `data_format=\"channels_first\"`, `inputs` is of shape\n        `(batch_size, channels, ...)`.\n    dilation_rate: int or int tuple/list of `len(inputs_spatial_shape)`,\n        specifying the dilation rate to use for dilated convolution. If\n        `dilation_rate` is int, then every spatial dimension shares\n        the same `dilation_rate`.\n\nReturns:\n    A tensor of rank N+2, the result of the depthwise conv operation.",
    "std_args": [
      "inputs",
      "kernel",
      "strides",
      "padding",
      "data_format",
      "dilation_rate"
    ],
    "type": "function"
  },
  "dequantize": {
    "description": "dequantize(w: array, /, scales: array, biases: Optional[array] = None, group_size: Optional[int] = None, bits: Optional[int] = None, mode: str = 'affine', dtype: Optional[Dtype] = None, *, stream: Union[None, Stream, Device] = None) -> array",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "descr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "deserialize": {
    "description": "Return a Keras activation function via its config.",
    "std_args": [
      "config",
      "custom_objects"
    ],
    "type": "function"
  },
  "determineexprtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "expr",
      "vars",
      "rules"
    ],
    "type": "function"
  },
  "determineexprtype_re_1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "determineexprtype_re_2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "determineexprtype_re_3": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "determineexprtype_re_4": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "determineexprtype_re_5": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "deterministic": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "device_ids": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "device_info": {
    "description": "Get information about the GPU device and system settings.",
    "std_args": [],
    "type": "function"
  },
  "device_mesh": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "device_type": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dgelsd": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "dgeqrf": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "diag": {
    "description": "Returns the specified diagonal or constructs a diagonal array.\n\nJAX implementation of :func:`numpy.diag`.\n\nThe JAX version always returns a copy of the input, although if this is used\nwithin a JIT compilation, the compiler may avoid the copy.\n\nArgs:\n  v: Input array. Can be a 1-D array to create a diagonal matrix or a\n    2-D array to extract a diagonal.\n  k: optional, default=0. Diagonal offset. Positive values place the diagonal\n    above the main diagonal, negative values place it below the main diagonal.\n\nReturns:\n  If `v` is a 2-D array, a 1-D array containing the diagonal elements.\n  If `v` is a 1-D array, a 2-D array with the input elements placed along the\n  specified diagonal.\n\nSee also:\n  - :func:`jax.numpy.diagflat`\n  - :func:`jax.numpy.diagonal`\n\nExamples:\n  Creating a diagonal matrix from a 1-D array:\n\n  >>> jnp.diag(jnp.array([1, 2, 3]))\n  Array([[1, 0, 0],\n         [0, 2, 0],\n         [0, 0, 3]], dtype=int32)\n\n  Specifying a diagonal offset:\n\n  >>> jnp.diag(jnp.array([1, 2, 3]), k=1)\n  Array([[0, 1, 0, 0],\n         [0, 0, 2, 0],\n         [0, 0, 0, 3],\n         [0, 0, 0, 0]], dtype=int32)\n\n  Extracting a diagonal from a 2-D array:\n\n  >>> x = jnp.array([[1, 2, 3],\n  ...                [4, 5, 6],\n  ...                [7, 8, 9]])\n  >>> jnp.diag(x)\n  Array([1, 5, 9], dtype=int32)",
    "std_args": [
      "v",
      "k"
    ],
    "type": "function"
  },
  "diag_indices": {
    "description": "Return indices for accessing the main diagonal of a multidimensional array.\n\nJAX implementation of :func:`numpy.diag_indices`.\n\nArgs:\n  n: int. The size of each dimension of the square array.\n  ndim: optional, int, default=2. The number of dimensions of the array.\n\nReturns:\n  A tuple of arrays, each of length `n`, containing the indices to access\n  the main diagonal.\n\nSee also:\n  - :func:`jax.numpy.diag_indices_from`\n  - :func:`jax.numpy.diagonal`\n\nExamples:\n  >>> jnp.diag_indices(3)\n  (Array([0, 1, 2], dtype=int32), Array([0, 1, 2], dtype=int32))\n  >>> jnp.diag_indices(4, ndim=3)\n  (Array([0, 1, 2, 3], dtype=int32),\n  Array([0, 1, 2, 3], dtype=int32),\n  Array([0, 1, 2, 3], dtype=int32))",
    "std_args": [
      "n",
      "ndim"
    ],
    "type": "function"
  },
  "diag_indices_from": {
    "description": "Return indices for accessing the main diagonal of a given array.\n\nJAX implementation of :func:`numpy.diag_indices_from`.\n\nArgs:\n  arr: Input array. Must be at least 2-dimensional and have equal length along\n    all dimensions.\n\nReturns:\n  A tuple of arrays containing the indices to access the main diagonal of\n  the input array.\n\nSee also:\n  - :func:`jax.numpy.diag_indices`\n  - :func:`jax.numpy.diagonal`\n\nExamples:\n  >>> arr = jnp.array([[1, 2, 3],\n  ...                  [4, 5, 6],\n  ...                  [7, 8, 9]])\n  >>> jnp.diag_indices_from(arr)\n  (Array([0, 1, 2], dtype=int32), Array([0, 1, 2], dtype=int32))\n  >>> arr = jnp.array([[[1, 2], [3, 4]],\n  ...                  [[5, 6], [7, 8]]])\n  >>> jnp.diag_indices_from(arr)\n  (Array([0, 1], dtype=int32),\n  Array([0, 1], dtype=int32),\n  Array([0, 1], dtype=int32))",
    "std_args": [
      "arr"
    ],
    "type": "function"
  },
  "diagflat": {
    "description": "Return a 2-D array with the flattened input array laid out on the diagonal.\n\nJAX implementation of :func:`numpy.diagflat`.\n\nThis differs from `np.diagflat` for some scalar values of `v`. JAX always returns\na two-dimensional array, whereas NumPy may return a scalar depending on the type\nof `v`.\n\nArgs:\n  v: Input array. Can be N-dimensional but is flattened to 1D.\n  k: optional, default=0. Diagonal offset. Positive values place the diagonal\n    above the main diagonal, negative values place it below the main diagonal.\n\nReturns:\n  A 2D array with the input elements placed along the diagonal with the\n  specified offset (k). The remaining entries are filled with zeros.\n\nSee also:\n  - :func:`jax.numpy.diag`\n  - :func:`jax.numpy.diagonal`\n\nExamples:\n  >>> jnp.diagflat(jnp.array([1, 2, 3]))\n  Array([[1, 0, 0],\n         [0, 2, 0],\n         [0, 0, 3]], dtype=int32)\n  >>> jnp.diagflat(jnp.array([1, 2, 3]), k=1)\n  Array([[0, 1, 0, 0],\n         [0, 0, 2, 0],\n         [0, 0, 0, 3],\n         [0, 0, 0, 0]], dtype=int32)\n  >>> a = jnp.array([[1, 2],\n  ...                [3, 4]])\n  >>> jnp.diagflat(a)\n  Array([[1, 0, 0, 0],\n         [0, 2, 0, 0],\n         [0, 0, 3, 0],\n         [0, 0, 0, 4]], dtype=int32)",
    "std_args": [
      "v",
      "k"
    ],
    "type": "function"
  },
  "dict_append": {
    "description": "The class representing a Python function.",
    "std_args": [
      "d_out",
      "d_in"
    ],
    "type": "function"
  },
  "dictappend": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rd",
      "ar"
    ],
    "type": "function"
  },
  "diff_filter": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "digamma": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "digitize": {
    "description": "Returns the indices of the bins to which each value in `x` belongs.\n\nArgs:\n    x: Input array to be binned.\n    bins: Array of bins. It has to be one-dimensional and monotonically\n        increasing.\n\nReturns:\n    Output array of indices, of same shape as `x`.\n\nExample:\n>>> x = np.array([0.0, 1.0, 3.0, 1.6])\n>>> bins = np.array([0.0, 3.0, 4.5, 7.0])\n>>> keras.ops.digitize(x, bins)\narray([1, 1, 2, 1])",
    "std_args": [
      "x",
      "bins"
    ],
    "type": "function"
  },
  "dilation": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dimensionpattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dims": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dirac": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dirac_": {
    "description": "Fill the {3, 4, 5}-dimensional input `Tensor` with the Dirac delta function.",
    "std_args": [
      "tensor",
      "groups"
    ],
    "type": "function"
  },
  "dirichlet": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "disable_compile": {
    "description": "disable_compile() -> None",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "display": {
    "description": "Display the given objects using the Treescope pretty-printer.",
    "std_args": [
      "args"
    ],
    "type": "function"
  },
  "distance_function": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "div_value": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "divide_no_nan": {
    "description": "Safe element-wise division which returns 0 where the denominator is 0.\n\nArgs:\n    x1: First input tensor.\n    x2: Second input tensor.\n\nReturns:\n    The quotient `x1/x2`, element-wise, with zero where x2 is zero.",
    "std_args": [
      "x1",
      "x2"
    ],
    "type": "function"
  },
  "divisor_override": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "divmod": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "do": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "a",
      "b",
      "tags"
    ],
    "type": "function"
  },
  "do_precision": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "float_small",
      "float_large"
    ],
    "type": "function"
  },
  "do_precision_lower_bound": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "float_small",
      "float_large"
    ],
    "type": "function"
  },
  "do_precision_upper_bound": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "float_small",
      "float_large"
    ],
    "type": "function"
  },
  "do_signed_overflow_bounds": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype"
    ],
    "type": "function"
  },
  "doc_note": {
    "description": "Adds a Notes section to an existing docstring.",
    "std_args": [
      "initialdoc",
      "note"
    ],
    "type": "function"
  },
  "dolowercase": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "domain": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "donate_argnums": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dorgqr": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "dot": {
    "description": "Compute the dot product of two arrays.\n\nRefer to :func:`jax.numpy.dot` for the full documentation.",
    "std_args": [
      "self",
      "b",
      "precision",
      "preferred_element_type"
    ],
    "type": "function"
  },
  "dot_general": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dot_general_cls": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dot_product_attention": {
    "description": "Computes dot-product attention given query, key, and value.",
    "std_args": [
      "query",
      "key",
      "value",
      "bias",
      "mask",
      "broadcast_dropout",
      "dropout_rng",
      "dropout_rate",
      "deterministic",
      "dtype",
      "precision",
      "module",
      "promote_dtype",
      "is_causal"
    ],
    "type": "function"
  },
  "dot_product_attention_weights": {
    "description": "Computes dot-product attention weights given query and key.",
    "std_args": [
      "query",
      "key",
      "bias",
      "mask",
      "broadcast_dropout",
      "dropout_rng",
      "dropout_rate",
      "deterministic",
      "dtype",
      "precision",
      "module",
      "promote_dtype",
      "is_causal"
    ],
    "type": "function"
  },
  "double": {
    "description": "Casts all floating point parameters and buffers to ``double`` datatype.",
    "std_args": [
      "self"
    ],
    "type": "attribute"
  },
  "double_sided_maxwell": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "downscale_factor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "drop_fields": {
    "description": "Return a new array with fields in `drop_names` dropped.",
    "std_args": [
      "base",
      "drop_names",
      "usemask",
      "asrecarray"
    ],
    "type": "function"
  },
  "dropout1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dropout1d": {
    "description": "Randomly zero out entire channels (a channel is a 1D feature map).",
    "std_args": [
      "input",
      "p",
      "training",
      "inplace"
    ],
    "type": "function"
  },
  "dropout2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dropout2d": {
    "description": "Randomly zero out entire channels (a channel is a 2D feature map).",
    "std_args": [
      "input",
      "p",
      "training",
      "inplace"
    ],
    "type": "function"
  },
  "dropout3": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dropout3d": {
    "description": "Randomly zero out entire channels (a channel is a 3D feature map).",
    "std_args": [
      "input",
      "p",
      "training",
      "inplace"
    ],
    "type": "function"
  },
  "dropout_rate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dsplit": {
    "description": "Split an array into sub-arrays depth-wise.\n\nJAX implementation of :func:`numpy.dsplit`.\n\nRefer to the documentation of :func:`jax.numpy.split` for details. ``dsplit`` is\nequivalent to ``split`` with ``axis=2``.\n\nExamples:\n\n  >>> x = jnp.arange(12).reshape(3, 1, 4)\n  >>> print(x)\n  [[[ 0  1  2  3]]\n  <BLANKLINE>\n   [[ 4  5  6  7]]\n  <BLANKLINE>\n   [[ 8  9 10 11]]]\n  >>> x1, x2 = jnp.dsplit(x, 2)\n  >>> print(x1)\n  [[[0 1]]\n  <BLANKLINE>\n   [[4 5]]\n  <BLANKLINE>\n   [[8 9]]]\n  >>> print(x2)\n  [[[ 2  3]]\n  <BLANKLINE>\n   [[ 6  7]]\n  <BLANKLINE>\n   [[10 11]]]\n\nSee also:\n  - :func:`jax.numpy.split`: split an array along any axis.\n  - :func:`jax.numpy.vsplit`: split vertically, i.e. along axis=0\n  - :func:`jax.numpy.hsplit`: split horizontally, i.e. along axis=1\n  - :func:`jax.numpy.array_split`: like ``split``, but allows ``indices_or_sections``\n    to be an integer that does not evenly divide the size of the array.",
    "std_args": [
      "ary",
      "indices_or_sections"
    ],
    "type": "function"
  },
  "dstack": {
    "description": "Stack arrays depth-wise.\n\nJAX implementation of :func:`numpy.dstack`.\n\nFor arrays of three or more dimensions, this is equivalent to\n:func:`jax.numpy.concatenate` with ``axis=2``.\n\nArgs:\n  tup: a sequence of arrays to stack; each must have the same shape along all\n    but the third axis. Input arrays will be promoted to at least rank 3. If a\n    single array is given it will be treated equivalently to `tup = unstack(tup)`,\n    but the implementation will avoid explicit unstacking.\n  dtype: optional dtype of the resulting array. If not specified, the dtype\n    will be determined via type promotion rules described in :ref:`type-promotion`.\n\nReturns:\n  the stacked result.\n\nSee also:\n  - :func:`jax.numpy.stack`: stack along arbitrary axes\n  - :func:`jax.numpy.concatenate`: concatenation along existing axes.\n  - :func:`jax.numpy.vstack`: stack vertically, i.e. along axis 0.\n  - :func:`jax.numpy.hstack`: stack horizontally, i.e. along axis 1.\n\nExamples:\n  Scalar values:\n\n  >>> jnp.dstack([1, 2, 3])\n  Array([[[1, 2, 3]]], dtype=int32, weak_type=True)\n\n  1D arrays:\n\n  >>> x = jnp.arange(3)\n  >>> y = jnp.ones(3)\n  >>> jnp.dstack([x, y])\n  Array([[[0., 1.],\n          [1., 1.],\n          [2., 1.]]], dtype=float32)\n\n  2D arrays:\n\n  >>> x = x.reshape(1, 3)\n  >>> y = y.reshape(1, 3)\n  >>> jnp.dstack([x, y])\n  Array([[[0., 1.],\n          [1., 1.],\n          [2., 1.]]], dtype=float32)",
    "std_args": [
      "tup",
      "dtype"
    ],
    "type": "attribute"
  },
  "dt1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dt2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dt3": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dt4": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dt5": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dt6": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dtnoinv": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dump_patches": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "eager_shard_stack": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ediff1d": {
    "description": "Compute the differences between consecutive elements of an array.",
    "std_args": [
      "arr",
      "to_end",
      "to_begin"
    ],
    "type": "function"
  },
  "eig": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "eigvals": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "einsum_op": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "einsum_path": {
    "description": "Evaluates the optimal contraction path without evaluating the einsum.\n\nJAX implementation of :func:`numpy.einsum_path`. This function calls into\nthe opt_einsum_ package, and makes use of its optimization routines.\n\nArgs:\n  subscripts: string containing axes names separated by commas.\n  *operands: sequence of one or more arrays corresponding to the subscripts.\n  optimize: specify how to optimize the order of computation. In JAX this defaults\n    to ``\"auto\"``. Other options are ``True`` (same as ``\"optimize\"``), ``False``\n    (unoptimized), or any string supported by ``opt_einsum``, which\n    includes ``\"optimize\"``,, ``\"greedy\"``, ``\"eager\"``, and others.\n\nReturns:\n  A tuple containing the path that may be passed to :func:`~jax.numpy.einsum`, and a\n  printable object representing this optimal path.\n\nExamples:\n  >>> key1, key2, key3 = jax.random.split(jax.random.key(0), 3)\n  >>> x = jax.random.randint(key1, minval=-5, maxval=5, shape=(2, 3))\n  >>> y = jax.random.randint(key2, minval=-5, maxval=5, shape=(3, 100))\n  >>> z = jax.random.randint(key3, minval=-5, maxval=5, shape=(100, 5))\n  >>> path, path_info = jnp.einsum_path(\"ij,jk,kl\", x, y, z, optimize=\"optimal\")\n  >>> print(path)\n  [(1, 2), (0, 1)]\n  >>> print(path_info)\n        Complete contraction:  ij,jk,kl->il\n              Naive scaling:  4\n          Optimized scaling:  3\n            Naive FLOP count:  9.000e+3\n        Optimized FLOP count:  3.060e+3\n        Theoretical speedup:  2.941e+0\n        Largest intermediate:  1.500e+1 elements\n      --------------------------------------------------------------------------------\n      scaling        BLAS                current                             remaining\n      --------------------------------------------------------------------------------\n        3           GEMM              kl,jk->lj                             ij,lj->il\n        3           GEMM              lj,ij->il                                il->il\n\n  Use the computed path in :func:`~jax.numpy.einsum`:\n\n  >>> jnp.einsum(\"ij,jk,kl\", x, y, z, optimize=path)\n  Array([[-754,  324, -142,   82,   50],\n         [ 408,  -50,   87,  -29,    7]], dtype=int32)\n\n.. _opt_einsum: https://github.com/dgasmith/opt_einsum",
    "std_args": [
      "subscripts",
      "operands",
      "optimize"
    ],
    "type": "function"
  },
  "einsum_str": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "elastic_transform": {
    "description": "Applies elastic deformation to the image(s).\n\nArgs:\n    images: Input image or batch of images. Must be 3D or 4D.\n    alpha: Scaling factor that controls the intensity of the deformation.\n    sigma: Standard deviation of the Gaussian filter used for\n        smoothing the displacement fields.\n    interpolation: Interpolation method. Available methods are `\"nearest\"`,\n        and `\"bilinear\"`. Defaults to `\"bilinear\"`.\n    fill_mode: Points outside the boundaries of the input are filled\n        according to the given mode. Available methods are `\"constant\"`,\n        `\"nearest\"`, `\"wrap\"` and `\"reflect\"`. Defaults to `\"constant\"`.\n        - `\"reflect\"`: `(d c b a | a b c d | d c b a)`\n            The input is extended by reflecting about the edge of the last\n            pixel.\n        - `\"constant\"`: `(k k k k | a b c d | k k k k)`\n            The input is extended by filling all values beyond\n            the edge with the same constant value k specified by\n            `fill_value`.\n        - `\"wrap\"`: `(a b c d | a b c d | a b c d)`\n            The input is extended by wrapping around to the opposite edge.\n        - `\"nearest\"`: `(a a a a | a b c d | d d d d)`\n            The input is extended by the nearest pixel.\n    fill_value: Value used for points outside the boundaries of the input if\n        `fill_mode=\"constant\"`. Defaults to `0`.\n    data_format: A string specifying the data format of the input tensor.\n        It can be either `\"channels_last\"` or `\"channels_first\"`.\n        `\"channels_last\"` corresponds to inputs with shape\n        `(batch, height, width, channels)`, while `\"channels_first\"`\n        corresponds to inputs with shape `(batch, channels, height, width)`.\n        If not specified, the value will default to\n        `keras.config.image_data_format`.\n\nReturns:\n    Transformed image or batch of images with elastic deformation.\n\nExamples:\n\n>>> x = np.random.random((2, 64, 80, 3))  # batch of 2 RGB images\n>>> y = keras.ops.image.elastic_transform(x)\n>>> y.shape\n(2, 64, 80, 3)\n\n>>> x = np.random.random((64, 80, 3))  # single RGB image\n>>> y = keras.ops.image.elastic_transform(x)\n>>> y.shape\n(64, 80, 3)\n\n>>> x = np.random.random((2, 3, 64, 80))  # batch of 2 RGB images\n>>> y = keras.ops.image.elastic_transform(\n...     x, data_format=\"channels_first\")\n>>> y.shape\n(2, 3, 64, 80)",
    "std_args": [
      "images",
      "alpha",
      "sigma",
      "interpolation",
      "fill_mode",
      "fill_value",
      "seed",
      "data_format"
    ],
    "type": "function"
  },
  "elem_sep": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "elementwise_affine": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "eliminate_quotes": {
    "description": "Replace quoted substrings of input string.",
    "std_args": [
      "s"
    ],
    "type": "function"
  },
  "ellipsis": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "elu_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ema": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "embed_dim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "embedding_bag": {
    "description": "Compute sums, means or maxes of `bags` of embeddings.",
    "std_args": [
      "input",
      "weight",
      "offsets",
      "max_norm",
      "norm_type",
      "scale_grad_by_freq",
      "mode",
      "sparse",
      "per_sample_weights",
      "include_last_offset",
      "padding_idx"
    ],
    "type": "function"
  },
  "embedding_dim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "empty_node": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "empty_repr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "enable_compile": {
    "description": "enable_compile() -> None",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "enable_external_loop": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "enable_grad": {
    "description": "Context-manager that enables gradient calculation.",
    "op_type": "context",
    "std_args": []
  },
  "enable_lora": {
    "description": "",
    "std_args": [
      "self",
      "rank",
      "lora_alpha",
      "a_initializer",
      "b_initializer"
    ],
    "type": "function"
  },
  "enable_nested_tensor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "encoder": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "end": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "end_dim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "endifpattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "endifs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "endpattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "endpoint": {
    "description": "The class representing a Python function.",
    "std_args": [
      "request"
    ],
    "type": "function"
  },
  "entr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "entropy": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "entrypattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "eps": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "epsilon": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "eq": {
    "description": "The class representing a Python function.",
    "std_args": [
      "v",
      "w",
      "msg"
    ],
    "type": "function"
  },
  "eqmask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "m1",
      "m2"
    ],
    "type": "function"
  },
  "equal_types": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "erfc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "erfcx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "erfinv": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "err_status": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "errmess": {
    "description": "Write an error message to stderr.",
    "std_args": [
      "s"
    ],
    "type": "function"
  },
  "error_message": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "error_on_non_matrix": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "estimate_control_variate_coefficients": {
    "description": "Estimates the control variate coefficients for the given parameters.",
    "std_args": [
      "function",
      "control_variate_from_function",
      "grad_estimator",
      "params",
      "dist_builder",
      "rng",
      "num_samples",
      "control_variate_state",
      "eps"
    ],
    "type": "function"
  },
  "euler_gamma": {
    "description": "Constant: 0.5772156649015329",
    "std_args": [],
    "type": "attribute"
  },
  "eval": {
    "description": "Set the module in evaluation mode.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "eval_mode": {
    "description": "Creates a new node set to evaluation mode.",
    "std_args": [
      "node",
      "only",
      "kwargs"
    ],
    "type": "function"
  },
  "eval_shape": {
    "description": "See ``jax.eval_shape``.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "ewarn": {
    "description": "The class representing a Python function.",
    "std_args": [
      "message"
    ],
    "type": "function"
  },
  "exact": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "exp2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "expectbegin": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "expected": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "expected_pyf": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "expit": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "explicit": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "exponential": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "exponential_decay": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "export_function": {
    "description": "export_function(arg0: object, fun: collections.abc.Callable, *args, shapeless: bool = False, **kwargs) -> None",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "export_to_dot": {
    "description": "export_to_dot(file: object, *args, **kwargs) -> None",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "exporter": {
    "description": "exporter(file: str, fun: collections.abc.Callable, *, shapeless: bool = False) -> mlx.core.FunctionExporter",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "expr2name": {
    "description": "The class representing a Python function.",
    "std_args": [
      "a",
      "block",
      "args"
    ],
    "type": "function"
  },
  "extend": {
    "description": "Append values from a Python iterable to the end of the list.",
    "std_args": [
      "self",
      "values"
    ],
    "type": "function"
  },
  "externalpattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "extra_repr": {
    "description": "Return the extra representation of the module.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "extract": {
    "description": "Return the elements of an array that satisfy a condition.\n\nJAX implementation of :func:`numpy.extract`.\n\nArgs:\n  condition: array of conditions. Will be converted to boolean and flattened to 1D.\n  arr: array of values to extract. Will be flattened to 1D.\n  size: optional static size for output. Must be specified in order for ``extract``\n    to be compatible with JAX transformations like :func:`~jax.jit` or :func:`~jax.vmap`.\n  fill_value: if ``size`` is specified, fill padded entries with this value (default: 0).\n\nReturns:\n  1D array of extracted entries . If ``size`` is specified, the result will have shape\n  ``(size,)`` and be right-padded with ``fill_value``. If ``size`` is not specified,\n  the output shape will depend on the number of True entries in ``condition``.\n\nNotes:\n  This function does not require strict shape agreement between ``condition`` and ``arr``.\n  If ``condition.size > arr.size``, then ``condition`` will be truncated, and if\n  ``arr.size > condition.size``, then ``arr`` will be truncated.\n\nSee also:\n  :func:`jax.numpy.compress`: multi-dimensional version of ``extract``.\n\nExamples:\n   Extract values from a 1D array:\n\n   >>> x = jnp.array([1, 2, 3, 4, 5, 6])\n   >>> mask = (x % 2 == 0)\n   >>> jnp.extract(mask, x)\n   Array([2, 4, 6], dtype=int32)\n\n   In the simplest case, this is equivalent to boolean indexing:\n\n   >>> x[mask]\n   Array([2, 4, 6], dtype=int32)\n\n   For use with JAX transformations, you can pass the ``size`` argument to\n   specify a static shape for the output, along with an optional ``fill_value``\n   that defaults to zero:\n\n   >>> jnp.extract(mask, x, size=len(x), fill_value=0)\n   Array([2, 4, 6, 0, 0, 0], dtype=int32)\n\n   Notice that unlike with boolean indexing, ``extract`` does not require strict\n   agreement between the sizes of the array and condition, and will effectively\n   truncate both to the minimum size:\n\n   >>> short_mask = jnp.array([False, True])\n   >>> jnp.extract(short_mask, x)\n   Array([2], dtype=int32)\n   >>> long_mask = jnp.array([True, False, True, False, False, False, False, False])\n   >>> jnp.extract(long_mask, x)\n   Array([1, 3], dtype=int32)",
    "std_args": [
      "condition",
      "arr",
      "size",
      "fill_value"
    ],
    "type": "function"
  },
  "extract_patches": {
    "description": "Extracts patches from the image(s).\n\nArgs:\n    images: Input image or batch of images. Must be 3D or 4D.\n    size: Patch size int or tuple (patch_height, patch_width)\n    strides: strides along height and width. If not specified, or\n        if `None`, it defaults to the same value as `size`.\n    dilation_rate: This is the input stride, specifying how far two\n        consecutive patch samples are in the input. For value other than 1,\n        strides must be 1. NOTE: `strides > 1` is not supported in\n        conjunction with `dilation_rate > 1`\n    padding: The type of padding algorithm to use: `\"same\"` or `\"valid\"`.\n    data_format: A string specifying the data format of the input tensor.\n        It can be either `\"channels_last\"` or `\"channels_first\"`.\n        `\"channels_last\"` corresponds to inputs with shape\n        `(batch, height, width, channels)`, while `\"channels_first\"`\n        corresponds to inputs with shape `(batch, channels, height, width)`.\n        If not specified, the value will default to\n        `keras.config.image_data_format`.\n\nReturns:\n    Extracted patches 3D (if not batched) or 4D (if batched)\n\nExamples:\n\n>>> image = np.random.random(\n...     (2, 20, 20, 3)\n... ).astype(\"float32\") # batch of 2 RGB images\n>>> patches = keras.ops.image.extract_patches(image, (5, 5))\n>>> patches.shape\n(2, 4, 4, 75)\n>>> image = np.random.random((20, 20, 3)).astype(\"float32\") # 1 RGB image\n>>> patches = keras.ops.image.extract_patches(image, (3, 3), (1, 1))\n>>> patches.shape\n(18, 18, 27)",
    "std_args": [
      "images",
      "size",
      "strides",
      "dilation_rate",
      "padding",
      "data_format"
    ],
    "type": "function"
  },
  "extract_patches_3d": {
    "description": "Extracts patches from the volume(s).\n\nArgs:\n    volumes: Input volume or batch of volumes. Must be 4D or 5D.\n    size: Patch size int or tuple (patch_depth, patch_height, patch_width)\n    strides: strides along depth, height, and width. If not specified, or\n        if `None`, it defaults to the same value as `size`.\n    dilation_rate: This is the input stride, specifying how far two\n        consecutive patch samples are in the input. Note that using\n        `dilation_rate > 1` is not supported in conjunction with\n        `strides > 1` on the TensorFlow backend.\n    padding: The type of padding algorithm to use: `\"same\"` or `\"valid\"`.\n    data_format: A string specifying the data format of the input tensor.\n        It can be either `\"channels_last\"` or `\"channels_first\"`.\n        `\"channels_last\"` corresponds to inputs with shape\n        `(batch, depth, height, width, channels)`, while `\"channels_first\"`\n        corresponds to inputs with shape\n        `(batch, channels, depth, height, width)`. If not specified,\n         the value will default to `keras.config.image_data_format()`.\n\nReturns:\n    Extracted patches 4D (if not batched) or 5D (if batched)\n\nExamples:\n\n>>> import numpy as np\n>>> import keras\n>>> # Batched case\n>>> volumes = np.random.random(\n...     (2, 10, 10, 10, 3)\n... ).astype(\"float32\") # batch of 2 volumes\n>>> patches = keras.ops.image.extract_patches_3d(volumes, (3, 3, 3))\n>>> patches.shape\n(2, 3, 3, 3, 81)\n>>> # Unbatched case\n>>> volume = np.random.random((10, 10, 10, 3)).astype(\"float32\") # 1 volume\n>>> patches = keras.ops.image.extract_patches_3d(volume, (3, 3, 3))\n>>> patches.shape\n(3, 3, 3, 81)",
    "std_args": [
      "volumes",
      "size",
      "strides",
      "dilation_rate",
      "padding",
      "data_format"
    ],
    "type": "function"
  },
  "extract_sequences": {
    "description": "Expands the dimension of last axis into sequences of `sequence_length`.\n\nSlides a window of size `sequence_length` over the last axis of the input\nwith a stride of `sequence_stride`, replacing the last axis with\n`[num_sequences, sequence_length]` sequences.\n\nIf the dimension along the last axis is N, the number of sequences can be\ncomputed by:\n\n`num_sequences = 1 + (N - sequence_length) // sequence_stride`\n\nArgs:\n    x: Input tensor.\n    sequence_length: An integer representing the sequences length.\n    sequence_stride: An integer representing the sequences hop size.\n\nReturns:\n    A tensor of sequences with shape [..., num_sequences, sequence_length].\n\nExample:\n\n>>> x = keras.ops.convert_to_tensor([1, 2, 3, 4, 5, 6])\n>>> extract_sequences(x, 3, 2)\narray([[1, 2, 3],\n   [3, 4, 5]])",
    "std_args": [
      "x",
      "sequence_length",
      "sequence_stride"
    ],
    "type": "function"
  },
  "eye_": {
    "description": "Fill the 2-dimensional input `Tensor` with the identity matrix.",
    "std_args": [
      "tensor"
    ],
    "type": "function"
  },
  "f": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "f2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "f2cexpr": {
    "description": "Rewrite Fortran expression as f2py supported C expression.",
    "std_args": [
      "expr"
    ],
    "type": "function"
  },
  "f2cmap_all": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "f2cmap_default": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "f2cmap_f90": {
    "description": "Generates a single f90 file for testing",
    "std_args": [
      "tmpdir_factory"
    ],
    "type": "function"
  },
  "f2cmap_mapped": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "f2py_parser": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "f2py_version": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "f2pyenhancementspattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "f3": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "f77modulename": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "f90modhooks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "f90modulevars": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fabs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "factory_kwargs": {
    "description": "Return a canonicalized dict of factory kwargs.",
    "std_args": [
      "kwargs"
    ],
    "type": "function"
  },
  "fail_if_array_equal": {
    "description": "Raises an assertion error if two masked arrays are not equal elementwise.",
    "std_args": [
      "x",
      "y",
      "err_msg",
      "verbose"
    ],
    "type": "function"
  },
  "fail_if_equal": {
    "description": "Raises an assertion error if two items are equal.",
    "std_args": [
      "actual",
      "desired",
      "err_msg"
    ],
    "type": "function"
  },
  "feature_alpha_dropout": {
    "description": "Randomly masks out entire channels (a channel is a feature map).",
    "std_args": [
      "input",
      "p",
      "training",
      "inplace"
    ],
    "type": "function"
  },
  "feature_axes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "feature_axis": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "feature_group_count": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "features": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fft1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "fft2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "fgetdims1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fgetdims2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fgetdims2_sa": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fields": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "filename": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "filepositiontext": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "files": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fill_diagonal": {
    "description": "Return a copy of the array with the diagonal overwritten.\n\nJAX implementation of :func:`numpy.fill_diagonal`.\n\nThe semantics of :func:`numpy.fill_diagonal` are to modify arrays in-place, which\nis not possible for JAX's immutable arrays. The JAX version returns a modified\ncopy of the input, and adds the ``inplace`` parameter which must be set to\n`False`` by the user as a reminder of this API difference.\n\nArgs:\n  a: input array. Must have ``a.ndim >= 2``. If ``a.ndim >= 3``, then all\n    dimensions must be the same size.\n  val: scalar or array with which to fill the diagonal. If an array, it will\n    be flattened and repeated to fill the diagonal entries.\n  wrap: Not implemented by JAX. Only the default value of ``False`` is supported.\n  inplace: must be set to False to indicate that the input is not modified\n    in-place, but rather a modified copy is returned.\n\nReturns:\n  A copy of ``a`` with the diagonal set to ``val``.\n\nExamples:\n  >>> x = jnp.zeros((3, 3), dtype=int)\n  >>> jnp.fill_diagonal(x, jnp.array([1, 2, 3]), inplace=False)\n  Array([[1, 0, 0],\n         [0, 2, 0],\n         [0, 0, 3]], dtype=int32)\n\n  Unlike :func:`numpy.fill_diagonal`, the input ``x`` is not modified.\n\n  If the diagonal value has too many entries, it will be truncated\n\n  >>> jnp.fill_diagonal(x, jnp.arange(100, 200), inplace=False)\n  Array([[100,   0,   0],\n         [  0, 101,   0],\n         [  0,   0, 102]], dtype=int32)\n\n  If the diagonal has too few entries, it will be repeated:\n\n  >>> x = jnp.zeros((4, 4), dtype=int)\n  >>> jnp.fill_diagonal(x, jnp.array([3, 4]), inplace=False)\n  Array([[3, 0, 0, 0],\n         [0, 4, 0, 0],\n         [0, 0, 3, 0],\n         [0, 0, 0, 4]], dtype=int32)\n\n  For non-square arrays, the diagonal of the leading square slice is filled:\n\n  >>> x = jnp.zeros((3, 5), dtype=int)\n  >>> jnp.fill_diagonal(x, 1, inplace=False)\n  Array([[1, 0, 0, 0, 0],\n         [0, 1, 0, 0, 0],\n         [0, 0, 1, 0, 0]], dtype=int32)\n\n  And for square N-dimensional arrays, the N-dimensional diagonal is filled:\n\n  >>> y = jnp.zeros((2, 2, 2))\n  >>> jnp.fill_diagonal(y, 1, inplace=False)\n  Array([[[1., 0.],\n          [0., 0.]],\n  <BLANKLINE>\n         [[0., 0.],\n          [0., 1.]]], dtype=float32)",
    "std_args": [
      "a",
      "val",
      "wrap",
      "inplace"
    ],
    "type": "function"
  },
  "fill_value": {
    "description": "The filling value of the masked array is a scalar. When setting, None",
    "std_args": [],
    "type": "attribute"
  },
  "filled": {
    "description": "Return a copy with masked fields filled with a given value.",
    "std_args": [
      "self",
      "fill_value"
    ],
    "type": "function"
  },
  "filter": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "filter_and_map": {
    "description": "Recursively filter the contents of the module using ``filter_fn``,",
    "std_args": [
      "self",
      "filter_fn",
      "map_fn",
      "is_leaf_fn"
    ],
    "type": "function"
  },
  "filter_files": {
    "description": "Filter files by prefix and suffix.",
    "std_args": [
      "prefix",
      "suffix",
      "files",
      "remove_prefix"
    ],
    "type": "function"
  },
  "filter_rng_streams": {
    "description": "The class representing a Python function.",
    "std_args": [
      "row"
    ],
    "type": "function"
  },
  "filter_state": {
    "description": "Filter a ``State`` into one or more ``State``'s. The",
    "std_args": [
      "state",
      "first",
      "filters"
    ],
    "type": "function"
  },
  "filters": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "filters_to_predicates": {
    "description": "The class representing a Python function.",
    "std_args": [
      "filters"
    ],
    "type": "function"
  },
  "final_graphdef": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "finalize_state": {
    "description": "",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "find_duplicates": {
    "description": "Finds duplicate nodes or node leaves in the given node.",
    "std_args": [
      "node",
      "only"
    ],
    "type": "function"
  },
  "find_f2py_commands": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "find_unused_parameters": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "findcommonblocks": {
    "description": "The class representing a Python function.",
    "std_args": [
      "block",
      "top"
    ],
    "type": "function"
  },
  "findf90modules": {
    "description": "The class representing a Python function.",
    "std_args": [
      "m"
    ],
    "type": "function"
  },
  "finished": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "first_from": {
    "description": "Return the first non-None argument.",
    "std_args": [
      "args",
      "error_msg"
    ],
    "type": "function"
  },
  "fix_invalid": {
    "description": "Return input with invalid data masked and replaced by a fill value.",
    "std_args": [
      "a",
      "mask",
      "copy",
      "fill_value"
    ],
    "type": "function"
  },
  "flags": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "flags2names": {
    "description": "The class representing a Python function.",
    "std_args": [
      "flags"
    ],
    "type": "function"
  },
  "flags_info": {
    "description": "The class representing a Python function.",
    "std_args": [
      "arr"
    ],
    "type": "function"
  },
  "flat": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "flat_state": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "flatiter": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "flatlist": {
    "description": "The class representing a Python function.",
    "std_args": [
      "lst"
    ],
    "type": "function"
  },
  "flatnonzero": {
    "description": "Return indices of nonzero elements in a flattened array\n\nJAX implementation of :func:`numpy.flatnonzero`.\n\n``jnp.flatnonzero(x)`` is equivalent to ``nonzero(ravel(a))[0]``. For a full\ndiscussion of the parameters to this function, refer to :func:`jax.numpy.nonzero`.\n\nArgs:\n  a: N-dimensional array.\n  size: optional static integer specifying the number of nonzero entries to\n    return. See :func:`jax.numpy.nonzero` for more discussion of this parameter.\n  fill_value: optional padding value when ``size`` is specified. Defaults to 0.\n    See :func:`jax.numpy.nonzero` for more discussion of this parameter.\n\nReturns:\n  Array containing the indices of each nonzero value in the flattened array.\n\nSee Also:\n  - :func:`jax.numpy.nonzero`\n  - :func:`jax.numpy.where`\n\nExamples:\n  >>> x = jnp.array([[0, 5, 0],\n  ...                [6, 0, 8]])\n  >>> jnp.flatnonzero(x)\n  Array([1, 3, 5], dtype=int32)\n\n  This is equivalent to calling :func:`~jax.numpy.nonzero` on the flattened\n  array, and extracting the first entry in the resulting tuple:\n\n  >>> jnp.nonzero(x.ravel())[0]\n  Array([1, 3, 5], dtype=int32)\n\n  The returned indices can be used to extract nonzero entries from the\n  flattened array:\n\n  >>> indices = jnp.flatnonzero(x)\n  >>> x.ravel()[indices]\n  Array([5, 6, 8], dtype=int32)",
    "std_args": [
      "a",
      "size",
      "fill_value"
    ],
    "type": "function"
  },
  "flatnotmasked_contiguous": {
    "description": "Find contiguous unmasked data in a masked array.",
    "std_args": [
      "a"
    ],
    "type": "function"
  },
  "flatnotmasked_edges": {
    "description": "Find the indices of the first and last unmasked values.",
    "std_args": [
      "a"
    ],
    "type": "function"
  },
  "flatten_descr": {
    "description": "Flatten a structured data-type description.",
    "std_args": [
      "ndtype"
    ],
    "type": "function"
  },
  "flatten_end": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "ref_index"
    ],
    "type": "function"
  },
  "flatten_inplace": {
    "description": "Flatten a sequence in place.",
    "std_args": [
      "seq"
    ],
    "type": "function"
  },
  "flatten_mapping": {
    "description": "Flatten a nested mapping.",
    "std_args": [
      "xs",
      "keep_empty_nodes",
      "is_leaf",
      "sep"
    ],
    "type": "function"
  },
  "flatten_mask": {
    "description": "Returns a completely flattened version of the mask, where nested fields",
    "std_args": [
      "mask"
    ],
    "type": "function"
  },
  "flatten_parameters": {
    "description": "Reset parameter data pointer so that they can use faster code paths.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "flatten_structured_array": {
    "description": "Flatten a structured array.",
    "std_args": [
      "a"
    ],
    "type": "function"
  },
  "flatten_to_sequence": {
    "description": "Flatten a nested mapping.",
    "std_args": [
      "xs",
      "is_leaf"
    ],
    "type": "function"
  },
  "flex_attention": {
    "description": "This function implements scaled dot product attention with an arbitrary attention score modification function.",
    "std_args": [
      "query",
      "key",
      "value",
      "score_mod",
      "block_mask",
      "scale",
      "enable_gqa",
      "return_lse",
      "kernel_options",
      "return_aux"
    ],
    "type": "function"
  },
  "flexible": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "flip_sequences": {
    "description": "Flips a sequence of inputs along the time axis.",
    "std_args": [
      "inputs",
      "seq_lengths",
      "num_batch_dims",
      "time_major"
    ],
    "type": "function"
  },
  "fliplr": {
    "description": "Reverse the order of elements of an array along axis 1.\n\nJAX implementation of :func:`numpy.fliplr`.\n\nArgs:\n  m: Array with at least two dimensions.\n\nReturns:\n  An array with the elements in reverse order along axis 1.\n\nSee Also:\n  - :func:`jax.numpy.flip`: reverse the order along the given axis\n  - :func:`jax.numpy.flipud`: reverse the order along axis 0\n\nExamples:\n  >>> x = jnp.array([[1, 2],\n  ...                [3, 4]])\n  >>> jnp.fliplr(x)\n  Array([[2, 1],\n         [4, 3]], dtype=int32)",
    "std_args": [
      "m"
    ],
    "type": "function"
  },
  "flipud": {
    "description": "Reverse the order of elements of an array along axis 0.\n\nJAX implementation of :func:`numpy.flipud`.\n\nArgs:\n  m: Array with at least one dimension.\n\nReturns:\n  An array with the elements in reverse order along axis 0.\n\nSee Also:\n  - :func:`jax.numpy.flip`: reverse the order along the given axis\n  - :func:`jax.numpy.fliplr`: reverse the order along axis 1\n\nExamples:\n  >>> x = jnp.array([[1, 2],\n  ...                [3, 4]])\n  >>> jnp.flipud(x)\n  Array([[3, 4],\n         [1, 2]], dtype=int32)",
    "std_args": [
      "m"
    ],
    "type": "function"
  },
  "flist": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "float": {
    "description": "Casts all floating point parameters and buffers to ``float`` datatype.",
    "std_args": [
      "self"
    ],
    "type": "attribute"
  },
  "float4_e2m1fn": {
    "description": "A JAX scalar constructor of type float4_e2m1fn.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "class"
  },
  "float8_e3m4": {
    "description": "A JAX scalar constructor of type float8_e3m4.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "class"
  },
  "float8_e4m3": {
    "description": "A JAX scalar constructor of type float8_e4m3.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "class"
  },
  "float8_e4m3b11fnuz": {
    "description": "A JAX scalar constructor of type float8_e4m3b11fnuz.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "class"
  },
  "float8_e4m3fn": {
    "description": "A JAX scalar constructor of type float8_e4m3fn.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "class"
  },
  "float8_e4m3fnuz": {
    "description": "A JAX scalar constructor of type float8_e4m3fnuz.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "class"
  },
  "float8_e5m2": {
    "description": "A JAX scalar constructor of type float8_e5m2.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "class"
  },
  "float8_e5m2fnuz": {
    "description": "A JAX scalar constructor of type float8_e5m2fnuz.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "class"
  },
  "float8_e8m0fnu": {
    "description": "A JAX scalar constructor of type float8_e8m0fnu.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "class"
  },
  "float_": {
    "description": "A JAX scalar constructor of type float64.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "class"
  },
  "float_power": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "float_types_list": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "floating": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "attribute"
  },
  "flops": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "flush": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "fmax": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fmin": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fmod": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fold": {
    "description": "Combine an array of sliding local blocks into a large containing tensor.",
    "std_args": [
      "input",
      "output_size",
      "kernel_size",
      "dilation",
      "padding",
      "stride"
    ],
    "type": "function"
  },
  "fori_loop": {
    "description": "A Flax NNX transformation of `jax.lax.fori_loop <https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.fori_loop.html>`_.",
    "std_args": [
      "lower",
      "upper",
      "body_fun",
      "init_val",
      "unroll"
    ],
    "type": "function"
  },
  "fork": {
    "description": "Returns a new Rngs object with new unique RNG keys.",
    "std_args": [
      "self",
      "split"
    ],
    "type": "function"
  },
  "fork_rngs": {
    "description": "Forks the (nested) Rng states of the given node.",
    "std_args": [
      "node",
      "split"
    ],
    "type": "function"
  },
  "format_float": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x",
      "parens"
    ],
    "type": "function"
  },
  "formatpattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fortran77_code": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fortran90_code": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fortrantypes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "forward": {
    "description": "Auto-generated from flax_nnx_dynamic_wiring",
    "std_args": [],
    "type": "function"
  },
  "forward_rnn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fprefix": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fractional_max_pool2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fractional_max_pool2d_with_indices": {
    "description": "fractional_max_pool2d(input, kernel_size, output_size=None, output_ratio=None, return_indices=False, _random_samples=None)",
    "std_args": [
      "input",
      "kernel_size",
      "output_size",
      "output_ratio",
      "return_indices",
      "_random_samples"
    ],
    "type": "function"
  },
  "fractional_max_pool3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fractional_max_pool3d_with_indices": {
    "description": "fractional_max_pool3d(input, kernel_size, output_size=None, output_ratio=None, return_indices=False, _random_samples=None)",
    "std_args": [
      "input",
      "kernel_size",
      "output_size",
      "output_ratio",
      "return_indices",
      "_random_samples"
    ],
    "type": "function"
  },
  "freeze": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "frequencies": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "frexp": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "from_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "x"
    ],
    "type": "function"
  },
  "from_config": {
    "description": "",
    "std_args": [
      "config"
    ],
    "type": "function"
  },
  "from_embedding": {
    "description": "Create a :obj:`QuantizedEmbedding` layer from an :obj:`Embedding` layer.",
    "std_args": [
      "cls",
      "embedding_layer",
      "group_size",
      "bits",
      "mode"
    ],
    "type": "function"
  },
  "from_flat_info": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "lowering",
      "in_tree",
      "in_avals",
      "donate_argnums",
      "out_tree",
      "no_kwargs"
    ],
    "type": "function"
  },
  "from_flat_path": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "flat_state"
    ],
    "type": "function"
  },
  "from_flat_state": {
    "description": "Convert flat state object into :class:`State` object.",
    "std_args": [
      "flat_state",
      "cls"
    ],
    "type": "function"
  },
  "from_indexmap": {
    "description": "The class representing a Python function.",
    "std_args": [
      "indexmap"
    ],
    "type": "function"
  },
  "from_kv_blocks": {
    "description": "Creates a BlockMask instance from key-value block information.",
    "std_args": [
      "cls",
      "kv_num_blocks",
      "kv_indices",
      "full_kv_num_blocks",
      "full_kv_indices",
      "BLOCK_SIZE",
      "mask_mod",
      "seq_lengths",
      "compute_q_blocks"
    ],
    "type": "function"
  },
  "from_linear": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "linear_layer",
      "segments",
      "group"
    ],
    "type": "function"
  },
  "from_metadata": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "value",
      "attributes"
    ],
    "type": "function"
  },
  "from_prefixes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "prefixes",
      "metadata"
    ],
    "type": "function"
  },
  "from_pretrained": {
    "description": "Create EmbeddingBag instance from given 2-dimensional FloatTensor.",
    "std_args": [
      "cls",
      "embeddings",
      "freeze",
      "max_norm",
      "norm_type",
      "scale_grad_by_freq",
      "mode",
      "sparse",
      "include_last_offset",
      "padding_idx"
    ],
    "type": "function"
  },
  "from_quantized_linear": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "quantized_linear_layer",
      "segments",
      "group"
    ],
    "type": "function"
  },
  "from_refmap": {
    "description": "The class representing a Python function.",
    "std_args": [
      "refmap"
    ],
    "type": "function"
  },
  "from_sorted_keys_values": {
    "description": "The class representing a Python function.",
    "std_args": [
      "keys",
      "values"
    ],
    "type": "function"
  },
  "from_split": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "graphdef",
      "state",
      "states",
      "metadata"
    ],
    "type": "function"
  },
  "from_states": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "state",
      "states"
    ],
    "type": "function"
  },
  "from_tree": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tree",
      "prefix",
      "merge_fn",
      "is_node_leaf",
      "is_leaf",
      "map_non_graph_nodes",
      "is_inner",
      "ctxtag"
    ],
    "type": "function"
  },
  "fromarrays": {
    "description": "Creates a mrecarray from a (flat) list of masked arrays.",
    "std_args": [
      "arraylist",
      "dtype",
      "shape",
      "formats",
      "names",
      "titles",
      "aligned",
      "byteorder",
      "fill_value"
    ],
    "type": "function"
  },
  "frombuffer": {
    "description": "Convert a buffer into a 1-D JAX array.\n\nJAX implementation of :func:`numpy.frombuffer`.\n\nArgs:\n  buffer: an object containing the data. It must be either a bytes object with\n    a length that is an integer multiple of the dtype element size, or\n    it must be an object exporting the `Python buffer interface`_.\n  dtype: optional. Desired data type for the array. Default is ``float64``.\n    This specifies the dtype used to parse the buffer, but note that after parsing,\n    64-bit values will be cast to 32-bit JAX arrays if the ``jax_enable_x64``\n    flag is set to ``False``.\n  count: optional integer specifying the number of items to read from the buffer.\n    If -1 (default), all items from the buffer are read.\n  offset: optional integer specifying the number of bytes to skip at the beginning\n    of the buffer. Default is 0.\n\nReturns:\n  A 1-D JAX array representing the interpreted data from the buffer.\n\nSee also:\n  - :func:`jax.numpy.fromstring`: convert a string of text into 1-D JAX array.\n\nExamples:\n  Using a bytes buffer:\n\n  >>> buf = b\"\\x00\\x01\\x02\\x03\\x04\"\n  >>> jnp.frombuffer(buf, dtype=jnp.uint8)\n  Array([0, 1, 2, 3, 4], dtype=uint8)\n  >>> jnp.frombuffer(buf, dtype=jnp.uint8, offset=1)\n  Array([1, 2, 3, 4], dtype=uint8)\n\n  Constructing a JAX array via the Python buffer interface, using Python's\n  built-in :mod:`array` module.\n\n  >>> from array import array\n  >>> pybuffer = array('i', [0, 1, 2, 3, 4])\n  >>> jnp.frombuffer(pybuffer, dtype=jnp.int32)\n  Array([0, 1, 2, 3, 4], dtype=int32)\n\n.. _Python buffer interface: https://docs.python.org/3/c-api/buffer.html",
    "std_args": [
      "buffer",
      "dtype",
      "count",
      "offset"
    ],
    "type": "attribute"
  },
  "fromfile": {
    "description": "Unimplemented JAX wrapper for jnp.fromfile.\n\nThis function is left deliberately unimplemented because it may be non-pure and thus\nunsafe for use with JIT and other JAX transformations. Consider using\n``jnp.asarray(np.fromfile(...))`` instead, although care should be taken if ``np.fromfile``\nis used within jax transformations because of its potential side-effect of consuming the\nfile object; for more information see `Common Gotchas: Pure Functions\n<https://docs.jax.dev/en/latest/notebooks/Common_Gotchas_in_JAX.html#pure-functions>`_.",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "fromflex": {
    "description": "Build a masked array from a suitable flexible-type array.",
    "std_args": [
      "fxarray"
    ],
    "type": "function"
  },
  "fromfunction": {
    "description": "Create an array from a function applied over indices.\n\nJAX implementation of :func:`numpy.fromfunction`. The JAX implementation\ndiffers in that it dispatches via :func:`jax.vmap`, and so unlike in NumPy\nthe function logically operates on scalar inputs, and need not explicitly\nhandle broadcasted inputs (See *Examples* below).\n\nArgs:\n  function: a function that takes *N* dynamic scalars and outputs a scalar.\n  shape: a length-*N* tuple of integers specifying the output shape.\n  dtype: optionally specify the dtype of the inputs. Defaults to floating-point.\n  kwargs: additional keyword arguments are passed statically to ``function``.\n\nReturns:\n  An array of shape ``shape`` if ``function`` returns a scalar, or in general\n  a pytree of arrays with leading dimensions ``shape``, as determined by the\n  output of ``function``.\n\nSee also:\n  - :func:`jax.vmap`: the core transformation that the :func:`fromfunction`\n    API is built on.\n\nExamples:\n  Generate a multiplication table of a given shape:\n\n  >>> jnp.fromfunction(jnp.multiply, shape=(3, 6), dtype=int)\n  Array([[ 0,  0,  0,  0,  0,  0],\n         [ 0,  1,  2,  3,  4,  5],\n         [ 0,  2,  4,  6,  8, 10]], dtype=int32)\n\n  When ``function`` returns a non-scalar the output will have leading\n  dimension of ``shape``:\n\n  >>> def f(x):\n  ...   return (x + 1) * jnp.arange(3)\n  >>> jnp.fromfunction(f, shape=(2,))\n  Array([[0., 1., 2.],\n         [0., 2., 4.]], dtype=float32)\n\n  ``function`` may return multiple results, in which case each is mapped\n  independently:\n\n  >>> def f(x, y):\n  ...   return x + y, x * y\n  >>> x_plus_y, x_times_y = jnp.fromfunction(f, shape=(3, 5))\n  >>> print(x_plus_y)\n  [[0. 1. 2. 3. 4.]\n   [1. 2. 3. 4. 5.]\n   [2. 3. 4. 5. 6.]]\n  >>> print(x_times_y)\n  [[0. 0. 0. 0. 0.]\n   [0. 1. 2. 3. 4.]\n   [0. 2. 4. 6. 8.]]\n\n  The JAX implementation differs slightly from NumPy's implementation. In\n  :func:`numpy.fromfunction`, the function is expected to explicitly operate\n  element-wise on the full grid of input values:\n\n  >>> def f(x, y):\n  ...   print(f\"{x.shape = }\\n{y.shape = }\")\n  ...   return x + y\n  ...\n  >>> np.fromfunction(f, (2, 3))\n  x.shape = (2, 3)\n  y.shape = (2, 3)\n  array([[0., 1., 2.],\n         [1., 2., 3.]])\n\n  In :func:`jax.numpy.fromfunction`, the function is vectorized via\n  :func:`jax.vmap`, and so is expected to operate on scalar values:\n\n  >>> jnp.fromfunction(f, (2, 3))\n  x.shape = ()\n  y.shape = ()\n  Array([[0., 1., 2.],\n         [1., 2., 3.]], dtype=float32)",
    "std_args": [
      "function",
      "shape",
      "dtype",
      "kwargs"
    ],
    "type": "function"
  },
  "fromiter": {
    "description": "Unimplemented JAX wrapper for jnp.fromiter.\n\nThis function is left deliberately unimplemented because it may be non-pure and thus\nunsafe for use with JIT and other JAX transformations. Consider using\n``jnp.asarray(np.fromiter(...))`` instead, although care should be taken if ``np.fromiter``\nis used within jax transformations because of its potential side-effect of consuming the\niterable object; for more information see `Common Gotchas: Pure Functions\n<https://docs.jax.dev/en/latest/notebooks/Common_Gotchas_in_JAX.html#pure-functions>`_.",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "fromkeys": {
    "description": "Return a new ParameterDict with the keys provided.",
    "std_args": [
      "self",
      "keys",
      "default"
    ],
    "type": "function"
  },
  "frompyfunc": {
    "description": "Create a JAX ufunc from an arbitrary JAX-compatible scalar function.\n\nArgs:\n  func : a callable that takes `nin` scalar arguments and returns `nout` outputs.\n  nin: integer specifying the number of scalar inputs\n  nout: integer specifying the number of scalar outputs\n  identity: (optional) a scalar specifying the identity of the operation, if any.\n\nReturns:\n  wrapped : jax.numpy.ufunc wrapper of func.\n\nExamples:\n  Here is an example of creating a ufunc similar to :obj:`jax.numpy.add`:\n\n  >>> import operator\n  >>> add = frompyfunc(operator.add, nin=2, nout=1, identity=0)\n\n  Now all the standard :class:`jax.numpy.ufunc` methods are available:\n\n  >>> x = jnp.arange(4)\n  >>> add(x, 10)\n  Array([10, 11, 12, 13], dtype=int32)\n  >>> add.outer(x, x)\n  Array([[0, 1, 2, 3],\n         [1, 2, 3, 4],\n         [2, 3, 4, 5],\n         [3, 4, 5, 6]], dtype=int32)\n  >>> add.reduce(x)\n  Array(6, dtype=int32)\n  >>> add.accumulate(x)\n  Array([0, 1, 3, 6], dtype=int32)\n  >>> add.at(x, 1, 10, inplace=False)\n  Array([ 0, 11,  2,  3], dtype=int32)",
    "std_args": [
      "func",
      "nin",
      "nout",
      "identity"
    ],
    "type": "function"
  },
  "fromrecords": {
    "description": "Creates a MaskedRecords from a list of records.",
    "std_args": [
      "reclist",
      "dtype",
      "shape",
      "formats",
      "names",
      "titles",
      "aligned",
      "byteorder",
      "fill_value",
      "mask"
    ],
    "type": "function"
  },
  "fromstring": {
    "description": "Convert a string of text into 1-D JAX array.\n\nJAX implementation of :func:`numpy.fromstring`.\n\nArgs:\n  string: input string containing the data.\n  dtype: optional. Desired data type for the array. Default is ``float``.\n  count: optional integer specifying the number of items to read from the string.\n    If -1 (default), all items are read.\n  sep: the string used to separate values in the input string.\n\nReturns:\n  A 1-D JAX array containing the parsed data from the input string.\n\nSee also:\n  - :func:`jax.numpy.frombuffer`: construct a JAX array from an object\n    that implements the buffer interface.\n\nExamples:\n  >>> jnp.fromstring(\"1 2 3\", dtype=int, sep=\" \")\n  Array([1, 2, 3], dtype=int32)\n  >>> jnp.fromstring(\"0.1, 0.2, 0.3\", dtype=float, count=2, sep=\",\")\n  Array([0.1, 0.2], dtype=float32)",
    "std_args": [
      "string",
      "dtype",
      "count",
      "sep"
    ],
    "type": "function"
  },
  "fromtextfile": {
    "description": "Creates a mrecarray from data stored in the file `filename`.",
    "std_args": [
      "fname",
      "delimiter",
      "commentchar",
      "missingchar",
      "varnames",
      "vartypes"
    ],
    "type": "function"
  },
  "fsuffix": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "full_kv_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "full_kv_num_blocks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "full_q_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "full_q_num_blocks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "full_version": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fun": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "funcs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "functional": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls"
    ],
    "type": "function"
  },
  "functional_call": {
    "description": "Perform a functional call on the module by replacing the module parameters and buffers with the provided ones.",
    "std_args": [
      "module",
      "parameters_and_buffers",
      "args",
      "kwargs",
      "tie_weights",
      "strict"
    ],
    "type": "function"
  },
  "functionpattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fuse_conv_bn_eval": {
    "description": "Fuse a convolutional module and a BatchNorm module into a single, new convolutional module.",
    "std_args": [
      "conv",
      "bn",
      "transpose"
    ],
    "type": "function"
  },
  "fuse_conv_bn_weights": {
    "description": "Fuse convolutional module parameters and BatchNorm module parameters into new convolutional module parameters.",
    "std_args": [
      "conv_w",
      "conv_b",
      "bn_rm",
      "bn_rv",
      "bn_eps",
      "bn_w",
      "bn_b",
      "transpose"
    ],
    "type": "function"
  },
  "fuse_linear_bn_eval": {
    "description": "Fuse a linear module and a BatchNorm module into a single, new linear module.",
    "std_args": [
      "linear",
      "bn"
    ],
    "type": "function"
  },
  "fuse_linear_bn_weights": {
    "description": "Fuse linear module parameters and BatchNorm module parameters into new linear module parameters.",
    "std_args": [
      "linear_w",
      "linear_b",
      "bn_rm",
      "bn_rv",
      "bn_eps",
      "bn_w",
      "bn_b"
    ],
    "type": "function"
  },
  "fwd": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "gamma": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "gammainc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "gammaincc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "gammaln": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "gate_fn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "gather_mm": {
    "description": "gather_mm(a: array, b: array, /, lhs_indices: array, rhs_indices: array, *, sorted_indices: bool = False, stream: Union[None, Stream, Device] = None) -> array",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "gather_qmm": {
    "description": "gather_qmm(x: array, w: array, /, scales: array, biases: Optional[array] = None, lhs_indices: Optional[array] = None, rhs_indices: Optional[array] = None, transpose: bool = True, group_size: Optional[int] = None, bits: Optional[int] = None, mode: str = 'affine', *, sorted_indices: bool = False, stream: Union[None, Stream, Device] = None) -> array",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "gauss_from_uint": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x",
      "n",
      "bits"
    ],
    "type": "function"
  },
  "gaussian_blur": {
    "description": "Applies a Gaussian blur to the image(s).\n\nArgs:\n    images: Input image or batch of images. Must be 3D or 4D.\n    kernel_size: A tuple of two integers, specifying the height and width\n        of the Gaussian kernel.\n    sigma: A tuple of two floats, specifying the standard deviation of\n        the Gaussian kernel along height and width.\n    data_format: A string specifying the data format of the input tensor.\n        It can be either `\"channels_last\"` or `\"channels_first\"`.\n        `\"channels_last\"` corresponds to inputs with shape\n        `(batch, height, width, channels)`, while `\"channels_first\"`\n        corresponds to inputs with shape `(batch, channels, height, width)`.\n        If not specified, the value will default to\n        `keras.config.image_data_format`.\n\nReturns:\n    Blurred image or batch of images.\n\nExamples:\n\n>>> x = np.random.random((2, 64, 80, 3))  # batch of 2 RGB images\n>>> y = keras.ops.image.gaussian_blur(x)\n>>> y.shape\n(2, 64, 80, 3)\n\n>>> x = np.random.random((64, 80, 3))  # single RGB image\n>>> y = keras.ops.image.gaussian_blur(x)\n>>> y.shape\n(64, 80, 3)\n\n>>> x = np.random.random((2, 3, 64, 80))  # batch of 2 RGB images\n>>> y = keras.ops.image.gaussian_blur(\n...     x, data_format=\"channels_first\")\n>>> y.shape\n(2, 3, 64, 80)",
    "std_args": [
      "images",
      "kernel_size",
      "sigma",
      "data_format"
    ],
    "type": "function"
  },
  "gaussian_nll_loss": {
    "description": "Compute the Gaussian negative log likelihood loss.",
    "std_args": [
      "input",
      "target",
      "var",
      "full",
      "eps",
      "reduction"
    ],
    "type": "function"
  },
  "gcd": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "gelu_approx": {
    "description": "An approximation to Gaussian Error Linear Unit.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "gelu_fast_approx": {
    "description": "A fast approximation to Gaussian Error Linear Unit.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "generalized_normal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "generate_square_subsequent_mask": {
    "description": "Generate a square causal mask for the sequence.",
    "std_args": [
      "sz",
      "device",
      "dtype"
    ],
    "type": "function"
  },
  "generate_state": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "n_words",
      "dtype"
    ],
    "type": "function"
  },
  "generationtime": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "generic": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "attribute"
  },
  "gentitle": {
    "description": "The class representing a Python function.",
    "std_args": [
      "name"
    ],
    "type": "function"
  },
  "geometric": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "geomspace": {
    "description": "Generate geometrically-spaced values.\n\nJAX implementation of :func:`numpy.geomspace`.\n\nArgs:\n  start: scalar or array. Specifies the starting values.\n  stop: scalar or array. Specifies the stop values.\n  num: int, optional, default=50. Number of values to generate.\n  endpoint: bool, optional, default=True. If True, then include the ``stop`` value\n    in the result. If False, then exclude the ``stop`` value.\n  dtype: optional. Specifies the dtype of the output.\n  axis: int, optional, default=0. Axis along which to generate the geomspace.\n\nReturns:\n  An array containing the geometrically-spaced values.\n\nSee also:\n  - :func:`jax.numpy.arange`: Generate ``N`` evenly-spaced values given a starting\n    point and a step value.\n  - :func:`jax.numpy.linspace`: Generate evenly-spaced values.\n  - :func:`jax.numpy.logspace`: Generate logarithmically-spaced values.\n\nExamples:\n  List 5 geometrically-spaced values between 1 and 16:\n\n  >>> with jnp.printoptions(precision=3, suppress=True):\n  ...   jnp.geomspace(1, 16, 5)\n  Array([ 1.,  2.,  4.,  8., 16.], dtype=float32)\n\n  List 4 geomtrically-spaced values between 1 and 16, with ``endpoint=False``:\n\n  >>> with jnp.printoptions(precision=3, suppress=True):\n  ...   jnp.geomspace(1, 16, 4, endpoint=False)\n  Array([1., 2., 4., 8.], dtype=float32)\n\n  Multi-dimensional geomspace:\n\n  >>> start = jnp.array([1, 1000])\n  >>> stop = jnp.array([27, 1])\n  >>> with jnp.printoptions(precision=3, suppress=True):\n  ...   jnp.geomspace(start, stop, 4)\n  Array([[   1., 1000.],\n         [   3.,  100.],\n         [   9.,   10.],\n         [  27.,    1.]], dtype=float32)",
    "std_args": [
      "start",
      "stop",
      "num",
      "endpoint",
      "dtype",
      "axis"
    ],
    "type": "function"
  },
  "get": {
    "description": "Return the parameter associated with key if present. Otherwise return default if provided, None if not.",
    "std_args": [
      "self",
      "key",
      "default"
    ],
    "type": "function"
  },
  "getA": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "getA1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "getH": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "getI": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "getT": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_a_var": {
    "description": "The class representing a Python function.",
    "std_args": [
      "obj"
    ],
    "type": "function"
  },
  "get_active_memory": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_all_with_path": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "get_bit_generator": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_buffer": {
    "description": "Return the buffer given by ``target`` if it exists, otherwise throw an error.",
    "std_args": [
      "self",
      "target"
    ],
    "type": "function"
  },
  "get_build_config": {
    "description": "Returns a dictionary with the layer's input shape.\n\nThis method returns a config dict that can be used by\n`build_from_config(config)` to create all states (e.g. Variables and\nLookup tables) needed by the layer.\n\nBy default, the config only contains the input shape that the layer\nwas built with. If you're writing a custom layer that creates state in\nan unusual way, you should override this method to make sure this state\nis already created when Keras attempts to load its value upon model\nloading.\n\nReturns:\n    A dict containing the input shape associated with the layer.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_cache_memory": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_clipped_bbox": {
    "description": "",
    "std_args": [
      "self",
      "bounding_boxes",
      "h_end",
      "h_start",
      "w_end",
      "w_start"
    ],
    "type": "function"
  },
  "get_col_name": {
    "description": "Given the keypath of a Flax variable type, return its Linen collection name.",
    "std_args": [
      "keypath"
    ],
    "type": "function"
  },
  "get_complex_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dtype"
    ],
    "type": "function"
  },
  "get_config": {
    "description": "",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_data": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "get_docdir": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_dropout_mask": {
    "description": "",
    "std_args": [
      "self",
      "step_input"
    ],
    "type": "function"
  },
  "get_elastic_transform_params": {
    "description": "",
    "std_args": [
      "self",
      "height",
      "width",
      "factor"
    ],
    "type": "function"
  },
  "get_elsize": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "get_expected_cell_size": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "input",
      "batch_sizes"
    ],
    "type": "function"
  },
  "get_expected_hidden_size": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "input",
      "batch_sizes"
    ],
    "type": "function"
  },
  "get_extra_state": {
    "description": "Return any extra state to include in the module's state_dict.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_f2py_modulename": {
    "description": "The class representing a Python function.",
    "std_args": [
      "source"
    ],
    "type": "function"
  },
  "get_fieldspec": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "get_fieldstructure": {
    "description": "Returns a dictionary with fields indexing lists of their parent fields.",
    "std_args": [
      "adtype",
      "lastname",
      "parents"
    ],
    "type": "function"
  },
  "get_fill_value": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_imag": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_include": {
    "description": "Return the directory that contains the ``fortranobject.c`` and ``.h`` files.",
    "std_args": [],
    "type": "function"
  },
  "get_initial_state": {
    "description": "",
    "std_args": [
      "self",
      "batch_size"
    ],
    "type": "function"
  },
  "get_io_paths": {
    "description": "Takes in a temporary file for testing and returns the expected output and input paths",
    "std_args": [
      "fname_inp",
      "mname"
    ],
    "type": "function"
  },
  "get_item": {
    "description": "Return `x[key]`.",
    "std_args": [
      "x",
      "key"
    ],
    "type": "function"
  },
  "get_kind": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "get_mask": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "get_masked_subclass": {
    "description": "Return the youngest subclass of MaskedArray from a list of (masked) arrays.",
    "std_args": [
      "arrays"
    ],
    "type": "function"
  },
  "get_mat": {
    "description": "The class representing a Python function.",
    "std_args": [
      "n"
    ],
    "type": "function"
  },
  "get_metadata": {
    "description": "Get metadata for the Variable.",
    "std_args": [
      "self",
      "name",
      "default",
      "exclude_required"
    ],
    "type": "function"
  },
  "get_module_dir": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_named_sharding": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tree",
      "mesh"
    ],
    "type": "function"
  },
  "get_names": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "get_names_flat": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "get_needs": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_newer_options": {
    "description": "The class representing a Python function.",
    "std_args": [
      "iline"
    ],
    "type": "function"
  },
  "get_node_impl": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "get_node_impl_for_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "get_overridable_numpy_array_functions": {
    "description": "List all numpy functions overridable via `__array_function__`",
    "std_args": [],
    "type": "function"
  },
  "get_overridable_numpy_ufuncs": {
    "description": "List all numpy ufuncs overridable via `__array_ufunc__`",
    "std_args": [],
    "type": "function"
  },
  "get_parameter": {
    "description": "Return the parameter given by ``target`` if it exists, otherwise throw an error.",
    "std_args": [
      "self",
      "target"
    ],
    "type": "function"
  },
  "get_partition_spec": {
    "description": "Returns the ``Partitionspec`` for this partitioned value.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_peak_memory": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_prefix": {
    "description": "The class representing a Python function.",
    "std_args": [
      "module"
    ],
    "type": "function"
  },
  "get_printoptions": {
    "description": "Alias of :func:`numpy.get_printoptions`.\n\nJAX arrays are printed via NumPy, so NumPy's `printoptions`\nconfigurations will apply to printed JAX arrays.\n\nSee the :func:`numpy.set_printoptions` documentation for details\non the available options and their meanings.",
    "std_args": [],
    "type": "function"
  },
  "get_random_transformation": {
    "description": "",
    "std_args": [
      "self",
      "data",
      "training",
      "seed"
    ],
    "type": "function"
  },
  "get_raw_value": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_real": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_real_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dtype"
    ],
    "type": "function"
  },
  "get_recurrent_dropout_mask": {
    "description": "",
    "std_args": [
      "self",
      "step_input"
    ],
    "type": "function"
  },
  "get_repr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "obj"
    ],
    "type": "function"
  },
  "get_rtol": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dtype"
    ],
    "type": "function"
  },
  "get_shifted_bbox": {
    "description": "",
    "std_args": [
      "self",
      "bounding_boxes",
      "w_shift_factor",
      "h_shift_factor"
    ],
    "type": "function"
  },
  "get_signature": {
    "description": "Construct a signature and replace all default parameter-values.",
    "std_args": [
      "func",
      "default"
    ],
    "type": "function"
  },
  "get_sorted_names": {
    "description": "The class representing a Python function.",
    "std_args": [
      "vars"
    ],
    "type": "function"
  },
  "get_state": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "get_temp_module_name": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_test_cases": {
    "description": "The class representing a Python function.",
    "std_args": [
      "directories"
    ],
    "type": "function"
  },
  "get_testdir": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "get_transformed_x_y": {
    "description": "",
    "std_args": [
      "self",
      "x",
      "y",
      "transform"
    ],
    "type": "function"
  },
  "get_types": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_usedict": {
    "description": "The class representing a Python function.",
    "std_args": [
      "block"
    ],
    "type": "function"
  },
  "get_useparameters": {
    "description": "The class representing a Python function.",
    "std_args": [
      "block",
      "param_map"
    ],
    "type": "function"
  },
  "get_value": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "index"
    ],
    "type": "function"
  },
  "get_value_hooks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "get_var_pspec": {
    "description": "Given an `nnx.Variable`, return its `PartitionSpec`.",
    "std_args": [
      "v"
    ],
    "type": "function"
  },
  "get_variable_p": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "get_vocabulary": {
    "description": "Returns the current vocabulary of the layer.\n\nArgs:\n    include_special_tokens: If `True`, the returned vocabulary\n        will include the padding and OOV tokens,\n        and a term's index in the vocabulary will equal\n        the term's index when calling the layer. If `False`, the\n        returned vocabulary will not include any padding\n        or OOV tokens.",
    "std_args": [
      "self",
      "include_special_tokens"
    ],
    "type": "function"
  },
  "get_weights": {
    "description": "Return the values of `layer.weights` as a list of NumPy arrays.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "getargs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "getargs2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "getarrdims": {
    "description": "The class representing a Python function.",
    "std_args": [
      "a",
      "var",
      "verbose"
    ],
    "type": "function"
  },
  "getarrdocsign": {
    "description": "The class representing a Python function.",
    "std_args": [
      "a",
      "var"
    ],
    "type": "function"
  },
  "getblockname": {
    "description": "The class representing a Python function.",
    "std_args": [
      "block",
      "unknown"
    ],
    "type": "function"
  },
  "getcallprotoargument": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout",
      "cb_map"
    ],
    "type": "function"
  },
  "getcallstatement": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "getctype": {
    "description": "Determines C type",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "getdata": {
    "description": "Return the data of a masked array as an ndarray.",
    "std_args": [
      "a",
      "subok"
    ],
    "type": "function"
  },
  "getdimension": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "getdomain": {
    "description": "Return a domain suitable for given abscissae.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "getfortranname": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "getinit": {
    "description": "The class representing a Python function.",
    "std_args": [
      "a",
      "var"
    ],
    "type": "function"
  },
  "getlincoef": {
    "description": "Obtain ``a`` and ``b`` when ``e == \"a*x+b\"``, where ``x`` is a symbol in",
    "std_args": [
      "e",
      "xset"
    ],
    "type": "function"
  },
  "getlincoef_re_1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "getmask": {
    "description": "Return the mask of a masked array, or nomask.",
    "std_args": [
      "a"
    ],
    "type": "function"
  },
  "getmaskarray": {
    "description": "Return the mask of a masked array, or full boolean array of False.",
    "std_args": [
      "arr"
    ],
    "type": "function"
  },
  "getmultilineblock": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout",
      "blockname",
      "comment",
      "counter"
    ],
    "type": "function"
  },
  "getpath": {
    "description": "The class representing a Python function.",
    "std_args": [
      "a"
    ],
    "type": "function"
  },
  "getpydocsign": {
    "description": "The class representing a Python function.",
    "std_args": [
      "a",
      "var"
    ],
    "type": "function"
  },
  "getpymethoddef": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "getrestdoc": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "getstrlength": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "getuseblocks": {
    "description": "The class representing a Python function.",
    "std_args": [
      "pymod"
    ],
    "type": "function"
  },
  "getusercode": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "getusercode1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "gh22819_cli": {
    "description": "F90 file for testing disallowed CLI arguments in ghff819",
    "std_args": [
      "tmpdir_factory"
    ],
    "type": "function"
  },
  "gh23598_warn": {
    "description": "F90 file for testing warnings in gh23598",
    "std_args": [
      "tmpdir_factory"
    ],
    "type": "function"
  },
  "gil_enabled_at_start": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "git_revision": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "global_unstructured": {
    "description": "Globally prunes tensors corresponding to all parameters in ``parameters`` by applying the specified ``pruning_method``.",
    "std_args": [
      "parameters",
      "pruning_method",
      "importance_scores",
      "kwargs"
    ],
    "type": "function"
  },
  "glorot_normal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "glorot_uniform": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "gotnextfile": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "gpu": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "grad": {
    "description": "Evaluates gradient.",
    "std_args": [
      "func",
      "argnums",
      "has_aux"
    ],
    "type": "function"
  },
  "gradient_as_bucket_view": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "graph_pop": {
    "description": "The class representing a Python function.",
    "std_args": [
      "node",
      "filters"
    ],
    "type": "function"
  },
  "graphdef": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "grid_sample": {
    "description": "Compute grid sample.",
    "std_args": [
      "input",
      "grid",
      "mode",
      "padding_mode",
      "align_corners"
    ],
    "type": "function"
  },
  "group": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "group_norm": {
    "description": "Apply Group Normalization for last certain number of dimensions.",
    "std_args": [
      "input",
      "num_groups",
      "weight",
      "bias",
      "eps"
    ],
    "type": "function"
  },
  "group_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "groupbegins77": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "groupbegins90": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "groupcache": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "groupcounter": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "groupends": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "grouplist": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "groupname": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "groups": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "gumbel": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "gumbel_softmax": {
    "description": "Sample from the Gumbel-Softmax distribution (`Link 1`_  `Link 2`_) and optionally discretize.",
    "std_args": [
      "logits",
      "tau",
      "hard",
      "eps",
      "dim"
    ],
    "type": "function"
  },
  "hadamard_transform": {
    "description": "hadamard_transform(a: array, scale: Optional[float] = None, stream: Union[None, Stream, Device] = None) -> array",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "half": {
    "description": "Casts all floating point parameters and buffers to ``half`` datatype.",
    "std_args": [
      "self"
    ],
    "type": "attribute"
  },
  "hamming": {
    "description": "Return a Hamming window of size M.\n\nJAX implementation of :func:`numpy.hamming`.\n\nArgs:\n  M: The window size.\n\nReturns:\n  An array of size M containing the Hamming window.\n\nExamples:\n  >>> with jnp.printoptions(precision=2, suppress=True):\n  ...   print(jnp.hamming(4))\n  [0.08 0.77 0.77 0.08]\n\nSee also:\n  - :func:`jax.numpy.bartlett`: return a Bartlett window of size M.\n  - :func:`jax.numpy.blackman`: return a Blackman window of size M.\n  - :func:`jax.numpy.hanning`: return a Hanning window of size M.\n  - :func:`jax.numpy.kaiser`: return a Kaiser window of size M.",
    "std_args": [
      "M"
    ],
    "type": "function"
  },
  "hanning": {
    "description": "Return a Hanning window of size M.\n\nJAX implementation of :func:`numpy.hanning`.\n\nArgs:\n  M: The window size.\n\nReturns:\n  An array of size M containing the Hanning window.\n\nExamples:\n  >>> with jnp.printoptions(precision=2, suppress=True):\n  ...   print(jnp.hanning(4))\n  [0.   0.75 0.75 0.  ]\n\nSee also:\n  - :func:`jax.numpy.bartlett`: return a Bartlett window of size M.\n  - :func:`jax.numpy.blackman`: return a Blackman window of size M.\n  - :func:`jax.numpy.hamming`: return a Hamming window of size M.\n  - :func:`jax.numpy.kaiser`: return a Kaiser window of size M.",
    "std_args": [
      "M"
    ],
    "type": "function"
  },
  "hard_shrink": {
    "description": "Hard Shrink activation function.\n\nIt is defined as:\n\n`hard_shrink(x) = x` if `|x| > threshold`,\n`hard_shrink(x) = 0` otherwise.\n\nArgs:\n    x: Input tensor.\n    threshold: Threshold value. Defaults to 0.5.",
    "std_args": [
      "x",
      "threshold"
    ],
    "type": "function"
  },
  "hard_sigmoid": {
    "description": "Hard sigmoid activation function.\n\nThe hard sigmoid activation is defined as:\n\n- `0` if `if x <= -3`\n- `1` if `x >= 3`\n- `(x/6) + 0.5` if `-3 < x < 3`\n\nIt's a faster, piecewise linear approximation\nof the sigmoid activation.\n\nArgs:\n    x: Input tensor.\n\nReference:\n\n- [Wikipedia \"Hard sigmoid\"](https://en.wikipedia.org/wiki/Hard_sigmoid)",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "hard_silu": {
    "description": "Hard SiLU activation function, also known as Hard Swish.\n\nIt is defined as:\n\n- `0` if `if x < -3`\n- `x` if `x > 3`\n- `x * (x + 3) / 6` if `-3 <= x <= 3`\n\nIt's a faster, piecewise linear approximation of the silu activation.\n\nArgs:\n    x: Input tensor.\n\nReference:\n\n- [A Howard, 2019](https://arxiv.org/abs/1905.02244)",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "hard_swish": {
    "description": "Hard SiLU activation function, also known as Hard Swish.\n\nIt is defined as:\n\n- `0` if `if x < -3`\n- `x` if `x > 3`\n- `x * (x + 3) / 6` if `-3 <= x <= 3`\n\nIt's a faster, piecewise linear approximation of the silu activation.\n\nArgs:\n    x: Input tensor.\n\nReference:\n\n- [A Howard, 2019](https://arxiv.org/abs/1905.02244)",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "hard_tanh": {
    "description": "HardTanh activation function.\n\nIt is defined as:\n`hard_tanh(x) = -1 for x < -1`,\n`hard_tanh(x) = x for -1 <= x <= 1`,\n`hard_tanh(x) = 1 for x > 1`.\n\nArgs:\n    x: Input tensor.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "harden_mask": {
    "description": "Forces the mask to hard.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "hardmask": {
    "description": "Specifies whether values can be unmasked through assignments.",
    "std_args": [],
    "type": "attribute"
  },
  "hardtanh_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "has_aux": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "has_c": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "has_c_compiler": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "has_delayed_bufalloc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "has_f77": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "has_f77_compiler": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "has_f90": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "has_f90_compiler": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "has_fortran_compiler": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "has_index": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "has_keyword_arg": {
    "description": "Return True if func has keyword-only arguments with the given name.",
    "std_args": [
      "func",
      "name"
    ],
    "type": "function"
  },
  "has_metadata": {
    "description": "Check if the Variable has a metadata entry for the given name.",
    "std_args": [
      "self",
      "name"
    ],
    "type": "function"
  },
  "has_multi_index": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "has_qdd": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "has_ref": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "has_setup": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "has_shared_memory": {
    "description": "Check that created array shares data with input array.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "has_uninitialized_params": {
    "description": "Check if a module has parameters that are not initialized.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "hasassumedshape": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "hasbody": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "hascallstatement": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "hascommon": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "hasderivedtypes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "hasexternals": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "hasinitvalue": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "hasinitvalueasstring": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "hasnote": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "hasobject": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hasresultnote": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "hasvariables": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "he_normal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "he_uniform": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "head": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "head_bias": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "head_dim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "head_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "heaviside": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "hello_world_f77": {
    "description": "Generates a single f77 file for testing",
    "std_args": [
      "tmpdir_factory"
    ],
    "type": "function"
  },
  "hello_world_f90": {
    "description": "Generates a single f90 file for testing",
    "std_args": [
      "tmpdir_factory"
    ],
    "type": "function"
  },
  "herm2poly": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermadd": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermcompanion": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermder": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermdiv": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermdomain": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "herme2poly": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermeadd": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermecompanion": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermeder": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermediv": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermedomain": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermefit": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermefromroots": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermegauss": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermegrid2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermegrid3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermeint": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermeline": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermemul": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermemulx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermeone": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermepow": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermeroots": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermesub": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermetrim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermeval": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermeval2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermeval3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermevander": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermevander2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermevander3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermeweight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermex": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermezero": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermfit": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermfromroots": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermgauss": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermgrid2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermgrid3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermint": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermite_polynomial_h": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermite_polynomial_he": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermitian": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermline": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermmul": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermmulx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermone": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermpow": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermroots": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermsub": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermtrim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermval": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermval2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermval3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermvander": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermvander2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermvander3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermweight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermzero": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hf": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hfft2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hfftn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hg": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hi": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hidden_features": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hidden_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hinge_embedding_loss": {
    "description": "Compute the hinge embedding loss.",
    "std_args": [
      "input",
      "target",
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "hinge_loss": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "histogram": {
    "description": "Compute a 1-dimensional histogram.\n\nJAX implementation of :func:`numpy.histogram`.\n\nArgs:\n  a: array of values to be binned. May be any size or dimension.\n  bins: Specify the number of bins in the histogram (default: 10). ``bins``\n    may also be an array specifying the locations of the bin edges.\n  range: tuple of scalars. Specifies the range of the data. If not specified,\n    the range is inferred from the data.\n  weights: An optional array specifying the weights of the data points.\n    Should be broadcast-compatible with ``a``. If not specified, each\n    data point is weighted equally.\n  density: If True, return the normalized histogram in units of counts\n    per unit length. If False (default) return the (weighted) counts per bin.\n\nReturns:\n  A tuple of arrays ``(histogram, bin_edges)``, where ``histogram`` contains\n  the aggregated data, and ``bin_edges`` specifies the boundaries of the bins.\n\nSee Also:\n  - :func:`jax.numpy.bincount`: Count the number of occurrences of each value in an array.\n  - :func:`jax.numpy.histogram2d`: Compute the histogram of a 2D array.\n  - :func:`jax.numpy.histogramdd`: Compute the histogram of an N-dimensional array.\n  - :func:`jax.numpy.histogram_bin_edges`: Compute the bin edges for a histogram.\n\nExamples:\n  >>> a = jnp.array([1, 2, 3, 10, 11, 15, 19, 25])\n  >>> counts, bin_edges = jnp.histogram(a, bins=8)\n  >>> print(counts)\n  [3. 0. 0. 2. 1. 0. 1. 1.]\n  >>> print(bin_edges)\n  [ 1.  4.  7. 10. 13. 16. 19. 22. 25.]\n\n  Specifying the bin range:\n\n  >>> counts, bin_edges = jnp.histogram(a, range=(0, 25), bins=5)\n  >>> print(counts)\n  [3. 0. 2. 2. 1.]\n  >>> print(bin_edges)\n  [ 0.  5. 10. 15. 20. 25.]\n\n  Specifying the bin edges explicitly:\n\n  >>> bin_edges = jnp.array([0, 10, 20, 30])\n  >>> counts, _ = jnp.histogram(a, bins=bin_edges)\n  >>> print(counts)\n  [3. 4. 1.]\n\n  Using ``density=True`` returns a normalized histogram:\n\n  >>> density, bin_edges = jnp.histogram(a, density=True)\n  >>> dx = jnp.diff(bin_edges)\n  >>> normed_sum = jnp.sum(density * dx)\n  >>> jnp.allclose(normed_sum, 1.0)\n  Array(True, dtype=bool)",
    "std_args": [
      "a",
      "bins",
      "range",
      "weights",
      "density"
    ],
    "type": "function"
  },
  "histogram2d": {
    "description": "Compute a 2-dimensional histogram.\n\nJAX implementation of :func:`numpy.histogram2d`.\n\nArgs:\n  x: one-dimensional array of x-values for points to be binned.\n  y: one-dimensional array of y-values for points to be binned.\n  bins: Specify the number of bins in the histogram (default: 10). ``bins``\n    may also be an array specifying the locations of the bin edges, or a pair\n    of integers or pair of arrays specifying the number of bins in each\n    dimension.\n  range: Pair of arrays or lists of the form ``[[xmin, xmax], [ymin, ymax]]``\n    specifying the range of the data in each dimension. If not specified, the\n    range is inferred from the data.\n  weights: An optional array specifying the weights of the data points.\n    Should be the same shape as ``x`` and ``y``. If not specified, each\n    data point is weighted equally.\n  density: If True, return the normalized histogram in units of counts\n    per unit area. If False (default) return the (weighted) counts per bin.\n\nReturns:\n  A tuple of arrays ``(histogram, x_edges, y_edges)``, where ``histogram``\n  contains the aggregated data, and ``x_edges`` and ``y_edges`` specify the\n  boundaries of the bins.\n\nSee Also:\n  - :func:`jax.numpy.histogram`: Compute the histogram of a 1D array.\n  - :func:`jax.numpy.histogramdd`: Compute the histogram of an N-dimensional array.\n  - :func:`jax.numpy.histogram_bin_edges`: Compute the bin edges for a histogram.\n\nExamples:\n  >>> x = jnp.array([1, 2, 3, 10, 11, 15, 19, 25])\n  >>> y = jnp.array([2, 5, 6, 8, 13, 16, 17, 18])\n  >>> counts, x_edges, y_edges = jnp.histogram2d(x, y, bins=8)\n  >>> counts.shape\n  (8, 8)\n  >>> x_edges\n  Array([ 1.,  4.,  7., 10., 13., 16., 19., 22., 25.], dtype=float32)\n  >>> y_edges\n  Array([ 2.,  4.,  6.,  8., 10., 12., 14., 16., 18.], dtype=float32)\n\n  Specifying the bin range:\n\n  >>> counts, x_edges, y_edges = jnp.histogram2d(x, y, range=[(0, 25), (0, 25)], bins=5)\n  >>> counts.shape\n  (5, 5)\n  >>> x_edges\n  Array([ 0.,  5., 10., 15., 20., 25.], dtype=float32)\n  >>> y_edges\n  Array([ 0.,  5., 10., 15., 20., 25.], dtype=float32)\n\n  Specifying the bin edges explicitly:\n\n  >>> x_edges = jnp.array([0, 10, 20, 30])\n  >>> y_edges = jnp.array([0, 10, 20, 30])\n  >>> counts, _, _ = jnp.histogram2d(x, y, bins=[x_edges, y_edges])\n  >>> counts\n  Array([[3, 0, 0],\n         [1, 3, 0],\n         [0, 1, 0]], dtype=int32)\n\n  Using ``density=True`` returns a normalized histogram:\n\n  >>> density, x_edges, y_edges = jnp.histogram2d(x, y, density=True)\n  >>> dx = jnp.diff(x_edges)\n  >>> dy = jnp.diff(y_edges)\n  >>> normed_sum = jnp.sum(density * dx[:, None] * dy[None, :])\n  >>> jnp.allclose(normed_sum, 1.0)\n  Array(True, dtype=bool)",
    "std_args": [
      "x",
      "y",
      "bins",
      "range",
      "weights",
      "density"
    ],
    "type": "function"
  },
  "histogram_bin_edges": {
    "description": "Compute the bin edges for a histogram.\n\nJAX implementation of :func:`numpy.histogram_bin_edges`.\n\nArgs:\n  a: array of values to be binned\n  bins: Specify the number of bins in the histogram (default: 10).\n  range: tuple of scalars. Specifies the range of the data. If not specified,\n    the range is inferred from the data.\n  weights: unused by JAX.\n\nReturns:\n  An array of bin edges for the histogram.\n\nSee also:\n  - :func:`jax.numpy.histogram`: compute a 1D histogram.\n  - :func:`jax.numpy.histogram2d`: compute a 2D histogram.\n  - :func:`jax.numpy.histogramdd`: compute an N-dimensional histogram.\n\nExamples:\n  >>> a = jnp.array([2, 5, 3, 6, 4, 1])\n  >>> jnp.histogram_bin_edges(a, bins=5)\n  Array([1., 2., 3., 4., 5., 6.], dtype=float32)\n  >>> jnp.histogram_bin_edges(a, bins=5, range=(-10, 10))  # doctest: +SKIP\n  Array([-10.,  -6.,  -2.,   2.,   6.,  10.], dtype=float32)",
    "std_args": [
      "a",
      "bins",
      "range",
      "weights"
    ],
    "type": "function"
  },
  "histogramdd": {
    "description": "Compute an N-dimensional histogram.\n\nJAX implementation of :func:`numpy.histogramdd`.\n\nArgs:\n  sample: input array of shape ``(N, D)`` representing ``N`` points in\n    ``D`` dimensions.\n  bins: Specify the number of bins in each dimension of the histogram.\n    (default: 10). May also be a length-D sequence of integers or arrays\n    of bin edges.\n  range: Length-D sequence of pairs specifying the range for each dimension.\n    If not specified, the range is inferred from the data.\n  weights: An optional shape ``(N,)`` array specifying the weights of the\n    data points.\n    Should be the same shape as ``sample``. If not specified, each\n    data point is weighted equally.\n  density: If True, return the normalized histogram in units of counts\n    per unit volume. If False (default) return the (weighted) counts per bin.\n\nReturns:\n  A tuple of arrays ``(histogram, bin_edges)``, where ``histogram`` contains\n  the aggregated data, and ``bin_edges`` specifies the boundaries of the bins.\n\nSee Also:\n  - :func:`jax.numpy.histogram`: Compute the histogram of a 1D array.\n  - :func:`jax.numpy.histogram2d`: Compute the histogram of a 2D array.\n  - :func:`jax.numpy.histogram_bin_edges`: Compute the bin edges for a histogram.\n\nExamples:\n  A histogram over 100 points in three dimensions\n\n  >>> key = jax.random.key(42)\n  >>> a = jax.random.normal(key, (100, 3))\n  >>> counts, bin_edges = jnp.histogramdd(a, bins=6,\n  ...                                     range=[(-3, 3), (-3, 3), (-3, 3)])\n  >>> counts.shape\n  (6, 6, 6)\n  >>> bin_edges  # doctest: +SKIP\n  [Array([-3., -2., -1.,  0.,  1.,  2.,  3.], dtype=float32),\n   Array([-3., -2., -1.,  0.,  1.,  2.,  3.], dtype=float32),\n   Array([-3., -2., -1.,  0.,  1.,  2.,  3.], dtype=float32)]\n\n  Using ``density=True`` returns a normalized histogram:\n\n  >>> density, bin_edges = jnp.histogramdd(a, density=True)\n  >>> bin_widths = map(jnp.diff, bin_edges)\n  >>> dx, dy, dz = jnp.meshgrid(*bin_widths, indexing='ij')\n  >>> normed = jnp.sum(density * dx * dy * dz)\n  >>> jnp.allclose(normed, 1.0)\n  Array(True, dtype=bool)",
    "std_args": [
      "sample",
      "bins",
      "range",
      "weights",
      "density"
    ],
    "type": "function"
  },
  "ho": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "holidays": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "householder_product": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hsplit": {
    "description": "Split an array into sub-arrays horizontally.\n\nJAX implementation of :func:`numpy.hsplit`.\n\nRefer to the documentation of :func:`jax.numpy.split` for details. ``hsplit`` is\nequivalent to ``split`` with ``axis=1``, or ``axis=0`` for one-dimensional arrays.\n\nExamples:\n  1D array:\n\n  >>> x = jnp.array([1, 2, 3, 4, 5, 6])\n  >>> x1, x2 = jnp.hsplit(x, 2)\n  >>> print(x1, x2)\n  [1 2 3] [4 5 6]\n\n  2D array:\n\n  >>> x = jnp.array([[1, 2, 3, 4],\n  ...                [5, 6, 7, 8]])\n  >>> x1, x2 = jnp.hsplit(x, 2)\n  >>> print(x1)\n  [[1 2]\n   [5 6]]\n  >>> print(x2)\n  [[3 4]\n   [7 8]]\n\nSee also:\n  - :func:`jax.numpy.split`: split an array along any axis.\n  - :func:`jax.numpy.vsplit`: split vertically, i.e. along axis=0\n  - :func:`jax.numpy.dsplit`: split depth-wise, i.e. along axis=2\n  - :func:`jax.numpy.array_split`: like ``split``, but allows ``indices_or_sections``\n    to be an integer that does not evenly divide the size of the array.",
    "std_args": [
      "ary",
      "indices_or_sections"
    ],
    "type": "attribute"
  },
  "hstack": {
    "description": "Horizontally stack arrays.\n\nJAX implementation of :func:`numpy.hstack`.\n\nFor arrays of one or more dimensions, this is equivalent to\n:func:`jax.numpy.concatenate` with ``axis=1``.\n\nArgs:\n  tup: a sequence of arrays to stack; each must have the same shape along all\n    but the second axis. Input arrays will be promoted to at least rank 1.\n    If a single array is given it will be treated equivalently to\n    `tup = unstack(tup)`, but the implementation will avoid explicit unstacking.\n  dtype: optional dtype of the resulting array. If not specified, the dtype\n    will be determined via type promotion rules described in :ref:`type-promotion`.\n\nReturns:\n  the stacked result.\n\nSee also:\n  - :func:`jax.numpy.stack`: stack along arbitrary axes\n  - :func:`jax.numpy.concatenate`: concatenation along existing axes.\n  - :func:`jax.numpy.vstack`: stack vertically, i.e. along axis 0.\n  - :func:`jax.numpy.dstack`: stack depth-wise, i.e. along axis 2.\n\nExamples:\n  Scalar values:\n\n  >>> jnp.hstack([1, 2, 3])\n  Array([1, 2, 3], dtype=int32, weak_type=True)\n\n  1D arrays:\n\n  >>> x = jnp.arange(3)\n  >>> y = jnp.ones(3)\n  >>> jnp.hstack([x, y])\n  Array([0., 1., 2., 1., 1., 1.], dtype=float32)\n\n  2D arrays:\n\n  >>> x = x.reshape(3, 1)\n  >>> y = y.reshape(3, 1)\n  >>> jnp.hstack([x, y])\n  Array([[0., 1.],\n         [1., 1.],\n         [2., 1.]], dtype=float32)",
    "std_args": [
      "tup",
      "dtype"
    ],
    "type": "function"
  },
  "hsv_to_rgb": {
    "description": "Convert HSV images to RGB.\n\n`images` must be of float dtype, and the output is only well defined if the\nvalues in `images` are in `[0, 1]`.\n\nArgs:\n    images: Input image or batch of images. Must be 3D or 4D.\n    data_format: A string specifying the data format of the input tensor.\n        It can be either `\"channels_last\"` or `\"channels_first\"`.\n        `\"channels_last\"` corresponds to inputs with shape\n        `(batch, height, width, channels)`, while `\"channels_first\"`\n        corresponds to inputs with shape `(batch, channels, height, width)`.\n        If not specified, the value will default to\n        `keras.config.image_data_format`.\n\nReturns:\n    RGB image or batch of RGB images.\n\nExamples:\n\n>>> import numpy as np\n>>> from keras import ops\n>>> x = np.random.random((2, 4, 4, 3))\n>>> y = ops.image.hsv_to_rgb(x)\n>>> y.shape\n(2, 4, 4, 3)\n\n>>> x = np.random.random((4, 4, 3)) # Single HSV image\n>>> y = ops.image.hsv_to_rgb(x)\n>>> y.shape\n(4, 4, 3)\n\n>>> x = np.random.random((2, 3, 4, 4))\n>>> y = ops.image.hsv_to_rgb(x, data_format=\"channels_first\")\n>>> y.shape\n(2, 3, 4, 4)",
    "std_args": [
      "images",
      "data_format"
    ],
    "type": "function"
  },
  "http_fakefile": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "http_fakepath": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "http_file": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "http_path": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "huber_loss": {
    "description": "Compute the Huber loss, with optional weighting.",
    "std_args": [
      "input",
      "target",
      "reduction",
      "delta",
      "weight"
    ],
    "type": "function"
  },
  "hugepage_setup": {
    "description": "We usually use madvise hugepages support, but on some old kernels it",
    "std_args": [],
    "type": "function"
  },
  "hypergeometric": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "i0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "i0e": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "i1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "i1e": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "id": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "identity_like_generalized": {
    "description": "The class representing a Python function.",
    "std_args": [
      "a"
    ],
    "type": "function"
  },
  "ids": {
    "description": "The class representing a Python function.",
    "std_args": [
      "a"
    ],
    "type": "function"
  },
  "if_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ifft2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "ig": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ignore_index": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ignorecontains": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ihfft2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ihfftn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ii": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ilist": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "impl": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "hijax_var",
      "leaves",
      "treedef",
      "var_type"
    ],
    "type": "function"
  },
  "implicitpattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "import_function": {
    "description": "import_function(file: str) -> Callable",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "in1_features": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in1d": {
    "description": "Test whether each element of an array is also present in a second",
    "std_args": [
      "ar1",
      "ar2",
      "assume_unique",
      "invert"
    ],
    "type": "function"
  },
  "in2_features": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in_avals": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in_axes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in_compact": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in_features": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in_ipython": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in_kv_features": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in_proj_bias": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in_proj_weight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in_shardings": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in_specs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in_top_k": {
    "description": "Checks if the targets are in the top-k predictions.\n\nArgs:\n    targets: A tensor of true labels.\n    predictions: A tensor of predicted labels.\n    k: An integer representing the number of predictions to consider.\n\nReturns:\n    A boolean tensor of the same shape as `targets`, where each element\n    indicates whether the corresponding target is in the top-k predictions.\n\nExample:\n\n>>> targets = keras.ops.convert_to_tensor([2, 5, 3])\n>>> predictions = keras.ops.convert_to_tensor(\n... [[0.1, 0.4, 0.6, 0.9, 0.5],\n...  [0.1, 0.7, 0.9, 0.8, 0.3],\n...  [0.1, 0.6, 0.9, 0.9, 0.5]])\n>>> in_top_k(targets, predictions, k=3)\narray([ True False  True], shape=(3,), dtype=bool)",
    "std_args": [
      "targets",
      "predictions",
      "k"
    ],
    "type": "function"
  },
  "in_tree": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "include_last_offset": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "include_paths": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "includes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "includes0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "indent": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "index": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "index_ref": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "index_ref_stack": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "indices": {
    "description": "Generate arrays of grid indices.\n\nJAX implementation of :func:`numpy.indices`.\n\nArgs:\n  dimensions: the shape of the grid.\n  dtype: the dtype of the indices (defaults to integer).\n  sparse: if True, then return sparse indices. Default is False, which\n    returns dense indices.\n\nReturns:\n  An array of shape ``(len(dimensions), *dimensions)`` If ``sparse`` is False,\n  or a sequence of arrays of the same length as ``dimensions`` if ``sparse`` is True.\n\nSee also:\n  - :func:`jax.numpy.meshgrid`: generate a grid from arbitrary input arrays.\n  - :obj:`jax.numpy.mgrid`: generate dense indices using a slicing syntax.\n  - :obj:`jax.numpy.ogrid`: generate sparse indices using a slicing syntax.\n\nExamples:\n  >>> jnp.indices((2, 3))\n  Array([[[0, 0, 0],\n          [1, 1, 1]],\n  <BLANKLINE>\n         [[0, 1, 2],\n          [0, 1, 2]]], dtype=int32)\n  >>> jnp.indices((2, 3), sparse=True)\n  (Array([[0],\n         [1]], dtype=int32), Array([[0, 1, 2]], dtype=int32))",
    "std_args": [
      "dimensions",
      "dtype",
      "sparse"
    ],
    "type": "attribute"
  },
  "inexact": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "attribute"
  },
  "info": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "init": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "init_cache": {
    "description": "Initializes cache for fast autoregressive decoding. When",
    "std_args": [
      "self",
      "input_shape",
      "dtype"
    ],
    "type": "function"
  },
  "init_single": {
    "description": "Initialize optimizer state",
    "std_args": [
      "self",
      "parameter",
      "state"
    ],
    "type": "function"
  },
  "init_with_output": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "rngs",
      "args",
      "method",
      "mutable",
      "kwargs"
    ],
    "type": "function"
  },
  "initialize_carry": {
    "description": "Initialize the RNN cell carry.",
    "std_args": [
      "self",
      "input_shape",
      "rngs",
      "carry_init"
    ],
    "type": "function"
  },
  "initialize_parameters": {
    "description": "Initialize parameters according to the input batch properties.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "initializing": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "inject_hyperparams": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "inject_stateful_hyperparams": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "inner": {
    "description": "Returns the inner product of a and b for arrays of floating point types.",
    "std_args": [
      "a",
      "b"
    ],
    "type": "function"
  },
  "inner_loop": {
    "description": "",
    "std_args": [
      "self",
      "sequences",
      "initial_state",
      "mask",
      "training"
    ],
    "type": "function"
  },
  "inner_ref_outer_index": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "innerproduct": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "inplace": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_args": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_carry_argnum": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_dilation": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_kwargs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_layouts": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_shape": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_shardings": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "insert": {
    "description": "Insert a given module before a given index in the list.",
    "std_args": [
      "self",
      "index",
      "module"
    ],
    "type": "function"
  },
  "insert_quotes": {
    "description": "Inverse of eliminate_quotes.",
    "std_args": [
      "s",
      "d"
    ],
    "type": "function"
  },
  "instance_norm": {
    "description": "Apply Instance Normalization independently for each channel in every data sample within a batch.",
    "std_args": [
      "input",
      "running_mean",
      "running_var",
      "weight",
      "bias",
      "use_input_stats",
      "momentum",
      "eps"
    ],
    "type": "function"
  },
  "int": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "attribute"
  },
  "int2": {
    "description": "A JAX scalar constructor of type int2.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "class"
  },
  "int4": {
    "description": "A JAX scalar constructor of type int4.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "class"
  },
  "int8": {
    "description": "A JAX scalar constructor of type int8.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "attribute"
  },
  "int_": {
    "description": "A JAX scalar constructor of type int64.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "attribute"
  },
  "int_func": {
    "description": "The class representing a Python function.",
    "std_args": [
      "request"
    ],
    "type": "function"
  },
  "intc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "integer": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "attribute"
  },
  "integer_types": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "intent": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "intent_list": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "intentpattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "interp": {
    "description": "One-dimensional linear interpolation.\n\nJAX implementation of :func:`numpy.interp`.\n\nArgs:\n  x: N-dimensional array of x coordinates at which to evaluate the interpolation.\n  xp: one-dimensional sorted array of points to be interpolated.\n  fp: array of shape ``xp.shape`` containing the function values associated with ``xp``.\n  left: specify how to handle points ``x < xp[0]``. Default is to return ``fp[0]``.\n    If ``left`` is a scalar value, it will return this value. if ``left`` is the string\n    ``\"extrapolate\"``, then the value will be determined by linear extrapolation.\n    ``left`` is ignored if ``period`` is specified.\n  right: specify how to handle points ``x > xp[-1]``. Default is to return ``fp[-1]``.\n    If ``right`` is a scalar value, it will return this value. if ``right`` is the string\n    ``\"extrapolate\"``, then the value will be determined by linear extrapolation.\n    ``right`` is ignored if ``period`` is specified.\n  period: optionally specify the period for the *x* coordinates, for e.g. interpolation\n    in angular space.\n\nReturns:\n  an array of shape ``x.shape`` containing the interpolated function at values ``x``.\n\nExamples:\n  >>> xp = jnp.arange(10)\n  >>> fp = 2 * xp\n  >>> x = jnp.array([0.5, 2.0, 3.5])\n  >>> interp(x, xp, fp)\n  Array([1., 4., 7.], dtype=float32)\n\n  Unless otherwise specified, extrapolation will be constant:\n\n  >>> x = jnp.array([-10., 10.])\n  >>> interp(x, xp, fp)\n  Array([ 0., 18.], dtype=float32)\n\n  Use ``\"extrapolate\"`` mode for linear extrapolation:\n\n  >>> interp(x, xp, fp, left='extrapolate', right='extrapolate')\n  Array([-20.,  20.], dtype=float32)\n\n  For periodic interpolation, specify the ``period``:\n\n  >>> xp = jnp.array([0, jnp.pi / 2, jnp.pi, 3 * jnp.pi / 2])\n  >>> fp = jnp.sin(xp)\n  >>> x = 2 * jnp.pi  # note: not in input array\n  >>> jnp.interp(x, xp, fp, period=2 * jnp.pi)\n  Array(0., dtype=float32)",
    "std_args": [
      "x",
      "xp",
      "fp",
      "left",
      "right",
      "period"
    ],
    "type": "function"
  },
  "interpolate": {
    "description": "Down/up samples the input.",
    "std_args": [
      "input",
      "size",
      "scale_factor",
      "mode",
      "align_corners",
      "recompute_scale_factor",
      "antialias"
    ],
    "type": "function"
  },
  "intersect1d": {
    "description": "Compute the set intersection of two 1D arrays.\n\nJAX implementation of :func:`numpy.intersect1d`.\n\nBecause the size of the output of ``intersect1d`` is data-dependent, the function\nis not typically compatible with :func:`~jax.jit` and other JAX transformations.\nThe JAX version adds the optional ``size`` argument which must be specified\nstatically for ``jnp.intersect1d`` to be used in such contexts.\n\nArgs:\n  ar1: first array of values to intersect.\n  ar2: second array of values to intersect.\n  assume_unique: if True, assume the input arrays contain unique values. This allows\n    a more efficient implementation, but if ``assume_unique`` is True and the input\n    arrays contain duplicates, the behavior is undefined. default: False.\n  return_indices: If True, return arrays of indices specifying where the intersected\n    values first appear in the input arrays.\n  size: if specified, return only the first ``size`` sorted elements. If there are fewer\n    elements than ``size`` indicates, the return value will be padded with ``fill_value``,\n    and returned indices will be padded with an out-of-bound index.\n  fill_value: when ``size`` is specified and there are fewer than the indicated number of\n    elements, fill the remaining entries ``fill_value``. Defaults to the smallest value\n    in the intersection.\n\nReturns:\n  An array ``intersection``, or if ``return_indices=True``, a tuple of arrays\n  ``(intersection, ar1_indices, ar2_indices)``. Returned values are\n\n  - ``intersection``:\n    A 1D array containing each value that appears in both ``ar1`` and ``ar2``.\n  - ``ar1_indices``:\n    *(returned if return_indices=True)* an array of shape ``intersection.shape`` containing\n    the indices in flattened ``ar1`` of values in ``intersection``. For 1D inputs,\n    ``intersection`` is equivalent to ``ar1[ar1_indices]``.\n  - ``ar2_indices``:\n    *(returned if return_indices=True)* an array of shape ``intersection.shape`` containing\n    the indices in flattened ``ar2`` of values in ``intersection``. For 1D inputs,\n    ``intersection`` is equivalent to ``ar2[ar2_indices]``.\n\nSee also:\n  - :func:`jax.numpy.union1d`: the set union of two 1D arrays.\n  - :func:`jax.numpy.setxor1d`: the set XOR of two 1D arrays.\n  - :func:`jax.numpy.setdiff1d`: the set difference of two 1D arrays.\n\nExamples:\n  >>> ar1 = jnp.array([1, 2, 3, 4])\n  >>> ar2 = jnp.array([3, 4, 5, 6])\n  >>> jnp.intersect1d(ar1, ar2)\n  Array([3, 4], dtype=int32)\n\n  Computing intersection with indices:\n\n  >>> intersection, ar1_indices, ar2_indices = jnp.intersect1d(ar1, ar2, return_indices=True)\n  >>> intersection\n  Array([3, 4], dtype=int32)\n\n  ``ar1_indices`` gives the indices of the intersected values within ``ar1``:\n\n   >>> ar1_indices\n   Array([2, 3], dtype=int32)\n   >>> jnp.all(intersection == ar1[ar1_indices])\n   Array(True, dtype=bool)\n\n  ``ar2_indices`` gives the indices of the intersected values within ``ar2``:\n\n   >>> ar2_indices\n   Array([0, 1], dtype=int32)\n   >>> jnp.all(intersection == ar2[ar2_indices])\n   Array(True, dtype=bool)",
    "std_args": [
      "ar1",
      "ar2",
      "assume_unique",
      "return_indices",
      "size",
      "fill_value"
    ],
    "type": "function"
  },
  "intp": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "intrinsicpattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "inv_ex": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "invalid_baseurl": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "invalid_httpfile": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "invalid_httpurl": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "invalid_textfile": {
    "description": "The class representing a Python function.",
    "std_args": [
      "filedir"
    ],
    "type": "function"
  },
  "invbadnames": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "invert": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "invert_permutation": {
    "description": "Returns the inverse of ``permutation``.",
    "std_args": [
      "permutation"
    ],
    "type": "function"
  },
  "io": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ipu": {
    "description": "Move all model parameters and buffers to the IPU.",
    "std_args": [
      "self",
      "device"
    ],
    "type": "function"
  },
  "irfft2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "isMA": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "isMaskedArray": {
    "description": "Test whether input is an instance of MaskedArray.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "is_array_ref": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "is_available": {
    "description": "Check if the Metal back-end is available.",
    "std_args": [],
    "type": "function"
  },
  "is_cuda": {
    "description": "Return true if `self.data` stored on a gpu.",
    "std_args": [],
    "type": "attribute"
  },
  "is_data": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_free_format": {
    "description": "Check if file is in free format Fortran.",
    "std_args": [
      "fname"
    ],
    "type": "function"
  },
  "is_graph_node": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "is_high": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "leaf_avals",
      "treedef",
      "var_type"
    ],
    "type": "function"
  },
  "is_hijax": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_initializing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_inner": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_inplace": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_integer": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_intent": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "names"
    ],
    "type": "function"
  },
  "is_intent_exact": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "names"
    ],
    "type": "function"
  },
  "is_lazy": {
    "description": "Returns whether ``param`` is an ``UninitializedParameter`` or ``UninitializedBuffer``.",
    "std_args": [
      "param"
    ],
    "type": "function"
  },
  "is_mask": {
    "description": "Return True if m is a valid, standard mask.",
    "std_args": [
      "m"
    ],
    "type": "function"
  },
  "is_masked": {
    "description": "Determine whether input has masked values.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "is_mutable": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_namedtuple": {
    "description": "The class representing a Python function.",
    "std_args": [
      "obj"
    ],
    "type": "function"
  },
  "is_node": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "is_node_leaf": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "is_node_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "is_parametrized": {
    "description": "Determine if a module has a parametrization.",
    "std_args": [
      "module",
      "tensor_name"
    ],
    "type": "function"
  },
  "is_pinned": {
    "description": "Return true if `self.data` stored on in pinned memory.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_pruned": {
    "description": "Check if a module is pruned by looking for pruning pre-hooks.",
    "std_args": [
      "module"
    ],
    "type": "function"
  },
  "is_pytree_node": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "is_setup": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_string_or_list_of_strings": {
    "description": "The class representing a Python function.",
    "std_args": [
      "val"
    ],
    "type": "function"
  },
  "is_tensor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "is_tree_node": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "is_unexpected": {
    "description": "Check if this needs to be considered.",
    "std_args": [
      "name"
    ],
    "type": "function"
  },
  "is_valid": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_vanilla_variable": {
    "description": "A variable is vanilla if its metadata is essentially blank.",
    "std_args": [
      "vs"
    ],
    "type": "function"
  },
  "isalignedstruct": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "isallocatable": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isarray": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isarrayofstrings": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isattr_value": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isbuiltin": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ischaracter": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "ischaracter_or_characterarray": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "ischaracterarray": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isclose": {
    "description": "Return whether two tensors are element-wise almost equal.\n\nArgs:\n    x1: First input tensor.\n    x2: Second input tensor.\n    rtol: Relative tolerance.\n    atol: Absolute tolerance.\n    equal_nan: If `True`, element-wise NaNs are considered equal.\n\nReturns:\n    Output boolean tensor.",
    "std_args": [
      "x1",
      "x2",
      "rtol",
      "atol",
      "equal_nan"
    ],
    "type": "function"
  },
  "iscomplex": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "iscomplexarray": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "iscomplexfunction": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "iscomplexfunction_warn": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "iscomplexobj": {
    "description": "Check if the input is a complex number or an array containing complex elements.\n\nJAX implementation of :func:`numpy.iscomplexobj`.\n\nThe function evaluates based on input type rather than value.\nInputs with zero imaginary parts are still considered complex.\n\nArgs:\n  x: input object to check.\n\nReturns:\n  True if ``x`` is a complex number or an array containing at least one complex element,\n  False otherwise.\n\nSee Also:\n  - :func:`jax.numpy.isrealobj`\n  - :func:`jax.numpy.iscomplex`\n\nExamples:\n  >>> jnp.iscomplexobj(True)\n  False\n  >>> jnp.iscomplexobj(0)\n  False\n  >>> jnp.iscomplexobj(jnp.array([1, 2]))\n  False\n  >>> jnp.iscomplexobj(1+2j)\n  True\n  >>> jnp.iscomplexobj(jnp.array([0, 1+2j]))\n  True",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "iscontiguous": {
    "description": "Return a boolean indicating whether the data is contiguous.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "iscstyledirective": {
    "description": "The class representing a Python function.",
    "std_args": [
      "f2py_line"
    ],
    "type": "function"
  },
  "isdouble": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isdummyroutine": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "isexternal": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isfalse": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isfunction": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "isfunction_wrap": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "isin": {
    "description": "Determine whether elements in ``element`` appear in ``test_elements``.\n\nJAX implementation of :func:`numpy.isin`.\n\nArgs:\n  element: input array of elements for which membership will be checked.\n  test_elements: N-dimensional array of test values to check for the presence of\n    each element.\n  invert: If True, return ``~isin(element, test_elements)``. Default is False.\n  assume_unique: if true, input arrays are assumed to be unique, which can\n    lead to more efficient computation. If the input arrays are not unique\n    and assume_unique is set to True, the results are undefined.\n  method: string specifying the method used to compute the result. Supported\n    options are 'compare_all', 'binary_search', 'sort', and 'auto' (default).\n\nReturns:\n  A boolean array of shape ``element.shape`` that specifies whether each element\n  appears in ``test_elements``.\n\nExamples:\n  >>> elements = jnp.array([1, 2, 3, 4])\n  >>> test_elements = jnp.array([[1, 5, 6, 3, 7, 1]])\n  >>> jnp.isin(elements, test_elements)\n  Array([ True, False,  True, False], dtype=bool)",
    "std_args": [
      "element",
      "test_elements",
      "assume_unique",
      "invert",
      "method"
    ],
    "type": "function"
  },
  "isint1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isint1array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isinteger": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isintent_aligned16": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isintent_aligned4": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isintent_aligned8": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isintent_aux": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isintent_c": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isintent_cache": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isintent_callback": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isintent_copy": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isintent_dict": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "isintent_hide": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isintent_in": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isintent_inout": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isintent_inplace": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isintent_nothide": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isintent_out": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isintent_overwrite": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "islogical": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "islogicalfunction": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "islong_complex": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "islong_double": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "islong_doublefunction": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "islong_long": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "islong_longfunction": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "ismoduleroutine": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "ismutable": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isnat": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "isnative": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "isneginf": {
    "description": "Return boolean array indicating whether each element of input is negative infinite.\n\nJAX implementation of :obj:`numpy.isneginf`.\n\nArgs:\n  x: input array or scalar. ``complex`` dtype are not supported.\n\nReturns:\n  A boolean array of same shape as ``x`` containing ``True`` where ``x`` is\n  ``-inf``, and ``False`` otherwise.\n\nSee also:\n  - :func:`jax.numpy.isinf`: Returns a boolean array indicating whether each\n    element of input is either positive or negative infinity.\n  - :func:`jax.numpy.isposinf`: Returns a boolean array indicating whether each\n    element of input is positive infinity.\n  - :func:`jax.numpy.isfinite`: Returns a boolean array indicating whether each\n    element of input is finite.\n  - :func:`jax.numpy.isnan`: Returns a boolean array indicating whether each\n    element of input is not a number (``NaN``).\n\nExamples:\n  >>> jnp.isneginf(jnp.inf)\n  Array(False, dtype=bool)\n  >>> x = jnp.array([-jnp.inf, 5, jnp.inf, jnp.nan, 1])\n  >>> jnp.isneginf(x)\n  Array([ True, False, False, False, False], dtype=bool)",
    "std_args": [
      "x",
      "out"
    ],
    "type": "function"
  },
  "isoptional": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isposinf": {
    "description": "Return boolean array indicating whether each element of input is positive infinite.\n\nJAX implementation of :obj:`numpy.isposinf`.\n\nArgs:\n  x: input array or scalar. ``complex`` dtype are not supported.\n\nReturns:\n  A boolean array of same shape as ``x`` containing ``True`` where ``x`` is\n  ``inf``, and ``False`` otherwise.\n\nSee also:\n  - :func:`jax.numpy.isinf`: Returns a boolean array indicating whether each\n    element of input is either positive or negative infinity.\n  - :func:`jax.numpy.isneginf`: Returns a boolean array indicating whether each\n    element of input is negative infinity.\n  - :func:`jax.numpy.isfinite`: Returns a boolean array indicating whether each\n    element of input is finite.\n  - :func:`jax.numpy.isnan`: Returns a boolean array indicating whether each\n    element of input is not a number (``NaN``).\n\nExamples:\n  >>> jnp.isposinf(5)\n  Array(False, dtype=bool)\n  >>> x = jnp.array([-jnp.inf, 5, jnp.inf, jnp.nan, 1])\n  >>> jnp.isposinf(x)\n  Array([False, False,  True, False, False], dtype=bool)",
    "std_args": [
      "x",
      "out"
    ],
    "type": "function"
  },
  "isprivate": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isreal": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isrealobj": {
    "description": "Check if the input is not a complex number or an array containing complex elements.\n\nJAX implementation of :func:`numpy.isrealobj`.\n\nThe function evaluates based on input type rather than value.\nInputs with zero imaginary parts are still considered complex.\n\nArgs:\n  x: input object to check.\n\nReturns:\n  False if ``x`` is a complex number or an array containing at least one complex element,\n  True otherwise.\n\nSee Also:\n  - :func:`jax.numpy.iscomplexobj`\n  - :func:`jax.numpy.isreal`\n\nExamples:\n  >>> jnp.isrealobj(0)\n  True\n  >>> jnp.isrealobj(1.2)\n  True\n  >>> jnp.isrealobj(jnp.array([1, 2]))\n  True\n  >>> jnp.isrealobj(1+2j)\n  False\n  >>> jnp.isrealobj(jnp.array([0, 1+2j]))\n  False",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "isrequired": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isroutine": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "isscalar": {
    "description": "Return True if the input is a scalar.\n\nJAX implementation of :func:`numpy.isscalar`. JAX's implementation differs\nfrom NumPy's in that it considers zero-dimensional arrays to be scalars; see\nthe *Note* below for more details.\n\nArgs:\n  element: input object to check; any type is valid input.\n\nReturns:\n  True if ``element`` is a scalar value or an array-like object with zero\n  dimensions, False otherwise.\n\nNote:\n  JAX and NumPy differ in their representation of scalar values. NumPy has\n  special scalar objects (e.g. ``np.int32(0)``) which are distinct from\n  zero-dimensional arrays (e.g. ``np.array(0)``), and :func:`numpy.isscalar`\n  returns ``True`` for the former and ``False`` for the latter.\n\n  JAX does not define special scalar objects, but rather represents scalars as\n  zero-dimensional arrays. As such, :func:`jax.numpy.isscalar` returns ``True``\n  for both scalar objects (e.g. ``0.0`` or ``np.float32(0.0)``) and array-like\n  objects with zero dimensions (e.g. ``jnp.array(0.0)``, ``np.array(0.0)``).\n\n  One reason for the different conventions in ``isscalar`` is to maintain\n  JIT-invariance: i.e. the property that the result of a function should not\n  change when it is JIT-compiled. Because scalar inputs are cast to\n  zero-dimensional JAX arrays at JIT boundaries, the semantics of\n  :func:`numpy.isscalar` are such that the result changes under JIT:\n\n  >>> np.isscalar(1.0)\n  True\n  >>> jax.jit(np.isscalar)(1.0)\n  Array(False, dtype=bool)\n\n  By treating zero-dimensional arrays as scalars, :func:`jax.numpy.isscalar`\n  avoids this issue:\n\n  >>> jnp.isscalar(1.0)\n  True\n  >>> jax.jit(jnp.isscalar)(1.0)\n  Array(True, dtype=bool)\n\nExamples:\n  In JAX, both scalars and zero-dimensional array-like objects are considered\n  scalars:\n\n  >>> jnp.isscalar(1.0)\n  True\n  >>> jnp.isscalar(1 + 1j)\n  True\n  >>> jnp.isscalar(jnp.array(1))  # zero-dimensional JAX array\n  True\n  >>> jnp.isscalar(jnp.int32(1))  # JAX scalar constructor\n  True\n  >>> jnp.isscalar(np.array(1.0))  # zero-dimensional NumPy array\n  True\n  >>> jnp.isscalar(np.int32(1))  # NumPy scalar type\n  True\n\n  Arrays with one or more dimension are not considered scalars:\n\n  >>> jnp.isscalar(jnp.array([1]))\n  False\n  >>> jnp.isscalar(np.array([1]))\n  False\n\n  Compare this to :func:`numpy.isscalar`, which returns ``True`` for\n  scalar-typed objects, and ``False`` for *all* arrays, even those with\n  zero dimensions:\n\n  >>> np.isscalar(np.int32(1))  # scalar object\n  True\n  >>> np.isscalar(np.array(1))  # zero-dimensional array\n  False\n\n  In JAX, as in NumPy, objects which are not array-like are not considered\n  scalars:\n\n  >>> jnp.isscalar(None)\n  False\n  >>> jnp.isscalar([1])\n  False\n  >>> jnp.isscalar(())\n  False\n  >>> jnp.isscalar(slice(10))\n  False",
    "std_args": [
      "element"
    ],
    "type": "function"
  },
  "issequence": {
    "description": "Is seq a sequence (ndarray, list or tuple)?",
    "std_args": [
      "seq"
    ],
    "type": "function"
  },
  "issigned_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "issigned_chararray": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "issigned_long_longarray": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "issigned_shortarray": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isstring": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isstring_or_stringarray": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isstringarray": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isstringfunction": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "issubdtype": {
    "description": "Return True if arg1 is equal or lower than arg2 in the type hierarchy.\n\nJAX implementation of :func:`numpy.issubdtype`.\n\nThe main difference in JAX's implementation is that it properly handles\ndtype extensions such as :code:`bfloat16`.\n\nArgs:\n  arg1: dtype-like object. In typical usage, this will be a dtype specifier,\n    such as ``\"float32\"`` (i.e. a string), ``np.dtype('int32')`` (i.e. an\n    instance of :class:`numpy.dtype`), ``jnp.complex64`` (i.e. a JAX scalar\n    constructor), or ``np.uint8`` (i.e. a NumPy scalar type).\n  arg2: dtype-like object. In typical usage, this will be a generic scalar\n    type, such as ``jnp.integer``, ``jnp.floating``, or ``jnp.complexfloating``.\n\nReturns:\n  True if arg1 represents a dtype that is equal or lower in the type\n  hierarchy than arg2.\n\nSee also:\n  - :func:`jax.numpy.isdtype`: similar function aligning with the array API standard.\n\nExamples:\n  >>> jnp.issubdtype('uint32', jnp.unsignedinteger)\n  True\n  >>> jnp.issubdtype(np.int32, jnp.integer)\n  True\n  >>> jnp.issubdtype(jnp.bfloat16, jnp.floating)\n  True\n  >>> jnp.issubdtype(np.dtype('complex64'), jnp.complexfloating)\n  True\n  >>> jnp.issubdtype('complex64', jnp.integer)\n  False\n\n  Be aware that while this is very similar to :func:`numpy.issubdtype`, the\n  results of these differ in the case of JAX's custom floating point types:\n\n  >>> np.issubdtype('bfloat16', np.floating)\n  False\n  >>> jnp.issubdtype('bfloat16', jnp.floating)\n  True",
    "std_args": [
      "arg1",
      "arg2"
    ],
    "type": "function"
  },
  "issubroutine": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "issubroutine_wrap": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "istft": {
    "description": "Inverse Short-Time Fourier Transform along the last axis of the input.\n\nTo reconstruct an original waveform, the parameters should be the same in\n`stft`.\n\nArgs:\n    x: Tuple of the real and imaginary parts of the input tensor. Both\n        tensors in the tuple should be of floating type.\n    sequence_length: An integer representing the sequence length.\n    sequence_stride: An integer representing the sequence hop size.\n    fft_length: An integer representing the size of the FFT that produced\n        `stft`. Should be of type `int32`.\n    length: An integer representing the output is clipped to exactly length.\n        If not specified, no padding or clipping take place. Defaults to\n        `None`.\n    window: A string, a tensor of the window or `None`. If `window` is a\n        string, available values are `\"hann\"` and `\"hamming\"`. If `window`\n        is a tensor, it will be used directly as the window and its length\n        must be `sequence_length`. If `window` is `None`, no windowing is\n        used. Defaults to `\"hann\"`.\n    center: Whether `x` was padded on both sides so that the t-th sequence\n        is centered at time `t * sequence_stride`. Defaults to `True`.\n\nReturns:\n    A tensor containing the inverse Short-Time Fourier Transform along the\n    last axis of `x`.\n\nExample:\n\n>>> x = keras.ops.convert_to_tensor([0.0, 1.0, 2.0, 3.0, 4.0])\n>>> istft(stft(x, 1, 1, 1), 1, 1, 1)\narray([0.0, 1.0, 2.0, 3.0, 4.0])",
    "std_args": [
      "x",
      "sequence_length",
      "sequence_stride",
      "fft_length",
      "length",
      "window",
      "center"
    ],
    "type": "function"
  },
  "isthreadsafe": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "istrue": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isunsigned": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isunsigned_char": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isunsigned_chararray": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isunsigned_long_long": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isunsigned_long_longarray": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isunsigned_short": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isunsigned_shortarray": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isunsignedarray": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "isvariable": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "item": {
    "description": "Copy an element of an array to a standard Python scalar and return it.",
    "std_args": [
      "self",
      "args"
    ],
    "type": "function"
  },
  "items": {
    "description": "Return an iterable of the ParameterDict key/value pairs.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "itemsize": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "iter_children": {
    "description": "Iterates over all children :class:`Module`'s of a given Module. This",
    "std_args": [
      "module"
    ],
    "type": "function"
  },
  "iter_graph": {
    "description": "Iterates over all nested nodes and leaves of the given graph node, including the current node.",
    "std_args": [
      "node"
    ],
    "type": "function"
  },
  "iter_modules": {
    "description": "Recursively iterates over all nested :class:`Module`'s of the given Module, including",
    "std_args": [
      "module"
    ],
    "type": "function"
  },
  "iterationneedsapi": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "iterindex": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "iternext": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "iterrange": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "iters": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "itersize": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "itviews": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "itype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ix_": {
    "description": "Return a multi-dimensional grid (open mesh) from N one-dimensional sequences.\n\nJAX implementation of :func:`numpy.ix_`.\n\nArgs:\n  *args: N one-dimensional arrays\n\nReturns:\n  Tuple of Jax arrays forming an open mesh, each with N dimensions.\n\nSee Also:\n  - :obj:`jax.numpy.ogrid`\n  - :obj:`jax.numpy.mgrid`\n  - :func:`jax.numpy.meshgrid`\n\nExamples:\n  >>> rows = jnp.array([0, 2])\n  >>> cols = jnp.array([1, 3])\n  >>> open_mesh = jnp.ix_(rows, cols)\n  >>> open_mesh\n  (Array([[0],\n        [2]], dtype=int32), Array([[1, 3]], dtype=int32))\n  >>> [grid.shape for grid in open_mesh]\n  [(2, 1), (1, 2)]\n  >>> x = jnp.array([[10, 20, 30, 40],\n  ...                [50, 60, 70, 80],\n  ...                [90, 100, 110, 120],\n  ...                [130, 140, 150, 160]])\n  >>> x[open_mesh]\n  Array([[ 20,  40],\n         [100, 120]], dtype=int32)",
    "std_args": [
      "args"
    ],
    "type": "function"
  },
  "jax_in_shardings": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "jax_nondiff_argnums": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "jax_out_shardings": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "jax_to_nnx_path": {
    "description": "The class representing a Python function.",
    "std_args": [
      "jax_path"
    ],
    "type": "function"
  },
  "jax_trace": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "jit": {
    "description": "JIT Compilation.",
    "std_args": [
      "func",
      "static_argnums"
    ],
    "type": "function"
  },
  "jit_wrapped": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "jitted_fn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "join": {
    "description": "Context manager for training with uneven inputs across processes in DDP.",
    "std_args": [
      "self",
      "divide_by_initial_world_size",
      "enable",
      "throw_on_early_termination"
    ],
    "type": "function"
  },
  "join_by": {
    "description": "Join arrays `r1` and `r2` on key `key`.",
    "std_args": [
      "key",
      "r1",
      "r2",
      "jointype",
      "r1postfix",
      "r2postfix",
      "defaults",
      "usemask",
      "asrecarray"
    ],
    "type": "function"
  },
  "join_device": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "join_hook": {
    "description": "DDP join hook enables training on uneven inputs by mirroring communications in forward and backward passes.",
    "std_args": [
      "self",
      "kwargs"
    ],
    "type": "function"
  },
  "join_process_group": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "join_schedules": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "jvp": {
    "description": "The class representing a Python function.",
    "std_args": [
      "_",
      "primals",
      "tangents",
      "avals"
    ],
    "type": "function"
  },
  "k": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "k_proj_weight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kaiming_normal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kaiming_normal_": {
    "description": "Fill the input `Tensor` with values using a Kaiming normal distribution.",
    "std_args": [
      "tensor",
      "a",
      "mode",
      "nonlinearity",
      "generator"
    ],
    "type": "function"
  },
  "kaiming_uniform": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kaiming_uniform_": {
    "description": "Fill the input `Tensor` with values using a Kaiming uniform distribution.",
    "std_args": [
      "tensor",
      "a",
      "mode",
      "nonlinearity",
      "generator"
    ],
    "type": "function"
  },
  "kaiser": {
    "description": "Return a Kaiser window of size M.\n\nJAX implementation of :func:`numpy.kaiser`.\n\nArgs:\n  M: The window size.\n  beta: The Kaiser window parameter.\n\nReturns:\n  An array of size M containing the Kaiser window.\n\nExamples:\n  >>> with jnp.printoptions(precision=2, suppress=True):\n  ...   print(jnp.kaiser(4, 1.5))\n  [0.61 0.95 0.95 0.61]\n\nSee also:\n  - :func:`jax.numpy.bartlett`: return a Bartlett window of size M.\n  - :func:`jax.numpy.blackman`: return a Blackman window of size M.\n  - :func:`jax.numpy.hamming`: return a Hamming window of size M.\n  - :func:`jax.numpy.hanning`: return a Hanning window of size M.",
    "std_args": [
      "M",
      "beta"
    ],
    "type": "function"
  },
  "kdim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "keep_order": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "keep_params_nonnegative": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "keepdim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kernel": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kernel_dilation": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kernel_shape": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kernel_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "key": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "key_index": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "key_ln": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "key_proj": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "keys": {
    "description": "Return an iterable of the ParameterDict keys.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "kind": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kindselector": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kl_div": {
    "description": "Compute the KL Divergence loss.",
    "std_args": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction",
      "log_target"
    ],
    "type": "function"
  },
  "kl_div_loss": {
    "description": "Computes the Kullback-Leibler divergence loss.",
    "std_args": [
      "inputs",
      "targets",
      "axis",
      "reduction"
    ],
    "type": "function"
  },
  "kl_divergence": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kpack": {
    "description": "ROCm-specific kernel packing parameter.",
    "std_args": [],
    "type": "attribute"
  },
  "kron": {
    "description": "Kronecker product of `x1` and `x2`.\n\nComputes the Kronecker product of two input tensors. If `x1` has shape\n`(a0, a1, ..., an)` and `x2` has shape `(b0, b1, ..., bn)`, then the\noutput will have shape `(a0*b0, a1*b1, ..., an*bn)`.\n\nArgs:\n    x1: First input tensor.\n    x2: Second input tensor.\n\nReturns:\n    A tensor representing the Kronecker product of `x1` and `x2`.",
    "std_args": [
      "x1",
      "x2"
    ],
    "type": "function"
  },
  "kv_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kv_num_blocks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kv_sep": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kwarg_shardings": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kwarg_specs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kwargs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "l1_loss": {
    "description": "Compute the L1 loss, with optional weighting.",
    "std_args": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction",
      "weight"
    ],
    "type": "function"
  },
  "l1_unstructured": {
    "description": "Prune tensor by removing units with the lowest L1-norm.",
    "std_args": [
      "module",
      "name",
      "amount",
      "importance_scores"
    ],
    "type": "function"
  },
  "l2_loss": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "l_and": {
    "description": "The class representing a Python function.",
    "std_args": [
      "f"
    ],
    "type": "function"
  },
  "l_not": {
    "description": "The class representing a Python function.",
    "std_args": [
      "f"
    ],
    "type": "function"
  },
  "l_or": {
    "description": "The class representing a Python function.",
    "std_args": [
      "f"
    ],
    "type": "function"
  },
  "label_smoothing": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lag2poly": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lagadd": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lagcompanion": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lagder": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lagdiv": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lagdomain": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lagfit": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lagfromroots": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "laggauss": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "laggrid2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "laggrid3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lagint": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lagline": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lagmul": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lagmulx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lagone": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lagpow": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lagroots": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lagsub": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lagtrim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "laguerre_polynomial_l": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lagval": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lagval2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lagval3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lagvander": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lagvander2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lagvander3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lagweight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lagx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lagzero": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lambd": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "laplace": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "larger_types": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "layer_instance": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "layer_norm": {
    "description": "Apply Layer Normalization for last certain number of dimensions.",
    "std_args": [
      "input",
      "normalized_shape",
      "weight",
      "bias",
      "eps"
    ],
    "type": "function"
  },
  "layer_normalization": {
    "description": "Layer normalization layer (Ba et al., 2016).\n\nNormalize the activations of the previous layer for each given example in a\nbatch independently, rather than across a batch like Batch Normalization.\ni.e. applies a transformation that maintains the mean activation within each\nexample close to 0 and the activation standard deviation close to 1.\n\nArgs:\n    x: Input tensor.\n    gamma: Optional scaling factor for the normalization.\n    beta: Optional add offset for the normalized tensor.\n    axis: The axis or axes along which to perform normalization. Default to\n        `-1`.\n    epsilon: A lower bound value for the norm.\n        Defaults to `backend.epsilon()`.\n\nReturns:\n    The normalized array.\n\nExample:\n\n>>> x = keras.ops.arange(5, dtype=\"float32\")\n>>> keras.ops.layer_normalization(x)\narray([-1.4142135, -0.70710677, 0.0, 0.7071067, 1.4142135])",
    "std_args": [
      "x",
      "gamma",
      "beta",
      "axis",
      "epsilon",
      "kwargs"
    ],
    "type": "function"
  },
  "layers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lazy_init": {
    "description": "A shortcut of calling `nnx.bridge.lazy_init()` upon this module.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "lcb2_map": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lcb_map": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lcm": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "ldexp": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "ldl_factor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ldl_factor_ex": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ldl_solve": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "leaf_avals": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "leaf_modules": {
    "description": "Return the submodules that do not contain other modules.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "leaky_relu": {
    "description": "leaky_relu(input, negative_slope=0.01, inplace=False) -> Tensor",
    "std_args": [
      "input",
      "negative_slope",
      "inplace"
    ],
    "type": "function"
  },
  "leaky_relu_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "learning_rate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "leaves": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lecun_normal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lecun_uniform": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "left_shift": {
    "description": "Shift the bits of an integer to the left.",
    "std_args": [
      "a",
      "n"
    ],
    "type": "function"
  },
  "leg2poly": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legadd": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legcompanion": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legder": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legdiv": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legdomain": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legendre_polynomial_p": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legfit": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legfromroots": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "leggauss": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "leggrid2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "leggrid3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legint": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legline": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legmul": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legmulx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legone": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legpow": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legroots": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legsub": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legtrim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legval": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legval2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legval3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legvander": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legvander2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legvander3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legweight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legzero": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lenarraypattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "length_list": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lenkindpattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "like_function": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "linear1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "linear2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "linear_dimspecs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "linear_onecycle_schedule": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "linear_schedule": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "linear_solve": {
    "description": "Return a, b such that a * symbol + b == self.",
    "std_args": [
      "self",
      "symbol"
    ],
    "type": "function"
  },
  "linear_to_mel_weight_matrix": {
    "description": "Returns a matrix to warp linear scale spectrograms to the mel scale.\n\nReturns a weight matrix that can be used to re-weight a tensor\ncontaining `num_spectrogram_bins` linearly sampled frequency information\nfrom `[0, sampling_rate / 2]` into `num_mel_bins` frequency information\nfrom `[lower_edge_hertz, upper_edge_hertz]` on the mel scale.\n\nThis function follows the [Hidden Markov Model Toolkit (HTK)](\nhttp://htk.eng.cam.ac.uk/) convention, defining the mel scale in\nterms of a frequency in hertz according to the following formula:\n\n```mel(f) = 2595 * log10( 1 + f/700)```\n\nIn the returned matrix, all the triangles (filterbanks) have a peak\nvalue of 1.0.\n\nFor example, the returned matrix `A` can be used to right-multiply a\nspectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear\nscale spectrum values (e.g. STFT magnitudes) to generate a\n\"mel spectrogram\" `M` of shape `[frames, num_mel_bins]`.\n\n```\n# `S` has shape [frames, num_spectrogram_bins]\n# `M` has shape [frames, num_mel_bins]\nM = keras.ops.matmul(S, A)\n```\n\nThe matrix can be used with `keras.ops.tensordot` to convert an\narbitrary rank `Tensor` of linear-scale spectral bins into the\nmel scale.\n\n```\n# S has shape [..., num_spectrogram_bins].\n# M has shape [..., num_mel_bins].\nM = keras.ops.tensordot(S, A, 1)\n```\n\nReferences:\n- [Mel scale (Wikipedia)](https://en.wikipedia.org/wiki/Mel_scale)\n\nArgs:\n    num_mel_bins: Python int. How many bands in the resulting\n        mel spectrum.\n    num_spectrogram_bins: An integer `Tensor`. How many bins there are\n        in the source spectrogram data, which is understood to be\n        `fft_size // 2 + 1`, i.e. the spectrogram only contains the\n        nonredundant FFT bins.\n    sampling_rate: An integer or float `Tensor`. Samples per second of\n        the input signal used to create the spectrogram. Used to figure\n        out the frequencies corresponding to each spectrogram bin,\n        which dictates how they are mapped into the mel scale.\n    lower_edge_hertz: Python float. Lower bound on the frequencies to be\n        included in the mel spectrum. This corresponds to the lower\n        edge of the lowest triangular band.\n    upper_edge_hertz: Python float. The desired top edge of the highest\n        frequency band.\n    dtype: The `DType` of the result matrix. Must be a floating point\n        type.\n\nReturns:\n    A tensor of shape `[num_spectrogram_bins, num_mel_bins]`.",
    "std_args": [
      "self",
      "num_mel_bins",
      "num_spectrogram_bins",
      "sampling_rate",
      "lower_edge_hertz",
      "upper_edge_hertz",
      "dtype"
    ],
    "type": "function"
  },
  "linen_in_bridge_mdl": {
    "description": "Make Linen modules a submodule of a bridge module using wrappers.ToNNX().",
    "std_args": [
      "linen_module",
      "name"
    ],
    "type": "function"
  },
  "linen_rngs_dict": {
    "description": "Given a module, split out one of its every active RNG key collections.",
    "std_args": [
      "linen_module",
      "add_default"
    ],
    "type": "function"
  },
  "linen_vars_to_nnx_attrs": {
    "description": "Convert a dict of Linen-style variables to NNX variables.",
    "std_args": [
      "variables"
    ],
    "type": "function"
  },
  "list_or_scalar": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ln": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ln1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ln2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ln3": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ln_promote_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ln_structured": {
    "description": "Prune tensor by removing channels with the lowest L\\ ``n``-norm along the specified dimension.",
    "std_args": [
      "module",
      "name",
      "amount",
      "n",
      "dim",
      "importance_scores"
    ],
    "type": "function"
  },
  "lo_ty_qdd": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "variable_state"
    ],
    "type": "function"
  },
  "load_assets": {
    "description": "",
    "std_args": [
      "self",
      "dir_path"
    ],
    "type": "function"
  },
  "load_f2cmap_file": {
    "description": "The class representing a Python function.",
    "std_args": [
      "f2cmap_file"
    ],
    "type": "function"
  },
  "load_own_variables": {
    "description": "Loads the state of the layer.\n\nYou can override this method to take full control of how the state of\nthe layer is loaded upon calling `keras.models.load_model()`.\n\nArgs:\n    store: Dict from which the state of the model will be loaded.",
    "std_args": [
      "self",
      "store"
    ],
    "type": "function"
  },
  "load_weights": {
    "description": "Update the model's weights from a ``.npz``, a ``.safetensors`` file, or a list.",
    "std_args": [
      "self",
      "file_or_weights",
      "strict"
    ],
    "type": "function"
  },
  "loadfunc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "local_response_norm": {
    "description": "Apply local response normalization over an input signal.",
    "std_args": [
      "input",
      "size",
      "alpha",
      "beta",
      "k"
    ],
    "type": "function"
  },
  "lock": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "log_cosh": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "log_cosh_loss": {
    "description": "Computes the log cosh loss between inputs and targets.",
    "std_args": [
      "inputs",
      "targets",
      "reduction"
    ],
    "type": "function"
  },
  "log_input": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "log_ndtr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "log_prob": {
    "description": "Compute log probabilities for all :math:`\\texttt{n\\_classes}`.",
    "std_args": [
      "self",
      "input"
    ],
    "type": "function"
  },
  "log_sigmoid": {
    "description": "Logarithm of the sigmoid activation function.\n\nIt is defined as `f(x) = log(1 / (1 + exp(-x)))`.\n\nArgs:\n    x: Input tensor.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "log_target": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "logaddexp2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "logcumsumexp": {
    "description": "logcumsumexp(a: array, /, axis: Optional[int] = None, *, reverse: bool = False, inclusive: bool = True, stream: Union[None, Stream, Device] = None) -> array",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "logdet": {
    "description": "Computes log of the determinant of a hermitian positive definite matrix.\n\nArgs:\n    x: Input matrix. It must 2D and square.\n\nReturns:\n    The natural log of the determinant of matrix.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "loggamma": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "logger": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "logistic": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "logit": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lognormal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "logseries": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "logspace": {
    "description": "Generate logarithmically-spaced values.\n\nJAX implementation of :func:`numpy.logspace`.\n\nArgs:\n  start: scalar or array. Used to specify the start value. The start value is\n    ``base ** start``.\n  stop: scalar or array. Used to specify the stop value. The end value is\n    ``base ** stop``.\n  num: int, optional, default=50. Number of values to generate.\n  endpoint: bool, optional, default=True. If True, then include the ``stop`` value\n    in the result. If False, then exclude the ``stop`` value.\n  base: scalar or array, optional, default=10. Specifies the base of the logarithm.\n  dtype: optional. Specifies the dtype of the output.\n  axis: int, optional, default=0. Axis along which to generate the logspace.\n\nReturns:\n  An array of logarithm.\n\nSee also:\n  - :func:`jax.numpy.arange`: Generate ``N`` evenly-spaced values given a starting\n    point and a step value.\n  - :func:`jax.numpy.linspace`: Generate evenly-spaced values.\n  - :func:`jax.numpy.geomspace`: Generate geometrically-spaced values.\n\nExamples:\n  List 5 logarithmically spaced values between 1 (``10 ** 0``) and 100\n  (``10 ** 2``):\n\n  >>> with jnp.printoptions(precision=3, suppress=True):\n  ...   jnp.logspace(0, 2, 5)\n  Array([  1.   ,   3.162,  10.   ,  31.623, 100.   ], dtype=float32)\n\n  List 5 logarithmically-spaced values between 1(``10 ** 0``) and 100\n  (``10 ** 2``), excluding endpoint:\n\n  >>> with jnp.printoptions(precision=3, suppress=True):\n  ...   jnp.logspace(0, 2, 5, endpoint=False)\n  Array([ 1.   ,  2.512,  6.31 , 15.849, 39.811], dtype=float32)\n\n  List 7 logarithmically-spaced values between 1 (``2 ** 0``) and 4 (``2 ** 2``)\n  with base 2:\n\n  >>> with jnp.printoptions(precision=3, suppress=True):\n  ...   jnp.logspace(0, 2, 7, base=2)\n  Array([1.   , 1.26 , 1.587, 2.   , 2.52 , 3.175, 4.   ], dtype=float32)\n\n  Multi-dimensional logspace:\n\n  >>> start = jnp.array([0, 5])\n  >>> stop = jnp.array([5, 0])\n  >>> base = jnp.array([2, 3])\n  >>> with jnp.printoptions(precision=3, suppress=True):\n  ...   jnp.logspace(start, stop, 5, base=base)\n  Array([[  1.   , 243.   ],\n         [  2.378,  61.547],\n         [  5.657,  15.588],\n         [ 13.454,   3.948],\n         [ 32.   ,   1.   ]], dtype=float32)",
    "std_args": [
      "start",
      "stop",
      "num",
      "endpoint",
      "base",
      "dtype",
      "axis"
    ],
    "type": "function"
  },
  "long": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "attribute"
  },
  "longdouble": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "longlong": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lora": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lora_a": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lora_b": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lora_param_type": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lower": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "lowered": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lp_pool1d": {
    "description": "Apply a 1D power-average pooling over an input signal composed of several input planes.",
    "std_args": [
      "input",
      "norm_type",
      "kernel_size",
      "stride",
      "ceil_mode"
    ],
    "type": "function"
  },
  "lp_pool2d": {
    "description": "Apply a 2D power-average pooling over an input signal composed of several input planes.",
    "std_args": [
      "input",
      "norm_type",
      "kernel_size",
      "stride",
      "ceil_mode"
    ],
    "type": "function"
  },
  "lp_pool3d": {
    "description": "Apply a 3D power-average pooling over an input signal composed of several input planes.",
    "std_args": [
      "input",
      "norm_type",
      "kernel_size",
      "stride",
      "ceil_mode"
    ],
    "type": "function"
  },
  "ls": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lse": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lst": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lstsq": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "lu": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "lu_factor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "lu_factor_ex": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lu_solve": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "m2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mT": {
    "description": "Return the matrix-transpose of the masked array.",
    "std_args": [],
    "type": "attribute"
  },
  "magic_line": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "magnitude": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "main": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "make_attention_mask": {
    "description": "Mask-making helper for attention weights.",
    "std_args": [
      "query_input",
      "key_input",
      "pairwise_fn",
      "extra_batch_dims",
      "dtype"
    ],
    "type": "function"
  },
  "make_causal_mask": {
    "description": "Make a causal mask for self-attention.",
    "std_args": [
      "x",
      "extra_batch_dims",
      "dtype"
    ],
    "type": "function"
  },
  "make_f2py_compile_parser": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "make_mask": {
    "description": "Create a boolean mask from an array.",
    "std_args": [
      "m",
      "copy",
      "shrink",
      "dtype"
    ],
    "type": "function"
  },
  "make_mask_descr": {
    "description": "Construct a dtype description list from a given dtype.",
    "std_args": [
      "ndtype"
    ],
    "type": "function"
  },
  "make_mask_none": {
    "description": "Return a boolean mask of the given shape, filled with False.",
    "std_args": [
      "newshape",
      "dtype"
    ],
    "type": "function"
  },
  "make_rng": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "name"
    ],
    "type": "function"
  },
  "makemat": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "arr"
    ],
    "type": "function"
  },
  "malformed_magic": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "malicious_files": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "map": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "f"
    ],
    "type": "function"
  },
  "map_coordinates": {
    "description": "Map the input array to new coordinates by interpolation.\n\nNote that interpolation near boundaries differs from the scipy function,\nbecause we fixed an outstanding bug\n[scipy/issues/2640](https://github.com/scipy/scipy/issues/2640).\n\nArgs:\n    inputs: The input array.\n    coordinates: The coordinates at which inputs is evaluated.\n    order: The order of the spline interpolation. The order must be `0` or\n        `1`. `0` indicates the nearest neighbor and `1` indicates the linear\n        interpolation.\n    fill_mode: Points outside the boundaries of the inputs are filled\n        according to the given mode. Available methods are `\"constant\"`,\n        `\"nearest\"`, `\"wrap\"` and `\"mirror\"` and `\"reflect\"`. Defaults to\n        `\"constant\"`.\n        - `\"constant\"`: `(k k k k | a b c d | k k k k)`\n            The inputs is extended by filling all values beyond\n            the edge with the same constant value k specified by\n            `fill_value`.\n        - `\"nearest\"`: `(a a a a | a b c d | d d d d)`\n            The inputs is extended by the nearest pixel.\n        - `\"wrap\"`: `(a b c d | a b c d | a b c d)`\n            The inputs is extended by wrapping around to the opposite edge.\n        - `\"mirror\"`: `(c d c b | a b c d | c b a b)`\n            The inputs is extended by mirroring about the edge.\n        - `\"reflect\"`: `(d c b a | a b c d | d c b a)`\n            The inputs is extended by reflecting about the edge of the last\n            pixel.\n    fill_value: Value used for points outside the boundaries of the inputs\n        if `fill_mode=\"constant\"`. Defaults to `0`.\n\nReturns:\n    Output input or batch of inputs.",
    "std_args": [
      "inputs",
      "coordinates",
      "order",
      "fill_mode",
      "fill_value"
    ],
    "type": "function"
  },
  "map_params": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "map_prefix": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "path",
      "variable"
    ],
    "type": "function"
  },
  "map_state": {
    "description": "Map ``f`` over :class:`State` object.",
    "std_args": [
      "f",
      "state"
    ],
    "type": "function"
  },
  "mapdomain": {
    "description": "Apply linear map to input points.",
    "std_args": [
      "x",
      "old",
      "new"
    ],
    "type": "function"
  },
  "mapparms": {
    "description": "Linear map parameters between domains.",
    "std_args": [
      "old",
      "new"
    ],
    "type": "function"
  },
  "mapping": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "margin": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "margin_ranking_loss": {
    "description": "Compute the margin ranking loss.",
    "std_args": [
      "input1",
      "input2",
      "target",
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "markinnerspaces": {
    "description": "The function replace all spaces in the input variable line which are",
    "std_args": [
      "line"
    ],
    "type": "function"
  },
  "markoutercomma": {
    "description": "The class representing a Python function.",
    "std_args": [
      "line",
      "comma"
    ],
    "type": "function"
  },
  "markouterparen": {
    "description": "The class representing a Python function.",
    "std_args": [
      "line"
    ],
    "type": "function"
  },
  "mask": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mask_check": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mask_cols": {
    "description": "Mask columns of a 2D array that contain masked values.",
    "std_args": [
      "a",
      "axis"
    ],
    "type": "function"
  },
  "mask_indices": {
    "description": "Return indices of a mask of an (n, n) array.\n\nArgs:\n  n: static integer array dimension.\n  mask_func: a function that takes a shape ``(n, n)`` array and\n    an optional offset ``k``, and returns a shape ``(n, n)`` mask.\n    Examples of functions with this signature are\n    :func:`~jax.numpy.triu` and :func:`~jax.numpy.tril`.\n  k: a scalar value passed to ``mask_func``.\n  size: optional argument specifying the static size of the output arrays.\n    This is passed to :func:`~jax.numpy.nonzero` when generating the indices\n    from the mask.\n\nReturns:\n  a tuple of indices where ``mask_func`` is nonzero.\n\nSee also:\n  - :func:`jax.numpy.triu_indices`: compute ``mask_indices`` for :func:`~jax.numpy.triu`.\n  - :func:`jax.numpy.tril_indices`: compute ``mask_indices`` for :func:`~jax.numpy.tril`.\n\nExamples:\n  Calling ``mask_indices`` on built-in masking functions:\n\n  >>> jnp.mask_indices(3, jnp.triu)\n  (Array([0, 0, 0, 1, 1, 2], dtype=int32), Array([0, 1, 2, 1, 2, 2], dtype=int32))\n\n  >>> jnp.mask_indices(3, jnp.tril)\n  (Array([0, 1, 1, 2, 2, 2], dtype=int32), Array([0, 0, 1, 0, 1, 2], dtype=int32))\n\n  Calling ``mask_indices`` on a custom masking function:\n\n  >>> def mask_func(x, k=0):\n  ...   i = jnp.arange(x.shape[0])[:, None]\n  ...   j = jnp.arange(x.shape[1])\n  ...   return (i + 1) % (j + 1 + k) == 0\n  >>> mask_func(jnp.ones((3, 3)))\n  Array([[ True, False, False],\n         [ True,  True, False],\n         [ True, False,  True]], dtype=bool)\n  >>> jnp.mask_indices(3, mask_func)\n  (Array([0, 1, 1, 2, 2], dtype=int32), Array([0, 0, 1, 0, 2], dtype=int32))",
    "std_args": [
      "n",
      "mask_func",
      "k",
      "size"
    ],
    "type": "function"
  },
  "mask_mod": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mask_or": {
    "description": "Combine two masks with the ``logical_or`` operator.",
    "std_args": [
      "m1",
      "m2",
      "copy",
      "shrink"
    ],
    "type": "function"
  },
  "mask_rowcols": {
    "description": "Mask rows and/or columns of a 2D array that contain masked values.",
    "std_args": [
      "a",
      "axis"
    ],
    "type": "function"
  },
  "mask_rows": {
    "description": "Mask rows of a 2D array that contain masked values.",
    "std_args": [
      "a",
      "axis"
    ],
    "type": "function"
  },
  "masked": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "masked_all": {
    "description": "Empty masked array with all elements masked.",
    "std_args": [
      "shape",
      "dtype"
    ],
    "type": "function"
  },
  "masked_all_like": {
    "description": "Empty masked array with the properties of an existing array.",
    "std_args": [
      "arr"
    ],
    "type": "function"
  },
  "masked_array": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "masked_equal": {
    "description": "Mask an array where equal to a given value.",
    "std_args": [
      "x",
      "value",
      "copy"
    ],
    "type": "function"
  },
  "masked_greater": {
    "description": "Mask an array where greater than a given value.",
    "std_args": [
      "x",
      "value",
      "copy"
    ],
    "type": "function"
  },
  "masked_greater_equal": {
    "description": "Mask an array where greater than or equal to a given value.",
    "std_args": [
      "x",
      "value",
      "copy"
    ],
    "type": "function"
  },
  "masked_inside": {
    "description": "Mask an array inside a given interval.",
    "std_args": [
      "x",
      "v1",
      "v2",
      "copy"
    ],
    "type": "function"
  },
  "masked_invalid": {
    "description": "Mask an array where invalid values occur (NaNs or infs).",
    "std_args": [
      "a",
      "copy"
    ],
    "type": "function"
  },
  "masked_less": {
    "description": "Mask an array where less than a given value.",
    "std_args": [
      "x",
      "value",
      "copy"
    ],
    "type": "function"
  },
  "masked_less_equal": {
    "description": "Mask an array where less than or equal to a given value.",
    "std_args": [
      "x",
      "value",
      "copy"
    ],
    "type": "function"
  },
  "masked_not_equal": {
    "description": "Mask an array where *not* equal to a given value.",
    "std_args": [
      "x",
      "value",
      "copy"
    ],
    "type": "function"
  },
  "masked_object": {
    "description": "Mask the array `x` where the data are exactly equal to value.",
    "std_args": [
      "x",
      "value",
      "copy",
      "shrink"
    ],
    "type": "function"
  },
  "masked_outside": {
    "description": "Mask an array outside a given interval.",
    "std_args": [
      "x",
      "v1",
      "v2",
      "copy"
    ],
    "type": "function"
  },
  "masked_print_option": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "masked_singleton": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "masked_values": {
    "description": "Mask using floating point equality.",
    "std_args": [
      "x",
      "value",
      "rtol",
      "atol",
      "copy",
      "shrink"
    ],
    "type": "function"
  },
  "masked_where": {
    "description": "Mask an array where a condition is met.",
    "std_args": [
      "condition",
      "a",
      "copy"
    ],
    "type": "function"
  },
  "maskiter": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "materialize": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "shape",
      "device",
      "dtype"
    ],
    "type": "function"
  },
  "matrix": {
    "description": "matrix(data, dtype=None, copy=True)",
    "std_args": [],
    "type": "class"
  },
  "matrix_exp": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "matrix_instr_nonkdim": {
    "description": "ROCm-specific matrix instruction non-K dimension.",
    "std_args": [],
    "type": "attribute"
  },
  "matvec": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "max_filler": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "max_norm": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "max_pool": {
    "description": "Max pooling operation.\n\nArgs:\n    inputs: Tensor of rank N+2. `inputs` has shape\n        `(batch_size,) + inputs_spatial_shape + (num_channels,)` if\n        `data_format=\"channels_last\"`, or\n        `(batch_size, num_channels) + inputs_spatial_shape` if\n        `data_format=\"channels_first\"`. Pooling happens over the spatial\n        dimensions only.\n    pool_size: int or tuple/list of integers of size\n        `len(inputs_spatial_shape)`, specifying the size of the pooling\n        window for each spatial dimension of the input tensor. If\n        `pool_size` is int, then every spatial dimension shares the same\n        `pool_size`.\n    strides: int or tuple/list of integers of size\n        `len(inputs_spatial_shape)`. The stride of the sliding window for\n        each spatial dimension of the input tensor. If `strides` is int,\n        then every spatial dimension shares the same `strides`.\n    padding: string, either `\"valid\"` or `\"same\"`. `\"valid\"` means no\n        padding is applied, and `\"same\"` results in padding evenly to the\n        left/right or up/down of the input such that output has the\n        same height/width dimension as the input when `strides=1`.\n    data_format: A string, either `\"channels_last\"` or `\"channels_first\"`.\n        `data_format` determines the ordering of the dimensions in the\n        inputs. If `data_format=\"channels_last\"`, `inputs` is of shape\n        `(batch_size, ..., channels)` while if\n        `data_format=\"channels_first\"`, `inputs` is of shape\n        `(batch_size, channels, ...)`.\n\nReturns:\n    A tensor of rank N+2, the result of the max pooling operation.",
    "std_args": [
      "inputs",
      "pool_size",
      "strides",
      "padding",
      "data_format"
    ],
    "type": "function"
  },
  "max_pool1d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "max_pool1d_with_indices": {
    "description": "max_pool1d(input, kernel_size, stride=None, padding=0, dilation=1, ceil_mode=False, return_indices=False)",
    "std_args": [
      "input",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "ceil_mode",
      "return_indices"
    ],
    "type": "function"
  },
  "max_pool2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "max_pool2d_with_indices": {
    "description": "max_pool2d(input, kernel_size, stride=None, padding=0, dilation=1, ceil_mode=False, return_indices=False)",
    "std_args": [
      "input",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "ceil_mode",
      "return_indices"
    ],
    "type": "function"
  },
  "max_pool3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "max_pool3d_with_indices": {
    "description": "max_pool3d(input, kernel_size, stride=None, padding=0, dilation=1, ceil_mode=False, return_indices=False)",
    "std_args": [
      "input",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "ceil_mode",
      "return_indices"
    ],
    "type": "function"
  },
  "max_scores": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "max_unpool1d": {
    "description": "Compute a partial inverse of :class:`MaxPool1d`.",
    "std_args": [
      "input",
      "indices",
      "kernel_size",
      "stride",
      "padding",
      "output_size"
    ],
    "type": "function"
  },
  "max_unpool2d": {
    "description": "Compute a partial inverse of :class:`MaxPool2d`.",
    "std_args": [
      "input",
      "indices",
      "kernel_size",
      "stride",
      "padding",
      "output_size"
    ],
    "type": "function"
  },
  "max_unpool3d": {
    "description": "Compute a partial inverse of :class:`MaxPool3d`.",
    "std_args": [
      "input",
      "indices",
      "kernel_size",
      "stride",
      "padding",
      "output_size"
    ],
    "type": "function"
  },
  "max_val": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "maximum_fill_value": {
    "description": "Return the minimum value that can be represented by the dtype of an object.",
    "std_args": [
      "obj"
    ],
    "type": "function"
  },
  "maxwell": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "measure_valued_estimation_mean": {
    "description": "Measure valued grads of a Gaussian expectation of `function` wrt the mean.",
    "std_args": [
      "function",
      "dist",
      "rng",
      "num_samples",
      "coupling"
    ],
    "type": "function"
  },
  "measure_valued_estimation_std": {
    "description": "Measure valued grads of a Gaussian expectation of `function` wrt the std.",
    "std_args": [
      "function",
      "dist",
      "rng",
      "num_samples",
      "coupling"
    ],
    "type": "function"
  },
  "measure_valued_jacobians": {
    "description": "Measure valued gradient estimation.",
    "std_args": [
      "function",
      "params",
      "dist_builder",
      "rng",
      "num_samples",
      "coupling"
    ],
    "type": "function"
  },
  "median": {
    "description": "Compute the median along the specified axis.",
    "std_args": [
      "a",
      "axis",
      "out",
      "overwrite_input",
      "keepdims"
    ],
    "type": "function"
  },
  "memmap": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "memory_analysis": {
    "description": "A summary of estimated memory requirements.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "merge": {
    "description": "The inverse of :func:`flax.nnx.split`.",
    "std_args": [
      "graphdef",
      "state",
      "states",
      "copy"
    ],
    "type": "function"
  },
  "merge_arrays": {
    "description": "Merge arrays field by field.",
    "std_args": [
      "seqarrays",
      "fill_value",
      "flatten",
      "usemask",
      "asrecarray"
    ],
    "type": "function"
  },
  "merge_context": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctxtag",
      "inner"
    ],
    "type": "function"
  },
  "merge_fn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "merge_inputs": {
    "description": "Takes in a function that contains jax-compatible data structures in the",
    "std_args": [
      "f",
      "ctxtag"
    ],
    "type": "function"
  },
  "merge_masks": {
    "description": "Determine mask type and combine masks if necessary.",
    "std_args": [
      "self",
      "attn_mask",
      "key_padding_mask",
      "query"
    ],
    "type": "function"
  },
  "merge_state": {
    "description": "The inverse of :meth:`split() <flax.nnx.State.state.split>`.",
    "std_args": [
      "state",
      "states",
      "cls"
    ],
    "type": "function"
  },
  "merge_tree_node": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctx",
      "path",
      "prefix",
      "leaf"
    ],
    "type": "function"
  },
  "mess": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "metadata": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "metadata_fn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "metal_kernel": {
    "description": "A jit-compiled custom Metal kernel defined from a source string.",
    "std_args": [
      "name",
      "input_names",
      "output_names",
      "source",
      "header",
      "ensure_row_contiguous",
      "atomic_outputs"
    ],
    "type": "function"
  },
  "methods_supporting_weights": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "min_filler": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "min_val": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "minimum_fill_value": {
    "description": "Return the maximum value that can be represented by the dtype of an object.",
    "std_args": [
      "obj"
    ],
    "type": "function"
  },
  "mixed_precision": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mixed_types_structured": {
    "description": "Function providing heterogeneous input data with a structured dtype, along",
    "std_args": [],
    "type": "function"
  },
  "mode": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "modf": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "modified_bessel_i0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "modified_bessel_i1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "modified_bessel_k0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "modified_bessel_k1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "modified_orthogonal": {
    "description": "Modified orthogonal initializer for compatibility with half precision.",
    "std_args": [
      "key",
      "shape",
      "dtype"
    ],
    "type": "function"
  },
  "modsign2map": {
    "description": "modulename",
    "std_args": [
      "m"
    ],
    "type": "function"
  },
  "module_name": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "module_rules": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "module_stack": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "module_type": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "moduleprocedurepattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "moduleprocedures": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "modules": {
    "description": "Return an iterator over all modules in the network.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "moments": {
    "description": "Calculates the mean and variance of `x`.\n\nThe mean and variance are calculated by aggregating the contents of `x`\nacross `axes`. If `x` is 1-D and `axes = [0]` this is just the mean and\nvariance of a vector.\n\nArgs:\n    x: Input tensor.\n    axes: A list of axes which to compute mean and variance.\n    keepdims: If this is set to `True`, the axes which are reduced are left\n        in the result as dimensions with size one.\n    synchronized: Only applicable with the TensorFlow backend.\n        If `True`, synchronizes the global batch statistics (mean and\n        variance) across all devices at each training step in a\n        distributed training strategy. If `False`, each replica uses its own\n        local batch statistics.\n\nReturns:\n    A tuple containing two tensors - mean and variance.\n\nExample:\n\n>>> x = keras.ops.convert_to_tensor([0, 1, 2, 3, 100], dtype=\"float32\")\n>>> keras.ops.moments(x, axes=[0])\n(array(21.2, dtype=float32), array(1553.3601, dtype=float32))",
    "std_args": [
      "x",
      "axes",
      "keepdims",
      "synchronized"
    ],
    "type": "function"
  },
  "momentum": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "moving_avg_baseline": {
    "description": "A moving average baseline.",
    "std_args": [
      "function",
      "decay",
      "zero_debias",
      "use_decay_early_training_heuristic"
    ],
    "type": "function"
  },
  "mr_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mr_class": {
    "description": "Translate slice objects to concatenation along the first axis.",
    "std_args": [
      "self"
    ],
    "type": "class"
  },
  "mrec": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mrecarray": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mse_loss": {
    "description": "Compute the element-wise mean squared error, with optional weighting.",
    "std_args": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction",
      "weight"
    ],
    "type": "function"
  },
  "msg": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "msubarray": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mtia": {
    "description": "Move all model parameters and buffers to the MTIA.",
    "std_args": [
      "self",
      "device"
    ],
    "type": "function"
  },
  "multi_dot": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "multi_head_attention_forward": {
    "description": "Forward method for MultiHeadAttention.",
    "std_args": [
      "query",
      "key",
      "value",
      "embed_dim_to_check",
      "num_heads",
      "in_proj_weight",
      "in_proj_bias",
      "bias_k",
      "bias_v",
      "add_zero_attn",
      "dropout_p",
      "out_proj_weight",
      "out_proj_bias",
      "training",
      "key_padding_mask",
      "need_weights",
      "attn_mask",
      "use_separate_proj_weight",
      "q_proj_weight",
      "k_proj_weight",
      "v_proj_weight",
      "static_k",
      "static_v",
      "average_attn_weights",
      "is_causal"
    ],
    "type": "function"
  },
  "multi_hot": {
    "description": "Encodes integer labels as multi-hot vectors.\n\nThis function encodes integer labels as multi-hot vectors, where each label\nis mapped to a binary value in the resulting vector.\n\nArgs:\n    inputs: Tensor of integer labels to be converted to multi-hot vectors.\n    num_classes: Integer, the total number of unique classes.\n    axis: (optional) Axis along which the multi-hot encoding should be\n        added. Defaults to `-1`, which corresponds to the last dimension.\n    dtype: (optional) The data type of the resulting tensor. Default\n        is backend's float type.\n    sparse: Whether to return a sparse tensor; for backends that support\n        sparse tensors.\n\nReturns:\n    Tensor: The multi-hot encoded tensor.\n\nExample:\n\n>>> data = keras.ops.convert_to_tensor([0, 4])\n>>> keras.ops.multi_hot(data, num_classes=5)\narray([1.0, 0.0, 0.0, 0.0, 1.0], dtype=float32)",
    "std_args": [
      "inputs",
      "num_classes",
      "axis",
      "dtype",
      "sparse",
      "kwargs"
    ],
    "type": "function"
  },
  "multi_index": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "multi_margin_loss": {
    "description": "Compute the multi margin loss, with optional weighting.",
    "std_args": [
      "input",
      "target",
      "p",
      "margin",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "multi_transform": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "multigammaln": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "multihead_attn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "multilabel_margin_loss": {
    "description": "Compute the multilabel margin loss.",
    "std_args": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "multilabel_soft_margin_loss": {
    "description": "Compute the multilabel soft margin loss.",
    "std_args": [
      "input",
      "target",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "multilinepattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "multiple_results": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "multivariate_normal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "mutable": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mvoid": {
    "description": "Fake a 'void' object to use for masked array with structured dtypes.",
    "std_args": [],
    "type": "class"
  },
  "my_cacw": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "record",
      "modules"
    ],
    "type": "class"
  },
  "myeval": {
    "description": "Like `eval` but returns only integers and floats",
    "std_args": [
      "e",
      "g",
      "l"
    ],
    "type": "function"
  },
  "n": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "n_children_spawned": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "n_classes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "n_clusters": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "n_power_iterations": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "n_steps": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "na_object": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "name": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nameargspattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "named_buffers": {
    "description": "Return an iterator over module buffers, yielding both the name of the buffer as well as the buffer itself.",
    "std_args": [
      "self",
      "prefix",
      "recurse",
      "remove_duplicate"
    ],
    "type": "function"
  },
  "named_chain": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "named_children": {
    "description": "Return an iterator over immediate children modules, yielding both the name of the module as well as the module itself.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "named_modules": {
    "description": "Return an iterator over all modules in the network, yielding both the name of the module as well as the module itself.",
    "std_args": [
      "self",
      "memo",
      "prefix",
      "remove_duplicate"
    ],
    "type": "function"
  },
  "named_parameters": {
    "description": "Return an iterator over module parameters, yielding both the name of the parameter as well as the parameter itself.",
    "std_args": [
      "self",
      "prefix",
      "recurse",
      "remove_duplicate"
    ],
    "type": "function"
  },
  "namepattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nan_to_num": {
    "description": "Replace NaN with zero and infinity with large finite numbers.\n\nArgs:\n    x: Input data.\n    nan: Optional float or int. Value to replace `NaN` entries with.\n    posinf: Optional float or int.\n        Value to replace positive infinity with.\n    neginf: Optional float or int.\n        Value to replace negative infinity with.\n\nReturns:\n    `x`, with non-finite values replaced.",
    "std_args": [
      "x",
      "nan",
      "posinf",
      "neginf"
    ],
    "type": "function"
  },
  "nanargmax": {
    "description": "Return the index of the maximum value of an array, ignoring NaNs.\n\nJAX implementation of :func:`numpy.nanargmax`.\n\nArgs:\n  a: input array\n  axis: optional integer specifying the axis along which to find the maximum\n    value. If ``axis`` is not specified, ``a`` will be flattened.\n  out: unused by JAX\n  keepdims: if True, then return an array with the same number of dimensions\n    as ``a``.\n\nReturns:\n  an array containing the index of the maximum value along the specified axis.\n\nNote:\n  In the case of an axis with all-NaN values, the returned index will be -1.\n  This differs from the behavior of :func:`numpy.nanargmax`, which raises an error.\n\nSee also:\n  - :func:`jax.numpy.argmax`: return the index of the maximum value.\n  - :func:`jax.numpy.nanargmin`: compute ``argmin`` while ignoring NaN values.\n\nExamples:\n  >>> x = jnp.array([1, 3, 5, 4, jnp.nan])\n\n  Using a standard :func:`~jax.numpy.argmax` leads to potentially unexpected results:\n\n  >>> jnp.argmax(x)\n  Array(4, dtype=int32)\n\n  Using ``nanargmax`` returns the index of the maximum non-NaN value.\n\n  >>> jnp.nanargmax(x)\n  Array(2, dtype=int32)\n\n  >>> x = jnp.array([[1, 3, jnp.nan],\n  ...                [5, 4, jnp.nan]])\n  >>> jnp.nanargmax(x, axis=1)\n  Array([1, 0], dtype=int32)\n\n  >>> jnp.nanargmax(x, axis=1, keepdims=True)\n  Array([[1],\n         [0]], dtype=int32)",
    "std_args": [
      "a",
      "axis",
      "out",
      "keepdims"
    ],
    "type": "function"
  },
  "nanargmin": {
    "description": "Return the index of the minimum value of an array, ignoring NaNs.\n\nJAX implementation of :func:`numpy.nanargmin`.\n\nArgs:\n  a: input array\n  axis: optional integer specifying the axis along which to find the maximum\n    value. If ``axis`` is not specified, ``a`` will be flattened.\n  out: unused by JAX\n  keepdims: if True, then return an array with the same number of dimensions\n    as ``a``.\n\nReturns:\n  an array containing the index of the minimum value along the specified axis.\n\nNote:\n  In the case of an axis with all-NaN values, the returned index will be -1.\n  This differs from the behavior of :func:`numpy.nanargmin`, which raises an error.\n\nSee also:\n  - :func:`jax.numpy.argmin`: return the index of the minimum value.\n  - :func:`jax.numpy.nanargmax`: compute ``argmax`` while ignoring NaN values.\n\nExamples:\n  >>> x = jnp.array([jnp.nan, 3, 5, 4, 2])\n  >>> jnp.nanargmin(x)\n  Array(4, dtype=int32)\n\n  >>> x = jnp.array([[1, 3, jnp.nan],\n  ...                [5, 4, jnp.nan]])\n  >>> jnp.nanargmin(x, axis=1)\n  Array([0, 1], dtype=int32)\n\n  >>> jnp.nanargmin(x, axis=1, keepdims=True)\n  Array([[0],\n         [1]], dtype=int32)",
    "std_args": [
      "a",
      "axis",
      "out",
      "keepdims"
    ],
    "type": "function"
  },
  "nanfunc_ids": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nanfuncs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nargs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "native_channel_shuffle": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nbytes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nd": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ndarray": {
    "description": "Array base class for JAX\n\n``jax.Array`` is the public interface for instance checks and type annotation\nof JAX arrays and tracers. Its main applications are in instance checks and\ntype annotations; for example::\n\n  x = jnp.arange(5)\n  isinstance(x, jax.Array)  # returns True both inside and outside traced functions.\n\n  def f(x: Array) -> Array:  # type annotations are valid for traced and non-traced types.\n    return x\n\n``jax.Array`` should not be used directly for creation of arrays; instead you\nshould use array creation routines offered in :mod:`jax.numpy`, such as\n:func:`jax.numpy.array`, :func:`jax.numpy.zeros`, :func:`jax.numpy.ones`,\n:func:`jax.numpy.full`, :func:`jax.numpy.arange`, etc.",
    "std_args": [],
    "type": "class"
  },
  "ndenumerate": {
    "description": "Multidimensional index iterator.",
    "std_args": [
      "a",
      "compressed"
    ],
    "type": "function"
  },
  "ndim": {
    "description": "Return the number of dimensions of an array.\n\nJAX implementation of :func:`numpy.ndim`. Unlike ``np.ndim``, this function\nraises a :class:`TypeError` if the input is a collection such as a list or\ntuple.\n\nArgs:\n  a: array-like object, or any object with an ``ndim`` attribute.\n\nReturns:\n  An integer specifying the number of dimensions of ``a``.\n\nExamples:\n  Number of dimensions for arrays:\n\n  >>> x = jnp.arange(10)\n  >>> jnp.ndim(x)\n  1\n  >>> y = jnp.ones((2, 3))\n  >>> jnp.ndim(y)\n  2\n\n  This also works for scalars:\n\n  >>> jnp.ndim(3.14)\n  0\n\n  For arrays, this can also be accessed via the :attr:`jax.Array.ndim` property:\n\n  >>> x.ndim\n  1",
    "std_args": [
      "a"
    ],
    "type": "attribute"
  },
  "nditer": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "ndtr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ndtri": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "needs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "negative_binomial": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "negative_slope": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nesterov": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "new_from_loval": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "variable_state",
      "lo_vals"
    ],
    "type": "function"
  },
  "new_index_ref": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "new_ref_index": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "new_stream": {
    "description": "new_stream(device: mlx.core.Device) -> mlx.core.Stream",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "new_value": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "new_variable_p": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "newbyteorder": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "new_order"
    ],
    "type": "function"
  },
  "next": {
    "description": "",
    "std_args": [
      "self",
      "ordered"
    ],
    "type": "function"
  },
  "nhead": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nin": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nll_loss": {
    "description": "Compute the negative log likelihood loss.",
    "std_args": [
      "input",
      "target",
      "weight",
      "size_average",
      "ignore_index",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "nnx_attrs_to_linen_vars": {
    "description": "Convert a dict of NNX variables to Linen-style variables.",
    "std_args": [
      "nnx_attrs"
    ],
    "type": "function"
  },
  "nnx_class": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nnx_in_bridge_mdl": {
    "description": "Make pure NNX modules a submodule of a bridge module.",
    "std_args": [
      "factory",
      "name"
    ],
    "type": "function"
  },
  "no_grad": {
    "description": "Context-manager that disabled gradient calculation.",
    "op_type": "context",
    "std_args": []
  },
  "no_sync": {
    "description": "Context manager to disable gradient synchronizations across DDP processes.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "node_dict": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "node"
    ],
    "type": "function"
  },
  "node_stats": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nodedefs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nodes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nomask": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "noncentral_chisquare": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "noncentral_f": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nondiff_argnums": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nondiff_states": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "noninv": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nonlinear_dimspecs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nonlinearity": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "noop_mask": {
    "description": "Returns a noop mask_mod",
    "std_args": [
      "batch",
      "head",
      "token_q",
      "token_kv"
    ],
    "type": "function"
  },
  "norm": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "norm1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "norm2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "norm3": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "norm_first": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "norm_type": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "normal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "normal_": {
    "description": "Fill the input Tensor with values drawn from the normal distribution.",
    "std_args": [
      "tensor",
      "mean",
      "std",
      "generator"
    ],
    "type": "function"
  },
  "normalize_qk": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "normalize_whitespace": {
    "description": "Remove leading and trailing whitespace, and convert internal",
    "std_args": [
      "s"
    ],
    "type": "function"
  },
  "normalized_shape": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "normalized_weights": {
    "description": "Generate spectral normalized weights.\n\nThis method returns the updated value for `self.kernel` with the\nspectral normalized value, so that the layer is ready for `call()`.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "notmasked_contiguous": {
    "description": "Find contiguous unmasked data in a masked array along the given axis.",
    "std_args": [
      "a",
      "axis"
    ],
    "type": "function"
  },
  "notmasked_edges": {
    "description": "Find the indices of the first and last unmasked values along an axis.",
    "std_args": [
      "a",
      "axis"
    ],
    "type": "function"
  },
  "nout": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "np_floats": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nrec": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ns_steps": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ntensors": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ntxent": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ntypes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num23seq": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num2seq": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_attributes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_channels": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_dts": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_embeddings": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_feature_axes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_features": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_groups": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_heads": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_ids": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_layers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_leaves": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_parameters": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_stages": {
    "description": "Number of pipeline stages in the CUDA kernel. Higher values may improve performance",
    "std_args": [],
    "type": "attribute"
  },
  "num_warps": {
    "description": "Number of warps to use in the CUDA kernel. Higher values may improve performance",
    "std_args": [],
    "type": "attribute"
  },
  "number": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "attribute"
  },
  "number_types": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "numel": {
    "description": "Returns the number of elements (not accounting for sparsity) in the mask.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "numiter": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "numpy_version": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "obj": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "obj_copy": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "object_": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "object_id": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "offset": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "old_assert_almost_equal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "old_urlopen": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "on_add_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "axis_index",
      "axis_name"
    ],
    "type": "function"
  },
  "on_create_value": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "value"
    ],
    "type": "function"
  },
  "on_get_value": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "value"
    ],
    "type": "function"
  },
  "on_remove_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "axis_index",
      "axis_name"
    ],
    "type": "function"
  },
  "on_set_value": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "value"
    ],
    "type": "function"
  },
  "one_hot": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "ones_": {
    "description": "Fill the input Tensor with the scalar value `1`.",
    "std_args": [
      "tensor"
    ],
    "type": "function"
  },
  "ones_init": {
    "description": "Builds an initializer that returns a constant array full of ones.",
    "std_args": [],
    "type": "function"
  },
  "only": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "onlyfuncs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "op": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "openfile": {
    "description": "Opens the file handle of file `fname`.",
    "std_args": [
      "fname"
    ],
    "type": "function"
  },
  "openhook": {
    "description": "Ensures that filename is opened with correct encoding parameter.",
    "std_args": [
      "filename",
      "mode"
    ],
    "type": "function"
  },
  "operands": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "operatorpattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ops": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "opt_func_info": {
    "description": "Returns a dictionary containing the currently supported CPU dispatched",
    "std_args": [
      "func_name",
      "signature"
    ],
    "type": "function"
  },
  "opt_state": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "optimizers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "optionalpattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "options": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "or_masks": {
    "description": "Returns a mask_mod that's the union of provided mask_mods",
    "std_args": [
      "mask_mods"
    ],
    "type": "function"
  },
  "origin": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "original": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "orthogonal": {
    "description": "Apply an orthogonal or unitary parametrization to a matrix or a batch of matrices.",
    "std_args": [
      "module",
      "name",
      "orthogonal_map",
      "use_trivialization"
    ],
    "type": "function"
  },
  "orthogonal_": {
    "description": "Fill the input `Tensor` with a (semi) orthogonal matrix.",
    "std_args": [
      "tensor",
      "gain",
      "generator"
    ],
    "type": "function"
  },
  "other": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "out": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "out_axes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "out_channels": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "out_dot_general": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "out_dot_general_cls": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "out_features": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "out_info": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "out_proj": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "out_promote_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "out_shardings": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "out_specs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "out_tree": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "outer_index": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "outer_index_inner_ref": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "outer_index_outer_ref": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "outer_ref_outer_index": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "outerproduct": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "outmess": {
    "description": "The class representing a Python function.",
    "std_args": [
      "t"
    ],
    "type": "function"
  },
  "outneeds": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_carry_argnum": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_device": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_padding": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_ratio": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_shardings": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "outputs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "p": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pack_padded_sequence": {
    "description": "Packs a Tensor containing padded sequences of variable length.",
    "std_args": [
      "input",
      "lengths",
      "batch_first",
      "enforce_sorted"
    ],
    "type": "function"
  },
  "pack_sequence": {
    "description": "Packs a list of variable length Tensors.",
    "std_args": [
      "sequences",
      "enforce_sorted"
    ],
    "type": "function"
  },
  "pad_images": {
    "description": "Pad `images` with zeros to the specified `height` and `width`.\n\nArgs:\n    images: Input image or batch of images. Must be 3D or 4D.\n    top_padding: Number of rows of zeros to add on top.\n    left_padding: Number of columns of zeros to add on the left.\n    bottom_padding: Number of rows of zeros to add at the bottom.\n    right_padding: Number of columns of zeros to add on the right.\n    target_height: Height of output images.\n    target_width: Width of output images.\n    data_format: A string specifying the data format of the input tensor.\n        It can be either `\"channels_last\"` or `\"channels_first\"`.\n        `\"channels_last\"` corresponds to inputs with shape\n        `(batch, height, width, channels)`, while `\"channels_first\"`\n        corresponds to inputs with shape `(batch, channels, height, width)`.\n        If not specified, the value will default to\n        `keras.config.image_data_format`.\n\nReturns:\n    Padded image or batch of images.\n\nExample:\n\n>>> images = np.random.random((15, 25, 3))\n>>> padded_images = keras.ops.image.pad_images(\n...     images, 2, 3, target_height=20, target_width=30\n... )\n>>> padded_images.shape\n(20, 30, 3)\n\n>>> batch_images = np.random.random((2, 15, 25, 3))\n>>> padded_batch = keras.ops.image.pad_images(\n...     batch_images, 2, 3, target_height=20, target_width=30\n... )\n>>> padded_batch.shape\n(2, 20, 30, 3)",
    "std_args": [
      "images",
      "top_padding",
      "left_padding",
      "bottom_padding",
      "right_padding",
      "target_height",
      "target_width",
      "data_format"
    ],
    "type": "function"
  },
  "pad_packed_sequence": {
    "description": "Pad a packed batch of variable length sequences.",
    "std_args": [
      "sequence",
      "batch_first",
      "padding_value",
      "total_length"
    ],
    "type": "function"
  },
  "pad_sequence": {
    "description": "Pad a list of variable length Tensors with :attr:`padding_value`.",
    "std_args": [
      "sequences",
      "batch_first",
      "padding_value",
      "padding_side"
    ],
    "type": "function"
  },
  "padded1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "padded1b": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "padded2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "padding": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "padding_idx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pairwise_distance": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "parallel_apply": {
    "description": "Apply each `module` in :attr:`modules` in parallel on each of :attr:`devices`.",
    "std_args": [
      "modules",
      "inputs",
      "kwargs_tup",
      "devices"
    ],
    "type": "function"
  },
  "param_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "param_eval": {
    "description": "Creates a dictionary of indices and values for each parameter in a",
    "std_args": [
      "v",
      "g_params",
      "params",
      "dimspec"
    ],
    "type": "function"
  },
  "param_parse": {
    "description": "Recursively parse array dimensions.",
    "std_args": [
      "d",
      "params"
    ],
    "type": "function"
  },
  "parameterpattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "parameters_to_ignore": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "parameters_to_vector": {
    "description": "Flatten an iterable of parameters into a single vector.",
    "std_args": [
      "parameters"
    ],
    "type": "function"
  },
  "params": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "params_0": {
    "description": "The class representing a Python function.",
    "std_args": [
      "f"
    ],
    "type": "function"
  },
  "params_1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "f",
      "bounded"
    ],
    "type": "function"
  },
  "pareto": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "parse": {
    "description": "Parse a Fortran expression to an Expr.",
    "std_args": [
      "s",
      "language"
    ],
    "type": "function"
  },
  "parse_name_for_bind": {
    "description": "The class representing a Python function.",
    "std_args": [
      "line"
    ],
    "type": "function"
  },
  "partition": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "path": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "paths": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pathwise_jacobians": {
    "description": "Pathwise gradient estimation.",
    "std_args": [
      "function",
      "params",
      "dist_builder",
      "rng",
      "num_samples"
    ],
    "type": "function"
  },
  "pdist": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "per_example_global_norm_clip": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "per_example_layer_norm_clip": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "permutation": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "permute_hidden": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "hx",
      "permutation"
    ],
    "type": "function"
  },
  "persistent": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "perspective_transform": {
    "description": "Applies a perspective transformation to the image(s).\n\nArgs:\n    images: Input image or batch of images. Must be 3D or 4D.\n    start_points: A tensor of shape `(N, 4, 2)` or `(4, 2)`,\n        representing the source points in the original image\n        that define the transformation.\n    end_points: A tensor of shape `(N, 4, 2)` or `(4, 2)`,\n        representing the target points in the output image\n        after transformation.\n    interpolation: Interpolation method. Available methods are `\"nearest\"`,\n        and `\"bilinear\"`. Defaults to `\"bilinear\"`.\n    fill_value: Value used for points outside the boundaries of the input if\n        extrapolation is needed. Defaults to `0`.\n    data_format: A string specifying the data format of the input tensor.\n        It can be either `\"channels_last\"` or `\"channels_first\"`.\n        `\"channels_last\"` corresponds to inputs with shape\n        `(batch, height, width, channels)`, while `\"channels_first\"`\n        corresponds to inputs with shape `(batch, channels, height, width)`.\n        If not specified, the value will default to\n        `keras.config.image_data_format`.\n\nReturns:\n    Applied perspective transform image or batch of images.\n\nExamples:\n\n>>> x = np.random.random((2, 64, 80, 3))  # batch of 2 RGB images\n>>> start_points = np.array(\n...     [\n...         [[0, 0], [0, 64], [80, 0], [80, 64]],\n...         [[0, 0], [0, 64], [80, 0], [80, 64]],\n...     ]\n... )\n>>> end_points = np.array(\n...     [\n...         [[3, 5], [7, 64], [76, -10], [84, 61]],\n...         [[8, 10], [10, 61], [65, 3], [88, 43]],\n...     ]\n... )\n>>> y = keras.ops.image.perspective_transform(x, start_points, end_points)\n>>> y.shape\n(2, 64, 80, 3)\n\n>>> x = np.random.random((64, 80, 3))  # single RGB image\n>>> start_points = np.array([[0, 0], [0, 64], [80, 0], [80, 64]])\n>>> end_points = np.array([[3, 5], [7, 64], [76, -10], [84, 61]])\n>>> y = keras.ops.image.perspective_transform(x, start_points, end_points)\n>>> y.shape\n(64, 80, 3)\n\n>>> x = np.random.random((2, 3, 64, 80))  # batch of 2 RGB images\n>>> start_points = np.array(\n...     [\n...         [[0, 0], [0, 64], [80, 0], [80, 64]],\n...         [[0, 0], [0, 64], [80, 0], [80, 64]],\n...     ]\n... )\n>>> end_points = np.array(\n...     [\n...         [[3, 5], [7, 64], [76, -10], [84, 61]],\n...         [[8, 10], [10, 61], [65, 3], [88, 43]],\n...     ]\n... )\n>>> y = keras.ops.image.perspective_transform(\n...     x, start_points, end_points, data_format=\"channels_first\"\n... )\n>>> y.shape\n(2, 3, 64, 80)",
    "std_args": [
      "images",
      "start_points",
      "end_points",
      "interpolation",
      "fill_value",
      "data_format"
    ],
    "type": "function"
  },
  "perturb": {
    "description": "Add an zero-value variable (\"perturbation\") to the intermediate value.",
    "std_args": [
      "self",
      "name",
      "value",
      "variable_type"
    ],
    "type": "function"
  },
  "piecewise": {
    "description": "Evaluate a function defined piecewise across the domain.\n\nJAX implementation of :func:`numpy.piecewise`, in terms of :func:`jax.lax.switch`.\n\nNote:\n  Unlike :func:`numpy.piecewise`, :func:`jax.numpy.piecewise` requires functions\n  in ``funclist`` to be traceable by JAX, as it is implemented via\n  :func:`jax.lax.switch`.\n\nArgs:\n  x: array of input values.\n  condlist: boolean array or sequence of boolean arrays corresponding to the\n    functions in ``funclist``. If a sequence of arrays, the length of each\n    array must match the length of ``x``\n  funclist: list of arrays or functions; must either be the same length as\n    ``condlist``, or have length ``len(condlist) + 1``, in which case the\n    last entry is the default applied when none of the conditions are True.\n    Alternatively, entries of ``funclist`` may be numerical values, in which\n    case they indicate a constant function.\n  args, kwargs: additional arguments are passed to each function in\n    ``funclist``.\n\nReturns:\n  An array which is the result of evaluating the functions on ``x`` at\n  the specified conditions.\n\nSee also:\n  - :func:`jax.lax.switch`: choose between *N* functions based on an index.\n  - :func:`jax.lax.cond`: choose between two functions based on a boolean condition.\n  - :func:`jax.numpy.where`: choose between two results based on a boolean mask.\n  - :func:`jax.lax.select`: choose between two results based on a boolean mask.\n  - :func:`jax.lax.select_n`: choose between *N* results based on a boolean mask.\n\nExamples:\n  Here's an example of a function which is zero for negative values, and linear\n  for positive values:\n\n  >>> x = jnp.array([-4, -3, -2, -1, 0, 1, 2, 3, 4])\n\n  >>> condlist = [x < 0, x >= 0]\n  >>> funclist = [lambda x: 0 * x, lambda x: x]\n  >>> jnp.piecewise(x, condlist, funclist)\n  Array([0, 0, 0, 0, 0, 1, 2, 3, 4], dtype=int32)\n\n  ``funclist`` can also contain a simple scalar value for constant functions:\n\n  >>> condlist = [x < 0, x >= 0]\n  >>> funclist = [0, lambda x: x]\n  >>> jnp.piecewise(x, condlist, funclist)\n  Array([0, 0, 0, 0, 0, 1, 2, 3, 4], dtype=int32)\n\n  You can specify a default value by appending an extra condition to ``funclist``:\n\n  >>> condlist = [x < -1, x > 1]\n  >>> funclist = [lambda x: 1 + x, lambda x: x - 1, 0]\n  >>> jnp.piecewise(x, condlist, funclist)\n  Array([-3, -2,  -1,  0,  0,  0,  1,  2, 3], dtype=int32)\n\n  ``condlist`` may also be a simple array of scalar conditions, in which case\n  the associated function applies to the whole range\n\n  >>> condlist = jnp.array([False, True, False])\n  >>> funclist = [lambda x: x * 0, lambda x: x * 10, lambda x: x * 100]\n  >>> jnp.piecewise(x, condlist, funclist)\n  Array([-40, -30, -20, -10,   0,  10,  20,  30,  40], dtype=int32)",
    "std_args": [
      "x",
      "condlist",
      "funclist",
      "args",
      "kw"
    ],
    "type": "function"
  },
  "piecewise_constant_schedule": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "piecewise_interpolate_schedule": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pin_memory": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "pixel_shuffle": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pixel_unshuffle": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "place": {
    "description": "Update array elements based on a mask.\n\nJAX implementation of :func:`numpy.place`.\n\nThe semantics of :func:`numpy.place` are to modify arrays in-place, which\nis not possible for JAX's immutable arrays. The JAX version returns a modified\ncopy of the input, and adds the ``inplace`` parameter which must be set to\n`False`` by the user as a reminder of this API difference.\n\nArgs:\n  arr: array into which values will be placed.\n  mask: boolean mask with the same size as ``arr``.\n  vals: values to be inserted into ``arr`` at the locations indicated\n    by mask. If too many values are supplied, they will be truncated.\n    If not enough values are supplied, they will be repeated.\n  inplace: must be set to False to indicate that the input is not modified\n    in-place, but rather a modified copy is returned.\n\nReturns:\n  A copy of ``arr`` with masked values set to entries from `vals`.\n\nSee Also:\n  - :func:`jax.numpy.put`: put elements into an array at numerical indices.\n  - :func:`jax.numpy.ndarray.at`: array updates using NumPy-style indexing\n\nExamples:\n  >>> x = jnp.zeros((3, 5), dtype=int)\n  >>> mask = (jnp.arange(x.size) % 3 == 0).reshape(x.shape)\n  >>> mask\n  Array([[ True, False, False,  True, False],\n         [False,  True, False, False,  True],\n         [False, False,  True, False, False]], dtype=bool)\n\n  Placing a scalar value:\n\n  >>> jnp.place(x, mask, 1, inplace=False)\n  Array([[1, 0, 0, 1, 0],\n         [0, 1, 0, 0, 1],\n         [0, 0, 1, 0, 0]], dtype=int32)\n\n  In this case, ``jnp.place`` is similar to the masked array update syntax:\n\n  >>> x.at[mask].set(1)\n  Array([[1, 0, 0, 1, 0],\n         [0, 1, 0, 0, 1],\n         [0, 0, 1, 0, 0]], dtype=int32)\n\n  ``place`` differs when placing values from an array. The array is repeated\n  to fill the masked entries:\n\n  >>> vals = jnp.array([1, 3, 5])\n  >>> jnp.place(x, mask, vals, inplace=False)\n  Array([[1, 0, 0, 3, 0],\n         [0, 5, 0, 0, 1],\n         [0, 0, 3, 0, 0]], dtype=int32)",
    "std_args": [
      "arr",
      "mask",
      "vals",
      "inplace"
    ],
    "type": "function"
  },
  "plugin": {
    "description": "The class representing a Python function.",
    "std_args": [
      "version"
    ],
    "type": "function"
  },
  "pmap": {
    "description": "Reference-aware version of `jax.vmap <https://jax.readthedocs.io/en/latest/_autosummary/jax.vmap.html>`__.",
    "std_args": [
      "f",
      "axis_name",
      "in_axes",
      "out_axes",
      "static_broadcasted_argnums",
      "devices",
      "backend",
      "axis_size",
      "donate_argnums",
      "global_arg_shapes",
      "transform_metadata"
    ],
    "type": "function"
  },
  "poisson": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "poisson_nll_loss": {
    "description": "Compute the Poisson negative log likelihood loss.",
    "std_args": [
      "input",
      "target",
      "log_input",
      "full",
      "size_average",
      "eps",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "polar": {
    "description": "Constructs a complex tensor whose elements are Cartesian\ncoordinates corresponding to the polar coordinates\nwith absolute value `abs` and angle `angle`.\n\nThe operation is numerically equivalent to `torch.polar()`.\nIt is not equivalent to `scipy.lingalg.polar()` which performs\nSingular Value Decomposition.\n\nGiven the magnitude (`abs_`) and angle (`angle`), this function computes the\ncorresponding complex number in the form of `real + imaginary * 1j`, where:\n- `real = abs_ * cos(angle)`\n- `imaginary = abs_ * sin(angle)`\n\nArgs:\n    abs_: The magnitude (absolute value) of the complex number.\n    angle: The angle (in radians) of the complex number.\n\nReturns:\n    A complex number (or array of complex numbers) with the same shape as\n    `abs_` and `angle`.\n\nExample:\n\n>>> abs_ = keras.random.normal((1, 2))\n>>> angle = keras.random.normal((1, 2))\n>>> keras.ops.nn.polar(abs_, angle).shape\n(1, 2)\n>>> keras.ops.nn.polar(abs_, angle)\nArray([[0.63185346-0.59370506j, 0.48960376-0.31677645j]], dtype=complex64)",
    "std_args": [
      "abs_",
      "angle"
    ],
    "type": "function"
  },
  "poly2cheb": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "poly2herm": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "poly2herme": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "poly2lag": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "poly2leg": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polyadd": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polycompanion": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polyder": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polydiv": {
    "description": "Returns the quotient and remainder of polynomial division.\n\nJAX implementation of :func:`numpy.polydiv`.\n\nArgs:\n  u: Array of dividend polynomial coefficients.\n  v: Array of divisor polynomial coefficients.\n  trim_leading_zeros: Default is ``False``. If ``True`` removes the leading\n    zeros in the return value to match the result of numpy. But prevents the\n    function from being able to be used in compiled code. Due to differences\n    in accumulation of floating point arithmetic errors, the cutoff for values\n    to be considered zero may lead to inconsistent results between NumPy and\n    JAX, and even between different JAX backends. The result may lead to\n    inconsistent output shapes when ``trim_leading_zeros=True``.\n\nReturns:\n  A tuple of quotient and remainder arrays. The dtype of the output is always\n  promoted to inexact.\n\nNote:\n  :func:`jax.numpy.polydiv` only accepts arrays as input unlike\n  :func:`numpy.polydiv` which accepts scalar inputs as well.\n\nSee also:\n  - :func:`jax.numpy.polyadd`: Computes the sum of two polynomials.\n  - :func:`jax.numpy.polysub`: Computes the difference of two polynomials.\n  - :func:`jax.numpy.polymul`: Computes the product of two polynomials.\n\nExamples:\n  >>> x1 = jnp.array([5, 7, 9])\n  >>> x2 = jnp.array([4, 1])\n  >>> np.polydiv(x1, x2)\n  (array([1.25  , 1.4375]), array([7.5625]))\n  >>> jnp.polydiv(x1, x2)\n  (Array([1.25  , 1.4375], dtype=float32), Array([0.    , 0.    , 7.5625], dtype=float32))\n\n  If ``trim_leading_zeros=True``, the result matches with ``np.polydiv``'s.\n\n  >>> jnp.polydiv(x1, x2, trim_leading_zeros=True)\n  (Array([1.25  , 1.4375], dtype=float32), Array([7.5625], dtype=float32))",
    "std_args": [
      "u",
      "v",
      "trim_leading_zeros"
    ],
    "type": "attribute"
  },
  "polydomain": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polyfit": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polyfromroots": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polygamma": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polygrid2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polygrid3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polyint": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polyline": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polymul": {
    "description": "Returns the product of two polynomials.\n\nJAX implementation of :func:`numpy.polymul`.\n\nArgs:\n  a1: 1D array of polynomial coefficients.\n  a2: 1D array of polynomial coefficients.\n  trim_leading_zeros: Default is ``False``. If ``True`` removes the leading\n    zeros in the return value to match the result of numpy. But prevents the\n    function from being able to be used in compiled code. Due to differences\n    in accumulation of floating point arithmetic errors, the cutoff for values\n    to be considered zero may lead to inconsistent results between NumPy and\n    JAX, and even between different JAX backends. The result may lead to\n    inconsistent output shapes when ``trim_leading_zeros=True``.\n\nReturns:\n  An array of the coefficients of the product of the two polynomials. The dtype\n  of the output is always promoted to inexact.\n\nNote:\n  :func:`jax.numpy.polymul` only accepts arrays as input unlike\n  :func:`numpy.polymul` which accepts scalar inputs as well.\n\nSee also:\n  - :func:`jax.numpy.polyadd`: Computes the sum of two polynomials.\n  - :func:`jax.numpy.polysub`: Computes the difference of two polynomials.\n  - :func:`jax.numpy.polydiv`: Computes the quotient and remainder of polynomial\n    division.\n\nExamples:\n  >>> x1 = np.array([2, 1, 0])\n  >>> x2 = np.array([0, 5, 0, 3])\n  >>> np.polymul(x1, x2)\n  array([10,  5,  6,  3,  0])\n  >>> jnp.polymul(x1, x2)\n  Array([ 0., 10.,  5.,  6.,  3.,  0.], dtype=float32)\n\n  If ``trim_leading_zeros=True``, the result matches with ``np.polymul``'s.\n\n  >>> jnp.polymul(x1, x2, trim_leading_zeros=True)\n  Array([10.,  5.,  6.,  3.,  0.], dtype=float32)\n\n  For input arrays of dtype ``complex``:\n\n  >>> x3 = np.array([2., 1+2j, 1-2j])\n  >>> x4 = np.array([0, 5, 0, 3])\n  >>> np.polymul(x3, x4)\n  array([10. +0.j,  5.+10.j, 11.-10.j,  3. +6.j,  3. -6.j])\n  >>> jnp.polymul(x3, x4)\n  Array([ 0. +0.j, 10. +0.j,  5.+10.j, 11.-10.j,  3. +6.j,  3. -6.j],      dtype=complex64)\n  >>> jnp.polymul(x3, x4, trim_leading_zeros=True)\n  Array([10. +0.j,  5.+10.j, 11.-10.j,  3. +6.j,  3. -6.j], dtype=complex64)",
    "std_args": [
      "a1",
      "a2",
      "trim_leading_zeros"
    ],
    "type": "attribute"
  },
  "polymulx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polynomial_atoms": {
    "description": "Return a set of expressions used as atoms in polynomial self.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "polynomial_schedule": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polyone": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polypow": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polyroots": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polysub": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polytrim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polyval": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polyval2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polyval3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polyvalfromroots": {
    "description": "Evaluate a polynomial specified by its roots at points x.",
    "std_args": [
      "x",
      "r",
      "tensor"
    ],
    "type": "function"
  },
  "polyvander": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polyvander2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polyvander3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polyx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "polyzero": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pool": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pool_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pop": {
    "description": "Remove key from the ParameterDict and return its parameter.",
    "std_args": [
      "self",
      "key"
    ],
    "type": "function"
  },
  "pop_key": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "popitem": {
    "description": "Remove and return the last inserted `(key, parameter)` pair from the ParameterDict.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "pos_weight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "post_processing_hooks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "postcrack": {
    "description": "TODO:",
    "std_args": [
      "block",
      "args",
      "tab"
    ],
    "type": "function"
  },
  "postcrack2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "block",
      "tab",
      "param_map"
    ],
    "type": "function"
  },
  "postlist": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "power": {
    "description": "Calculate element-wise base ``x1`` exponential of ``x2``.\n\nJAX implementation of :obj:`numpy.power`.\n\nArgs:\n  x1: scalar or array. Specifies the bases.\n  x2: scalar or array. Specifies the exponent. ``x1`` and ``x2`` should either\n    have same shape or be broadcast compatible.\n\nReturns:\n  An array containing the base ``x1`` exponentials of ``x2`` with same dtype\n  as input.\n\nNote:\n  - When ``x2`` is a concrete integer scalar, ``jnp.power`` lowers to\n    :func:`jax.lax.integer_pow`.\n  - When ``x2`` is a traced scalar or an array, ``jnp.power`` lowers to\n    :func:`jax.lax.pow`.\n  - ``jnp.power`` raises a ``TypeError`` for integer type raised to a concrete\n    negative integer power. For a non-concrete power, the operation is invalid\n    and the returned value is implementation-defined.\n  - ``jnp.power`` returns ``nan`` for negative value raised to the power of\n    non-integer values.\n\nSee also:\n  - :func:`jax.lax.pow`: Computes element-wise power, :math:`x^y`.\n  - :func:`jax.lax.integer_pow`: Computes element-wise power :math:`x^y`, where\n    :math:`y` is a fixed integer.\n  - :func:`jax.numpy.float_power`: Computes the first array raised to the power\n    of second array, element-wise, by promoting to the inexact dtype.\n  - :func:`jax.numpy.pow`: Computes the first array raised to the power of second\n    array, element-wise.\n\nExamples:\n  Inputs with scalar integers:\n\n  >>> jnp.power(4, 3)\n  Array(64, dtype=int32, weak_type=True)\n\n  Inputs with same shape:\n\n  >>> x1 = jnp.array([2, 4, 5])\n  >>> x2 = jnp.array([3, 0.5, 2])\n  >>> jnp.power(x1, x2)\n  Array([ 8.,  2., 25.], dtype=float32)\n\n  Inputs with broadcast compatibility:\n\n  >>> x3 = jnp.array([-2, 3, 1])\n  >>> x4 = jnp.array([[4, 1, 6],\n  ...                 [1.3, 3, 5]])\n  >>> jnp.power(x3, x4)\n  Array([[16.,  3.,  1.],\n         [nan, 27.,  1.]], dtype=float32)",
    "std_args": [
      "x1",
      "x2"
    ],
    "type": "function"
  },
  "precision": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "precompiled_cuda_kernel": {
    "description": "Run a precompiled CUDA kernel defined from PTX or cubin.",
    "std_args": [
      "name",
      "compiled_source",
      "inputs",
      "output_shapes",
      "output_dtypes",
      "scalars",
      "grid",
      "threadgroup",
      "shared_memory",
      "init_value",
      "ensure_row_contiguous",
      "stream"
    ],
    "type": "function"
  },
  "predicate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "predicates": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "predict": {
    "description": "Return the class with the highest probability for each example in the input minibatch.",
    "std_args": [
      "self",
      "input"
    ],
    "type": "function"
  },
  "preferred_element_type": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "preparse_sysargv": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "prev_value": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "previous_context": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "print_cancast_table": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ntypes"
    ],
    "type": "function"
  },
  "print_coercion_table": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ntypes",
      "inputfirstvalue",
      "inputsecondvalue",
      "firstarray",
      "use_promote_types"
    ],
    "type": "function"
  },
  "print_new_cast_table": {
    "description": "Prints new casts, the values given are default \"can-cast\" values, not",
    "std_args": [
      "can_cast",
      "legacy",
      "flags"
    ],
    "type": "function"
  },
  "printoptions": {
    "description": "Alias of :func:`numpy.printoptions`.\n\nJAX arrays are printed via NumPy, so NumPy's `printoptions`\nconfigurations will apply to printed JAX arrays.\n\nSee the :func:`numpy.set_printoptions` documentation for details\non the available options and their meanings.",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "privatepattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "process_f2cmap_dict": {
    "description": "Update the Fortran-to-C type mapping dictionary with new mappings and",
    "std_args": [
      "f2cmap_all",
      "new_map",
      "c2py_map",
      "verbose"
    ],
    "type": "function"
  },
  "process_group": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "product": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "proj_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "promote_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "promote_types": {
    "description": "Returns the type to which a binary operation should cast its arguments.\n\nJAX implementation of :func:`numpy.promote_types`. For details of JAX's\ntype promotion semantics, see :ref:`type-promotion`.\n\nArgs:\n  a: a :class:`numpy.dtype` or a dtype specifier.\n  b: a :class:`numpy.dtype` or a dtype specifier.\n\nReturns:\n  A :class:`numpy.dtype` object.\n\nExamples:\n  Type specifiers may be strings, dtypes, or scalar types, and the return\n  value is always a dtype:\n\n  >>> jnp.promote_types('int32', 'float32')  # strings\n  dtype('float32')\n  >>> jnp.promote_types(jnp.dtype('int32'), jnp.dtype('float32'))  # dtypes\n  dtype('float32')\n  >>> jnp.promote_types(jnp.int32, jnp.float32)  # scalar types\n  dtype('float32')\n\n  Built-in scalar types (:type:`int`, :type:`float`, or :type:`complex`) are\n  treated as weakly-typed and will not change the bit width of a strongly-typed\n  counterpart (see discussion in :ref:`type-promotion`):\n\n  >>> jnp.promote_types('uint8', int)\n  dtype('uint8')\n  >>> jnp.promote_types('float16', float)\n  dtype('float16')\n\n  This differs from the NumPy version of this function, which treats built-in scalar\n  types as equivalent to 64-bit types:\n\n  >>> import numpy\n  >>> numpy.promote_types('uint8', int)\n  dtype('int64')\n  >>> numpy.promote_types('float16', float)\n  dtype('float64')",
    "std_args": [
      "a",
      "b"
    ],
    "type": "function"
  },
  "prune": {
    "description": "Compute and returns a pruned version of input tensor ``t``.",
    "std_args": [
      "self",
      "t",
      "default_mask",
      "importance_scores"
    ],
    "type": "function"
  },
  "psi": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "psnr": {
    "description": "Peak Signal-to-Noise Ratio (PSNR) function.\n\nThis function computes the Peak Signal-to-Noise Ratio between two signals,\n`x1` and `x2`. PSNR is a measure of the quality of a reconstructed signal.\nThe higher the PSNR, the closer the reconstructed signal is to the original\nsignal. Note that it can become negative when the signal power is\nsmaller that the noise power.\n\nArgs:\n    x1: The first input signal.\n    x2: The second input signal. Must have the same shape as `x1`.\n    max_val: The maximum possible value in the signals.\n\nReturns:\n    float: The PSNR value between `x1` and `x2`.\n\nExamples:\n\n>>> x1 = keras.random.normal((2, 4, 4, 3))\n>>> x2 = keras.random.normal((2, 4, 4, 3))\n>>> max_val = 1.0\n>>> keras.ops.nn.psnr(x1, x2, max_val)\n-3.1697404",
    "std_args": [
      "x1",
      "x2",
      "max_val"
    ],
    "type": "function"
  },
  "ptp": {
    "description": "Return the peak-to-peak range along a given axis.\n\nJAX implementation of :func:`numpy.ptp`.\n\nArgs:\n  a: input array.\n  axis: optional, int or sequence of ints, default=None. Axis along which the\n    range is computed. If None, the range is computed on the flattened array.\n  keepdims: bool, default=False. If true, reduced axes are left in the result\n    with size 1.\n  out: Unused by JAX.\n\nReturns:\n  An array with the range of elements along specified axis of input.\n\nExamples:\n  By default, ``jnp.ptp`` computes the range along all axes.\n\n  >>> x = jnp.array([[1, 3, 5, 2],\n  ...                [4, 6, 8, 1],\n  ...                [7, 9, 3, 4]])\n  >>> jnp.ptp(x)\n  Array(8, dtype=int32)\n\n  If ``axis=1``, computes the range along axis 1.\n\n  >>> jnp.ptp(x, axis=1)\n  Array([4, 7, 6], dtype=int32)\n\n  To preserve the dimensions of input, you can set ``keepdims=True``.\n\n  >>> jnp.ptp(x, axis=1, keepdims=True)\n  Array([[4],\n         [7],\n         [6]], dtype=int32)",
    "std_args": [
      "a",
      "axis",
      "out",
      "keepdims"
    ],
    "type": "function"
  },
  "publicpattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pure": {
    "description": "Returns a new tree with all ``Variable`` objects replaced with inner values.",
    "std_args": [
      "tree"
    ],
    "type": "function"
  },
  "put": {
    "description": "Put elements into an array at given indices.\n\nJAX implementation of :func:`numpy.put`.\n\nThe semantics of :func:`numpy.put` are to modify arrays in-place, which\nis not possible for JAX's immutable arrays. The JAX version returns a modified\ncopy of the input, and adds the ``inplace`` parameter which must be set to\n`False`` by the user as a reminder of this API difference.\n\nArgs:\n  a: array into which values will be placed.\n  ind: array of indices over the flattened array at which to put values.\n  v: array of values to put into the array.\n  mode: string specifying how to handle out-of-bound indices. Supported values:\n\n    - ``\"clip\"`` (default): clip out-of-bound indices to the final index.\n    - ``\"wrap\"``: wrap out-of-bound indices to the beginning of the array.\n\n  inplace: must be set to False to indicate that the input is not modified\n    in-place, but rather a modified copy is returned.\n\nReturns:\n  A copy of ``a`` with specified entries updated.\n\nSee Also:\n  - :func:`jax.numpy.place`: place elements into an array via boolean mask.\n  - :func:`jax.numpy.ndarray.at`: array updates using NumPy-style indexing.\n  - :func:`jax.numpy.take`: extract values from an array at given indices.\n\nExamples:\n  >>> x = jnp.zeros(5, dtype=int)\n  >>> indices = jnp.array([0, 2, 4])\n  >>> values = jnp.array([10, 20, 30])\n  >>> jnp.put(x, indices, values, inplace=False)\n  Array([10,  0, 20,  0, 30], dtype=int32)\n\n  This is equivalent to the following :attr:`jax.numpy.ndarray.at` indexing syntax:\n\n  >>> x.at[indices].set(values)\n  Array([10,  0, 20,  0, 30], dtype=int32)\n\n  There are two modes for handling out-of-bound indices. By default they are\n  clipped:\n\n  >>> indices = jnp.array([0, 2, 6])\n  >>> jnp.put(x, indices, values, inplace=False, mode='clip')\n  Array([10,  0, 20,  0, 30], dtype=int32)\n\n  Alternatively, they can be wrapped to the beginning of the array:\n\n  >>> jnp.put(x, indices, values, inplace=False, mode='wrap')\n  Array([10,  30, 20,  0, 0], dtype=int32)\n\n  For N-dimensional inputs, the indices refer to the flattened array:\n\n  >>> x = jnp.zeros((3, 5), dtype=int)\n  >>> indices = jnp.array([0, 7, 14])\n  >>> jnp.put(x, indices, values, inplace=False)\n  Array([[10,  0,  0,  0,  0],\n         [ 0,  0, 20,  0,  0],\n         [ 0,  0,  0,  0, 30]], dtype=int32)",
    "std_args": [
      "a",
      "ind",
      "v",
      "mode",
      "inplace"
    ],
    "type": "function"
  },
  "put_along_axis": {
    "description": "put_along_axis(a: array, /, indices: array, values: array, axis: Optional[int] = None, *, stream: Union[None, Stream, Device] = None) -> array",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "putmask": {
    "description": "Changes elements of an array based on conditional and input values.",
    "std_args": [
      "a",
      "mask",
      "values"
    ],
    "type": "function"
  },
  "pwd": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pyarr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pyarr_attr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pyf": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pyf_src": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pyffilename": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pytest_addoption": {
    "description": "The class representing a Python function.",
    "std_args": [
      "parser"
    ],
    "type": "function"
  },
  "pytest_configure": {
    "description": "The class representing a Python function.",
    "std_args": [
      "config"
    ],
    "type": "function"
  },
  "pytest_itemcollected": {
    "description": "Check FPU precision mode was not changed during test collection.",
    "std_args": [
      "item"
    ],
    "type": "function"
  },
  "pytest_sessionstart": {
    "description": "The class representing a Python function.",
    "std_args": [
      "session"
    ],
    "type": "function"
  },
  "pytest_terminal_summary": {
    "description": "The class representing a Python function.",
    "std_args": [
      "terminalreporter",
      "exitstatus",
      "config"
    ],
    "type": "function"
  },
  "pytestmark": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pytorch_compatible": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "q_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "q_num_blocks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "q_proj_weight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "qkv_dot_general": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "qkv_dot_general_cls": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "qkv_features": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "qkv_promote_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "qqmm": {
    "description": "qqmm(x: array, w: array, scales: Optional[array] = None, group_size: Optional[int] = None, bits: Optional[int] = None, mode: str = 'nvfp4', *, stream: Union[None, Stream, Device] = None) -> array",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "quantile": {
    "description": "Compute the q-th quantile(s) of the data along the specified axis.\n\nArgs:\n    x: Input tensor.\n    q: Probability or sequence of probabilities for the quantiles to\n        compute. Values must be between 0 and 1 inclusive.\n    axis: Axis or axes along which the quantiles are computed. Defaults to\n        `axis=None` which is to compute the quantile(s) along a flattened\n        version of the array.\n    method: A string specifies the method to use for estimating the\n        quantile. Available methods are `\"linear\"`, `\"lower\"`, `\"higher\"`,\n        `\"midpoint\"`, and `\"nearest\"`. Defaults to `\"linear\"`.\n        If the desired quantile lies between two data points `i < j`:\n        - `\"linear\"`: `i + (j - i) * fraction`, where fraction is the\n            fractional part of the index surrounded by `i` and `j`.\n        - `\"lower\"`: `i`.\n        - `\"higher\"`: `j`.\n        - `\"midpoint\"`: `(i + j) / 2`\n        - `\"nearest\"`: `i` or `j`, whichever is nearest.\n    keepdims: If this is set to `True`, the axes which are reduce\n        are left in the result as dimensions with size one.\n\nReturns:\n    The quantile(s). If `q` is a single probability and `axis=None`, then\n    the result is a scalar. If multiple probabilities levels are given,\n    first axis of the result corresponds to the quantiles. The other axes\n    are the axes that remain after the reduction of `x`.",
    "std_args": [
      "x",
      "q",
      "axis",
      "method",
      "keepdims"
    ],
    "type": "function"
  },
  "quantile_methods": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "quantize": {
    "description": "",
    "std_args": [
      "self",
      "mode",
      "type_check",
      "config"
    ],
    "type": "function"
  },
  "quantized_build": {
    "description": "",
    "std_args": [
      "self",
      "input_shape",
      "mode"
    ],
    "type": "function"
  },
  "quantized_call": {
    "description": "",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "quantized_matmul": {
    "description": "quantized_matmul(x: array, w: array, /, scales: array, biases: Optional[array] = None, transpose: bool = True, group_size: Optional[int] = None, bits: Optional[int] = None, mode: str = 'affine', *, stream: Union[None, Stream, Device] = None) -> array",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "query": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "query_ln": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "query_proj": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "quiet": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rad2deg": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rademacher": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "radians": {
    "description": "Alias of :func:`jax.numpy.deg2rad`",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "rand": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "random": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "random_integers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "random_like": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "random_raw": {
    "description": "random_raw(self, size=None)",
    "std_args": [
      "self",
      "size",
      "output"
    ],
    "type": "function"
  },
  "random_sample": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "random_structured": {
    "description": "Prune tensor by removing random channels along the specified dimension.",
    "std_args": [
      "module",
      "name",
      "amount",
      "dim"
    ],
    "type": "function"
  },
  "random_unstructured": {
    "description": "Prune tensor by removing random (currently unpruned) units.",
    "std_args": [
      "module",
      "name",
      "amount"
    ],
    "type": "function"
  },
  "ranf": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rank": {
    "description": "Get the rank of this process",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "rate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ravel": {
    "description": "Flatten array into a 1-dimensional shape.\n\nRefer to :func:`jax.numpy.ravel` for the full documentation.",
    "std_args": [
      "self",
      "order",
      "out_sharding"
    ],
    "type": "function"
  },
  "ravel_multi_index": {
    "description": "Convert multi-dimensional indices into flat indices.\n\nJAX implementation of :func:`numpy.ravel_multi_index`\n\nArgs:\n  multi_index: sequence of integer arrays containing indices in each dimension.\n  dims: sequence of integer sizes; must have ``len(dims) == len(multi_index)``\n  mode: how to handle out-of bound indices. Options are\n\n    - ``\"raise\"`` (default): raise a ValueError. This mode is incompatible\n      with :func:`~jax.jit` or other JAX transformations.\n    - ``\"clip\"``: clip out-of-bound indices to valid range.\n    - ``\"wrap\"``: wrap out-of-bound indices to valid range.\n\n  order: ``\"C\"`` (default) or ``\"F\"``, specify whether to assume C-style\n    row-major order or Fortran-style column-major order.\n\nReturns:\n  array of flattened indices\n\nSee also:\n  :func:`jax.numpy.unravel_index`: inverse of this function.\n\nExamples:\n  Define a 2-dimensional array and a sequence of indices of even values:\n\n  >>> x = jnp.array([[2., 3., 4.],\n  ...                [5., 6., 7.]])\n  >>> indices = jnp.where(x % 2 == 0)\n  >>> indices\n  (Array([0, 0, 1], dtype=int32), Array([0, 2, 1], dtype=int32))\n  >>> x[indices]\n  Array([2., 4., 6.], dtype=float32)\n\n  Compute the flattened indices:\n\n  >>> indices_flat = jnp.ravel_multi_index(indices, x.shape)\n  >>> indices_flat\n  Array([0, 2, 4], dtype=int32)\n\n  These flattened indices can be used to extract the same values from the\n  flattened ``x`` array:\n\n  >>> x_flat = x.ravel()\n  >>> x_flat\n  Array([2., 3., 4., 5., 6., 7.], dtype=float32)\n  >>> x_flat[indices_flat]\n  Array([2., 4., 6.], dtype=float32)\n\n  The original indices can be recovered with :func:`~jax.numpy.unravel_index`:\n\n  >>> jnp.unravel_index(indices_flat, x.shape)\n  (Array([0, 0, 1], dtype=int32), Array([0, 2, 1], dtype=int32))",
    "std_args": [
      "multi_index",
      "dims",
      "mode",
      "order"
    ],
    "type": "function"
  },
  "raw_mapping": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "raw_value": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rayleigh": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "read": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "size"
    ],
    "type": "function"
  },
  "read_loval": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "variable_state",
      "variable"
    ],
    "type": "function"
  },
  "readfortrancode": {
    "description": "Read fortran codes from files and",
    "std_args": [
      "ffile",
      "dowithline",
      "istop"
    ],
    "type": "function"
  },
  "real16pattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "real8pattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rearrange": {
    "description": "Rearranges the axes of a Keras tensor according to a specified pattern,\neinops-style.\n\nArgs:\n    tensor: Input Keras tensor.\n    pattern: String describing the rearrangement in einops notation.\n    **axes_lengths: Keyword arguments specifying lengths of axes\n        when axes decomposition is used.\n\nReturns:\n    Tensor: A Keras tensor with rearranged axes.\n\nFollows the logic of:\n\n1. If decomposition is needed, reshape to match decomposed dimensions.\n2. Permute known and inferred axes to match the form of the output.\n3. Reshape to match the desired output shape.\n\n\nExample Usage:\n\n```\n>>> import numpy as np\n>>> from keras.ops import rearrange\n>>> images = np.random.rand(32, 30, 40, 3) # BHWC format\n\n# Reordering to BCHW\n>>> rearrange(images, 'b h w c -> b c h w').shape\nTensorShape([32, 3, 30, 40])\n\n# \"Merge\" along first axis - concat images from a batch\n>>> rearrange(images, 'b h w c -> (b h) w c').shape\nTensorShape([960, 40, 3])\n\n# \"Merge\" along second axis - concat images horizontally\n>>> rearrange(images, 'b h w c -> h (b w) c').shape\nTensorShape([30, 1280, 3])\n\n# Flatten images into a CHW vector\n>>> rearrange(images, 'b h w c -> b (c h w)').shape\nTensorShape([32, 3600])\n\n# Decompose H and W axes into 4 smaller patches\n>>> rearrange(images, 'b (h1 h) (w1 w) c -> (b h1 w1) h w c', h1=2, w1=2).shape\nTensorShape([128, 15, 20, 3])\n\n# Space-to-depth decomposition of input axes\n>>> rearrange(images, 'b (h h1) (w w1) c -> b h w (c h1 w1)', h1=2, w1=2).shape\nTensorShape([32, 15, 20, 12])\n```",
    "std_args": [
      "tensor",
      "pattern",
      "axes_lengths"
    ],
    "type": "function"
  },
  "rec_append_fields": {
    "description": "Add new fields to an existing array.",
    "std_args": [
      "base",
      "names",
      "data",
      "dtypes"
    ],
    "type": "function"
  },
  "rec_drop_fields": {
    "description": "Returns a new numpy.recarray with fields in `drop_names` dropped.",
    "std_args": [
      "base",
      "drop_names"
    ],
    "type": "function"
  },
  "rec_join": {
    "description": "Join arrays `r1` and `r2` on keys.",
    "std_args": [
      "key",
      "r1",
      "r2",
      "jointype",
      "r1postfix",
      "r2postfix",
      "defaults"
    ],
    "type": "function"
  },
  "recompute_scale_factor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "record_arrays": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "recordmask": {
    "description": "Get or set the mask of the array if it has no named fields. For",
    "std_args": [],
    "type": "attribute"
  },
  "recursive_fill_fields": {
    "description": "Fills fields from output with fields from input,",
    "std_args": [
      "input",
      "output"
    ],
    "type": "function"
  },
  "recursive_map": {
    "description": "Recursively applies a function to all nodes and leaves of the given graph node.",
    "std_args": [
      "f",
      "node"
    ],
    "type": "function"
  },
  "recv": {
    "description": "Recv an array with shape ``shape`` and dtype ``dtype`` from process",
    "std_args": [
      "shape",
      "dtype",
      "src",
      "group",
      "stream"
    ],
    "type": "function"
  },
  "recv_like": {
    "description": "Recv an array with shape and type like ``x`` from process with rank",
    "std_args": [
      "x",
      "src",
      "group",
      "stream"
    ],
    "type": "function"
  },
  "reduce": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "array",
      "axis",
      "dtype",
      "out",
      "kwargs"
    ],
    "type": "function"
  },
  "reduce_add": {
    "description": "Sum tensors from multiple GPUs.",
    "std_args": [
      "inputs",
      "destination"
    ],
    "type": "function"
  },
  "reduce_add_coalesced": {
    "description": "Sum tensors from multiple GPUs.",
    "std_args": [
      "inputs",
      "destination",
      "buffer_size"
    ],
    "type": "function"
  },
  "reduceat": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "array",
      "indices",
      "axis",
      "dtype",
      "out"
    ],
    "type": "function"
  },
  "reduction_axes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ref_index": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ref_index_stack": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "register_backward_hook": {
    "description": "Register a backward hook on the module.",
    "std_args": [
      "self",
      "hook"
    ],
    "type": "function"
  },
  "register_comm_hook": {
    "description": "Register communication hook for user-defined DDP aggregation of gradients across multiple workers.",
    "std_args": [
      "self",
      "state",
      "hook"
    ],
    "type": "function"
  },
  "register_data_type": {
    "description": "Registers a type as pytree data type recognized by Object.",
    "std_args": [
      "type_"
    ],
    "type": "function"
  },
  "register_forward_hook": {
    "description": "Register a forward hook on the module.",
    "std_args": [
      "self",
      "hook",
      "prepend",
      "with_kwargs",
      "always_call"
    ],
    "type": "function"
  },
  "register_forward_pre_hook": {
    "description": "Register a forward pre-hook on the module.",
    "std_args": [
      "self",
      "hook",
      "prepend",
      "with_kwargs"
    ],
    "type": "function"
  },
  "register_full_backward_hook": {
    "description": "Register a backward hook on the module.",
    "std_args": [
      "self",
      "hook",
      "prepend"
    ],
    "type": "function"
  },
  "register_full_backward_pre_hook": {
    "description": "Register a backward pre-hook on the module.",
    "std_args": [
      "self",
      "hook",
      "prepend"
    ],
    "type": "function"
  },
  "register_graph_node_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "type",
      "flatten",
      "set_key",
      "pop_key",
      "create_empty",
      "clear",
      "init"
    ],
    "type": "function"
  },
  "register_load_state_dict_post_hook": {
    "description": "Register a post-hook to be run after module's :meth:`~nn.Module.load_state_dict` is called.",
    "std_args": [
      "self",
      "hook"
    ],
    "type": "function"
  },
  "register_load_state_dict_pre_hook": {
    "description": "Register a pre-hook to be run before module's :meth:`~nn.Module.load_state_dict` is called.",
    "std_args": [
      "self",
      "hook"
    ],
    "type": "function"
  },
  "register_module_backward_hook": {
    "description": "Register a backward hook common to all the modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_module_buffer_registration_hook": {
    "description": "Register a buffer registration hook common to all modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_module_forward_hook": {
    "description": "Register a global forward hook for all the modules.",
    "std_args": [
      "hook",
      "with_kwargs",
      "always_call"
    ],
    "type": "function"
  },
  "register_module_forward_pre_hook": {
    "description": "Register a forward pre-hook common to all modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_module_full_backward_hook": {
    "description": "Register a backward hook common to all the modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_module_full_backward_pre_hook": {
    "description": "Register a backward pre-hook common to all the modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_module_module_registration_hook": {
    "description": "Register a module registration hook common to all modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_module_parameter_registration_hook": {
    "description": "Register a parameter registration hook common to all modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_parametrization": {
    "description": "Register a parametrization to a tensor in a module.",
    "std_args": [
      "module",
      "tensor_name",
      "parametrization",
      "unsafe"
    ],
    "type": "function"
  },
  "register_pytree_node_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "type",
      "flatten",
      "unflatten",
      "set_key",
      "pop_key"
    ],
    "type": "function"
  },
  "register_state_dict_post_hook": {
    "description": "Register a post-hook for the :meth:`~torch.nn.Module.state_dict` method.",
    "std_args": [
      "self",
      "hook"
    ],
    "type": "function"
  },
  "register_state_dict_pre_hook": {
    "description": "Register a pre-hook for the :meth:`~torch.nn.Module.state_dict` method.",
    "std_args": [
      "self",
      "hook"
    ],
    "type": "function"
  },
  "register_variable_name": {
    "description": "Register a pair of Linen collection name and its NNX type.",
    "std_args": [
      "name",
      "typ",
      "overwrite"
    ],
    "type": "function"
  },
  "relative_step": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "release": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "relu2": {
    "description": "Applies the ReLU\u00b2 activation function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "relu_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "remat": {
    "description": "A 'lifted' version of the",
    "std_args": [
      "f",
      "prevent_cse",
      "static_argnums",
      "policy"
    ],
    "type": "function"
  },
  "rematerialized_call": {
    "description": "Enable rematerialization dynamically for layer's call method.\n\nArgs:\n    layer_call: The original `call` method of a layer.\n\nReturns:\n    Rematerialized layer's `call` method.",
    "std_args": [
      "self",
      "layer_call",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "remove": {
    "description": "Remove the pruning reparameterization from a module and the pruning method from the forward hook.",
    "std_args": [
      "module",
      "name"
    ],
    "type": "function"
  },
  "remove_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "index",
      "params"
    ],
    "type": "function"
  },
  "remove_axis_hooks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "remove_multi_index": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "remove_parametrizations": {
    "description": "Remove the parametrizations on a tensor in a module.",
    "std_args": [
      "module",
      "tensor_name",
      "leave_parametrized"
    ],
    "type": "function"
  },
  "remove_spectral_norm": {
    "description": "Remove the spectral normalization reparameterization from a module.",
    "std_args": [
      "module",
      "name"
    ],
    "type": "function"
  },
  "remove_weight_norm": {
    "description": "Remove the weight normalization reparameterization from a module.",
    "std_args": [
      "module",
      "name"
    ],
    "type": "function"
  },
  "removespaces": {
    "description": "The class representing a Python function.",
    "std_args": [
      "expr"
    ],
    "type": "function"
  },
  "rename_fields": {
    "description": "Rename the fields from a flexible-datatype ndarray or recarray.",
    "std_args": [
      "base",
      "namemapper"
    ],
    "type": "function"
  },
  "render_object_constructor": {
    "description": "Renders an object in \"constructor format\", similar to a dataclass.",
    "std_args": [
      "object_type",
      "attributes",
      "path",
      "subtree_renderer",
      "roundtrippable",
      "color",
      "first_line_annotation"
    ],
    "type": "function"
  },
  "repack_fields": {
    "description": "Re-pack the fields of a structured array or dtype in memory.",
    "std_args": [
      "a",
      "align",
      "recurse"
    ],
    "type": "function"
  },
  "replace": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "replace_boxed": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "val"
    ],
    "type": "function"
  },
  "replace_by_pure_dict": {
    "description": "Replace input ``state`` values with ``pure_dict`` values.",
    "std_args": [
      "state",
      "pure_dict",
      "replace_fn"
    ],
    "type": "function"
  },
  "replace_parenthesis": {
    "description": "Replace substrings of input that are enclosed in parenthesis.",
    "std_args": [
      "s"
    ],
    "type": "function"
  },
  "replicate": {
    "description": "The class representing a Python function.",
    "std_args": [
      "network",
      "devices",
      "detach"
    ],
    "type": "function"
  },
  "repmat": {
    "description": "Repeat a 0-D to 2-D array or matrix MxN times.",
    "std_args": [
      "a",
      "m",
      "n"
    ],
    "type": "function"
  },
  "require_backward_grad_sync": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "require_fields": {
    "description": "Casts a structured array to a new dtype using assignment by field-name.",
    "std_args": [
      "array",
      "required_dtype"
    ],
    "type": "function"
  },
  "require_forward_param_sync": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "required_metadata": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "required_version": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "requiredpattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "requires_grad_": {
    "description": "Change if autograd should record operations on parameters in this module.",
    "std_args": [
      "self",
      "requires_grad"
    ],
    "type": "function"
  },
  "requiresf90wrapper": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "res1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "res2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "res3": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "reseed": {
    "description": "Update the keys of the specified RNG streams with new keys.",
    "std_args": [
      "node",
      "policy",
      "stream_keys"
    ],
    "type": "function"
  },
  "reserved_fields": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "reset": {
    "description": "Reset all underlying ``Metric``'s.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "reset_dropout_mask": {
    "description": "Reset the cached dropout mask if any.\n\nThe RNN layer invokes this in the `call()` method\nso that the cached mask is cleared after calling `cell.call()`. The\nmask should be cached across all timestep within the same batch, but\nshouldn't be cached between batches.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "reset_global_f2py_vars": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "reset_parameters": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "reset_peak_memory": {
    "description": "reset_peak_memory() -> None",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "reset_recurrent_dropout_mask": {
    "description": "",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "reset_state": {
    "description": "",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "reset_states": {
    "description": "",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "reshape_weight_to_matrix": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "weight"
    ],
    "type": "function"
  },
  "residual": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "resolve_dtypes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtypes",
      "signature",
      "casting",
      "reduction"
    ],
    "type": "function"
  },
  "resolve_kwargs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "fun",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "restore_int_paths": {
    "description": "Restore integer paths from string value in the dict.",
    "std_args": [
      "pure_dict"
    ],
    "type": "function"
  },
  "restore_rngs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "backups"
    ],
    "type": "function"
  },
  "restore_singleton_bitgen": {
    "description": "Ensures that the singleton bitgen is restored after a test",
    "std_args": [],
    "type": "function"
  },
  "retreal_f77": {
    "description": "Generates a single f77 file for testing",
    "std_args": [
      "tmpdir_factory"
    ],
    "type": "function"
  },
  "return_carry": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "return_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "reverse": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rfft2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "rfunc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rg": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rgb_to_grayscale": {
    "description": "Convert RGB images to grayscale.\n\nThis function converts RGB images to grayscale images. It supports both\n3D and 4D tensors.\n\nArgs:\n    images: Input image or batch of images. Must be 3D or 4D.\n    data_format: A string specifying the data format of the input tensor.\n        It can be either `\"channels_last\"` or `\"channels_first\"`.\n        `\"channels_last\"` corresponds to inputs with shape\n        `(batch, height, width, channels)`, while `\"channels_first\"`\n        corresponds to inputs with shape `(batch, channels, height, width)`.\n        If not specified, the value will default to\n        `keras.config.image_data_format`.\n\nReturns:\n    Grayscale image or batch of grayscale images.\n\nExamples:\n\n>>> import numpy as np\n>>> from keras import ops\n>>> x = np.random.random((2, 4, 4, 3))\n>>> y = ops.image.rgb_to_grayscale(x)\n>>> y.shape\n(2, 4, 4, 1)\n\n>>> x = np.random.random((4, 4, 3)) # Single RGB image\n>>> y = ops.image.rgb_to_grayscale(x)\n>>> y.shape\n(4, 4, 1)\n\n>>> x = np.random.random((2, 3, 4, 4))\n>>> y = ops.image.rgb_to_grayscale(x, data_format=\"channels_first\")\n>>> y.shape\n(2, 1, 4, 4)",
    "std_args": [
      "images",
      "data_format"
    ],
    "type": "function"
  },
  "rgb_to_hsv": {
    "description": "Convert RGB images to HSV.\n\n`images` must be of float dtype, and the output is only well defined if the\nvalues in `images` are in `[0, 1]`.\n\nAll HSV values are in `[0, 1]`. A hue of `0` corresponds to pure red, `1/3`\nis pure green, and `2/3` is pure blue.\n\nArgs:\n    images: Input image or batch of images. Must be 3D or 4D.\n    data_format: A string specifying the data format of the input tensor.\n        It can be either `\"channels_last\"` or `\"channels_first\"`.\n        `\"channels_last\"` corresponds to inputs with shape\n        `(batch, height, width, channels)`, while `\"channels_first\"`\n        corresponds to inputs with shape `(batch, channels, height, width)`.\n        If not specified, the value will default to\n        `keras.config.image_data_format`.\n\nReturns:\n    HSV image or batch of HSV images.\n\nExamples:\n\n>>> import numpy as np\n>>> from keras import ops\n>>> x = np.random.random((2, 4, 4, 3))\n>>> y = ops.image.rgb_to_hsv(x)\n>>> y.shape\n(2, 4, 4, 3)\n\n>>> x = np.random.random((4, 4, 3)) # Single RGB image\n>>> y = ops.image.rgb_to_hsv(x)\n>>> y.shape\n(4, 4, 3)\n\n>>> x = np.random.random((2, 3, 4, 4))\n>>> y = ops.image.rgb_to_hsv(x, data_format=\"channels_first\")\n>>> y.shape\n(2, 3, 4, 4)",
    "std_args": [
      "images",
      "data_format"
    ],
    "type": "function"
  },
  "rho": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "right_inverse": {
    "description": "Call the ``right_inverse`` methods of the parametrizations in the inverse registration order.",
    "std_args": [
      "self",
      "value"
    ],
    "type": "function"
  },
  "right_shift": {
    "description": "Shift the bits of an integer to the right.",
    "std_args": [
      "a",
      "n"
    ],
    "type": "function"
  },
  "rint": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rmbadname": {
    "description": "The class representing a Python function.",
    "std_args": [
      "names"
    ],
    "type": "function"
  },
  "rmbadname1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "name"
    ],
    "type": "function"
  },
  "rms_norm": {
    "description": "Apply Root Mean Square Layer Normalization.",
    "std_args": [
      "input",
      "normalized_shape",
      "weight",
      "eps"
    ],
    "type": "function"
  },
  "rms_normalization": {
    "description": "Performs Root Mean Square (RMS) normalization on `x`.\n\nThe Keras operation implements the operation as described in\n[Root Mean Square Layer Normalization](https://arxiv.org/pdf/1910.07467)\nby Biao Zhang et al.\n\nThe operation is different from LayerNormalization with RMS scaling.\n\nIt is defined as `rms_normalization(x) = x * rsqrt(mean(square(x))) * scale`\n\nArgs:\n    x: Input tensor.\n    scale: Optional scaling factor for the normalization.\n    axis: The axis or axes along which to perform normalization. Defaults\n        to `-1`.\n    epsilon: A lower bound value for the norm. Defaults to\n        `backend.epsilon()`.\n\nReturns:\n    The normalized array.\n\nExample:\n\n>>> x = keras.random.normal((1, 10))\n>>> keras.ops.rms_normalization(x)\narray([[0.69384296, 0.94444374, 0.16551171, 0.05749961, 1.11008865,\n        0.52475186, 1.57686807, 1.69893307, 1.27292764, 0.30819128]])",
    "std_args": [
      "x",
      "scale",
      "axis",
      "epsilon"
    ],
    "type": "function"
  },
  "rng_collection": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rngs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "roots": {
    "description": "Returns the roots of a polynomial given the coefficients ``p``.\n\nJAX implementations of :func:`numpy.roots`.\n\nArgs:\n  p: Array of polynomial coefficients having rank-1.\n  strip_zeros : bool, default=True. If True, then leading zeros in the\n    coefficients will be stripped, similar to :func:`numpy.roots`. If set to\n    False, leading zeros will not be stripped, and undefined roots will be\n    represented by NaN values in the function output. ``strip_zeros`` must be\n    set to ``False`` for the function to be compatible with :func:`jax.jit` and\n    other JAX transformations.\n\nReturns:\n  An array containing the roots of the polynomial.\n\nNote:\n  Unlike ``np.roots`` of this function, the ``jnp.roots`` returns the roots\n  in a complex array regardless of the values of the roots.\n\nSee Also:\n  - :func:`jax.numpy.poly`: Finds the polynomial coefficients of the given\n    sequence of roots.\n  - :func:`jax.numpy.polyfit`: Least squares polynomial fit to data.\n  - :func:`jax.numpy.polyval`: Evaluate a polynomial at specific values.\n\nExamples:\n  >>> coeffs = jnp.array([0, 1, 2])\n\n  The default behavior matches numpy and strips leading zeros:\n\n  >>> jnp.roots(coeffs)\n  Array([-2.+0.j], dtype=complex64)\n\n  With ``strip_zeros=False``, extra roots are set to NaN:\n\n  >>> jnp.roots(coeffs, strip_zeros=False)\n  Array([-2. +0.j, nan+nanj], dtype=complex64)",
    "std_args": [
      "p",
      "strip_zeros"
    ],
    "type": "function"
  },
  "rope": {
    "description": "Apply rotary positional encoding to the input.",
    "std_args": [
      "a",
      "dims",
      "traditional",
      "base",
      "scale",
      "offset",
      "freqs",
      "stream"
    ],
    "type": "function"
  },
  "rot90": {
    "description": "Rotate an array by 90 degrees in the plane specified by axes.\n\nThis function rotates an array counterclockwise\nby 90 degrees `k` times in the plane specified by `axes`.\nSupports arrays of two or more dimensions.\n\nArgs:\n    array: Input array to rotate.\n    k: Number of times the array is rotated by 90 degrees.\n    axes: A tuple of two integers specifying the\n        plane of rotation (defaults to `(0, 1)`).\n\nReturns:\n    Rotated array.\n\nExamples:\n\n>>> import numpy as np\n>>> from keras import ops\n>>> m = np.array([[1, 2], [3, 4]])\n>>> rotated = ops.rot90(m)\n>>> rotated\narray([[2, 4],\n       [1, 3]])\n\n>>> m = np.arange(8).reshape((2, 2, 2))\n>>> rotated = ops.rot90(m, k=1, axes=(1, 2))\n>>> rotated\narray([[[1, 3],\n        [0, 2]],\n       [[5, 7],\n        [4, 6]]])",
    "std_args": [
      "array",
      "k",
      "axes"
    ],
    "type": "function"
  },
  "round_": {
    "description": "Return a copy of a, rounded to 'decimals' places.",
    "std_args": [
      "a",
      "decimals",
      "out"
    ],
    "type": "function"
  },
  "roundtrip": {
    "description": "The class representing a Python function.",
    "std_args": [
      "arr"
    ],
    "type": "function"
  },
  "roundtrip_randsize": {
    "description": "The class representing a Python function.",
    "std_args": [
      "arr"
    ],
    "type": "function"
  },
  "roundtrip_truncated": {
    "description": "The class representing a Python function.",
    "std_args": [
      "arr"
    ],
    "type": "function"
  },
  "rout_rules": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "routine_rules": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "routsign2map": {
    "description": "name,NAME,begintitle,endtitle",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "row_stack": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rrelu": {
    "description": "rrelu(input, lower=1./8, upper=1./3, training=False, inplace=False) -> Tensor",
    "std_args": [
      "input",
      "lower",
      "upper",
      "training",
      "inplace"
    ],
    "type": "function"
  },
  "rrelu_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rshft_0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rshft_1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rshft_2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rshft_3": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rshft_all": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rsqrt": {
    "description": "Computes reciprocal of square root of x element-wise.\n\nArgs:\n    x: input tensor\n\nReturns:\n    A tensor with the same dtype as `x`.\n\nExample:\n\n>>> x = keras.ops.convert_to_tensor([1.0, 10.0, 100.0])\n>>> keras.ops.rsqrt(x)\narray([1.0, 0.31622776, 0.1], dtype=float32)",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "run": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "run_compile": {
    "description": "Do it all in one call!",
    "std_args": [],
    "type": "function"
  },
  "run_main": {
    "description": "Equivalent to running::",
    "std_args": [
      "comline_list"
    ],
    "type": "function"
  },
  "run_mypy": {
    "description": "Clears the cache and run mypy before running any of the typing tests.",
    "std_args": [],
    "type": "function"
  },
  "running_mean": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "running_var": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "runtime_executable": {
    "description": "An arbitrary object representation of this executable.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "safe_softmax_cross_entropy": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "same_line": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sample": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "saturate_cast": {
    "description": "Performs a safe saturating cast to the desired dtype.\n\nSaturating cast prevents data type overflow when casting to `dtype` with\nsmaller values range. E.g.\n`ops.cast(ops.cast([-1, 256], \"float32\"), \"uint8\")` returns `[255, 0]`,\nbut `ops.saturate_cast(ops.cast([-1, 256], \"float32\"), \"uint8\")` returns\n`[0, 255]`.\n\nArgs:\n    x: A tensor or variable.\n    dtype: The target type.\n\nReturns:\n    A safely casted tensor of the specified `dtype`.\n\nExample:\n\nImage resizing with bicubic interpolation may produce values outside\noriginal range.\n>>> image2x2 = np.array([0, 1, 254, 255], dtype=\"uint8\").reshape(1, 2, 2, 1)\n>>> image4x4 = tf.image.resize(image2x2, (4, 4), method=\"bicubic\")\n>>> print(image4x4.numpy().squeeze())\n>>> # [[-22.500004 -22.204624 -21.618908 -21.32353 ]\n>>> #  [ 52.526054  52.82143   53.407146  53.70253 ]\n>>> #  [201.29752  201.59288  202.17859  202.47395 ]\n>>> #  [276.32355  276.61893  277.20465  277.50006 ]]\n\nCasting this resized image back to `uint8` will cause overflow.\n>>> image4x4_casted = ops.cast(image4x4, \"uint8\")\n>>> print(image4x4_casted.numpy().squeeze())\n>>> # [[234 234 235 235]\n>>> #  [ 52  52  53  53]\n>>> #  [201 201 202 202]\n>>> #  [ 20  20  21  21]]\n\nSaturate casting to `uint8` will clip values to `uint8` range before\ncasting and will not cause overflow.\n>>> image4x4_saturate_casted = ops.saturate_cast(image4x4, \"uint8\")\n>>> print(image4x4_saturate_casted.numpy().squeeze())\n>>> # [[  0   0   0   0]\n>>> #  [ 52  52  53  53]\n>>> #  [201 201 202 202]\n>>> #  [255 255 255 255]]",
    "std_args": [
      "x",
      "dtype"
    ],
    "type": "function"
  },
  "save_assets": {
    "description": "",
    "std_args": [
      "self",
      "dir_path"
    ],
    "type": "function"
  },
  "save_gguf": {
    "description": "save_gguf(file: Union[file, str, pathlib.Path], arrays: dict[str, array], metadata: dict[str, Union[array, str, list[str]]])",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "save_own_variables": {
    "description": "Saves the state of the layer.\n\nYou can override this method to take full control of how the state of\nthe layer is saved upon calling `model.save()`.\n\nArgs:\n    store: Dict where the state of the model will be saved.",
    "std_args": [
      "self",
      "store"
    ],
    "type": "function"
  },
  "save_safetensors": {
    "description": "save_safetensors(file: Union[file, str, pathlib.Path], arrays: dict[str, array], metadata: Optional[dict[str, str]] = None)",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "save_weights": {
    "description": "Save the model's weights to a file. The saving method is determined by the file extension:",
    "std_args": [
      "self",
      "file"
    ],
    "type": "function"
  },
  "savez": {
    "description": "savez(file: Union[file, str, pathlib.Path], *args, **kwargs)",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "savez_compressed": {
    "description": "savez_compressed(file: Union[file, str, pathlib.Path], *args, **kwargs)",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "sc": {
    "description": "scale function used by the below tests",
    "std_args": [
      "self",
      "request"
    ],
    "type": "function"
  },
  "scalar": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scalar_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scalars": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scale": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scale_and_translate": {
    "description": "Apply a scale and translation to the images.\n\nGenerates a new image of `output_shape` by resampling from the input image\nusing the sampling method corresponding to method. For 2D images, this\noperation transforms a location in the input images, (x, y), to a location\nin the output image according to:\n\n`(x * scale[1] + translation[1], y * scale[0] + translation[0])`.\n\n(Note the inverse warp is used to generate the sample locations.) Assumes\nhalf-centered pixels, i.e the pixel at integer location row, col has\ncoordinates y, x = row + 0.5, col + 0.5, and similarly for other input image\ndimensions.\n\nIf an output location(pixel) maps to an input sample location that is\noutside the input boundaries then the value for the output location will be\nset to zero.\n\nThe `method` argument expects one of the following resize methods:\n\n- `\"linear\"`, `\"bilinear\"`, `\"trilinear\"`, `\"triangle\"`: Linear\n    interpolation. If `antialias` is True, uses a triangular filter when\n    downsampling.\n- `\"cubic\"`, `\"bicubic\"`, `\"tricubic\"`: Cubic interpolation, using the Keys\n    cubic kernel.\n- `\"lanczos3\"`: Lanczos resampling, using a kernel of radius 3.\n- `\"lanczos5\"`: Lanczos resampling, using a kernel of radius 5.\n\nArgs:\n    images: The input array.\n    output_shape: The output shape, as a sequence of integers with length\n        equal to the number of dimensions of image.\n    scale: A [K] array with the same number of dimensions as `images`,\n        containing the scale to apply in each dimension.\n    translation: A [K] array with the same number of dimensions as `images`,\n        containing the translation to apply in each dimension.\n    spatial_dims: A length K tuple specifying the spatial dimensions that\n        the passed `scale` and `translation` should be applied to.\n    method: A string specifying the resizing method to use. Available\n        methods are `\"linear\"`, `\"bilinear\"`, `\"trilinear\"`, `\"triangle\"`,\n        `\"cubic\"`, `\"bicubic\"`, `\"tricubic\"`, `\"lanczos3\"` and `\"lanczos5\"`.\n    antialias: Whether an antialiasing filter should be applied when\n        downsampling. Has no effect when upsampling. Defaults to `True`.\n\nReturns:\n    The scale and translated images.\n\nExample:\n\n>>> images = np.arange(9, dtype=\"float32\").reshape((3, 3))\n>>> scale = np.array([2.0, 2.0]).astype(\"float32\")\n>>> translation = -(scale / 2.0 - 0.5)\n>>> resized_images = keras.image.scale_and_translate(\n...     images, (5, 5), scale, translation, (0, 1), \"linear\"\n... )\n>>> resized_images\narray([[0.0 0.5 1.0 1.5 2.0]\n       [1.5 2.0 2.5 3.0 3.5]\n       [3.0 3.5 4.0 4.5 5.0]\n       [4.5 5.0 5.5 6.0 6.5]\n       [6.0 6.5 7.0 7.5 8.0]], dtype=float32)",
    "std_args": [
      "images",
      "output_shape",
      "scale",
      "translation",
      "spatial_dims",
      "method",
      "antialias"
    ],
    "type": "function"
  },
  "scale_factor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scale_grad_by_freq": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scale_init": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scale_parameter": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scaled_dot_product_attention": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "scaled_modified_bessel_k0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scaled_modified_bessel_k1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scales": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scaninputline": {
    "description": "The class representing a Python function.",
    "std_args": [
      "inputline"
    ],
    "type": "function"
  },
  "scatter_kwargs": {
    "description": "Scatter with support for kwargs dictionary.",
    "std_args": [
      "inputs",
      "kwargs",
      "target_gpus",
      "dim"
    ],
    "type": "function"
  },
  "scatter_update": {
    "description": "Update inputs via updates at scattered (sparse) indices.\n\nAt a high level, this operation does `inputs[indices] = updates`.\nAssume `inputs` is a tensor of shape `(D0, D1, ..., Dn)`, there are 2 main\nusages of `scatter_update`.\n\n1. `indices` is a 2D tensor of shape `(num_updates, n)`, where `num_updates`\n    is the number of updates to perform, and `updates` is a 1D tensor of\n    shape `(num_updates,)`. For example, if `inputs` is `zeros((4, 4, 4))`,\n    and we want to update `inputs[1, 2, 3]` and `inputs[0, 1, 3]` as 1, then\n    we can use:\n\n```python\ninputs = np.zeros((4, 4, 4))\nindices = [[1, 2, 3], [0, 1, 3]]\nupdates = np.array([1., 1.])\ninputs = keras.ops.scatter_update(inputs, indices, updates)\n```\n\n2 `indices` is a 2D tensor of shape `(num_updates, k)`, where `num_updates`\n    is the number of updates to perform, and `k` (`k < n`) is the size of\n    each index in `indices`. `updates` is a `n - k`-D tensor of shape\n    `(num_updates, inputs.shape[k:])`. For example, if\n    `inputs = np.zeros((4, 4, 4))`, and we want to update `inputs[1, 2, :]`\n    and `inputs[2, 3, :]` as `[1, 1, 1, 1]`, then `indices` would have shape\n    `(num_updates, 2)` (`k = 2`), and `updates` would have shape\n    `(num_updates, 4)` (`inputs.shape[2:] = 4`). See the code below:\n\n```python\ninputs = np.zeros((4, 4, 4))\nindices = [[1, 2], [2, 3]]\nupdates = np.array([[1., 1., 1, 1,], [1., 1., 1, 1,])\ninputs = keras.ops.scatter_update(inputs, indices, updates)\n```\n\nArgs:\n    inputs: A tensor, the tensor to be updated.\n    indices: A tensor or list/tuple of shape `(N, inputs.ndim)`, specifying\n        indices to update. `N` is the number of indices to update, must be\n        equal to the first dimension of `updates`.\n    updates: A tensor, the new values to be put to `inputs` at `indices`.\n\nReturns:\n    A tensor, has the same shape and dtype as `inputs`.",
    "std_args": [
      "inputs",
      "indices",
      "updates"
    ],
    "type": "function"
  },
  "scope": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "score_function_jacobians": {
    "description": "Score function gradient estimation.",
    "std_args": [
      "function",
      "params",
      "dist_builder",
      "rng",
      "num_samples"
    ],
    "type": "function"
  },
  "sdpa_kernel": {
    "description": "Context manager to select which backend to use for scaled dot product attention.",
    "std_args": [
      "backends",
      "set_priority"
    ],
    "type": "function"
  },
  "seed": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "seed_seq": {
    "description": "Get the seed sequence used to initialize the bit generator.",
    "std_args": [],
    "type": "attribute"
  },
  "seed_vector_bits": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "seeds": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "seek": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "off",
      "whence"
    ],
    "type": "function"
  },
  "seen_modules_repr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "segment_max": {
    "description": "Computes the max of segments in a tensor.\n\nArgs:\n    data: Input tensor.\n    segment_ids: A N-D tensor containing segment indices for each\n        element in `data`. data.shape[:len(segment_ids.shape)] should match.\n    num_segments: An integer representing the total number of\n        segments. If not specified, it is inferred from the maximum\n        value in `segment_ids`.\n    sorted: A boolean indicating whether `segment_ids` is sorted.\n        Defaults to `False`.\n\nReturns:\n    A tensor containing the max of segments, where each element\n    represents the max of the corresponding segment in `data`.\n\nExample:\n\n>>> data = keras.ops.convert_to_tensor([1, 2, 10, 20, 100, 200])\n>>> segment_ids = keras.ops.convert_to_tensor([0, 0, 1, 1, 2, 2])\n>>> num_segments = 3\n>>> keras.ops.segment_max(data, segment_ids, num_segments)\narray([2, 20, 200], dtype=int32)",
    "std_args": [
      "data",
      "segment_ids",
      "num_segments",
      "sorted"
    ],
    "type": "function"
  },
  "segment_sum": {
    "description": "Computes the sum of segments in a tensor.\n\nArgs:\n    data: Input tensor.\n    segment_ids: A N-D tensor containing segment indices for each\n        element in `data`. Num dims for segment ids should be strictly\n        smaller or equal to number of dims in data.\n    num_segments: An integer representing the total number of\n        segments. If not specified, it is inferred from the maximum\n        value in `segment_ids`.\n    sorted: A boolean indicating whether `segment_ids` is sorted.\n        Defaults to `False`.\n\nReturns:\n    A tensor containing the sum of segments, where each element\n    represents the sum of the corresponding segment in `data`.\n\nExample:\n\n>>> data = keras.ops.convert_to_tensor([1, 2, 10, 20, 100, 200])\n>>> segment_ids = keras.ops.convert_to_tensor([0, 0, 1, 1, 2, 2])\n>>> num_segments = 3\n>>> keras.ops.segment_sum(data, segment_ids,num_segments)\narray([3, 30, 300], dtype=int32)",
    "std_args": [
      "data",
      "segment_ids",
      "num_segments",
      "sorted"
    ],
    "type": "function"
  },
  "segmented_mm": {
    "description": "segmented_mm(a: array, b: array, /, segments: array, *, stream: Union[None, Stream, Device] = None) -> array",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "select": {
    "description": "Select values based on a series of conditions.\n\nJAX implementation of :func:`numpy.select`, implemented in terms\nof :func:`jax.lax.select_n`\n\nArgs:\n  condlist: sequence of array-like conditions. All entries must be mutually\n    broadcast-compatible.\n  choicelist: sequence of array-like values to choose. Must have the same length\n    as ``condlist``, and all entries must be broadcast-compatible with entries\n    of ``condlist``.\n  default: value to return when every condition is False (default: 0).\n\nReturns:\n  Array of selected values from ``choicelist`` corresponding to the first\n  ``True`` entry in ``condlist`` at each location.\n\nSee also:\n  - :func:`jax.numpy.where`: select between two values based on a single condition.\n  - :func:`jax.lax.select_n`: select between *N* values based on an index.\n\nExamples:\n  >>> condlist = [\n  ...    jnp.array([False, True, False, False]),\n  ...    jnp.array([True, False, False, False]),\n  ...    jnp.array([False, True, True, False]),\n  ... ]\n  >>> choicelist = [\n  ...    jnp.array([1, 2, 3, 4]),\n  ...    jnp.array([10, 20, 30, 40]),\n  ...    jnp.array([100, 200, 300, 400]),\n  ... ]\n  >>> jnp.select(condlist, choicelist, default=0)\n  Array([ 10,   2, 300,   0], dtype=int32)\n\n  This is logically equivalent to the following nested ``where`` statement:\n\n  >>> default = 0\n  >>> jnp.where(condlist[0],\n  ...   choicelist[0],\n  ...   jnp.where(condlist[1],\n  ...     choicelist[1],\n  ...     jnp.where(condlist[2],\n  ...       choicelist[2],\n  ...       default)))\n  Array([ 10,   2, 300,   0], dtype=int32)\n\n  However, for efficiency it is implemented in terms of :func:`jax.lax.select_n`.",
    "std_args": [
      "condlist",
      "choicelist",
      "default"
    ],
    "type": "function"
  },
  "selective_transform": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "selectpattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "self_attention": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "self_attn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "selu_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "send": {
    "description": "Send an array from the current process to the process that has rank",
    "std_args": [
      "x",
      "dst",
      "group",
      "stream"
    ],
    "type": "function"
  },
  "separable_conv": {
    "description": "General N-D separable convolution.\n\nThis ops supports 1D and 2D separable convolution. `separable_conv` is\na depthwise conv followed by a pointwise conv.\n\nArgs:\n    inputs: Tensor of rank N+2. `inputs` has shape\n        `(batch_size,) + inputs_spatial_shape + (num_channels,)` if\n        `data_format=\"channels_last\"`, or\n        `(batch_size, num_channels) + inputs_spatial_shape` if\n        `data_format=\"channels_first\"`.\n    depthwise_kernel: Tensor of rank N+2. `depthwise_kernel` has shape\n        [kernel_spatial_shape, num_input_channels, num_channels_multiplier],\n        `num_input_channels` should match the number of channels in\n        `inputs`.\n    pointwise_kernel: Tensor of rank N+2. `pointwise_kernel` has shape\n        `(*ones_like(kernel_spatial_shape),\n        num_input_channels * num_channels_multiplier, num_output_channels)`.\n    strides: int or int tuple/list of `len(inputs_spatial_shape)`,\n        specifying the strides of the convolution along each spatial\n        dimension. If `strides` is int, then every spatial dimension shares\n        the same `strides`.\n    padding: string, either `\"valid\"` or `\"same\"`. `\"valid\"` means no\n        padding is applied, and `\"same\"` results in padding evenly to the\n        left/right or up/down of the input such that output has the\n        same height/width dimension as the input when `strides=1`.\n    data_format: A string, either `\"channels_last\"` or `\"channels_first\"`.\n        `data_format` determines the ordering of the dimensions in the\n        inputs. If `data_format=\"channels_last\"`, `inputs` is of shape\n        `(batch_size, ..., channels)` while if\n        `data_format=\"channels_first\"`, `inputs` is of shape\n        `(batch_size, channels, ...)`.\n    dilation_rate: int or int tuple/list of `len(inputs_spatial_shape)`,\n        specifying the dilation rate to use for dilated convolution. If\n        `dilation_rate` is int, then every spatial dimension shares\n        the same `dilation_rate`.\n\nReturns:\n    A tensor of rank N+2, the result of the depthwise conv operation.",
    "std_args": [
      "inputs",
      "depthwise_kernel",
      "pointwise_kernel",
      "strides",
      "padding",
      "data_format",
      "dilation_rate"
    ],
    "type": "function"
  },
  "sepdict": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "seq_len_kv": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "seq_len_q": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "seq_lengths": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sequence": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "serialize": {
    "description": "",
    "std_args": [
      "activation"
    ],
    "type": "function"
  },
  "set": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "set_attr_priority": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "name",
      "value"
    ],
    "type": "function"
  },
  "set_attributes": {
    "description": "Sets the attributes of nested Modules including the current Module.",
    "std_args": [
      "self",
      "filters",
      "raise_if_not_found",
      "attributes"
    ],
    "type": "function"
  },
  "set_bit_generator": {
    "description": "The class representing a Python function.",
    "std_args": [
      "bitgen"
    ],
    "type": "function"
  },
  "set_cache_limit": {
    "description": "set_cache_limit(limit: int) -> int",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "set_default_device": {
    "description": "set_default_device(device: mlx.core.Device) -> None",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "set_default_printstyle": {
    "description": "Set the default format for the string representation of polynomials.",
    "std_args": [
      "style"
    ],
    "type": "function"
  },
  "set_default_stream": {
    "description": "set_default_stream(stream: mlx.core.Stream) -> None",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "set_dtype": {
    "description": "Set the dtype of the module's parameters.",
    "std_args": [
      "self",
      "dtype",
      "predicate"
    ],
    "type": "function"
  },
  "set_extra_state": {
    "description": "Set extra state contained in the loaded `state_dict`.",
    "std_args": [
      "self",
      "state"
    ],
    "type": "function"
  },
  "set_fill_value": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "value"
    ],
    "type": "function"
  },
  "set_key": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "set_memory_limit": {
    "description": "set_memory_limit(limit: int) -> int",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "set_metadata": {
    "description": "Set metadata for the Variable.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "set_mode": {
    "description": "Class method used by ``nnx.set_mode``.",
    "std_args": [
      "self",
      "use_running_average",
      "kwargs"
    ],
    "type": "function"
  },
  "set_mode_info": {
    "description": "Provides information about the ``set_mode`` arguments for a module and all",
    "std_args": [
      "node",
      "only"
    ],
    "type": "function"
  },
  "set_printoptions": {
    "description": "Alias of :func:`numpy.set_printoptions`.\n\nJAX arrays are printed via NumPy, so NumPy's `printoptions`\nconfigurations will apply to printed JAX arrays.\n\nSee the :func:`numpy.set_printoptions` documentation for details\non the available options and their meanings.",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "set_raw_value": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "value",
      "_unsafe_bypass_check"
    ],
    "type": "function"
  },
  "set_state": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "set_value": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "value",
      "index"
    ],
    "type": "function"
  },
  "set_value_hooks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "set_variable_p": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "set_vocabulary": {
    "description": "Sets vocabulary (and optionally document frequency) for this layer.\n\nThis method sets the vocabulary and IDF weights for this layer directly,\ninstead of analyzing a dataset through `adapt()`. It should be used\nwhenever the vocab (and optionally document frequency) information is\nalready known. If vocabulary data is already present in the layer, this\nmethod will replace it.\n\nArgs:\n    vocabulary: Either an array or a string path to a text file.\n        If passing an array, can pass a tuple, list, 1D NumPy array,\n        or 1D tensor containing the vocabulary terms.\n        If passing a file path, the file should contain one line\n        per term in the vocabulary.\n    idf_weights: A tuple, list, 1D NumPy array, or 1D tensor of inverse\n        document frequency weights with equal length to vocabulary.\n        Must be set if `output_mode` is `\"tf_idf\"`.\n        Should not be set otherwise.",
    "std_args": [
      "self",
      "vocabulary",
      "idf_weights"
    ],
    "type": "function"
  },
  "set_weights": {
    "description": "Sets the values of `layer.weights` from a list of NumPy arrays.",
    "std_args": [
      "self",
      "weights"
    ],
    "type": "function"
  },
  "set_wired_limit": {
    "description": "set_wired_limit(limit: int) -> int",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "setattrspec": {
    "description": "The class representing a Python function.",
    "std_args": [
      "decl",
      "attr",
      "force"
    ],
    "type": "function"
  },
  "setcharselector": {
    "description": "The class representing a Python function.",
    "std_args": [
      "decl",
      "sel",
      "force"
    ],
    "type": "function"
  },
  "setdefault": {
    "description": "Set the default for a key in the Parameterdict.",
    "std_args": [
      "self",
      "key",
      "default"
    ],
    "type": "function"
  },
  "setdiff1d": {
    "description": "Compute the set difference of two 1D arrays.\n\nJAX implementation of :func:`numpy.setdiff1d`.\n\nBecause the size of the output of ``setdiff1d`` is data-dependent, the function\nis not typically compatible with :func:`~jax.jit` and other JAX transformations.\nThe JAX version adds the optional ``size`` argument which must be specified statically\nfor ``jnp.setdiff1d`` to be used in such contexts.\n\nArgs:\n  ar1: first array of elements to be differenced.\n  ar2: second array of elements to be differenced.\n  assume_unique: if True, assume the input arrays contain unique values. This allows\n    a more efficient implementation, but if ``assume_unique`` is True and the input\n    arrays contain duplicates, the behavior is undefined. default: False.\n  size: if specified, return only the first ``size`` sorted elements. If there are fewer\n    elements than ``size`` indicates, the return value will be padded with ``fill_value``.\n  fill_value: when ``size`` is specified and there are fewer than the indicated number of\n    elements, fill the remaining entries ``fill_value``. Defaults to the minimum value.\n\nReturns:\n  an array containing the set difference of elements in the input array: i.e. the elements\n  in ``ar1`` that are not contained in ``ar2``.\n\nSee also:\n  - :func:`jax.numpy.intersect1d`: the set intersection of two 1D arrays.\n  - :func:`jax.numpy.setxor1d`: the set XOR of two 1D arrays.\n  - :func:`jax.numpy.union1d`: the set union of two 1D arrays.\n\nExamples:\n  Computing the set difference of two arrays:\n\n  >>> ar1 = jnp.array([1, 2, 3, 4])\n  >>> ar2 = jnp.array([3, 4, 5, 6])\n  >>> jnp.setdiff1d(ar1, ar2)\n  Array([1, 2], dtype=int32)\n\n  Because the output shape is dynamic, this will fail under :func:`~jax.jit` and other\n  transformations:\n\n  >>> jax.jit(jnp.setdiff1d)(ar1, ar2)  # doctest: +IGNORE_EXCEPTION_DETAIL\n  Traceback (most recent call last):\n     ...\n  ConcretizationTypeError: Abstract tracer value encountered where concrete value is expected: traced array with shape int32[4].\n  The error occurred while tracing the function setdiff1d at /Users/vanderplas/github/jax-ml/jax/jax/_src/numpy/setops.py:64 for jit. This concrete value was not available in Python because it depends on the value of the argument ar1.\n\n  In order to ensure statically-known output shapes, you can pass a static ``size``\n  argument:\n\n  >>> jit_setdiff1d = jax.jit(jnp.setdiff1d, static_argnames=['size'])\n  >>> jit_setdiff1d(ar1, ar2, size=2)\n  Array([1, 2], dtype=int32)\n\n  If ``size`` is too small, the difference is truncated:\n\n  >>> jit_setdiff1d(ar1, ar2, size=1)\n  Array([1], dtype=int32)\n\n  If ``size`` is too large, then the output is padded with ``fill_value``:\n\n  >>> jit_setdiff1d(ar1, ar2, size=4, fill_value=0)\n  Array([1, 2, 0, 0], dtype=int32)",
    "std_args": [
      "ar1",
      "ar2",
      "assume_unique",
      "size",
      "fill_value"
    ],
    "type": "function"
  },
  "setfield": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "val",
      "dtype",
      "offset"
    ],
    "type": "function"
  },
  "setkindselector": {
    "description": "The class representing a Python function.",
    "std_args": [
      "decl",
      "sel",
      "force"
    ],
    "type": "function"
  },
  "setmesstext": {
    "description": "The class representing a Python function.",
    "std_args": [
      "block"
    ],
    "type": "function"
  },
  "setup_class": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls"
    ],
    "type": "function"
  },
  "setup_method": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "setup_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "request"
    ],
    "type": "function"
  },
  "setxor1d": {
    "description": "Compute the set-wise xor of elements in two arrays.\n\nJAX implementation of :func:`numpy.setxor1d`.\n\nBecause the size of the output of ``setxor1d`` is data-dependent, the function is not\ncompatible with JIT or other JAX transformations.\n\nArgs:\n  ar1: first array of values to intersect.\n  ar2: second array of values to intersect.\n  assume_unique: if True, assume the input arrays contain unique values. This allows\n    a more efficient implementation, but if ``assume_unique`` is True and the input\n    arrays contain duplicates, the behavior is undefined. default: False.\n  size: if specified, return only the first ``size`` sorted elements. If there are fewer\n    elements than ``size`` indicates, the return value will be padded with ``fill_value``,\n    and returned indices will be padded with an out-of-bound index.\n  fill_value: when ``size`` is specified and there are fewer than the indicated number of\n    elements, fill the remaining entries ``fill_value``. Defaults to the smallest value\n    in the xor result.\n\nReturns:\n  An array of values that are found in exactly one of the input arrays.\n\nSee also:\n  - :func:`jax.numpy.intersect1d`: the set intersection of two 1D arrays.\n  - :func:`jax.numpy.union1d`: the set union of two 1D arrays.\n  - :func:`jax.numpy.setdiff1d`: the set difference of two 1D arrays.\n\nExamples:\n  >>> ar1 = jnp.array([1, 2, 3, 4])\n  >>> ar2 = jnp.array([3, 4, 5, 6])\n  >>> jnp.setxor1d(ar1, ar2)\n  Array([1, 2, 5, 6], dtype=int32)",
    "std_args": [
      "ar1",
      "ar2",
      "assume_unique",
      "size",
      "fill_value"
    ],
    "type": "function"
  },
  "sgdr_schedule": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "shard_inplace": {
    "description": "Shard a module in-place by updating its parameter dictionary with the",
    "std_args": [
      "module",
      "sharding",
      "segments",
      "group"
    ],
    "type": "function"
  },
  "shard_linear": {
    "description": "Create a new linear layer that has its parameters sharded and also",
    "std_args": [
      "module",
      "sharding",
      "segments",
      "group"
    ],
    "type": "function"
  },
  "shard_map": {
    "description": "Lifted version of",
    "std_args": [
      "f",
      "mesh",
      "in_specs",
      "out_specs",
      "axis_names",
      "check_vma"
    ],
    "type": "function"
  },
  "shardings": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "share_memory": {
    "description": "See :meth:`torch.Tensor.share_memory_`.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "share_memory_": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "sharedmask": {
    "description": "Share status of the mask (read-only).",
    "std_args": [],
    "type": "attribute"
  },
  "shifted_chebyshev_polynomial_t": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "shifted_chebyshev_polynomial_u": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "shifted_chebyshev_polynomial_v": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "shifted_chebyshev_polynomial_w": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "short": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "attribute"
  },
  "short_version": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "shortlist_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "show": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "showblocklist": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "shrink_mask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "a"
    ],
    "type": "function"
  },
  "shuffle": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "sigmoid_binary_cross_entropy": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sigmoid_focal_loss": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sign2map": {
    "description": "varname,ctype,atype",
    "std_args": [
      "a",
      "var"
    ],
    "type": "function"
  },
  "signature": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "signedinteger": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "attribute"
  },
  "sinc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "single": {
    "description": "A JAX scalar constructor of type float32.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "attribute"
  },
  "skip": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "skip_all_reduce_unused_params": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "skip_init": {
    "description": "Given a module class object and args / kwargs, instantiate the module without initializing parameters / buffers.",
    "std_args": [
      "module_cls",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "skip_large_updates": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "skip_not_finite": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "skip_rng": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "skipblocksuntil": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "skipemptyends": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "skipfuncs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "skipfunctions": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "slice_update": {
    "description": "Update an input by slicing in a tensor of updated values.\n\nAt a high level, this operation does\n`inputs[start_indices: start_indices + updates.shape] = updates`.\nAssume inputs is a tensor of shape `(D0, D1, ..., Dn)`,\n`start_indices` must be a list/tuple of n integers, specifying the starting\nindices. `updates` must have the same rank as `inputs`, and the size of each\ndim must not exceed `Di - start_indices[i]`. For example, if we have 2D\ninputs `inputs = np.zeros((5, 5))`, and we want to update the intersection\nof last 2 rows and last 2 columns as 1, i.e.,\n`inputs[3:, 3:] = np.ones((2, 2))`, then we can use the code below:\n\n```python\ninputs = np.zeros((5, 5))\nstart_indices = [3, 3]\nupdates = np.ones((2, 2))\ninputs = keras.ops.slice_update(inputs, start_indices, updates)\n```\n\nArgs:\n    inputs: A tensor, the tensor to be updated.\n    start_indices: A list/tuple of shape `(inputs.ndim,)`, specifying\n        the starting indices for updating.\n    updates: A tensor, the new values to be put to `inputs` at `indices`.\n        `updates` must have the same rank as `inputs`.\n\nReturns:\n    A tensor, has the same shape and dtype as `inputs`.",
    "std_args": [
      "inputs",
      "start_indices",
      "updates"
    ],
    "type": "function"
  },
  "slist": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "smaller_types": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "smooth_l1_loss": {
    "description": "Compute the Smooth L1 loss.",
    "std_args": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction",
      "beta"
    ],
    "type": "function"
  },
  "smooth_labels": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "snapshot": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "soft_margin_loss": {
    "description": "Compute the soft margin loss.",
    "std_args": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "soft_shrink": {
    "description": "Soft Shrink activation function.\n\nIt is defined as:\n\n`soft_shrink(x) = x - threshold` if `x > threshold`,\n`soft_shrink(x) = x + threshold` if `x < -threshold`,\n`soft_shrink(x) = 0` otherwise.\n\nArgs:\n    x: Input tensor.\n    threshold: Threshold value. Defaults to 0.5.",
    "std_args": [
      "x",
      "threshold"
    ],
    "type": "function"
  },
  "soften_mask": {
    "description": "Forces the mask to soft",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "softmax_cross_entropy": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "softmax_cross_entropy_with_integer_labels": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "solve_ex": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "solve_triangular": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "sometrue": {
    "description": "The class representing a Python function.",
    "std_args": [
      "target",
      "axis",
      "dtype"
    ],
    "type": "function"
  },
  "sort_variable_types": {
    "description": "The class representing a Python function.",
    "std_args": [
      "types"
    ],
    "type": "function"
  },
  "sorted_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sortvarnames": {
    "description": "The class representing a Python function.",
    "std_args": [
      "vars"
    ],
    "type": "function"
  },
  "sourcecodeform": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sources": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sow": {
    "description": "``sow()`` can be used to collect intermediate values without",
    "std_args": [
      "self",
      "variable_type",
      "name",
      "value",
      "reduce_fn",
      "init_fn"
    ],
    "type": "function"
  },
  "spacing": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sparse": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "sparse_": {
    "description": "Fill the 2D input `Tensor` as a sparse matrix.",
    "std_args": [
      "tensor",
      "sparsity",
      "std",
      "generator"
    ],
    "type": "function"
  },
  "sparse_categorical_crossentropy": {
    "description": "Computes sparse categorical cross-entropy loss.\n\nThe sparse categorical cross-entropy loss is similar to categorical\ncross-entropy, but it is used when the target tensor contains integer\nclass labels instead of one-hot encoded vectors. It measures the\ndissimilarity between the target and output probabilities or logits.\n\nArgs:\n    target: The target tensor representing the true class labels as\n        integers. Its shape should match the shape of the `output`\n        tensor except for the last dimension.\n    output: The output tensor representing the predicted probabilities\n        or logits.\n        Its shape should match the shape of the `target` tensor except\n        for the last dimension.\n    from_logits: (optional) Whether `output` is a tensor of logits\n        or probabilities.\n        Set it to `True` if `output` represents logits; otherwise,\n        set it to `False` if `output` represents probabilities.\n        Defaults to `False`.\n    axis: (optional) The axis along which the sparse categorical\n        cross-entropy is computed.\n        Defaults to `-1`, which corresponds to the last dimension\n        of the tensors.\n\nReturns:\n    Integer tensor: The computed sparse categorical cross-entropy\n    loss between `target` and `output`.\n\nExample:\n\n>>> target = keras.ops.convert_to_tensor([0, 1, 2], dtype=int32)\n>>> output = keras.ops.convert_to_tensor(\n... [[0.9, 0.05, 0.05],\n...  [0.1, 0.8, 0.1],\n...  [0.2, 0.3, 0.5]])\n>>> sparse_categorical_crossentropy(target, output)\narray([0.10536056 0.22314355 0.6931472 ], shape=(3,), dtype=float32)",
    "std_args": [
      "target",
      "output",
      "from_logits",
      "axis"
    ],
    "type": "function"
  },
  "sparse_plus": {
    "description": "SparsePlus activation function.\n\nSparsePlus is defined as:\n\n`sparse_plus(x) = 0` for `x <= -1`.\n`sparse_plus(x) = (1/4) * (x + 1)^2` for `-1 < x < 1`.\n`sparse_plus(x) = x` for `x >= 1`.\n\nArgs:\n    x: Input tensor.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "sparse_sigmoid": {
    "description": "Sparse sigmoid activation function.\n\nIt is defined as\n\n`f(x) = 0` for `x <= -1`,\n`f(x) = 0.5 * (x + 1)` for `-1 < x < 1`,\n`f(x) = 1` for `x >= 1`.\n\nArgs:\n    x: Input tensor.\n\nReference:\n\n- [M. Blondel, A. F. T. Martins, V. Niculae, 2019](https://arxiv.org/pdf/1901.02324)",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "sparsity": {
    "description": "Computes the percentage of blocks that are sparse (i.e. not computed)",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "spawn": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "n_children"
    ],
    "type": "function"
  },
  "spawn_key": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "spectral_norm": {
    "description": "Apply spectral normalization to a parameter in the given module.",
    "std_args": [
      "module",
      "name",
      "n_power_iterations",
      "eps",
      "dim"
    ],
    "type": "function"
  },
  "spherical_bessel_j0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "split_by_unquoted": {
    "description": "Splits the line into (line[:i], line[i:]),",
    "std_args": [
      "line",
      "characters"
    ],
    "type": "function"
  },
  "split_context": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ctxtag"
    ],
    "type": "function"
  },
  "split_inputs": {
    "description": "Takes in a function that contains graph nodes in the inputs and outputs, and",
    "std_args": [
      "f",
      "ctxtag"
    ],
    "type": "function"
  },
  "split_key_like": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "split_rngs": {
    "description": "Splits the (nested) Rng states of the given node.",
    "std_args": [
      "node",
      "splits",
      "only",
      "squeeze"
    ],
    "type": "function"
  },
  "split_state": {
    "description": "Split a :class:`State` into one or more :class:`State`'s. The",
    "std_args": [
      "state",
      "first",
      "filters"
    ],
    "type": "function"
  },
  "squared_error": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "squareplus": {
    "description": "Squareplus activation function.\n\nThe Squareplus activation function is defined as:\n\n`f(x) = (x + sqrt(x^2 + b)) / 2`\n\nWhere `b` is a smoothness parameter.\n\nArgs:\n    x: Input tensor.\n    b: Smoothness parameter. Defaults to 4.\n\nReference:\n\n- [Ramachandran et al., 2021](https://arxiv.org/abs/2112.11687)",
    "std_args": [
      "x",
      "b"
    ],
    "type": "function"
  },
  "src_device_obj": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "stack_arrays": {
    "description": "Superposes arrays fields by fields",
    "std_args": [
      "arrays",
      "defaults",
      "usemask",
      "asrecarray",
      "autoconvert"
    ],
    "type": "function"
  },
  "stacked": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "standard_cauchy": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "standard_deviation": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "standard_error_of_mean": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "standard_exponential": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "standard_gamma": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "standard_normal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "standard_t": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "start": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "start_capture": {
    "description": "Start a Metal capture.",
    "std_args": [
      "path"
    ],
    "type": "function"
  },
  "start_dim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "state": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "state_axes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "stateless_call": {
    "description": "Call the layer without any side effects.\n\nArgs:\n    trainable_variables: List of trainable variables of the model.\n    non_trainable_variables: List of non-trainable variables of the\n        model.\n    *args: Positional arguments to be passed to `call()`.\n    return_losses: If `True`, `stateless_call()` will return the list of\n        losses created during `call()` as part of its return values.\n    **kwargs: Keyword arguments to be passed to `call()`.\n\nReturns:\n    A tuple. By default, returns `(outputs, non_trainable_variables)`.\n        If `return_losses = True`, then returns\n        `(outputs, non_trainable_variables, losses)`.\n\nNote: `non_trainable_variables` include not only non-trainable weights\nsuch as `BatchNormalization` statistics, but also RNG seed state\n(if there are any random operations part of the layer, such as dropout),\nand `Metric` state (if there are any metrics attached to the layer).\nThese are all elements of state of the layer.\n\nExample:\n\n```python\nmodel = ...\ndata = ...\ntrainable_variables = model.trainable_variables\nnon_trainable_variables = model.non_trainable_variables\n# Call the model with zero side effects\noutputs, non_trainable_variables = model.stateless_call(\n    trainable_variables,\n    non_trainable_variables,\n    data,\n)\n# Attach the updated state to the model\n# (until you do this, the model is still in its pre-call state).\nfor ref_var, value in zip(\n    model.non_trainable_variables, non_trainable_variables\n):\n    ref_var.assign(value)\n```",
    "std_args": [
      "self",
      "trainable_variables",
      "non_trainable_variables",
      "args",
      "return_losses",
      "kwargs"
    ],
    "type": "function"
  },
  "states": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "static": {
    "description": "Annotates a an attribute as static.",
    "std_args": [
      "value",
      "kwargs"
    ],
    "type": "function"
  },
  "static_argnums": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "static_cache": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "static_graph": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "stats": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "stdfuncs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "step": {
    "description": "Performs a single optimization step.",
    "std_args": [],
    "type": "attribute"
  },
  "step_decay": {
    "description": "Make a step decay scheduler.",
    "std_args": [
      "init",
      "decay_rate",
      "step_size"
    ],
    "type": "function"
  },
  "stnd": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "stop_capture": {
    "description": "Stop a Metal capture.",
    "std_args": [],
    "type": "function"
  },
  "stop_gradient": {
    "description": "Stops gradient computation.\n\nArgs:\n    variable: A tensor variable for which the gradient\n        computation is to be disabled.\n\nReturns:\n    The variable with gradient computation disabled.\n\nExamples:\n\n>>> var = keras.backend.convert_to_tensor(\n...     [1., 2., 3.],\n...     dtype=\"float32\"\n... )\n>>> var = keras.ops.stop_gradient(var)",
    "std_args": [
      "variable"
    ],
    "type": "function"
  },
  "str": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "str_": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "str_short": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "short_dtypes",
      "_"
    ],
    "type": "function"
  },
  "stream": {
    "description": "stream(s: mlx.core.Stream | mlx.core.Device) -> mlx.core.StreamContext",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "strictf77": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "stride": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "strides": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "strip_func": {
    "description": "`re.sub` helper function for stripping module names.",
    "std_args": [
      "match"
    ],
    "type": "function"
  },
  "stripcomma": {
    "description": "The class representing a Python function.",
    "std_args": [
      "s"
    ],
    "type": "function"
  },
  "strptime": {
    "description": "This function is available in the datetime module only from Python >=",
    "std_args": [
      "s",
      "fmt"
    ],
    "type": "function"
  },
  "structured_to_unstructured": {
    "description": "Converts an n-D structured array into an (n+1)-D unstructured array.",
    "std_args": [
      "arr",
      "dtype",
      "copy",
      "casting"
    ],
    "type": "function"
  },
  "subarray": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "subdtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "subroutinepattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "substitute": {
    "description": "Recursively substitute symbols with values in symbols map.",
    "std_args": [
      "self",
      "symbols_map"
    ],
    "type": "function"
  },
  "suffix": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sum_gradients": {
    "description": "The class representing a Python function.",
    "std_args": [
      "group"
    ],
    "type": "function"
  },
  "sum_scatter": {
    "description": "Sum ``x`` across all processes in the group and shard the result along the first axis across ranks.",
    "std_args": [
      "x",
      "group",
      "stream"
    ],
    "type": "function"
  },
  "supports_color": {
    "description": "Returns True if the running system's terminal supports color, and False otherwise.",
    "std_args": [],
    "type": "function"
  },
  "swap": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "swapaxes": {
    "description": "Swap two axes of an array.\n\nRefer to :func:`jax.numpy.swapaxes` for full documentation.",
    "std_args": [
      "self",
      "axis1",
      "axis2"
    ],
    "type": "function"
  },
  "switch": {
    "description": "The class representing a Python function.",
    "std_args": [
      "index",
      "branches",
      "operands"
    ],
    "type": "function"
  },
  "switchdir": {
    "description": "The class representing a Python function.",
    "std_args": [
      "path"
    ],
    "type": "function"
  },
  "symbolic_call": {
    "description": "",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "symbolic_zeros": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "symbols": {
    "description": "Return a set of symbols contained in self.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "tabchar": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tabulate": {
    "description": "Creates a summary of the graph object represented as a table.",
    "std_args": [
      "obj",
      "input_args",
      "depth",
      "method",
      "row_filter",
      "table_kwargs",
      "column_kwargs",
      "console_kwargs",
      "compute_flops",
      "compute_vjp_flops",
      "input_kwargs"
    ],
    "type": "function"
  },
  "tag": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tags": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tail": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tanh_shrink": {
    "description": "Tanh shrink activation function.\n\nIt is defined as:\n\n`f(x) = x - tanh(x)`.\n\nArgs:\n    x: Input tensor.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "teardown_method": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "tensorinv": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "tensorsolve": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "test": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "test_0D_3D": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_0D_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_0_ndim_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_0_size": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_0_size_k": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_0d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_0d_0d_condition": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_0d_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "cls"
    ],
    "type": "function"
  },
  "test_0d_comparison": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_0d_unicode": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_100": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_1D": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_1D_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_1D_arrays": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_1D_rowvar": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_1D_variance": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_1_d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_1d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_1d_only": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_1d_shape_consistency": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_1d_with_missing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_1d_without_missing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_2D": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_2D_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_2D_array2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_2D_arrays": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_2d_array_inout": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype"
    ],
    "type": "function"
  },
  "test_2d_array_input": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype"
    ],
    "type": "function"
  },
  "test_2d_repeated_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_2d_waxis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_2d_with_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_2d_with_missing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_2d_without_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_2d_without_missing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_3D_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_3d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_3d_kwargs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_3d_shaped_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_3d_swap_axis0": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_3d_swap_axis1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_3d_swap_axis2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_4d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_BagObj": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_CachedHTTPFile": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tmp_path"
    ],
    "type": "function"
  },
  "test_DataSourceOpen": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tmp_path"
    ],
    "type": "function"
  },
  "test_Fraction": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_InvalidFile": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tmp_path"
    ],
    "type": "function"
  },
  "test_InvalidHTTP": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tmp_path"
    ],
    "type": "function"
  },
  "test_InvalidHTTPCacheURLError": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tmp_path"
    ],
    "type": "function"
  },
  "test_NPY_NO_EXPORT": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_RemoveHTTPFile": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tmp_path"
    ],
    "type": "function"
  },
  "test_TakeTransposeInnerOuter": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_UPLO": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_UnboundMethod_ticket_1156": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ValidBz2File": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tmp_path"
    ],
    "type": "function"
  },
  "test_ValidFile": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tmp_path"
    ],
    "type": "function"
  },
  "test_ValidGzipFile": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tmp_path"
    ],
    "type": "function"
  },
  "test_ValidHTTP": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tmp_path"
    ],
    "type": "function"
  },
  "test_VonMises_range": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test___module___attribute": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test___qualname___and___module___attribute": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test__copy": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test__cseries_to_zseries": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test__nan_mask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "arr",
      "expected"
    ],
    "type": "function"
  },
  "test__replace_nan": {
    "description": "Test that _replace_nan returns the original array if there are no",
    "std_args": [],
    "type": "function"
  },
  "test__zseries_to_cseries": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_abstract_interface": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_accepts_longdouble": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_accepts_npcomplexfloating": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_accepts_npfloating": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_access_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tmp_path"
    ],
    "type": "function"
  },
  "test_add": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "rhs"
    ],
    "type": "function"
  },
  "test_add_object": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_addfield": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_addsumprod": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_advance": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_advance_symmetry": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_advange_large": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_all": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "name"
    ],
    "type": "function"
  },
  "test_all_1d_norm_preserving": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_all_f77": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "name"
    ],
    "type": "function"
  },
  "test_all_f90": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "name"
    ],
    "type": "function"
  },
  "test_all_modules_are_expected": {
    "description": "Test that we don't add anything that looks like a new public module by",
    "std_args": [],
    "type": "function"
  },
  "test_all_modules_are_expected_2": {
    "description": "Method checking all objects. The pkgutil-based method in",
    "std_args": [],
    "type": "function"
  },
  "test_all_outliers": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_all_zero": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_allany": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_allany_oddities": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_allany_onmatrices": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_allclose": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_allclose_timedelta": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_allequal": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_allnans": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "axis",
      "dtype",
      "array"
    ],
    "type": "function"
  },
  "test_allzero": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "ndim"
    ],
    "type": "function"
  },
  "test_alpha_beta_rc": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_ambigous_fill": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_anom": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_anom_shape": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_any_and_all_result_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dtype"
    ],
    "type": "function"
  },
  "test_api": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_api_importable": {
    "description": "Check that all submodules listed higher up in this file can be imported",
    "std_args": [],
    "type": "function"
  },
  "test_append": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_append_double": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_append_fields_dtype_list": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_append_masked_array": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_append_masked_array_along_axis": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_append_on_flex": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_append_on_nested": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_append_single": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_append_to_objects": {
    "description": "Test append_fields when the base array contains objects",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_apply_along_axis_matrix": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_approximation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_argequivalent": {
    "description": "Test it translates from arg<func> to <func>",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_argmax_argmin": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_args": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_argsort": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_argsort_matches_sort": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_argument_validation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_arguments": {
    "description": "Test that arguments are coerced from arrays",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_arithmetic_with_masked_singleton": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_arithmetic_with_masked_singleton_on_1d_singleton": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_arr_weights_mismatch": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_array_almost_equal_matrix": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_array_api_entry_point": {
    "description": "Entry point for Array API implementation can be found with importlib and",
    "std_args": [],
    "type": "function"
  },
  "test_array_astype": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_array_equal_error_message_matrix": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_array_from_matrix_list": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_array_inout": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype"
    ],
    "type": "function"
  },
  "test_array_input": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype"
    ],
    "type": "function"
  },
  "test_array_input_varia": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_array_like": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_array_like_add": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_array_memory_sharing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_array_no_inheritance": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_array_object": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_array_order_preserve": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_array_output": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_array_return": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_array_size": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dimspec"
    ],
    "type": "function"
  },
  "test_array_to_list": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_array_vs_array_not_equal": {
    "description": "Test comparing an array with a scalar when not all values equal.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_array_vs_array_strict": {
    "description": "Test comparing two arrays with strict option.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_array_vs_float_array_strict": {
    "description": "Test comparing two arrays with strict option.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_array_vs_scalar": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_array_vs_scalar_is_equal": {
    "description": "Test comparing an array with a scalar when all values are equal.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_array_vs_scalar_strict": {
    "description": "Test comparing an array with a scalar with strict option.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_arraymethod": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_arraymethod_0d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_as_index": {
    "description": "Test results if `as_index=True`.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_as_numer_denom": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_as_series": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_as_strided": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_asarray": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_asarray_default_order": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_asarray_enforce_order": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_asmatrix": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_assert_raises_regex_context_manager": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_asserts": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_assign_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_assigning_docstring": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_assignment_by_condition": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_assignment_by_condition_2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_asterisk1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_asterisk2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_astype_basic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dt1",
      "dt2"
    ],
    "type": "function"
  },
  "test_astype_mask_ordering": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_asym": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_atleast_2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_attributepropagation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_attributes_readonly": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_auto_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_auto_dtype_largeint": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_auto_dtype_uniform": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_autoconversion": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_autonames_and_usecols": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_autostrip": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_average_class_without_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_average_matrix": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_aweights": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_axes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "op"
    ],
    "type": "function"
  },
  "test_axes_keyword": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_axis_argument_errors": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_axis_count": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "kwargs"
    ],
    "type": "function"
  },
  "test_axis_default": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_axis_insertion": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "cls"
    ],
    "type": "function"
  },
  "test_axis_insertion_ma": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_axis_keyword": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_axis_methods_nomask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_axis_out_of_range": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_axis_tuple": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_backwards_compatibility": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_bad_complex": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dtype",
      "field"
    ],
    "type": "function"
  },
  "test_bad_conditioned_fit": {
    "description": "The class representing a Python function.",
    "std_args": [
      "Poly"
    ],
    "type": "function"
  },
  "test_bad_count": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_bad_dtype_not_structured": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_bad_encoding": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_bad_fname": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_bad_formatstr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_bad_header": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_bad_input": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_bad_length": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "x_len",
      "y_len"
    ],
    "type": "function"
  },
  "test_bad_line": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_bad_magic_args": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_bad_ndmin": {
    "description": "The class representing a Python function.",
    "std_args": [
      "badval"
    ],
    "type": "function"
  },
  "test_bad_newline_in_iterator": {
    "description": "The class representing a Python function.",
    "std_args": [
      "data"
    ],
    "type": "function"
  },
  "test_bad_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_bad_usecols": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_badargs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_bartlett": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype",
      "M"
    ],
    "type": "function"
  },
  "test_basic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_basic0d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_basic1d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_basic2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_basic2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_basic_arithmetic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_basic_function_with_dynamic_programming_optimization": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_basic_function_with_three_arguments": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_basic_function_with_two_arguments": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_basic_keepdims": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "x",
      "axis",
      "expected_avg",
      "weights",
      "expected_wavg",
      "expected_wsum"
    ],
    "type": "function"
  },
  "test_basic_lr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_basic_nonsvd": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "is_complex"
    ],
    "type": "function"
  },
  "test_basic_property": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "shape",
      "dtype",
      "upper"
    ],
    "type": "function"
  },
  "test_basic_ud": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_basic_ufuncs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_basic_ufuncs_masked": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_basicattributes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_basis": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_basis_func": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_benchmark": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_beta": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_beta_expected_zero_frequency": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_beta_ridiculously_small_parameters": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_beta_small_parameters": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_beta_very_small_parameters": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_big_arrays": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_big_indices": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_bin_array_dims": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_bin_edge_cases": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_binary_decode": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_binary_decode_autodtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_binary_load": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_bindc_add_arr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_bindc_function": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_bindc_kinds": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_binomial": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_binops_d2D": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_binops_fails": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "f"
    ],
    "type": "function"
  },
  "test_binparameter_combination": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_bins_errors": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_blackman": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype",
      "M"
    ],
    "type": "function"
  },
  "test_blank_lines_normal_delimiter": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_blank_lines_spaces_delimit": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ws"
    ],
    "type": "function"
  },
  "test_blas64_dot": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_blas64_geqrf_lwork_smoketest": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_block_docstring": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_bmat_nondefault_str": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_bool": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_bool_conversion": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_bool_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_boolean_indexing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_both": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_bounds_checking": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_bounds_checking_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "endpoint"
    ],
    "type": "function"
  },
  "test_broadcast": {
    "description": "Test that non-indexing dimensions are broadcast in both directions",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_broadcast_kwargs": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_broadcast_shape": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_broadcast_shapes_raises": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_broadcast_shapes_succeeds": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_broadcast_size_error": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_broadcast_size_scalar": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_broadcast_to_raises": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_broadcast_to_succeeds": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_broadcasting": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_build_dir": {
    "description": "Ensures that the build directory can be specified",
    "std_args": [
      "capfd",
      "hello_world_f90",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_build_err_msg_custom_names": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_build_err_msg_custom_precision": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_build_err_msg_defaults": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_build_err_msg_no_verbose": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_byte_bounds": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_byteorder_check": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_bytes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_byteswapping_and_unaligned": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dtype",
      "value",
      "swap"
    ],
    "type": "function"
  },
  "test_byview": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_c_": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_c_contig_req_out": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dtype"
    ],
    "type": "function"
  },
  "test_c_copy_in_from_23casttype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_c_double": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_c_in_from_23casttype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_c_in_from_23seq": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_c_inout_23seq": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_cache": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_cache_hidden": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_call": {
    "description": "The class representing a Python function.",
    "std_args": [
      "Poly"
    ],
    "type": "function"
  },
  "test_call_with_list": {
    "description": "The class representing a Python function.",
    "std_args": [
      "Poly"
    ],
    "type": "function"
  },
  "test_call_within_randomstate": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_callstatement": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_callstatement_fortran": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_cannot_seed": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_case_sensitivity": {
    "description": "Test case sensitivity",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_cast": {
    "description": "The class representing a Python function.",
    "std_args": [
      "Poly1",
      "Poly2"
    ],
    "type": "function"
  },
  "test_casting_error": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_cdll": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "test_cffi": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_change_symbol": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_char": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_char_arr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_character_bc": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "state"
    ],
    "type": "function"
  },
  "test_character_not_bytes_compatible": {
    "description": "Test exception when a character cannot be encoded as 'S'.",
    "std_args": [],
    "type": "function"
  },
  "test_cheb2poly": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebadd": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebder": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebder_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebdiv": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebdomain": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebfit": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebfromroots": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebgrid2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebgrid3d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebint": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebint_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebline": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebmul": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebmulx": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebone": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebpow": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebpts1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebpts2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebroots": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebsub": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebtrim": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebval": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebval2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebval3d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebvander": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebvander2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebvander3d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebx": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebyshev_repr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chebyshev_str": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "inp",
      "tgt"
    ],
    "type": "function"
  },
  "test_chebzero": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_01": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_02": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_03": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_04": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_05": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_06": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_07": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_constant": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_constant_float": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_constant_float2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_constant_float3": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_constant_odd_pad_amount": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_constant_pad_2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_constant_zeros": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_large_integers": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_large_pad": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_large_pad_odd": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_maximum_1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_maximum_2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_maximum_stat_length": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_mean_2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_mean_shape_one": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_mean_stat_length": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_median": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_median_01": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_median_02": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_median_stat_length": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_minimum_1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_minimum_2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_minimum_stat_length": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_negative_stat_length": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "mode",
      "stat_length"
    ],
    "type": "function"
  },
  "test_check_object_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_odd_method": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_on_fields": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_on_scalar": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_shape": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_simple": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_check_width_shape_1_2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_checktitles": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_chisquare": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_choice_array_size_empty_tuple": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_choice_exceptions": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_choice_large_sample": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_choice_multidimensional_custom_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_choice_multidimensional_default_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_choice_nan_probabilities": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_choice_noninteger": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_choice_nonuniform_noreplace": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_choice_nonuniform_replace": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_choice_p_non_contiguous": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_choice_retun_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_choice_return_shape": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_choice_return_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_choice_sum_of_probs_tolerance": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_choice_uniform_noreplace": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_choice_uniform_replace": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_cholesky_empty_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "upper"
    ],
    "type": "function"
  },
  "test_choose": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_choose_with_out": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_clear_and_catch_warnings": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_clear_and_catch_warnings_inherit": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_cli_obj": {
    "description": "Ensures that the extra object can be specified when using meson backend",
    "std_args": [
      "capfd",
      "hello_world_f90",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_clip": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_clip_out": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_clip_statistic_range": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "mode"
    ],
    "type": "function"
  },
  "test_clipmodes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_closeness": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_closest_observation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_closing_fid": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_closing_zipfile_after_load": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_clump_masked": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_clump_unmasked": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_cmplx": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_code_runs": {
    "description": "Validate that the code in `path` properly during runtime.",
    "std_args": [
      "path"
    ],
    "type": "function"
  },
  "test_coercion_RandomState_Generator": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_coercion_bytes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_coercion_float": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_coercion_int": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_coercion_unicode": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_collision_with_default_delimiter_raises": {
    "description": "The class representing a Python function.",
    "std_args": [
      "ws"
    ],
    "type": "function"
  },
  "test_comment_multichar_error_with_quote": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_comment_multiple_chars": {
    "description": "The class representing a Python function.",
    "std_args": [
      "comment"
    ],
    "type": "function"
  },
  "test_comment_quotechar_collision_raises": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_commented_header": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_comments": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_comments_byte": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_comments_is_none": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_comments_multi_chars": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_comments_multiple": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_comments_unicode": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_common_block": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_common_gh19161": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_common_with_division": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_comp_no_mask_not_broadcast": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "op"
    ],
    "type": "function"
  },
  "test_comparisons": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_comparisons_for_numeric": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "op",
      "dt1",
      "dt2",
      "fill"
    ],
    "type": "function"
  },
  "test_comparisons_strings": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dt",
      "op",
      "fill"
    ],
    "type": "function"
  },
  "test_compiled_bytes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_complex": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_complex1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_complex128_fail": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_complex128_pass": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_complex64_fail": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_complex64_pass": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_complex_arrays": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_complex_bad": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_complex_bad2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_complex_coefficients": {
    "description": "Test both numpy and built-in complex.",
    "std_args": [],
    "type": "function"
  },
  "test_complex_good": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_complex_high_ord": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_complex_inf": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_complex_interp": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_complex_item": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_complex_misformatted": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_complex_negative_exponent": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_complex_parsing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dtype",
      "with_parens"
    ],
    "type": "function"
  },
  "test_complex_step": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_composition": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_compress": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_compress_nd": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_compress_rowcols": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_compressed": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_compressed_bz2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_compressed_gzip": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_compressed_lzma": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_compressed_roundtrip": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tmpdir"
    ],
    "type": "function"
  },
  "test_concatenate_alongaxis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_concatenate_basic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_concatenate_flexible": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_cond_dtypes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype",
      "norm_ord"
    ],
    "type": "function"
  },
  "test_configtool_cflags": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_configtool_pkgconfigdir": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_configtool_version": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_consecutive_quotechar_escaped": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_constant_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_constant_array_any_index": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_constant_array_delims": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_constant_both": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_constant_compound_int": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_constant_fixed_width": {
    "description": "Test LineSplitter w/ fixed-width fields",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_constant_integer_int": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_constant_integer_long": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_constant_no": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_constant_non_compound_int": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_constant_real_double": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_constant_real_single": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_constant_sum": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_constant_zero_default": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_context_manager": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_contig_req_out": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dist",
      "order",
      "dtype"
    ],
    "type": "function"
  },
  "test_contiguous": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_contiguous_handling": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_control_character_empty": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_control_character_newline_raises": {
    "description": "The class representing a Python function.",
    "std_args": [
      "nl"
    ],
    "type": "function"
  },
  "test_control_characters_as_bytes": {
    "description": "Byte control characters (comments, delimiter) are supported.",
    "std_args": [],
    "type": "function"
  },
  "test_conversion": {
    "description": "The class representing a Python function.",
    "std_args": [
      "Poly1",
      "Poly2"
    ],
    "type": "function"
  },
  "test_convert": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "kwarg"
    ],
    "type": "function"
  },
  "test_convert2ma_signature": {
    "description": "The class representing a Python function.",
    "std_args": [
      "fn",
      "signature"
    ],
    "type": "function"
  },
  "test_converter_with_structured_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_converter_with_unicode_dtype": {
    "description": "With the 'bytes' encoding, tokens are encoded prior to being",
    "std_args": [],
    "type": "function"
  },
  "test_converters_cornercases": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_converters_cornercases2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_converters_decode": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_converters_dict_raises_non_col_key": {
    "description": "The class representing a Python function.",
    "std_args": [
      "bad_col_ind"
    ],
    "type": "function"
  },
  "test_converters_dict_raises_non_integer_key": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_converters_dict_raises_val_not_callable": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_converters_negative_indices": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_converters_negative_indices_with_usecols": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_converters_nodecode": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_converters_with_usecols": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_converters_with_usecols_and_names": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_convolve": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_copy": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_copy_0d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_copy_immutable": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_copy_on_python_builtins": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_core_shims_coherence": {
    "description": "Check that all \"semi-public\" members of `numpy._core` are also accessible",
    "std_args": [],
    "type": "function"
  },
  "test_corrcoef_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "test_type"
    ],
    "type": "function"
  },
  "test_correct_quantile_value": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_count": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "kwargs"
    ],
    "type": "function"
  },
  "test_count_func": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_count_mean_with_matrix": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_count_on_python_builtins": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_cov_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "test_type"
    ],
    "type": "function"
  },
  "test_cov_parameters": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_coverage1_ticket_2100": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_covhelper": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_crackedlines": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_creation": {
    "description": "Test creation of a StringConverter",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_creation_from_ndarray_with_padding": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_creation_maskcreation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_creation_ndmin": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_creation_ndmin_from_maskedarray": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_creation_with_list_of_maskedarrays": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_creation_with_list_of_maskedarrays_no_bool_cast": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_cross": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_ctor": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ctypes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_cumprod": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_cumsum": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_cumsumprod": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_cumsumprod_with_output": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_cumulative_include_initial": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_custom_dtype_duck": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_custom_writer": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_cutdeg": {
    "description": "The class representing a Python function.",
    "std_args": [
      "Poly"
    ],
    "type": "function"
  },
  "test_cython": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tmp_path"
    ],
    "type": "function"
  },
  "test_data_stmts": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_data_subclassing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_datafriendly_add": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_datafriendly_add_arrays": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_datafriendly_div": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_datafriendly_mul": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_datafriendly_mul_arrays": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_datafriendly_pow": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_datafriendly_sub": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_datafriendly_sub_arrays": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_datetime": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_datetime64": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_datetime_conversion": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ddof": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ddof_too_big": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_debugcapi": {
    "description": "Ensures that debugging wrappers are written",
    "std_args": [
      "capfd",
      "hello_world_f90",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_debugcapi_bld": {
    "description": "Ensures that debugging wrappers work",
    "std_args": [
      "hello_world_f90",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_decorator": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_deepcopy": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_deepcopy_0d_obj": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_deepcopy_2d_obj": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_default": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_defaultPrivate": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_defaultPublic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tmp_path"
    ],
    "type": "function"
  },
  "test_default_1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_default_2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_default_3": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_default_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_default_field_format": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_default_fill_value": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_default_fill_value_complex": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_default_fill_value_structured": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_default_fill_value_void": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_default_float_converter_exception": {
    "description": "Ensure that the exception message raised during failed floating point",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_default_float_converter_no_default_hex_conversion": {
    "description": "Ensure that fromhex is only used for values with the correct prefix and",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_default_is_pcg64": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_default_symbol": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_defaults": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_definition": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_degree": {
    "description": "The class representing a Python function.",
    "std_args": [
      "Poly"
    ],
    "type": "function"
  },
  "test_del_attr_handling": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_delimiter": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_delimiter_and_multiple_comments_collision_raises": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_delimiter_comment_collision_raises": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_delimiter_quotechar_collision_raises": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_density": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_density_non_uniform_1d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_density_non_uniform_2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dependencies": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tmp_path"
    ],
    "type": "function"
  },
  "test_deriv": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_descr_to_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dt"
    ],
    "type": "function"
  },
  "test_dev0_a_b_rc_mixed": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_dev0_version": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_dev_a_b_rc_mixed": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_dev_version": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_diag": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_diag2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_diag_bounds": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_diag_indices": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_diag_indices_from": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_diagonal": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_diagonal_view": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dict_mode": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_diff_with_append": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_diff_with_dim_0": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_diff_with_n_0": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_diff_with_prepend": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_different_field_order": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dimensions": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dimesions": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dir_testing": {
    "description": "Assert that output of dir has only one \"testing/tester\"",
    "std_args": [],
    "type": "function"
  },
  "test_dirichlet": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dirichlet_alpha_non_contiguous": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dirichlet_bad_alpha": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dirichlet_moderately_small_alpha": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dirichlet_multiple_zeros_in_alpha": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "alpha"
    ],
    "type": "function"
  },
  "test_dirichlet_size": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dirichlet_small_alpha": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dispatch": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_div_zerodiv": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_divide_on_different_shapes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_divmod": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "rhs"
    ],
    "type": "function"
  },
  "test_do_not_rewrite_previous_keyword": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_do_not_touch_normal_spaces": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_doc_note": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_docstring": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_docstring_examples": {
    "description": "test the examples given in the docstring of ma.median",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_domained_binops_d2D": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dot": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dot_matrix": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_dot_out": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dot_returns_maskedarray": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dot_scalar_and_matrix_of_objects": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_dot_shape_mismatch": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_double": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_drop_fields": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_drop_metadata": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_drop_metadata_identity_and_copy": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dtype"
    ],
    "type": "function"
  },
  "test_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dtype_error": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dtype_from_char": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dtype_from_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dtype_from_input": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dtype_order": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dtype_persistence": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dtype",
      "mode"
    ],
    "type": "function"
  },
  "test_dtype_promotion_gh_29189": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dtype_reference_leaks": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dtype_with_converters": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dtype_with_converters_and_usecols": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dtype_with_object": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dtype_with_object_no_converter": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dtypes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_duck": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ducktyping": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_duplicate_keys": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dynamic_programming_logic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_dynamic_programming_optimization_and_out": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_easy_dtype": {
    "description": "Test ndtype on dtypes",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_easy_structured_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_edge_cases": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "method"
    ],
    "type": "function"
  },
  "test_edge_dtype": {
    "description": "Test that if an edge array is input, its type is preserved",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_edges": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ediff1d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ediff1d_forbidden_type_casts": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "ary",
      "prepend",
      "append",
      "expected"
    ],
    "type": "function"
  },
  "test_ediff1d_matrix": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_ediff1d_ndarray": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ediff1d_scalar_handling": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "ary",
      "prepend",
      "append",
      "expected"
    ],
    "type": "function"
  },
  "test_ediff1d_tobegin": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ediff1d_tobegin_toend": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ediff1d_toend": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_eig_build": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_eigh_build": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_element_len": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_eliminate_quotes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_empty": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_empty_a_b": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "m",
      "n",
      "n_rhs"
    ],
    "type": "function"
  },
  "test_empty_array_ravel": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "mode"
    ],
    "type": "function"
  },
  "test_empty_array_unravel": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_empty_field_after_tab": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_empty_file": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_empty_formatstr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_empty_herm_cases": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_empty_identity": {
    "description": "Empty input should put an identity matrix in u or vh",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_empty_indices": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_empty_list": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "minlength"
    ],
    "type": "function"
  },
  "test_empty_list_on_structured": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_empty_nonsq_cases": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_empty_npz": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tmpdir"
    ],
    "type": "function"
  },
  "test_empty_outputs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_empty_sq_cases": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_empty_usecols": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_empty_with_minlength": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_encoding": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_encoding_comment": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_end_if_comment": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_end_values": {
    "description": "Ensure that end values are exact.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_entropy_init": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_eq": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_eq_broadcast_with_unmasked": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "op"
    ],
    "type": "function"
  },
  "test_eq_different_dimensions": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_eq_for_numeric": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dt1",
      "dt2",
      "fill"
    ],
    "type": "function"
  },
  "test_eq_for_strings": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dt",
      "fill"
    ],
    "type": "function"
  },
  "test_eq_ne_structured_extra": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_eq_ne_structured_with_non_masked": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_eq_on_structured": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_eq_with_None": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_eq_with_scalar": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_equal": {
    "description": "The class representing a Python function.",
    "std_args": [
      "Poly"
    ],
    "type": "function"
  },
  "test_equal_edges": {
    "description": "Test that adjacent entries in an edge array can be equal",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_equal_nan": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_equal_nan_default": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_equal_split": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_equal_to_original": {
    "description": "Test the new (>=v1.15) and old implementations are equal (see #10073)",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_error_binnum_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_error_byteorder": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_error_message": {
    "description": "Check the message is formatted correctly for the decimal value.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_error_message_2": {
    "description": "Check the message is formatted correctly",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_error_message_unsigned": {
    "description": "Check the message is formatted correctly when overflow can occur",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_error_not_1d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "vals"
    ],
    "type": "function"
  },
  "test_error_shape_mismatch": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_error_small_input": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_errors": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_eval_scalar": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_example": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_exception": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_exception_message_bad_values": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dtype"
    ],
    "type": "function"
  },
  "test_exception_negative_row_limits": {
    "description": "skiprows and max_rows should raise for negative parameters.",
    "std_args": [
      "param"
    ],
    "type": "function"
  },
  "test_exception_noninteger_row_limits": {
    "description": "The class representing a Python function.",
    "std_args": [
      "param"
    ],
    "type": "function"
  },
  "test_exceptions": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_exceptions_bad_power": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dt"
    ],
    "type": "function"
  },
  "test_exceptions_non_square": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dt"
    ],
    "type": "function"
  },
  "test_exceptions_not_invertible": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dt"
    ],
    "type": "function"
  },
  "test_excludelist": {
    "description": "Test excludelist",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_execution_order_ticket_1487": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_exhaustiveness": {
    "description": "Validate that all nan functions are actually tested.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_exotic_formats": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_exotic_weights": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_exp": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_expand_dims_matrix": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_exponential": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_exponential_0": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_extended_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_extended_axis_invalid": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_external_as_attribute": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_external_as_statement": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_extreme": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_extremum_fill_value": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_extremum_fill_value_subdtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_eye": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_eye_bounds": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_f": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_f2cmap": {
    "description": "Check that Fortran-to-Python KIND specs can be passed",
    "std_args": [
      "capfd",
      "f2cmap_f90",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_f2py": {
    "description": "The class representing a Python function.",
    "std_args": [
      "f2py_cmd"
    ],
    "type": "function"
  },
  "test_f2py_only": {
    "description": "Test that functions can be kept by only:",
    "std_args": [
      "capfd",
      "retreal_f77",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_f2py_skip": {
    "description": "Tests that functions can be skipped",
    "std_args": [
      "capfd",
      "retreal_f77",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_f32_rounding": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_f_copy_in_from_23casttype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_f_decreasing_unsigned_int": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "f_dtype"
    ],
    "type": "function"
  },
  "test_f_in_from_23casttype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_f_inout_23seq": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_f_signed_int_big_jump": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "f_dtype"
    ],
    "type": "function"
  },
  "test_fail": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fails": {
    "description": "Test that in cases where the garbage cannot be collected, we raise an",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_failure": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fancy": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fancy_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fancy_dtype_alt": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fancy_indexing": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_fancy_printoptions": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fft": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fft2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fft_bad_out": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fft_inplace_out": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "axis"
    ],
    "type": "function"
  },
  "test_fft_n": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fft_out_argument": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype",
      "transpose",
      "axis"
    ],
    "type": "function"
  },
  "test_fft_output_order": {
    "description": "The class representing a Python function.",
    "std_args": [
      "order",
      "n"
    ],
    "type": "function"
  },
  "test_fft_with_integer_or_bool_input": {
    "description": "The class representing a Python function.",
    "std_args": [
      "data",
      "fft"
    ],
    "type": "function"
  },
  "test_fft_with_order": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dtype",
      "order",
      "fft"
    ],
    "type": "function"
  },
  "test_fftn": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fftn_out_and_s_interaction": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "fft"
    ],
    "type": "function"
  },
  "test_fftn_out_argument": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype",
      "transpose",
      "axes"
    ],
    "type": "function"
  },
  "test_field_assignment_by_name": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_field_growing_cases": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_fieldless_void": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_file_is_closed_on_error": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_file_processing_switch": {
    "description": "Tests that it is possible to return to file processing mode",
    "std_args": [
      "capfd",
      "hello_world_f90",
      "retreal_f77",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_file_roundtrip": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "filename_type"
    ],
    "type": "function"
  },
  "test_file_truncated": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tmp_path"
    ],
    "type": "function"
  },
  "test_filelike_bad_read": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_filelike_read_fails": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_filled": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_filled_with_f_order": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_filled_with_flexible_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_filled_with_mvoid": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_filled_with_nested_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_filled_with_object_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_filling_values": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fillvalue": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fillvalue_as_arguments": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fillvalue_bytes_or_str": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fillvalue_conversion": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fillvalue_datetime_timedelta": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fillvalue_exotic_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fillvalue_implicit_structured_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fillvalue_in_view": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fillvalue_individual_fields": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_find_duplicates": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_find_duplicates_ignoremask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_finite_range": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_first_linebreak_multiline_on_linewidth": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_first_linebreak_multiline_one_less_than_linewidth": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fit": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_fit_degenerate_domain": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fix": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fix_invalid": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fix_with_subclass": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fixed": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fixed_width_names": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_flags": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_flat": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_flatnotmasked_contiguous": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_flatten": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_flatten_dtype": {
    "description": "Testing flatten_dtype",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_flatten_mask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_flatten_structured_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_flatten_wflexible": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_float": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_float16_fail": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_float16_gh_29003": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_float16_ignore_nan": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_float16_pass": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_float16_underflow": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_float32_fail": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_float32_ignore_nan": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_float32_pass": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_float64_fail": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_float64_ignore_nan": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_float64_pass": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_float_conversion": {
    "description": "Some tests that the conversion to float64 works as accurately as the",
    "std_args": [],
    "type": "function"
  },
  "test_float_dtypes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype"
    ],
    "type": "function"
  },
  "test_float_special": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_floordiv": {
    "description": "The class representing a Python function.",
    "std_args": [
      "Poly"
    ],
    "type": "function"
  },
  "test_format": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_format_2_0": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_format_ascii": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_format_unicode": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fortran_order": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_forward": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_forward_binary_methods": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fraction": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_freethreading_compatible": {
    "description": "CLI :: --freethreading_compatible",
    "std_args": [
      "hello_world_f90",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_from_complex": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_from_float_hex": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_from_template": {
    "description": "Regression test for gh-10712.",
    "std_args": [],
    "type": "function"
  },
  "test_fromarrays": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fromflex": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_frommethod_signature": {
    "description": "The class representing a Python function.",
    "std_args": [
      "fn",
      "signature"
    ],
    "type": "function"
  },
  "test_frompyfunc_leaks": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "name",
      "incr"
    ],
    "type": "function"
  },
  "test_fromrecords": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fromrecords_wmask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fromroots": {
    "description": "The class representing a Python function.",
    "std_args": [
      "Poly"
    ],
    "type": "function"
  },
  "test_fromstring": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_fromtextfile": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_froomroots": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_ftype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_full_range": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_full_range_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "endpoint"
    ],
    "type": "function"
  },
  "test_full_reimport": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_function_maskedarray": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_function_ndarray": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_function_rettype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_functionality": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_functions_single_location": {
    "description": "Check that each public function is available from one location only.",
    "std_args": [],
    "type": "function"
  },
  "test_fweights": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gamma": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gamma_0": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gamma_floats": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gauss_inv": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gaussian_reset": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gaussian_reset_in_media_res": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gen_pyf": {
    "description": "Ensures that a signature file is generated via the CLI",
    "std_args": [
      "capfd",
      "hello_world_f90",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_gen_pyf_no_overwrite": {
    "description": "Ensures that the CLI refuses to overwrite signature files",
    "std_args": [
      "capfd",
      "hello_world_f90",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_gen_pyf_stdout": {
    "description": "Ensures that a signature file can be dumped to stdout",
    "std_args": [
      "capfd",
      "hello_world_f90",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_generalized_empty_herm_cases": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_generalized_empty_nonsq_cases": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_generalized_empty_sq_cases": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_generalized_herm_cases": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_generalized_nonsq_cases": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_generalized_raise_multiloop": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_generalized_sq_cases": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_generator": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_generator_ctor_old_style_pickle": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_generator_source": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_generator_spawning": {
    "description": "Test spawning new generators and bit_generators directly.",
    "std_args": [],
    "type": "function"
  },
  "test_generic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_generic_methods": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_generic_rank1": {
    "description": "Test rank 1 array for all dtypes.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_generic_rank3": {
    "description": "Test rank 3 array for all dtypes.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_genfromtxt": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "filename_type"
    ],
    "type": "function"
  },
  "test_geometric": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_geometric_exceptions": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_geometric_tiny_prob": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_get": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_get_args": {
    "description": "Test `typing.get_args`.",
    "std_args": [
      "name",
      "tup"
    ],
    "type": "function"
  },
  "test_get_fieldstructure": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_get_names": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_get_names_flat": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_get_origin": {
    "description": "Test `typing.get_origin`.",
    "std_args": [
      "name",
      "tup"
    ],
    "type": "function"
  },
  "test_get_state_warning": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_get_type_hints": {
    "description": "Test `typing.get_type_hints`.",
    "std_args": [
      "name",
      "tup"
    ],
    "type": "function"
  },
  "test_get_type_hints_str": {
    "description": "Test `typing.get_type_hints` with string-representation of types.",
    "std_args": [
      "name",
      "tup"
    ],
    "type": "function"
  },
  "test_getdomain": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_getitem": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_getmaskarray": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_getstate": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gft_from_gzip": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gft_using_filename": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gft_using_generator": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh15095": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh17797": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh18335": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh18684": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh21665": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh22648": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tmp_path"
    ],
    "type": "function"
  },
  "test_gh22819_cli": {
    "description": "Check that module names are handled correctly",
    "std_args": [
      "capfd",
      "gh22819_cli",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_gh22819_many_pyf": {
    "description": "Only one .pyf file allowed",
    "std_args": [
      "capfd",
      "gh22819_cli",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_gh23598_warn": {
    "description": "The class representing a Python function.",
    "std_args": [
      "capfd",
      "gh23598_warn",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_gh24008": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh24662": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh25211": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh25286": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh25337": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh25344": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh25784": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_gh25799": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh25867": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh26148": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh26148b": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh26466": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh26623": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_gh26920": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh27167": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh28014": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh2848": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh3425": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh4519": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh6308": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh_21022": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_gh_22556": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_gh_23110": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh_27658": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh_28354": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dt"
    ],
    "type": "function"
  },
  "test_gh_28354_array_like": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gh_28400": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_good_newline_in_iterator": {
    "description": "The class representing a Python function.",
    "std_args": [
      "data"
    ],
    "type": "function"
  },
  "test_goodvalues": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gumbel": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gumbel_0": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_gzip_load": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_gzip_loadtxt": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_gzip_loadtxt_from_string": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_hamming": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype",
      "M"
    ],
    "type": "function"
  },
  "test_hanning": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype",
      "M"
    ],
    "type": "function"
  },
  "test_hardmask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hardmask_again": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hardmask_oncemore_yay": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_has_nested_dtype": {
    "description": "Test has_nested_dtype",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_header": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_header_footer": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_header_growth_axis": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_herm2poly": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_herm_cases": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermadd": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermder": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermder_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermdiv": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermdomain": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_herme2poly": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermeadd": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermeder": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermeder_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermediv": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermedomain": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermefit": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermefromroots": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermegrid2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermegrid3d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermeint": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermeint_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermeline": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermemul": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermemulx": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermeone": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermepow": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermeroots": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermesub": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermetrim": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermeval": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermeval2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermeval3d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermevander": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermevander2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermevander3d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermex": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermezero": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermfit": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermfromroots": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermgrid2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermgrid3d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermint": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermint_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermiteE_repr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermiteE_str": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "inp",
      "tgt"
    ],
    "type": "function"
  },
  "test_hermite_repr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermite_str": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "inp",
      "tgt"
    ],
    "type": "function"
  },
  "test_hermline": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermmul": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermmulx": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermone": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermpow": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermroots": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermsub": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermtrim": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermval": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermval2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermval3d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermvander": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermvander2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermvander3d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermx": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hermzero": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hetero_shape_handling": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hfft": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hidden": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hidden_callback": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_histogram_bin_edges": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_histogramdd_too_many_bins": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hlink": {
    "description": "Add to the include directories",
    "std_args": [],
    "type": "function"
  },
  "test_hot_swap": {
    "description": "The class representing a Python function.",
    "std_args": [
      "restore_singleton_bitgen"
    ],
    "type": "function"
  },
  "test_huge_float": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dtype"
    ],
    "type": "function"
  },
  "test_huge_header": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tmpdir",
      "mmap_mode"
    ],
    "type": "function"
  },
  "test_huge_header_npz": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tmpdir"
    ],
    "type": "function"
  },
  "test_hypergeometric": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_hypergeometric_range": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_identical_samples": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_identity": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_identity_long_short": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype"
    ],
    "type": "function"
  },
  "test_identity_long_short_reversed": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype"
    ],
    "type": "function"
  },
  "test_if_len_x_is_small": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ifft": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ifft2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ifftn": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ignore_inner_quotes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ihfft": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_imag_real": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_immutable": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_implicit_cast_float_to_int_fails": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dtype"
    ],
    "type": "function"
  },
  "test_import": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_import_lazy_import": {
    "description": "Make sure we can actually use the modules we lazy load.",
    "std_args": [
      "name"
    ],
    "type": "function"
  },
  "test_in1d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_in1d_invert": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_in_bounds_fuzz": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_in_cache_from_2casttype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_in_cache_from_2casttype_failure": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_in_copy_from_2casttype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_in_from_23casttype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_in_from_2casttype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_in_from_2seq": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_in_nocopy": {
    "description": "Test if intent(in) array can be passed without copies",
    "std_args": [
      "self",
      "write",
      "order",
      "inp"
    ],
    "type": "function"
  },
  "test_in_out": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inclheader": {
    "description": "Add to the include directories",
    "std_args": [
      "capfd",
      "hello_world_f90",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_inclpath": {
    "description": "Add to the include directories",
    "std_args": [],
    "type": "function"
  },
  "test_include_dirs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_include_path": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_incompatible_dims": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_incompatible_shapes_raise_valueerror": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_incomplete_names": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inconsistent_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_incorrect_methods": {
    "description": "Check a Value Error is thrown when an unknown string is passed in",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ind": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_index_array_copied": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_index_floats": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_index_out_of_bounds": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "idx"
    ],
    "type": "function"
  },
  "test_index_split_high_bound": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_index_split_low_bound": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_index_split_simple": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_indexing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inexact_dtypes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inf": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inf_compare": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inf_compare_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inf_edges": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inf_item": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inf_items": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inf_zeroes_err": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "weights",
      "dty"
    ],
    "type": "function"
  },
  "test_info_method_heading": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_infs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_init": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_initial": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype"
    ],
    "type": "function"
  },
  "test_inner_join": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inner_scalar_and_matrix": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_inner_scalar_and_matrix_of_objects": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_inout": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inout_2seq": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inout_varia": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inplace": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inplace_addition_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inplace_addition_array_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inplace_addition_scalar": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inplace_addition_scalar_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inplace_division_array_float": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inplace_division_array_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inplace_division_misc": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inplace_division_scalar_float": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inplace_division_scalar_int": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inplace_division_scalar_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inplace_floor_division_array_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inplace_floor_division_scalar_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inplace_from_casttype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inplace_multiplication_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inplace_multiplication_array_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inplace_multiplication_scalar": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inplace_multiplication_scalar_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inplace_pow_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inplace_subtraction_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inplace_subtraction_array_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inplace_subtraction_scalar": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inplace_subtraction_scalar_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_input": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype"
    ],
    "type": "function"
  },
  "test_input_encoding": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tmp_path",
      "encoding"
    ],
    "type": "function"
  },
  "test_input_output": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_input_varia": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inspect_signature": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "cls"
    ],
    "type": "function"
  },
  "test_instance_methods": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_int": {
    "description": "Test `int` kind_func for integers up to 10**40.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_int64_dtype": {
    "description": "Check that int64 integer types can be specified",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_int64_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_int64_uint64_broadcast_exceptions": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "endpoint"
    ],
    "type": "function"
  },
  "test_int64_uint64_corner_case": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_int_beta": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_int_dtypes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype"
    ],
    "type": "function"
  },
  "test_int_negative_interval": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_integ": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_integ_coeffs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_integer": {
    "description": "Test that bin width for integer data is at least 1.",
    "std_args": [
      "self",
      "bins"
    ],
    "type": "function"
  },
  "test_integer_0_split": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_integer_delimiter": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_integer_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "int_func"
    ],
    "type": "function"
  },
  "test_integer_non_auto": {
    "description": "Test that the bin-width>=1 requirement *only* applies to auto binning.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_integer_repeat": {
    "description": "The class representing a Python function.",
    "std_args": [
      "int_func"
    ],
    "type": "function"
  },
  "test_integer_signs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dtype"
    ],
    "type": "function"
  },
  "test_integer_split": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_integer_split_2D_cols": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_integer_split_2D_default": {
    "description": "This will fail if we change default axis",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_integer_split_2D_rows": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_integer_split_2D_rows_greater_max_int32": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_integers": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_integers_broadcast": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype"
    ],
    "type": "function"
  },
  "test_integers_broadcast_errors": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype"
    ],
    "type": "function"
  },
  "test_integers_closed": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_integers_masked": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_integers_max_int": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_integers_numpy": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype"
    ],
    "type": "function"
  },
  "test_integers_small_dtype_chisquared": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "sample_size",
      "high",
      "dtype",
      "chi2max"
    ],
    "type": "function"
  },
  "test_intent_in": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_intent_inout": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_intersect1d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_intersect1d_array_like": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_intersect1d_indices": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_intmin": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inv_array_size": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dimspec"
    ],
    "type": "function"
  },
  "test_invalid": {
    "description": "Test invalid inputs",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_invalid_arguments": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_invalid_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_invalid_array_shape": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_invalid_converter": {
    "description": "The class representing a Python function.",
    "std_args": [
      "conv"
    ],
    "type": "function"
  },
  "test_invalid_init_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_invalid_init_values": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_invalid_initialization": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_invalid_legacy_state_setting": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_invalid_mode": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_invalid_n": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_invalid_prob": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_invalid_pvals_broadcast": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_invalid_raise": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_invalid_raise_with_usecols": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_invalid_range": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_invalid_scalar": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_invalid_state_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_invalid_state_value": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_inverse": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_irfft": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_irfft2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_irfft_with_n_1_regression": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_irfft_with_n_large_regression": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_irfftn": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_irfftn_out_and_s_interaction": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "s"
    ],
    "type": "function"
  },
  "test_isfile": {
    "description": "Test if all ``.pyi`` files are properly installed.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_isin": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "kind"
    ],
    "type": "function"
  },
  "test_isin_additional": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "kind"
    ],
    "type": "function"
  },
  "test_isin_boolean": {
    "description": "Test that isin works for boolean input",
    "std_args": [
      "self",
      "kind"
    ],
    "type": "function"
  },
  "test_isin_both_arrays_are_object": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_isin_both_arrays_have_structured_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_isin_char_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_isin_errors": {
    "description": "Test that isin raises expected errors.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_isin_first_array_is_object": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_isin_hit_alternate_algorithm": {
    "description": "Hit the standard isin code with integers",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_isin_invert": {
    "description": "Test isin's invert parameter",
    "std_args": [
      "self",
      "kind"
    ],
    "type": "function"
  },
  "test_isin_mixed_boolean": {
    "description": "Test that isin works as expected for bool/int input.",
    "std_args": [
      "self",
      "kind"
    ],
    "type": "function"
  },
  "test_isin_mixed_dtype": {
    "description": "Test that isin works as expected for mixed dtype input.",
    "std_args": [
      "self",
      "dtype1",
      "dtype2",
      "kind"
    ],
    "type": "function"
  },
  "test_isin_mixed_huge_vals": {
    "description": "Test values outside intp range (negative ones if 32bit system)",
    "std_args": [
      "self",
      "kind",
      "data"
    ],
    "type": "function"
  },
  "test_isin_second_array_is_object": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_isin_table_timedelta_fails": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_isin_timedelta": {
    "description": "Test that isin works for timedelta input",
    "std_args": [
      "self",
      "kind"
    ],
    "type": "function"
  },
  "test_isin_with_arrays_containing_tuples": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_isinstance": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "cls",
      "obj"
    ],
    "type": "function"
  },
  "test_isneginf": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_isposinf": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_issubclass": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "cls",
      "obj"
    ],
    "type": "function"
  },
  "test_iter_allocate_output_subtype": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_iterator_fails_getting_next_line": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_join": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_join_subdtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_jump": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_jumped": {
    "description": "The class representing a Python function.",
    "std_args": [
      "config"
    ],
    "type": "function"
  },
  "test_kaiser": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype",
      "M"
    ],
    "type": "function"
  },
  "test_keep_default": {
    "description": "Make sure we don't lose an explicit default",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_keep_default_zero": {
    "description": "Check that we don't lose a default of 0",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_keep_missing_values": {
    "description": "Check that we're not losing missing values",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_keepdims": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_keepdims_out": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "q",
      "axis"
    ],
    "type": "function"
  },
  "test_keepmask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_keys": {
    "description": "Test that ``TYPES.keys()`` and ``numpy.typing.__all__`` are synced.",
    "std_args": [],
    "type": "function"
  },
  "test_keywords": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_keywords2_ticket_2100": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_keywords3_ticket_2100": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_keywords4_ticket_2100": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_keywords5_ticket_2100": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_keywords_no_func_code": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_keywords_with_otypes_order1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_keywords_with_otypes_order2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_keywords_with_otypes_order3": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_keywords_with_otypes_several_kwd_args1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_keywords_with_otypes_several_kwd_args2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_kron_ma": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_kron_matrix": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_kron_shape": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "shape_a",
      "shape_b"
    ],
    "type": "function"
  },
  "test_kron_smoke": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "array_class"
    ],
    "type": "function"
  },
  "test_kroncompare": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_kwargs": {
    "description": "Test behavior of pad's kwargs for the given mode.",
    "std_args": [
      "mode"
    ],
    "type": "function"
  },
  "test_lag2poly": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lagadd": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lagder": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lagder_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lagdiv": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lagdomain": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lagfit": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lagfromroots": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_laggrid2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_laggrid3d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lagint": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lagint_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lagline": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lagmul": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lagmulx": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lagone": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lagpow": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lagroots": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lagsub": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lagtrim": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_laguerre_repr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_laguerre_str": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "inp",
      "tgt"
    ],
    "type": "function"
  },
  "test_lagval": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lagval2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lagval3d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lagvander": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lagvander2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lagvander3d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lagx": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lagzero": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lapack_endian": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_laplace": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_laplace_0": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_large": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_large_archive": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tmpdir"
    ],
    "type": "function"
  },
  "test_large_fancy_indexing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_large_file_support": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tmpdir"
    ],
    "type": "function"
  },
  "test_large_header": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_large_integers": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_large_integers_decreasing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_large_integers_increasing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_large_power": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dt"
    ],
    "type": "function"
  },
  "test_large_svd_32bit": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_large_unicode_characters": {
    "description": "The class representing a Python function.",
    "std_args": [
      "c1",
      "c2"
    ],
    "type": "function"
  },
  "test_large_zip": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_last_bin_inclusive_range": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_latex": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_latexdoc": {
    "description": "Ensures that TeX documentation is written out",
    "std_args": [
      "capfd",
      "hello_world_f90",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_latin1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lazy_load": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_leading_skip": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_leftouter_join": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_leg2poly": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legacy_pickle": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legacy_vector_functionality": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_legadd": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legder": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legder_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legder_orderhigherthancoeff": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legdiv": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legdomain": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legendre_repr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legendre_str": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "inp",
      "tgt"
    ],
    "type": "function"
  },
  "test_legfit": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legfromroots": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_leggrid2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_leggrid3d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legint": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legint_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legint_zerointord": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legline": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legline_zeroscl": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legmul": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legmulx": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legone": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legpow": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legroots": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legsub": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legtrim": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legval": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legval2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legval3d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legvander": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legvander2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legvander3d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legvander_negdeg": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legx": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_legzero": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_limited_variance": {
    "description": "Check when IQR is 0, but variance exists, we return a reasonable value.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_limits_arithmetic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_linear_interpolation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "function",
      "quantile",
      "method",
      "weighted",
      "expected",
      "input_dtype",
      "expected_dtype"
    ],
    "type": "function"
  },
  "test_linear_interpolation_extrapolation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_linear_interpolation_formula_0d_inputs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_linear_interpolation_formula_bounded": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "t",
      "a",
      "b"
    ],
    "type": "function"
  },
  "test_linear_interpolation_formula_monotonic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "t0",
      "t1",
      "a",
      "b"
    ],
    "type": "function"
  },
  "test_linear_interpolation_formula_symmetric": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "t",
      "a",
      "b"
    ],
    "type": "function"
  },
  "test_linear_nan_1D": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype"
    ],
    "type": "function"
  },
  "test_linear_root": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_linear_solve": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_linewidth_printoption": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "lw",
      "tgt"
    ],
    "type": "function"
  },
  "test_linspace": {
    "description": "The class representing a Python function.",
    "std_args": [
      "Poly"
    ],
    "type": "function"
  },
  "test_linspace_equivalence": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_list": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_list_indexing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_list_to_list": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_load_multiple_arrays_until_eof": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_load_non_npy": {
    "description": "Test loading non-.npy files and name mapping in .npz.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_load_padded_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tmpdir",
      "dt"
    ],
    "type": "function"
  },
  "test_load_refcount": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_loadtxt": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_loadtxt_fields_subarrays": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_logistic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_logitic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lognormal": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lognormal_0": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_logseries": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_logseries_convergence": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_logseries_exceptions": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "value"
    ],
    "type": "function"
  },
  "test_logseries_zero": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_long_str": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_longdouble_norm": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_low_dim_handling": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_lower_cmod": {
    "description": "Lowers cases by flag or when -h is present",
    "std_args": [
      "capfd",
      "hello_world_f77",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_lower_higher": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype"
    ],
    "type": "function"
  },
  "test_lower_sig": {
    "description": "Lowers cases in signature files by flag or when -h is present",
    "std_args": [
      "capfd",
      "hello_world_f77",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_lstsq_complex_larger_rhs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_main_namespace_all_dir_coherence": {
    "description": "Checks if `dir(np)` and `np.__all__` are consistent and return",
    "std_args": [],
    "type": "function"
  },
  "test_main_versions": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_make_bool_matrix_from_str": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_make_mask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_make_mask_descr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_manual_universal_newlines": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "newline"
    ],
    "type": "function"
  },
  "test_many_arguments": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_manyways": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mapdomain": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mapparms": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mask_element": {
    "description": "Check record access",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mask_indices": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_mask_not_backmangled": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mask_or": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mask_row_cols_axis_deprecation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "axis",
      "func",
      "rowcols_axis"
    ],
    "type": "function"
  },
  "test_mask_rowcols": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mask_shape_assignment_does_not_break_masked": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_masked": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_0d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_1d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_all": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_all_like": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_all_with_object": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_all_with_object_nested": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_array_create": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_array_multiply": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_array_no_copy": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_masked_array_repeat": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_array_repr_unicode": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_array_tobytes_fortran": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_array_underflow": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_binary_operations": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_binary_operations2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_constant": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_equal_fill_value": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_equal_wlist": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_flexible": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_invalid_error": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_invalid_full_mask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "copy"
    ],
    "type": "function"
  },
  "test_masked_invalid_pandas": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_nan_inf": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_otherfunctions": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_scalar": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_singleton_arithmetic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_singleton_array_creation_warns": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_singleton_equality": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_unary_operations": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_values": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_weights": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_where_bool": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_where_condition": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_where_mismatch": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_where_oddities": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_where_shape_constraint": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_masked_where_structured": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_maskedarray_subclassing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_maskedarray_tofile_raises_notimplementederror": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_maskedelement": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_matching_named_fields": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_matmul": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_matrix": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_matrix_builder": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_matrix_element": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_matrix_indexing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_matrix_memory_sharing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_matrix_multiply_by_1d_vector": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_matrix_norm": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_matrix_norm_empty": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_matrix_properties": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_matrix_rank": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_matrix_rank_rtol_argument": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "rtol"
    ],
    "type": "function"
  },
  "test_matrix_ravel_order": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_matrix_scalar": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_matrix_std_argmax": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_matrix_transpose": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_matrix_transpose_equals_swapaxes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "shape"
    ],
    "type": "function"
  },
  "test_matrix_transpose_equals_transpose_2d": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_matrix_transpose_raises_error_for_1d": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_matscalar": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_max": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_max_rows": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_max_rows_empty_lines": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "skip",
      "data"
    ],
    "type": "function"
  },
  "test_max_rows_larger": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_max_rows_with_read_continuation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_max_rows_with_skiprows": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_max_ulp": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_maxrows_exceeding_chunksize": {
    "description": "The class representing a Python function.",
    "std_args": [
      "nmax"
    ],
    "type": "function"
  },
  "test_maxrows_no_blank_lines": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dtype"
    ],
    "type": "function"
  },
  "test_mdat": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mean_overflow": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_meananom_object": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mem_digitize": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mem_masked_where": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mem_polymul": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mem_string_concat": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mem_vectorise": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_member_flatten": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_member_ravel": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_memmap_roundtrip": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tmpdir"
    ],
    "type": "function"
  },
  "test_memmap_takes_fast_route": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tmpdir"
    ],
    "type": "function"
  },
  "test_memory_layout_persistence": {
    "description": "Test if C and F order is preserved for all pad modes.",
    "std_args": [
      "mode"
    ],
    "type": "function"
  },
  "test_metadata_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dt"
    ],
    "type": "function"
  },
  "test_method": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_methods_with_output": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mgrid_single_element": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mgrid_size_none_handling": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "start",
      "stop",
      "step",
      "expected"
    ],
    "type": "function"
  },
  "test_midpoint": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype"
    ],
    "type": "function"
  },
  "test_min": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_min_int": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_minimummaximum_func": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_minmax": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_minmax_dtypes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_minmax_func": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_minmax_funcs_with_output": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_minmax_ints": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype",
      "mask",
      "axis"
    ],
    "type": "function"
  },
  "test_minmax_methods": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_minmax_reduce": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_minmax_time_dtypes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "time_type"
    ],
    "type": "function"
  },
  "test_misshaped_pad_width": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "pad_width",
      "mode"
    ],
    "type": "function"
  },
  "test_misshaped_pad_width_2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "mode"
    ],
    "type": "function"
  },
  "test_missing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_missing_names": {
    "description": "Test validate missing names",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_missing_with_tabs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mixed_arithmetic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mixed_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mixins_have_slots": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mmap": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mod": {
    "description": "The class representing a Python function.",
    "std_args": [
      "Poly"
    ],
    "type": "function"
  },
  "test_mod_gen_f77": {
    "description": "Checks the generation of files based on a module name",
    "std_args": [
      "capfd",
      "hello_world_f90",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_mod_gen_gh25263": {
    "description": "Check that pyf files are correctly generated with module structure",
    "std_args": [
      "capfd",
      "hello_world_f77",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_mode_all_but_economic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mode_raw": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_moduleOperators": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tmp_path"
    ],
    "type": "function"
  },
  "test_module_docstring": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_monotonic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_more_mixed_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mtypes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mul": {
    "description": "The class representing a Python function.",
    "std_args": [
      "Poly"
    ],
    "type": "function"
  },
  "test_multichar_basis_func": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_multidim": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_multidimensional_extrafunc": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_multidimensional_pvals": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_multifield_view": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_multiline": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_multinomial": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_multinomial_1d_pval": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_multinomial_empty": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_multinomial_n_float": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_multinomial_pval_broadcast": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "n"
    ],
    "type": "function"
  },
  "test_multinomial_pvals_float32": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_multiple_arrays": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_multiple_axes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "shape",
      "axis",
      "trim"
    ],
    "type": "function"
  },
  "test_multiple_percentiles": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_multiple_relevant_spaces": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_multivariate_normal": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_multivariate_normal_basic_stats": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "method"
    ],
    "type": "function"
  },
  "test_multivariate_normal_disallow_complex": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "mean",
      "cov"
    ],
    "type": "function"
  },
  "test_multivariate_normal_size_types": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mutation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mvoid_getitem": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mvoid_iter": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mvoid_multidim_print": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_mvoid_print": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_n": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_n_zero": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_n_zero_stream": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_name": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_nameargspattern_backtracking": {
    "description": "address ReDOS vulnerability:",
    "std_args": [
      "self",
      "adversary"
    ],
    "type": "function"
  },
  "test_named_argument_initialization": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_named_arrays": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_names_and_comments_none": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_names_auto_completion": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_names_overwrite": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_names_with_usecols_bug1636": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_nan": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_nan_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_nan_behavior": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_nan_err": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "err",
      "dty",
      "weights"
    ],
    "type": "function"
  },
  "test_nan_item": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_nan_items": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_nan_noncompare": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_nan_noncompare_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_nan_q": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_nan_value_with_weight": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "nan_weight"
    ],
    "type": "function"
  },
  "test_nan_value_with_weight_ndim": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "axis"
    ],
    "type": "function"
  },
  "test_nanfunc": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "mat",
      "dtype",
      "nanfunc",
      "func"
    ],
    "type": "function"
  },
  "test_nanfunc_correction": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "mat",
      "dtype",
      "nanfunc"
    ],
    "type": "function"
  },
  "test_nanfunc_ddof": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "mat",
      "dtype",
      "nanfunc",
      "func"
    ],
    "type": "function"
  },
  "test_nanfunc_q": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "mat",
      "dtype",
      "nanfunc",
      "func"
    ],
    "type": "function"
  },
  "test_nanfunctions_matrices": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_nanfunctions_matrices_general": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_nanstd_with_mean_keyword": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_nansum_with_boolean": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_nat_basic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype",
      "pos"
    ],
    "type": "function"
  },
  "test_nat_behavior": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype",
      "pos"
    ],
    "type": "function"
  },
  "test_nat_items": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_nd": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_nd_basic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "ndim"
    ],
    "type": "function"
  },
  "test_nd_indexing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_nd_shape": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_nd_values": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ndarray_mask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ndarrayfuncs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ndenumerate_allmasked": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ndenumerate_crash": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ndenumerate_mixedmasked": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ndenumerate_nomasked": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ndim": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ndindex": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_ndindex_against_ndenumerate_compatibility": {
    "description": "Test ndindex produces same indices as ndenumerate.",
    "std_args": [],
    "type": "function"
  },
  "test_ndindex_empty_iterator_behavior": {
    "description": "Test detailed behavior of empty iterators.",
    "std_args": [],
    "type": "function"
  },
  "test_ndindex_empty_shape": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_ndindex_iterator_independence": {
    "description": "Test that each ndindex instance creates independent iterators.",
    "std_args": [],
    "type": "function"
  },
  "test_ndindex_large_dimensions_behavior": {
    "description": "Test ndindex behaves correctly when initialized with large dimensions.",
    "std_args": [],
    "type": "function"
  },
  "test_ndindex_multidimensional_correctness": {
    "description": "Test ndindex produces correct indices for multidimensional arrays.",
    "std_args": [],
    "type": "function"
  },
  "test_ndindex_negative_dim_raises": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_ndindex_negative_dimensions": {
    "description": "Test that negative dimensions raise ValueError.",
    "std_args": [
      "negative_shape_arg"
    ],
    "type": "function"
  },
  "test_ndindex_non_integer_dimensions": {
    "description": "Test that non-integer dimensions raise TypeError.",
    "std_args": [
      "bad_shape"
    ],
    "type": "function"
  },
  "test_ndindex_stop_iteration_behavior": {
    "description": "Test that StopIteration is raised properly after exhaustion.",
    "std_args": [],
    "type": "function"
  },
  "test_ndindex_tuple_vs_args_consistency": {
    "description": "Test that ndindex(shape) and ndindex(*shape) produce same results.",
    "std_args": [],
    "type": "function"
  },
  "test_ndindex_zero_dimensions_explicit": {
    "description": "Test ndindex produces empty iterators for explicit",
    "std_args": [],
    "type": "function"
  },
  "test_ndmin_keyword": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "ndim"
    ],
    "type": "function"
  },
  "test_ndmin_single_row_or_col": {
    "description": "The class representing a Python function.",
    "std_args": [
      "data",
      "shape"
    ],
    "type": "function"
  },
  "test_ne_for_numeric": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dt1",
      "dt2",
      "fill"
    ],
    "type": "function"
  },
  "test_ne_for_strings": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dt",
      "fill"
    ],
    "type": "function"
  },
  "test_ne_on_structured": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_nearest": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype"
    ],
    "type": "function"
  },
  "test_neg": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_neg_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_negative_binomial": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_negative_binomial_exceptions": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_negative_binomial_invalid_p_n_combination": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_negative_binomial_p0_exception": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_negative_difference": {
    "description": "Check correct behavior of unsigned dtypes if there is a negative",
    "std_args": [
      "self",
      "dtype"
    ],
    "type": "function"
  },
  "test_negative_pad_width": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "pad_width",
      "mode"
    ],
    "type": "function"
  },
  "test_negative_zero": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_negbound": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_neginf": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_neginf_scalar": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_neq": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_nested_ma": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_nested_structured_subarray": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_no_delimiter": {
    "description": "Test LineSplitter w/o delimiter",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_no_duplicates_in_np__all__": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_no_freethreading_compatible": {
    "description": "CLI :: --no-freethreading-compatible",
    "std_args": [
      "hello_world_f90",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_no_input": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_no_keywords": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_no_lower_fail": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_no_masked_nan_warnings": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_no_p_overwrite": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_no_postfix": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_no_py312_distutils_fcompiler": {
    "description": "Check that no distutils imports are performed on 3.12",
    "std_args": [
      "capfd",
      "hello_world_f90",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_no_r1postfix": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_no_r2postfix": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_no_side_effects": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_no_thousands_support": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dtype"
    ],
    "type": "function"
  },
  "test_no_trim": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_noaxis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_nolatexdoc": {
    "description": "Ensures that TeX documentation is written out",
    "std_args": [
      "capfd",
      "hello_world_f90",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_non_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_non_bool_deprecation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_non_contiguous_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "mode"
    ],
    "type": "function"
  },
  "test_non_finite": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_non_finite_any_nan": {
    "description": "test that nans are propagated",
    "std_args": [
      "self",
      "sc"
    ],
    "type": "function"
  },
  "test_non_finite_behavior_exact_x": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_non_finite_half_inf_f": {
    "description": "Test interp where the f axis has a bound at inf",
    "std_args": [
      "self",
      "sc"
    ],
    "type": "function"
  },
  "test_non_finite_half_inf_x": {
    "description": "Test interp where the x axis has a bound at inf",
    "std_args": [
      "self",
      "sc"
    ],
    "type": "function"
  },
  "test_non_finite_half_inf_xf": {
    "description": "Test that interp where both axes have a bound at inf gives nan",
    "std_args": [
      "self",
      "sc"
    ],
    "type": "function"
  },
  "test_non_finite_inf": {
    "description": "Test that interp between opposite infs gives nan",
    "std_args": [
      "self",
      "sc"
    ],
    "type": "function"
  },
  "test_non_iterable": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_non_masked": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_non_numeric": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_non_spawnable": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_non_square_handling": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "a",
      "axes"
    ],
    "type": "function"
  },
  "test_noncentral_chisquare": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_noncentral_f": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_noncentral_f_nan": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_noncentral_f_small_df": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_none_as_string": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_noninstantized_bitgen": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_nonnumeric_object_coefficients": {
    "description": "Test coef fallback for object arrays of non-numeric coefficients.",
    "std_args": [
      "coefs",
      "tgt"
    ],
    "type": "function"
  },
  "test_nonsq_cases": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_nonzero": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_norestexdoc": {
    "description": "Ensures that TeX documentation is written out",
    "std_args": [
      "capfd",
      "hello_world_f90",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_norm_object_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_norm_vector_badarg": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_normal": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_normal_0": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_normal_floats": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_normal_zig_floats": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_noshink_on_creation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_noshrinking": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_notPublicPrivate": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tmp_path"
    ],
    "type": "function"
  },
  "test_not_an_filelike": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_not_an_iter": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_not_closing_opened_fid": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_not_equal": {
    "description": "The class representing a Python function.",
    "std_args": [
      "Poly"
    ],
    "type": "function"
  },
  "test_not_equal_nan": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_not_last_axis_success": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_notimplemented": {
    "description": "Check that 'not implemented' operations produce a failure.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_novalue": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_novariance": {
    "description": "Check that methods handle no variance in data",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_nowrap_private_proceedures": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tmp_path"
    ],
    "type": "function"
  },
  "test_nowrapfunc": {
    "description": "Ensures that fortran subroutine wrappers for F77 can be disabled",
    "std_args": [
      "capfd",
      "hello_world_f90",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_npd_arch": {
    "description": "CLI :: -c --arch",
    "std_args": [],
    "type": "function"
  },
  "test_npd_compiler": {
    "description": "CLI :: -c --compiler",
    "std_args": [],
    "type": "function"
  },
  "test_npd_debug": {
    "description": "CLI :: -c --debug",
    "std_args": [],
    "type": "function"
  },
  "test_npd_define": {
    "description": "CLI :: -D<define>",
    "std_args": [],
    "type": "function"
  },
  "test_npd_f77exec": {
    "description": "CLI :: -c --f77exec",
    "std_args": [],
    "type": "function"
  },
  "test_npd_f77flags": {
    "description": "CLI :: -c --f77flags",
    "std_args": [],
    "type": "function"
  },
  "test_npd_f90exec": {
    "description": "CLI :: -c --f90exec",
    "std_args": [],
    "type": "function"
  },
  "test_npd_f90flags": {
    "description": "CLI :: -c --f90flags",
    "std_args": [],
    "type": "function"
  },
  "test_npd_fcompiler": {
    "description": "CLI :: -c --fcompiler",
    "std_args": [],
    "type": "function"
  },
  "test_npd_help_fcompiler": {
    "description": "CLI :: -c --help-fcompiler",
    "std_args": [],
    "type": "function"
  },
  "test_npd_incl": {
    "description": "CLI :: -I/path/to/include/",
    "std_args": [],
    "type": "function"
  },
  "test_npd_lib": {
    "description": "CLI :: -c -L/path/to/lib/ -l<libname>",
    "std_args": [],
    "type": "function"
  },
  "test_npd_link_auto": {
    "description": "CLI :: -c --link-<resource>",
    "std_args": [],
    "type": "function"
  },
  "test_npd_linker": {
    "description": "CLI :: <filename>.o <filename>.so <filename>.a",
    "std_args": [],
    "type": "function"
  },
  "test_npd_noarch": {
    "description": "CLI :: -c --noarch",
    "std_args": [],
    "type": "function"
  },
  "test_npd_noopt": {
    "description": "CLI :: -c --noopt",
    "std_args": [],
    "type": "function"
  },
  "test_npd_opt": {
    "description": "CLI :: -c --opt",
    "std_args": [],
    "type": "function"
  },
  "test_npd_undefine": {
    "description": "CLI :: -U<name>",
    "std_args": [],
    "type": "function"
  },
  "test_npdistop": {
    "description": "CLI :: -c",
    "std_args": [
      "hello_world_f90",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_npzfile_dict": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_nul_character_error": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dtype"
    ],
    "type": "function"
  },
  "test_null_character": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_num_chars_is_linewidth": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_numba": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_numeric_object_coefficients": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_numpy_fft": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_numpy_linalg": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_numpy_namespace": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_numpy_ravel": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_numpy_ravel_order": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_numpy_reloading": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_numpy_state": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_numpy_version_attribute": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_numpyarithmetic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_object": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_object_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_object_array_of_0d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_object_cleanup_on_read_error": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_object_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_object_input": {
    "description": "The class representing a Python function.",
    "std_args": [
      "mode"
    ],
    "type": "function"
  },
  "test_object_no_weights": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_object_scalar_multiply": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_object_with_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_objects": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_oddfeatures_1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_oddfeatures_2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_oddfeatures_3": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_on_ndarray": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_one_arg_funcs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_one_bin": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_one_off": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_one_relevant_space": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ones": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_onintegers_with_mask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_openblas_threading": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_operate_4d_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_operations": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_operator": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_opt_out": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_optinfo_forward_propagation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_optinfo_propagation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_optional": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_optional_from_23seq": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_optional_from_2seq": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_optional_none": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_order": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_other_delimiter": {
    "description": "Test LineSplitter on delimiter",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_otypes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_otypes_object_28624": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_out": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "weighted"
    ],
    "type": "function"
  },
  "test_out_1d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_out_dtype_error": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_out_nan": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_out_size_mismatch": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_outer_join": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_outlier": {
    "description": "Check the FD, Scott and Doane with outliers.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_outliers": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_output": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_output_fill": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_output_fill_error": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_output_filling_exponential": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_output_filling_gamma": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_output_filling_gamma_broadcast": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_output_filling_uniform": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_overflow": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "arr"
    ],
    "type": "function"
  },
  "test_overlapping": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_overwrite": {
    "description": "Ensures that the build directory can be specified",
    "std_args": [
      "capfd",
      "hello_world_f90",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_overwrite_keyword": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_p_extremely_small": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_p_is_nan": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_p_non_contiguous": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_p_zero_stream": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_pack_unpack_order": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_packbits": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_packbits_empty": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_packbits_empty_with_axis": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_packbits_large": {
    "description": "The class representing a Python function.",
    "std_args": [
      "bitorder"
    ],
    "type": "function"
  },
  "test_packbits_very_large": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_pad_dict_pad_width": {
    "description": "The class representing a Python function.",
    "std_args": [
      "input_shape",
      "pad_width",
      "expected_shape"
    ],
    "type": "function"
  },
  "test_pad_empty_dimension": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_pad_non_empty_dimension": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "mode"
    ],
    "type": "function"
  },
  "test_pad_width_as_ndarray": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_pad_with_zero": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_padded_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_padded_union": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_pandas_duck": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_param_eval_empty_range": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_param_eval_nested": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_param_eval_non_array_param": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_param_eval_nonstandard_range": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_param_eval_too_many_dims": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_parametric_unit_discovery": {
    "description": "Check that the correct unit (e.g. month, day, second) is discovered from",
    "std_args": [
      "generic_data",
      "long_datum",
      "unitless_dtype",
      "expected_dtype",
      "nrows"
    ],
    "type": "function"
  },
  "test_pareto": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_parse_abstract_interface": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_parse_gufunc_signature": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_partial": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_partition_matrix_none": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_pass": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_pass_through": {
    "description": "Test if `x` already matching desired output are passed through.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_passes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_passthrough": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_pep338": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_percentile_empty_dim": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_percentile_gh_29003": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "qtype",
      "method"
    ],
    "type": "function"
  },
  "test_percentile_gh_29003_Fraction": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_percentile_list": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_percentile_no_overwrite": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_percentile_out": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "percentile",
      "with_weights"
    ],
    "type": "function"
  },
  "test_percentile_overwrite": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_period": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_permutation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_permutation_custom_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_permutation_exceptions": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_permutation_subclass": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_permuted": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype",
      "axis",
      "expected"
    ],
    "type": "function"
  },
  "test_permuted_empty": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_permuted_not_writeable": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_permuted_out_with_wrong_shape": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "outshape"
    ],
    "type": "function"
  },
  "test_permuted_out_with_wrong_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_permuted_with_strides": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_pickle": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_pickle_disallow": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tmpdir"
    ],
    "type": "function"
  },
  "test_pickle_preserves_seed_sequence": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_pickle_python2_python3": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_pickling": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_pickling_keepalignment": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_pickling_maskedconstant": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_pickling_subbaseclass": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_pickling_wstructured": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_pinv": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_pinv_rtol_arg": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_pkg_config_config_exists": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_pkg_config_entrypoint": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_place": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_pointer": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_poisson": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_poisson_exceptions": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_poly": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_poly1d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_poly1d_math": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_poly1d_misc": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "type_code"
    ],
    "type": "function"
  },
  "test_poly1d_nan_roots": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_poly1d_resolution": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_poly1d_str_and_repr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_poly1d_variable_arg": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_poly2cheb": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_poly2herm": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_poly2herme": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_poly2lag": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_poly2leg": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_poly_coeffs_mutable": {
    "description": "Coefficients should be modifiable",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_poly_div": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_poly_eq": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_poly_int_overflow": {
    "description": "Regression test for gh-5096.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polyadd": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polyder": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polyder_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polyder_return_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polydiv": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polydiv_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polydomain": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polyfit": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polyfit_build": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polyfit_with_masked_NaNs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polyfromroots": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polygrid2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polygrid2d_array_function_hook": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_polygrid3d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polyint": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polyint_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polyint_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polyline": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polyline_zero": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polymul": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "rhs"
    ],
    "type": "function"
  },
  "test_polymulx": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polynomial_atoms": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polynomial_mapdomain": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_polynomial_repr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polynomial_str": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "inp",
      "tgt"
    ],
    "type": "function"
  },
  "test_polynomial_str_domains": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polyone": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polypow": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polyroots": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polysub": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polytrim": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polyval": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polyval2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polyval2d_array_function_hook": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_polyval3d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polyvalfromroots": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polyvander": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polyvander2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polyvander3d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polyvandernegdeg": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polyx": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_polyzero": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_posinf": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_posinf_scalar": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_positional_regression_9477": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_pow": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_pow_too_large": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_power": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_power_is_minus_one": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dt"
    ],
    "type": "function"
  },
  "test_power_is_one": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dt"
    ],
    "type": "function"
  },
  "test_power_is_two": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dt"
    ],
    "type": "function"
  },
  "test_power_is_zero": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dt"
    ],
    "type": "function"
  },
  "test_power_with_broadcasting": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_precision": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_prepend": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_preserve_subclass": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_process_f2cmap_dict": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_prod": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_prod_object": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_property": {
    "description": "'symbol' attribute is read only.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ptp": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_pure_subclass_info_preservation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_put": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_put_hardmask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_put_nomask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_putmask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_py3_compat": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_python2_python3_interoperability": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_pytype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_pyyaml_not_found": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "mock_yaml_importer"
    ],
    "type": "function"
  },
  "test_q_zero_one": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "method"
    ],
    "type": "function"
  },
  "test_qr_empty": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "m",
      "n"
    ],
    "type": "function"
  },
  "test_qr_mode_full_future_warning": {
    "description": "Check mode='full' FutureWarning.",
    "std_args": [],
    "type": "function"
  },
  "test_quad_precision": {
    "description": "Test kind_func for quadruple precision [`real(16)`] of 32+ digits .",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_quantile_add_and_multiply_constant": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "weights",
      "method",
      "alpha"
    ],
    "type": "function"
  },
  "test_quantile_constant_weights": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "method",
      "alpha"
    ],
    "type": "function"
  },
  "test_quantile_gh_29003_Fraction": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_quantile_identification_equation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "weights",
      "method",
      "alpha"
    ],
    "type": "function"
  },
  "test_quantile_monotonic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "method"
    ],
    "type": "function"
  },
  "test_quantile_monotonic_hypo": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "arr"
    ],
    "type": "function"
  },
  "test_quantile_preserve_int_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype"
    ],
    "type": "function"
  },
  "test_quantile_scalar_nan": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_quantile_weights_min_max": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "method"
    ],
    "type": "function"
  },
  "test_quantile_weights_raises_negative_weights": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_quantile_weights_raises_unsupported_methods": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "method"
    ],
    "type": "function"
  },
  "test_quantile_with_integer_weights": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "method",
      "alpha"
    ],
    "type": "function"
  },
  "test_quantile_with_weights_and_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "method"
    ],
    "type": "function"
  },
  "test_quiet": {
    "description": "Reduce verbosity",
    "std_args": [
      "capfd",
      "hello_world_f90",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_quote_support_default": {
    "description": "Support for quoted fields is disabled by default.",
    "std_args": [],
    "type": "function"
  },
  "test_quotechar_multichar_error": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_quoted_character": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_quoted_field": {
    "description": "The class representing a Python function.",
    "std_args": [
      "q"
    ],
    "type": "function"
  },
  "test_quoted_field_is_not_empty": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_quoted_field_is_not_empty_nonstrict": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_quoted_field_with_whitepace_delimiter": {
    "description": "The class representing a Python function.",
    "std_args": [
      "q"
    ],
    "type": "function"
  },
  "test_radd": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "rhs"
    ],
    "type": "function"
  },
  "test_ragged_error": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_ragged_shuffle": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_ragged_usecols": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_raises": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_rand": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_rand_singleton": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_randint": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_randint_117": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_randn": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_randn_singleton": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_random": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_random_distribution_of_lsb": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype",
      "uint_view_type"
    ],
    "type": "function"
  },
  "test_random_float": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_random_float_scalar": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_random_integers": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_random_integers_deprecated": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_random_integers_max_int": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_random_raw": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_random_sample": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_random_unsupported_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_randomstate_ctor_old_style_pickle": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_rank2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_rank3": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ravel": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ravel_order": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "order",
      "data_order"
    ],
    "type": "function"
  },
  "test_raw": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_rayleigh": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_rayleigh_0": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_rcond": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_rdivmod": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "rhs"
    ],
    "type": "function"
  },
  "test_read_array_header_1_0": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_read_array_header_2_0": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_read_from_bad_generator": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_read_from_generator": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_read_from_generator_multitype": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_read_huge_row": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_read_magic": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_read_magic_bad_magic": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_read_version_1_0_bad_magic": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_real": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_recarrays": {
    "description": "Test record arrays.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_recfromcsv": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "filename_type"
    ],
    "type": "function"
  },
  "test_recfromtxt": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "filename_type"
    ],
    "type": "function"
  },
  "test_record": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_record_2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_record_3": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_record_array_with_object_field": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_record_unicode": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "path_type"
    ],
    "type": "function"
  },
  "test_reduce": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_reduced_rank": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_refcount_vectorize": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_reference_cycles": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_reference_data": {
    "description": "Check that SeedSequence generates data the same as the C++ reference.",
    "std_args": [],
    "type": "function"
  },
  "test_reference_types": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_reflected_binary_methods": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_regex": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_regression": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "weighted"
    ],
    "type": "function"
  },
  "test_regression_1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_regression_size_1_index": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_rename_fields": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_renamed_subroutine": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_repack_fields": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_repeatability": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_repeatability1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_repeatability2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_repeatability3": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_repeatability_32bit_boundary": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "bound",
      "expected"
    ],
    "type": "function"
  },
  "test_repeatability_32bit_boundary_broadcasting": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_repeatability_broadcasting": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "endpoint"
    ],
    "type": "function"
  },
  "test_repeated_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_repeated_input": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_repeated_wrapping": {
    "description": "Check wrapping on each side individually if the wrapped area is longer",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_repeated_wrapping_multiple_origin": {
    "description": "Assert that 'wrap' pads only with multiples of the original area if",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_replace_max": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_replace_space": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_replace_space_known_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_repmat": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_report_fail_percentage": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_report_max_relative_error": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_repr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_repr_lists_keys": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "count",
      "expected_repr"
    ],
    "type": "function"
  },
  "test_reset_state": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_reset_state_float": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_reset_state_gauss": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_reset_state_uint32": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_reshape": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_respect_dtype_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "endpoint"
    ],
    "type": "function"
  },
  "test_respect_dtype_singleton": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_restdoc": {
    "description": "Ensures that RsT documentation is written out",
    "std_args": [
      "capfd",
      "hello_world_f90",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_result_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_result_values": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "weighted",
      "use_out"
    ],
    "type": "function"
  },
  "test_return": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_return_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_return_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_returned": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_returntype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_reveal": {
    "description": "Validate that mypy correctly infers the return-types of",
    "std_args": [
      "path"
    ],
    "type": "function"
  },
  "test_reverse": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_rfft": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_rfft2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_rfft_even": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_rfft_odd": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_rfftn": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_right_basic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_right_left_behavior": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_right_open": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_right_open_random": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_right_open_reverse": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_rightmost_binedge": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_rmul": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "rhs"
    ],
    "type": "function"
  },
  "test_rng_zero_and_extremes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_rng_zero_and_extremes_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "endpoint"
    ],
    "type": "function"
  },
  "test_roots": {
    "description": "The class representing a Python function.",
    "std_args": [
      "Poly"
    ],
    "type": "function"
  },
  "test_rotation_axes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_round": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_round_with_output": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_round_with_scalar": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_roundtrip": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_roundtrip_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "bitorder",
      "count"
    ],
    "type": "function"
  },
  "test_roundtrip_randsize": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_roundtrip_truncated": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_row_column_indexing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_rscalarmul": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_rsub": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "rhs"
    ],
    "type": "function"
  },
  "test_s_axes_none": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "op"
    ],
    "type": "function"
  },
  "test_s_axes_none_2D": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "op"
    ],
    "type": "function"
  },
  "test_s_contains_none": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "op"
    ],
    "type": "function"
  },
  "test_s_negative_1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "op"
    ],
    "type": "function"
  },
  "test_same": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_same_as_ufunc": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_same_input_shapes": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_same_name_different_dtypes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_same_name_different_dtypes_key": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_same_prepend_append": {
    "description": "Test that appended and prepended values are equal",
    "std_args": [
      "self",
      "mode"
    ],
    "type": "function"
  },
  "test_sandboxing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tmp_path"
    ],
    "type": "function"
  },
  "test_sanity": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_save_load": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_save_load_memmap": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_save_load_memmap_readwrite": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "filename_type"
    ],
    "type": "function"
  },
  "test_savez_compressed_load": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "filename_type"
    ],
    "type": "function"
  },
  "test_savez_filename_clashes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_savez_load": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "filename_type"
    ],
    "type": "function"
  },
  "test_savez_nopickle": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_scalar": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_scalar_arithmetic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_scalar_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "cls"
    ],
    "type": "function"
  },
  "test_scalar_array_equiv": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "endpoint"
    ],
    "type": "function"
  },
  "test_scalar_domains_three_conditions": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_scalar_exception_propagation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_scalar_indexing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_scalar_interpolation_point": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_scalar_q": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_scalar_type_pow": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_scalarmul": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_scientific_notation": {
    "description": "Test that both 'e' and 'E' are parsed correctly.",
    "std_args": [],
    "type": "function"
  },
  "test_scott_vs_stone": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_sdot_bug_8577": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_second_order_accurate": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_seed": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_seed_alt_bit_gen": {
    "description": "The class representing a Python function.",
    "std_args": [
      "restore_singleton_bitgen"
    ],
    "type": "function"
  },
  "test_seed_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_seed_float_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_seedsequence": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_segmentation_fault": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_sequence": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_set_default_printoptions": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_set_element_as_object": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_set_elements": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_set_fields": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_set_fields_mask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_set_fill_value_unicode_py3": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_set_invalid_state": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_set_key": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_set_mask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_set_mask_fromarray": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_set_mask_fromfields": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_set_record_element": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_set_record_slice": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_set_records_masks": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_setdiff1d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_setdiff1d_char_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_setdiff1d_unique": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_setitem": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_setitem_no_warning": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_setitem_scalar": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_setslices_hardmask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_setting_fill_value_attribute": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_setxor1d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_setxor1d_unique": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_shallow_statistic_range": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "mode"
    ],
    "type": "function"
  },
  "test_shape": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_shape_3d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_shape_4d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_shape_and_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_shape_argument": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_shape_scalar": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_shaped_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_short_version": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_shortlatex": {
    "description": "Ensures that truncated documentation is written out",
    "std_args": [
      "capfd",
      "hello_world_f90",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_shrink_mask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_shuffle": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_shuffle_axis_nonsquare": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_shuffle_custom_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_shuffle_custom_axis_empty": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_shuffle_exceptions": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_shuffle_masked": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_shuffle_memoryview": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_shuffle_mixed_dimension": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_shuffle_no_object_unpacking": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "random",
      "use_array_like"
    ],
    "type": "function"
  },
  "test_shuffle_not_writeable": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_shuffle_of_array_of_different_length_strings": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_shuffle_of_array_of_objects": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_shuffle_untyped_warning": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "random"
    ],
    "type": "function"
  },
  "test_signature_center": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_signature_computed_size": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_signature_excluded": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_signature_invalid_inputs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_signature_invalid_outputs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_signature_match": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "nan_func",
      "func"
    ],
    "type": "function"
  },
  "test_signature_mean_last": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_signature_otypes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_signature_otypes_decorator": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_signature_outer": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_signature_simple": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_signature_two_outputs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_signed_integer_data": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "bins"
    ],
    "type": "function"
  },
  "test_signed_overflow_bounds": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_simple": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_simple101": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_simple2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_simple_0d_arrays": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_simple_1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_simple_arrays": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_simple_flexible": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_simple_item": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_simple_items": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_simple_items_and_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_simple_polynomial": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_simple_range": {
    "description": "Straightforward testing with a mixture of linspace data (for",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_simple_stat_length": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_simple_weight": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_simple_weight2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_simple_weighted": {
    "description": "Check that weighted data raises a TypeError",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_single": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_single_arg_integer_exception": {
    "description": "The class representing a Python function.",
    "std_args": [
      "high",
      "endpoint"
    ],
    "type": "function"
  },
  "test_single_dtype_w_explicit_names": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_single_dtype_w_implicit_names": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_single_dtype_wo_names": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_single_element_subscript": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_single_input": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_single_item_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "indexer"
    ],
    "type": "function"
  },
  "test_single_item_array_non_int": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_single_line_one_less": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_single_non_masked_value_on_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_single_value": {
    "description": "Test casting for a single value.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_singlerecord": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_singular": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_size": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_size_zero": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_size_zero_output": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_skip_footer": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_skip_footer_with_invalid": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_skiprow_exceeding_maxrows_exceeding_chunksize": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tmpdir",
      "nskip"
    ],
    "type": "function"
  },
  "test_skiprows": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_slices": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_small": {
    "description": "Smaller datasets have the potential to cause issues with the data",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_small_large": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_small_value_range": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_smallmask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_solo": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_solo_w_flatten": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_some_nan_values": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_sort": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_sort_2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_sort_complex": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_sort_flexible": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_sort_matrix_none": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_sort_real": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "type_in",
      "type_out"
    ],
    "type": "function"
  },
  "test_space_delimiter": {
    "description": "Test space delimiter",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_spacedelimiter": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_spacing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_sparse": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_special": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_specific_axes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_sq_cases": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_squeeze": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_squeeze_scalar": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_stable_sort": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_stack": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_stack_1d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_stack_masks": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_stack_nd": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_stacked_inputs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "outer_size",
      "size",
      "dt"
    ],
    "type": "function"
  },
  "test_stacked_singular": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_standard": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_standard_cauchy": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_standard_expoential_type_error": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_standard_exponential": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_standard_exponential_float": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_standard_exponential_float_log": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_standard_gamma": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_standard_gamma_0": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_standard_gamma_float": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_standard_gamma_unknown_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_standard_gammma_float_out": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_standard_gammma_scalar_float": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_standard_normal": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_standard_normal_unsupported_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_standard_normal_zig": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_standard_t": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_state_error_alt_bit_gen": {
    "description": "The class representing a Python function.",
    "std_args": [
      "restore_singleton_bitgen"
    ],
    "type": "function"
  },
  "test_state_setting": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_state_tuple": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_str": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_str_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_str_dtype_unit_discovery_with_converter": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_str_leading_zeros": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_str_repr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_str_repr_legacy": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_strict": {
    "description": "Test the behavior of the `strict` option.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_strided": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_string_arrays": {
    "description": "Test two arrays with different shapes are found not equal.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_string_callback": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_string_callback_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_string_dtype_default_fill_value": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_string_dtype_fill_value_on_construction": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_string_dtype_fill_value_persists_through_slice": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_string_no_length_given": {
    "description": "The given dtype is just 'S' or 'U' with no length. In these cases, the",
    "std_args": [
      "given_dtype",
      "expected_dtype"
    ],
    "type": "function"
  },
  "test_string_ticket_1892": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_string_to_object": {
    "description": "Make sure that string-to-object functions are properly recognized",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_stringload": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_strings": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_struct_array_pointer": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_structure": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_structure_aligned": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_structured": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_structured_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_structured_dtype_and_skiprows_no_empty_lines": {
    "description": "The class representing a Python function.",
    "std_args": [
      "skiprows"
    ],
    "type": "function"
  },
  "test_structured_dtype_offsets": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_structured_dtype_with_multi_shape": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_structured_dtype_with_quotes": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_structured_dtype_with_shape": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_structured_padded": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_structured_to_unstructured": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tmp_path"
    ],
    "type": "function"
  },
  "test_sub": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "rhs"
    ],
    "type": "function"
  },
  "test_subarray": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_subarray_fillvalue": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_subarray_key": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_subclass": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_subclass2": {
    "description": "Check that we return subclasses, even if a NaN scalar.",
    "std_args": [
      "self",
      "arr"
    ],
    "type": "function"
  },
  "test_subclass_2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_subclass_items": {
    "description": "test that getter and setter go via baseclass",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_subclass_nomask_items": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_subclass_preservation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_subclass_repr": {
    "description": "test that repr uses the name of the subclass",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_subclass_str": {
    "description": "test str with subclass that has overridden str, setitem",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_subclass_that_cannot_be_bool": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_subclass_that_does_not_implement_npall": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_subclass_that_overrides_eq": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_subclasses": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_subclasspreservation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_subdtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_subok": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_substitute": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_sum": {
    "description": "Test whether matrix.sum(axis=1) preserves orientation.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_sum_object": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_suppress_overflow_warnings": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_suppress_warnings_decorate_no_record": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_suppress_warnings_forwarding": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_suppress_warnings_record": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_suppress_warnings_type": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_svd_build": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_svd_no_uv": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_svdvals": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_swap_worked": {
    "description": "The class representing a Python function.",
    "std_args": [
      "restore_singleton_bitgen"
    ],
    "type": "function"
  },
  "test_swapaxes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_swapped_singleton_against_direct": {
    "description": "The class representing a Python function.",
    "std_args": [
      "restore_singleton_bitgen"
    ],
    "type": "function"
  },
  "test_switch_to_exp": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_symbol": {
    "description": "The class representing a Python function.",
    "std_args": [
      "poly",
      "tgt"
    ],
    "type": "function"
  },
  "test_symbol_bad_input": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "bad_input",
      "exception"
    ],
    "type": "function"
  },
  "test_symbol_basic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_symmetric_rank": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_tab_delimiter": {
    "description": "Test tab delimiter",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_take": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_take_masked_indices": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_tall_matrix": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_tall_matrix_wrap": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_tempdir": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_temppath": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_tensordot": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_tensorinv_ind_limit": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "ind"
    ],
    "type": "function"
  },
  "test_tensorinv_result": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_tensorinv_shape": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "shape",
      "ind"
    ],
    "type": "function"
  },
  "test_tensorsolve_result": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "shape"
    ],
    "type": "function"
  },
  "test_testAPI": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testAddSumProd": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testArithmetic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testArrayAttributes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testArrayMethods": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testAverage1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testAverage2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testAverage3": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testAverage4": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testBasic1d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testBasic2d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "s"
    ],
    "type": "function"
  },
  "test_testCI": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testCopySize": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testInplace": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testMaPut": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testMasked": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testMinMax": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testMinMax2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testMixedArithmetic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testOddFeatures": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testPickle": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testPut": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testPut2": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testScalarArithmetic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testSingleElementSubscript": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testTakeTransposeInnerOuter": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testToPython": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testUfuncRegression": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_testUfuncs1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_threadsafety": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_three_arg_funcs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_three_arguments_and_out": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_tile_one_repetition_on_array_gh4679": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_timedelta": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_timedelta64": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_times": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_toflex": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_tolist": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_tolist_specialcase": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_tomaxint": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_too_few_input_arrays": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_topython": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_tostring_c": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_tostring_fortran": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_trace": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_trailing_skip": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_transpose": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_transpose_view": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_traverse": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_treatment_of_NotImplemented": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_triangular": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_tricky_converter_bug1666": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_tril_indices": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_tril_triu_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_tril_triu_ndim2": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_tril_triu_ndim3": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_tril_triu_with_inf": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_trim": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_trim_arg": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_trimcoef": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_trimseq": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_trimseq_empty_input": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_triu_indices": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_truediv": {
    "description": "The class representing a Python function.",
    "std_args": [
      "Poly"
    ],
    "type": "function"
  },
  "test_truncate": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_tuple_func1d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_tuple_getitem_raises": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_two_arg_funcs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_two_arguments_and_out": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_two_compatible_by_ones_input_shapes": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_two_compatible_by_prepending_ones_input_shapes": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_two_conditions": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_two_keys_two_vars": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_two_values": {
    "description": "Test proper casting for two different values.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_types": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype"
    ],
    "type": "function"
  },
  "test_typical_cases": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "nsample",
      "method",
      "size"
    ],
    "type": "function"
  },
  "test_ufunc": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ufunc_at": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ufunc_nomask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ufunc_override": {
    "description": "The class representing a Python function.",
    "std_args": [
      "Poly"
    ],
    "type": "function"
  },
  "test_ufunc_two_outputs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_ufunc_with_out_varied": {
    "description": "Test that masked arrays are immune to gh-10459",
    "std_args": [],
    "type": "function"
  },
  "test_ufunc_with_output": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_uint64": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_uint64_dtype": {
    "description": "Check that uint64 integer types can be specified",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_uint64_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_uint_fill_value_and_filled": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_unary_methods": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unequal_split": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_uneven_dims": {
    "description": "Test 2D input, which has uneven dimension sizes",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unexpected_trim_value": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "trim"
    ],
    "type": "function"
  },
  "test_unicode": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unicode_and_bytes_fmt": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "iotype"
    ],
    "type": "function"
  },
  "test_unicode_bytestream": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unicode_field_names": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tmpdir"
    ],
    "type": "function"
  },
  "test_unicode_mode": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_unicode_roundtrip": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unicode_stringstream": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unicode_whitespace_stripping": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dtype"
    ],
    "type": "function"
  },
  "test_unicode_whitespace_stripping_complex": {
    "description": "The class representing a Python function.",
    "std_args": [
      "dtype"
    ],
    "type": "function"
  },
  "test_unicode_with_converter": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_uniform": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_uniform_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_uniform_double": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_uniform_float": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_uniform_neg_range": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_uniform_range_bounds": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_uniform_zero_range": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_union": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_union1d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unique_1d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unique_1d_with_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "axis"
    ],
    "type": "function"
  },
  "test_unique_allmasked": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unique_array_api_functions": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unique_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unique_axis0_equal_nan_on_1d_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unique_axis_errors": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unique_axis_float_raises_typeerror": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unique_axis_list": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unique_axis_minus1_eq_on_1d_array": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unique_axis_zeros": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unique_byte_string_hash_based": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unique_complex_signed_zeros": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dt",
      "values"
    ],
    "type": "function"
  },
  "test_unique_inverse_shape": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unique_inverse_with_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "axis"
    ],
    "type": "function"
  },
  "test_unique_masked": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unique_nanequals": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unique_onlist": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unique_onmaskedarray": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unique_sort_order_with_axis": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unique_subclass": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unique_unicode_string_hash_based": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unique_vstring_errors": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unique_vstring_hash_based_equal_nan": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unique_vstring_hash_based_not_equal_nan": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unique_with_matrix": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "data",
      "transpose",
      "dtype"
    ],
    "type": "function"
  },
  "test_unique_zero_sized": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unit_fweights_and_aweights": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_universal_newline": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_universal_newlines_quoted": {
    "description": "The class representing a Python function.",
    "std_args": [
      "newline"
    ],
    "type": "function"
  },
  "test_unknown_keyword_parameter": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unmatched_parenthesis_gh30268": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unnamed_and_named_fields": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unnamed_fields": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unpack_auto_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unpack_float_data": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unpack_single_name": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unpack_structured": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_unpackbits": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_unpackbits_empty": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_unpackbits_empty_with_axis": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_unpackbits_large": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_unsigned_monotonicity_check": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unstructured_to_structured": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unsupported_commontype": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_unsupported_hash_based": {
    "description": "These currently never use the hash-based solution.  However,",
    "std_args": [
      "self",
      "arg"
    ],
    "type": "function"
  },
  "test_unsupported_mode": {
    "description": "The class representing a Python function.",
    "std_args": [
      "mode"
    ],
    "type": "function"
  },
  "test_unsupported_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_untitled_cli": {
    "description": "Check that modules are named correctly",
    "std_args": [
      "capfd",
      "hello_world_f90",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_unused_converter": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unusual_order_negative_stride": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_unusual_order_positive_stride": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_upcasting": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_upgrade": {
    "description": "Tests the upgrade method.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_upgrademapper": {
    "description": "Tests updatemapper",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_upper_lower_arg": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_usecols": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_usecols_as_css": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_usecols_with_integer": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_usecols_with_named_columns": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_usecols_with_structured_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_user_filling_values": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_user_missing_values": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_userconverters_with_explicit_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_utf8_byte_encoding": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_utf8_file": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_utf8_file_nodtype_unicode": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_utf8_userconverters_with_explicit_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_vague_return_value": {
    "description": "Test that vague ndpointer return values do not promote to arrays",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_valid_numpy_version": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_valid_symbols": {
    "description": "Values for symbol that should pass input validation.",
    "std_args": [
      "self",
      "symbol"
    ],
    "type": "function"
  },
  "test_validate_nb_names": {
    "description": "Test validate nb names",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_validate_wo_names": {
    "description": "Test validate no names",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_values": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_vander_nd_exception": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_var": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_var_sets_maskedarray_scalar": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_variable_fixed_width": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_varmean_nomask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_varstd": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_varstd_ddof": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_varstd_specialcases": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_vector": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_vector_as_first_and_last_argument": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_vector_as_first_argument": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_vector_as_last_argument": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_vector_norm": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_vector_norm_empty": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_verbose": {
    "description": "Increase verbosity",
    "std_args": [
      "capfd",
      "hello_world_f90",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_version": {
    "description": "Ensure version",
    "std_args": [
      "capfd",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_version_1_point_10": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_version_2_0": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_version_2_0_memmap": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tmpdir"
    ],
    "type": "function"
  },
  "test_view": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_view_by_itself": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_view_flexible_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_view_simple_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_view_to_dtype_and_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_view_to_flexible_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_view_to_nothing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_view_to_simple_dtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_view_to_subdtype": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_view_to_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_void0d": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_void_coercion": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_vonmises": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_vonmises_large": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_vonmises_large_kappa": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "kappa"
    ],
    "type": "function"
  },
  "test_vonmises_large_kappa_range": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "mu",
      "kappa"
    ],
    "type": "function"
  },
  "test_vonmises_nan": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_vonmises_range": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_vonmises_small": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_w_shorter_flex": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_w_singlefield": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_wald": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_wald_nonnegative": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_warn": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_warn_len_equal_call_scenarios": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_warn_on_no_data": {
    "description": "Check that a UserWarning is emitted when no data is read from input.",
    "std_args": [
      "data",
      "ndmin",
      "usecols"
    ],
    "type": "function"
  },
  "test_warn_on_skipped_data": {
    "description": "The class representing a Python function.",
    "std_args": [
      "skiprows"
    ],
    "type": "function"
  },
  "test_warn_to_add_tests": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_warn_wrong_warning": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_warning_calls": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_warns_byteorder": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_weibull": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_weibull_0": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_weibull_fraction": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_weight": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_weight_and_input_dims_different": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_weights": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_where": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "dtype"
    ],
    "type": "function"
  },
  "test_where_broadcast": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_where_object": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_where_structured": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_where_structured_masked": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_where_type": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_where_with_masked_choice": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_where_with_masked_condition": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_wide_matrix": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_windows_os_sep": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "tmp_path"
    ],
    "type": "function"
  },
  "test_with_incorrect_minlength": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_with_iterable_object": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_with_masked_column_uniform": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_with_masked_column_various": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_with_minlength": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_with_minlength_and_weights": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_with_minlength_smaller_than_maxvalue": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_with_none": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_withmissing": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_withmissing_float": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_withnames": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_wmasked_arrays": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_wrapfunc_def": {
    "description": "Ensures that fortran subroutine wrappers for F77 are included by default",
    "std_args": [
      "capfd",
      "hello_world_f90",
      "monkeypatch"
    ],
    "type": "function"
  },
  "test_write_version": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_writeability": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_writeable": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_writeable_memoryview": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_writeback": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_wrong_ddof": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_x_decreasing_unsigned": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "x_dtype"
    ],
    "type": "function"
  },
  "test_x_signed_int_big_jump": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "x_dtype"
    ],
    "type": "function"
  },
  "test_xerbla_override": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_xtestCount": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_xy": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_zero": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_zero_dimensional_interpolation_point": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_zero_dims": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_zero_pad_width": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "pad_width",
      "mode"
    ],
    "type": "function"
  },
  "test_zero_padding": {
    "description": "Ensure that the implicit zero-padding does not cause problems.",
    "std_args": [],
    "type": "function"
  },
  "test_zero_padding_shortcuts": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "mode"
    ],
    "type": "function"
  },
  "test_zero_poly_dtype": {
    "description": "Regression test for gh-16354.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_zero_probability": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_zero_size": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "endpoint"
    ],
    "type": "function"
  },
  "test_zero_stat_length_invalid": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "mode"
    ],
    "type": "function"
  },
  "test_zero_stat_length_valid": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "mode"
    ],
    "type": "function"
  },
  "test_zeroes": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_zeros": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_zip_descr": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_zipf": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_zipf_a_near_1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_zipf_large_parameter": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "threads": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "threshold_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "throw_error": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "mess"
    ],
    "type": "class"
  },
  "time_major": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "timedelta64": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "tmp_static_cache": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "to": {
    "description": "Move and/or cast the parameters and buffers.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "to_dense": {
    "description": "Returns a dense block that is equivalent to the block mask.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "to_device": {
    "description": "Return a copy of the array on the specified device\n\nArgs:\n  device: :class:`~jax.Device` or :class:`~jax.sharding.Sharding`\n    to which the created array will be committed.\n  stream: not implemented, passing a non-None value will lead to an error.\nReturns:\n  copy of array placed on the specified device or devices.",
    "std_args": [
      "self",
      "device",
      "stream"
    ],
    "type": "function"
  },
  "to_empty": {
    "description": "Move the parameters and buffers to the specified device without copying storage.",
    "std_args": [
      "self",
      "device",
      "recurse"
    ],
    "type": "function"
  },
  "to_flat_state": {
    "description": "Convert state into flat state",
    "std_args": [
      "state"
    ],
    "type": "function"
  },
  "to_kwargs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "inputs",
      "kwargs",
      "device_id"
    ],
    "type": "function"
  },
  "to_linen": {
    "description": "Shortcut of `nnx.bridge.ToLinen` if user is not changing any of its default fields.",
    "std_args": [
      "nnx_class",
      "args",
      "metadata_fn",
      "name",
      "skip_rng",
      "abstract_init",
      "kwargs"
    ],
    "type": "function"
  },
  "to_linen_class": {
    "description": "Dynamically wraps an NNX module class into a Flax Linen module class.",
    "std_args": [
      "base_nnx_class",
      "base_metadata_fn",
      "base_skip_rng",
      "partial_kwargs"
    ],
    "type": "function"
  },
  "to_linen_var": {
    "description": "The class representing a Python function.",
    "std_args": [
      "vs"
    ],
    "type": "function"
  },
  "to_lojax": {
    "description": "The class representing a Python function.",
    "std_args": [
      "_",
      "hijax_var",
      "avals"
    ],
    "type": "function"
  },
  "to_nested_state": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "to_nnx__rngs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "to_nnx_var": {
    "description": "Convert a Linen variable to an NNX variable.",
    "std_args": [
      "col",
      "x"
    ],
    "type": "function"
  },
  "to_nnx_variable": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "to_opt_state": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tree"
    ],
    "type": "function"
  },
  "to_predicate": {
    "description": "Converts a Filter to a predicate function.",
    "std_args": [
      "filter"
    ],
    "type": "function"
  },
  "to_pure_dict": {
    "description": "Convert :class:`State` object into pure dictionary state.",
    "std_args": [
      "state",
      "extract_fn"
    ],
    "type": "function"
  },
  "to_quantized": {
    "description": "Return a :obj:`QuantizedLinear` layer that approximates this layer.",
    "std_args": [
      "self",
      "group_size",
      "bits",
      "mode"
    ],
    "type": "function"
  },
  "to_state": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "to_string": {
    "description": "Returns a string representation of the block mask. Quite nifty.",
    "std_args": [
      "self",
      "grid_size",
      "limit"
    ],
    "type": "function"
  },
  "to_tangent_aval": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "to_tangent_qdd": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "to_tree": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tree",
      "prefix",
      "split_fn",
      "map_non_graph_nodes",
      "ctxtag",
      "check_aliasing"
    ],
    "type": "function"
  },
  "tobytes": {
    "description": "Return the array data as a string containing the raw bytes in the array.",
    "std_args": [
      "self",
      "fill_value",
      "order"
    ],
    "type": "function"
  },
  "tofile": {
    "description": "Save a masked array to a file in binary format.",
    "std_args": [
      "self",
      "fid",
      "sep",
      "format"
    ],
    "type": "function"
  },
  "toflex": {
    "description": "Transforms a masked array into a flexible-type array.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "tolist": {
    "description": "Return the matrix as a (possibly nested) list.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "tomaxint": {
    "description": "tomaxint(size=None)",
    "std_args": [
      "self",
      "size"
    ],
    "type": "function"
  },
  "top_k": {
    "description": "Finds the top-k values and their indices in a tensor.\n\nArgs:\n    x: Input tensor.\n    k: An integer representing the number of top elements to retrieve.\n    sorted: A boolean indicating whether to sort the output in\n    descending order. Defaults to `True`.\n\nReturns:\n    A tuple containing two tensors. The first tensor contains the\n    top-k values, and the second tensor contains the indices of the\n    top-k values in the input tensor.\n\nExample:\n\n>>> x = keras.ops.convert_to_tensor([5, 2, 7, 1, 9, 3])\n>>> values, indices = top_k(x, k=3)\n>>> print(values)\narray([9 7 5], shape=(3,), dtype=int32)\n>>> print(indices)\narray([4 2 0], shape=(3,), dtype=int32)",
    "std_args": [
      "x",
      "k",
      "sorted"
    ],
    "type": "function"
  },
  "torch.utils": {
    "description": "Torch Utilities Namespace",
    "std_args": []
  },
  "torch.utils.data": {
    "description": "Torch Data Utilities Namespace",
    "std_args": []
  },
  "torecords": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "tostring": {
    "description": "Return a string representation of Expr.",
    "std_args": [
      "self",
      "parent_precedence",
      "language"
    ],
    "type": "function"
  },
  "total": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "trace_state": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "traced": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "track_running_stats": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "traditional": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "train": {
    "description": "Set the module in training mode.",
    "std_args": [
      "self",
      "mode"
    ],
    "type": "function"
  },
  "train_mode": {
    "description": "Creates a new node set to training mode.",
    "std_args": [
      "node",
      "only",
      "kwargs"
    ],
    "type": "function"
  },
  "trainable_parameter_filter": {
    "description": "The class representing a Python function.",
    "std_args": [
      "module",
      "key",
      "value"
    ],
    "type": "function"
  },
  "trainable_parameters": {
    "description": "Recursively return all the non frozen :class:`mlx.core.array` members of",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "training": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "transfer_parametrizations_and_params": {
    "description": "Transfer parametrizations and the parameters they parametrize from :attr:`from_module` to :attr:`to_module`.",
    "std_args": [
      "from_module",
      "to_module",
      "tensor_name"
    ],
    "type": "function"
  },
  "transform_bounding_boxes": {
    "description": "",
    "std_args": [
      "self",
      "bounding_boxes",
      "transformation",
      "training"
    ],
    "type": "function"
  },
  "transform_images": {
    "description": "",
    "std_args": [
      "self",
      "images",
      "transformation",
      "training"
    ],
    "type": "function"
  },
  "transform_labels": {
    "description": "",
    "std_args": [
      "self",
      "labels",
      "transformation",
      "training"
    ],
    "type": "function"
  },
  "transform_metadata": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "transform_segmentation_masks": {
    "description": "",
    "std_args": [
      "self",
      "segmentation_masks",
      "transformation",
      "training"
    ],
    "type": "function"
  },
  "transform_single_bounding_box": {
    "description": "",
    "std_args": [
      "self",
      "bounding_box",
      "transformation",
      "training"
    ],
    "type": "function"
  },
  "transform_single_image": {
    "description": "",
    "std_args": [
      "self",
      "image",
      "transformation",
      "training"
    ],
    "type": "function"
  },
  "transform_single_label": {
    "description": "",
    "std_args": [
      "self",
      "label",
      "transformation",
      "training"
    ],
    "type": "function"
  },
  "transform_single_segmentation_mask": {
    "description": "",
    "std_args": [
      "self",
      "segmentation_mask",
      "transformation",
      "training"
    ],
    "type": "function"
  },
  "transpose_kernel": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "trapezoid": {
    "description": "Integrate along the given axis using the composite trapezoidal rule.\n\nArgs:\n    y: Input tensor.\n    x: Optional tensor specifying sample points corresponding to `y`.\n       If `None`, spacing is assumed to be `dx`.\n    dx: Spacing between sample points when `x` is `None`.\n    axis: Axis along which to integrate. Default is the last axis.\n\nReturns:\n    The approximate integral of `y` along the given axis.\n\nExample:\n>>> y = keras.ops.convert_to_tensor([[1, 2, 3], [4, 5, 6]])\n>>> keras.ops.trapezoid(y, axis=1)\narray([ 4., 10.], dtype=float32)",
    "std_args": [
      "y",
      "x",
      "dx",
      "axis"
    ],
    "type": "function"
  },
  "traverse": {
    "description": "Traverse expression tree with visit function.",
    "std_args": [
      "self",
      "visit",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "tree_add_scalar_mul": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tree_l1_norm": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tree_l2_norm": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tree_linf_norm": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tree_map_params": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tree_node_args": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tree_scalar_mul": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "treedef": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tri": {
    "description": "Return an array with ones on and below the diagonal and zeros elsewhere.\n\nJAX implementation of :func:`numpy.tri`\n\nArgs:\n  N: int. Dimension of the rows of the returned array.\n  M: optional, int. Dimension of the columns of the returned array. If not\n    specified, then ``M = N``.\n  k: optional, int, default=0. Specifies the sub-diagonal on and below which\n    the array is filled with ones. ``k=0`` refers to main diagonal, ``k<0``\n    refers to sub-diagonal below the main diagonal and ``k>0`` refers to\n    sub-diagonal above the main diagonal.\n  dtype: optional, data type of the returned array. The default type is float.\n\nReturns:\n  An array of shape ``(N, M)`` containing the lower triangle with elements\n  below the sub-diagonal specified by ``k`` are set to one and zero elsewhere.\n\nSee also:\n  - :func:`jax.numpy.tril`: Returns a lower triangle of an array.\n  - :func:`jax.numpy.triu`: Returns an upper triangle of an array.\n\nExamples:\n  >>> jnp.tri(3)\n  Array([[1., 0., 0.],\n         [1., 1., 0.],\n         [1., 1., 1.]], dtype=float32)\n\n  When ``M`` is not equal to ``N``:\n\n  >>> jnp.tri(3, 4)\n  Array([[1., 0., 0., 0.],\n         [1., 1., 0., 0.],\n         [1., 1., 1., 0.]], dtype=float32)\n\n  when ``k>0``:\n\n  >>> jnp.tri(3, k=1)\n  Array([[1., 1., 0.],\n         [1., 1., 1.],\n         [1., 1., 1.]], dtype=float32)\n\n  When ``k<0``:\n\n  >>> jnp.tri(3, 4, k=-1)\n  Array([[0., 0., 0., 0.],\n         [1., 0., 0., 0.],\n         [1., 1., 0., 0.]], dtype=float32)",
    "std_args": [
      "N",
      "M",
      "k",
      "dtype"
    ],
    "type": "function"
  },
  "tri_inv": {
    "description": "Compute the inverse of a triangular square matrix.",
    "std_args": [
      "a",
      "upper",
      "stream"
    ],
    "type": "function"
  },
  "triangular": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tril_indices": {
    "description": "Return the indices of lower triangle of an array of size ``(n, m)``.\n\nJAX implementation of :func:`numpy.tril_indices`.\n\nArgs:\n  n: int. Number of rows of the array for which the indices are returned.\n  k: optional, int, default=0. Specifies the sub-diagonal on and below which\n    the indices of lower triangle are returned. ``k=0`` refers to main diagonal,\n    ``k<0`` refers to sub-diagonal below the main diagonal and ``k>0`` refers\n    to sub-diagonal above the main diagonal.\n  m: optional, int. Number of columns of the array for which the indices are\n    returned. If not specified, then ``m = n``.\n\nReturns:\n  A tuple of two arrays containing the indices of the lower triangle, one along\n  each axis.\n\nSee also:\n  - :func:`jax.numpy.triu_indices`: Returns the indices of upper triangle of an\n    array of size ``(n, m)``.\n  - :func:`jax.numpy.triu_indices_from`: Returns the indices of upper triangle\n    of a given array.\n  - :func:`jax.numpy.tril_indices_from`: Returns the indices of lower triangle\n    of a given array.\n\nExamples:\n  If only ``n`` is provided in input, the indices of lower triangle of an array\n  of size ``(n, n)`` array are returned.\n\n  >>> jnp.tril_indices(3)\n  (Array([0, 1, 1, 2, 2, 2], dtype=int32), Array([0, 0, 1, 0, 1, 2], dtype=int32))\n\n  If both ``n`` and ``m`` are provided in input, the indices of lower triangle\n  of an ``(n, m)`` array are returned.\n\n  >>> jnp.tril_indices(3, m=2)\n  (Array([0, 1, 1, 2, 2], dtype=int32), Array([0, 0, 1, 0, 1], dtype=int32))\n\n  If ``k = 1``, the indices on and below the first sub-diagonal above the main\n  diagonal are returned.\n\n  >>> jnp.tril_indices(3, k=1)\n  (Array([0, 0, 1, 1, 1, 2, 2, 2], dtype=int32), Array([0, 1, 0, 1, 2, 0, 1, 2], dtype=int32))\n\n  If ``k = -1``, the indices on and below the first sub-diagonal below the main\n  diagonal are returned.\n\n  >>> jnp.tril_indices(3, k=-1)\n  (Array([1, 2, 2], dtype=int32), Array([0, 0, 1], dtype=int32))",
    "std_args": [
      "n",
      "k",
      "m"
    ],
    "type": "function"
  },
  "tril_indices_from": {
    "description": "Return the indices of lower triangle of a given array.\n\nJAX implementation of :func:`numpy.tril_indices_from`.\n\nArgs:\n  arr: input array. Must have ``arr.ndim == 2``.\n  k: optional, int, default=0. Specifies the sub-diagonal on and below which\n    the indices of upper triangle are returned. ``k=0`` refers to main diagonal,\n    ``k<0`` refers to sub-diagonal below the main diagonal and ``k>0`` refers\n    to sub-diagonal above the main diagonal.\n\nReturns:\n  A tuple of two arrays containing the indices of the lower triangle, one along\n  each axis.\n\nSee also:\n  - :func:`jax.numpy.triu_indices_from`: Returns the indices of upper triangle\n    of a given array.\n  - :func:`jax.numpy.tril_indices`: Returns the indices of lower triangle of an\n    array of size ``(n, m)``.\n  - :func:`jax.numpy.tril`: Returns a lower triangle of an array\n\nExamples:\n  >>> arr = jnp.array([[1, 2, 3],\n  ...                  [4, 5, 6],\n  ...                  [7, 8, 9]])\n  >>> jnp.tril_indices_from(arr)\n  (Array([0, 1, 1, 2, 2, 2], dtype=int32), Array([0, 0, 1, 0, 1, 2], dtype=int32))\n\n  Elements indexed by ``jnp.tril_indices_from`` correspond to those in the\n  output of ``jnp.tril``.\n\n  >>> ind = jnp.tril_indices_from(arr)\n  >>> arr[ind]\n  Array([1, 4, 5, 7, 8, 9], dtype=int32)\n  >>> jnp.tril(arr)\n  Array([[1, 0, 0],\n         [4, 5, 0],\n         [7, 8, 9]], dtype=int32)\n\n  When ``k > 0``:\n\n  >>> jnp.tril_indices_from(arr, k=1)\n  (Array([0, 0, 1, 1, 1, 2, 2, 2], dtype=int32), Array([0, 1, 0, 1, 2, 0, 1, 2], dtype=int32))\n\n  When ``k < 0``:\n\n  >>> jnp.tril_indices_from(arr, k=-1)\n  (Array([1, 2, 2], dtype=int32), Array([0, 0, 1], dtype=int32))",
    "std_args": [
      "arr",
      "k"
    ],
    "type": "function"
  },
  "trim": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "trim_zeros": {
    "description": "Trim leading and/or trailing zeros of the input array.\n\nJAX implementation of :func:`numpy.trim_zeros`.\n\nArgs:\n  filt: N-dimensional input array.\n  trim: string, optional, default = ``fb``. Specifies from which end the input\n    is trimmed.\n\n    - ``f`` - trims only the leading zeros.\n    - ``b`` - trims only the trailing zeros.\n    - ``fb`` - trims both leading and trailing zeros.\n\n  axis: optional axis or axes along which to trim. If not specified, trim along\n    all axes of the array.\n\nReturns:\n  An array containing the trimmed input with same dtype as ``filt``.\n\nExamples:\n  One-dimensional input:\n\n  >>> x = jnp.array([0, 0, 2, 0, 1, 4, 3, 0, 0, 0])\n  >>> jnp.trim_zeros(x)\n  Array([2, 0, 1, 4, 3], dtype=int32)\n  >>> jnp.trim_zeros(x, trim='f')\n  Array([2, 0, 1, 4, 3, 0, 0, 0], dtype=int32)\n  >>> jnp.trim_zeros(x, trim='b')\n  Array([0, 0, 2, 0, 1, 4, 3], dtype=int32)\n\n  Two-dimensional input:\n\n  >>> x = jnp.zeros((4, 5)).at[1:3, 1:4].set(1)\n  >>> x\n  Array([[0., 0., 0., 0., 0.],\n         [0., 1., 1., 1., 0.],\n         [0., 1., 1., 1., 0.],\n         [0., 0., 0., 0., 0.]], dtype=float32)\n  >>> jnp.trim_zeros(x)\n  Array([[1., 1., 1.],\n         [1., 1., 1.]], dtype=float32)\n  >>> jnp.trim_zeros(x, trim='f')\n  Array([[1., 1., 1., 0.],\n         [1., 1., 1., 0.],\n         [0., 0., 0., 0.]], dtype=float32)\n  >>> jnp.trim_zeros(x, axis=0)\n  Array([[0., 1., 1., 1., 0.],\n         [0., 1., 1., 1., 0.]], dtype=float32)\n  >>> jnp.trim_zeros(x, axis=1)\n  Array([[0., 0., 0.],\n         [1., 1., 1.],\n         [1., 1., 1.],\n         [0., 0., 0.]], dtype=float32)",
    "std_args": [
      "filt",
      "trim",
      "axis"
    ],
    "type": "function"
  },
  "trimcoef": {
    "description": "Remove \"small\" \"trailing\" coefficients from a polynomial.",
    "std_args": [
      "c",
      "tol"
    ],
    "type": "function"
  },
  "trimseq": {
    "description": "Remove small Poly series coefficients.",
    "std_args": [
      "seq"
    ],
    "type": "function"
  },
  "triplet_loss": {
    "description": "Computes the triplet loss for a set of anchor, positive, and negative samples.",
    "std_args": [
      "anchors",
      "positives",
      "negatives",
      "axis",
      "p",
      "margin",
      "eps",
      "reduction"
    ],
    "type": "function"
  },
  "triplet_margin_loss": {
    "description": "Compute the triplet loss between given input tensors and a margin greater than 0.",
    "std_args": [
      "anchor",
      "positive",
      "negative",
      "margin",
      "p",
      "eps",
      "swap",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "triplet_margin_with_distance_loss": {
    "description": "Compute the triplet margin loss for input tensors using a custom distance function.",
    "std_args": [
      "anchor",
      "positive",
      "negative",
      "distance_function",
      "margin",
      "swap",
      "reduction"
    ],
    "type": "function"
  },
  "triu_indices": {
    "description": "Return the indices of upper triangle of an array of size ``(n, m)``.\n\nJAX implementation of :func:`numpy.triu_indices`.\n\nArgs:\n  n: int. Number of rows of the array for which the indices are returned.\n  k: optional, int, default=0. Specifies the sub-diagonal on and above which\n    the indices of upper triangle are returned. ``k=0`` refers to main diagonal,\n    ``k<0`` refers to sub-diagonal below the main diagonal and ``k>0`` refers\n    to sub-diagonal above the main diagonal.\n  m: optional, int. Number of columns of the array for which the indices are\n    returned. If not specified, then ``m = n``.\n\nReturns:\n  A tuple of two arrays containing the indices of the upper triangle, one along\n  each axis.\n\nSee also:\n  - :func:`jax.numpy.tril_indices`: Returns the indices of lower triangle of an\n    array of size ``(n, m)``.\n  - :func:`jax.numpy.triu_indices_from`: Returns the indices of upper triangle\n    of a given array.\n  - :func:`jax.numpy.tril_indices_from`: Returns the indices of lower triangle\n    of a given array.\n\nExamples:\n  If only ``n`` is provided in input, the indices of upper triangle of an array\n  of size ``(n, n)`` array are returned.\n\n  >>> jnp.triu_indices(3)\n  (Array([0, 0, 0, 1, 1, 2], dtype=int32), Array([0, 1, 2, 1, 2, 2], dtype=int32))\n\n  If both ``n`` and ``m`` are provided in input, the indices of upper triangle\n  of an ``(n, m)`` array are returned.\n\n  >>> jnp.triu_indices(3, m=2)\n  (Array([0, 0, 1], dtype=int32), Array([0, 1, 1], dtype=int32))\n\n  If ``k = 1``, the indices on and above the first sub-diagonal above the main\n  diagonal are returned.\n\n  >>> jnp.triu_indices(3, k=1)\n  (Array([0, 0, 1], dtype=int32), Array([1, 2, 2], dtype=int32))\n\n  If ``k = -1``, the indices on and above the first sub-diagonal below the main\n  diagonal are returned.\n\n  >>> jnp.triu_indices(3, k=-1)\n  (Array([0, 0, 0, 1, 1, 1, 2, 2], dtype=int32), Array([0, 1, 2, 0, 1, 2, 1, 2], dtype=int32))",
    "std_args": [
      "n",
      "k",
      "m"
    ],
    "type": "function"
  },
  "triu_indices_from": {
    "description": "Return the indices of upper triangle of a given array.\n\nJAX implementation of :func:`numpy.triu_indices_from`.\n\nArgs:\n  arr: input array. Must have ``arr.ndim == 2``.\n  k: optional, int, default=0. Specifies the sub-diagonal on and above which\n    the indices of upper triangle are returned. ``k=0`` refers to main diagonal,\n    ``k<0`` refers to sub-diagonal below the main diagonal and ``k>0`` refers\n    to sub-diagonal above the main diagonal.\n\nReturns:\n  A tuple of two arrays containing the indices of the upper triangle, one along\n  each axis.\n\nSee also:\n  - :func:`jax.numpy.tril_indices_from`: Returns the indices of lower triangle\n    of a given array.\n  - :func:`jax.numpy.triu_indices`: Returns the indices of upper triangle of an\n    array of size ``(n, m)``.\n  - :func:`jax.numpy.triu`: Return an upper triangle of an array.\n\nExamples:\n  >>> arr = jnp.array([[1, 2, 3],\n  ...                  [4, 5, 6],\n  ...                  [7, 8, 9]])\n  >>> jnp.triu_indices_from(arr)\n  (Array([0, 0, 0, 1, 1, 2], dtype=int32), Array([0, 1, 2, 1, 2, 2], dtype=int32))\n\n  Elements indexed by ``jnp.triu_indices_from`` correspond to those in the\n  output of ``jnp.triu``.\n\n  >>> ind = jnp.triu_indices_from(arr)\n  >>> arr[ind]\n  Array([1, 2, 3, 5, 6, 9], dtype=int32)\n  >>> jnp.triu(arr)\n  Array([[1, 2, 3],\n         [0, 5, 6],\n         [0, 0, 9]], dtype=int32)\n\n  When ``k > 0``:\n\n  >>> jnp.triu_indices_from(arr, k=1)\n  (Array([0, 0, 1], dtype=int32), Array([1, 2, 2], dtype=int32))\n\n  When ``k < 0``:\n\n  >>> jnp.triu_indices_from(arr, k=-1)\n  (Array([0, 0, 0, 1, 1, 1, 2, 2], dtype=int32), Array([0, 1, 2, 0, 1, 2, 1, 2], dtype=int32))",
    "std_args": [
      "arr",
      "k"
    ],
    "type": "function"
  },
  "true_divide": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "true_intent_list": {
    "description": "The class representing a Python function.",
    "std_args": [
      "var"
    ],
    "type": "function"
  },
  "trunc_normal_": {
    "description": "Fill the input Tensor with values drawn from a truncated normal distribution.",
    "std_args": [
      "tensor",
      "mean",
      "std",
      "a",
      "b",
      "generator"
    ],
    "type": "function"
  },
  "truncated_normal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "tuple_init": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tuple_reduce": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ty": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "typ": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "type": {
    "description": "Casts all parameters and buffers to :attr:`dst_type`.",
    "std_args": [
      "self",
      "dst_type"
    ],
    "type": "attribute"
  },
  "type_before_parametrizations": {
    "description": "Return the module type before parametrizations were applied and if not, then it returns the module type.",
    "std_args": [
      "module"
    ],
    "type": "function"
  },
  "type_counter": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "type_state": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "typedef_need_dict": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "typedefpattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "typedefs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "typedefs_generated": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "types": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "typespattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "typespattern4implicit": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ubyte": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ufunc": {
    "description": "Universal functions which operation element-by-element on arrays.\n\nJAX implementation of :class:`numpy.ufunc`.\n\nThis is a class for JAX-backed implementations of NumPy's ufunc APIs.\nMost users will never need to instantiate :class:`ufunc`, but rather\nwill use the pre-defined ufuncs in :mod:`jax.numpy`.\n\nFor constructing your own ufuncs, see :func:`jax.numpy.frompyfunc`.\n\nExamples:\n  Universal functions are functions that apply element-wise to broadcasted\n  arrays, but they also come with a number of extra attributes and methods.\n\n  As an example, consider the function :obj:`jax.numpy.add`. The object\n  acts as a function that applies addition to broadcasted arrays in an\n  element-wise manner:\n\n  >>> x = jnp.array([1, 2, 3, 4, 5])\n  >>> jnp.add(x, 1)\n  Array([2, 3, 4, 5, 6], dtype=int32)\n\n  Each :class:`ufunc` object includes a number of attributes that describe\n  its behavior:\n\n  >>> jnp.add.nin  # number of inputs\n  2\n  >>> jnp.add.nout  # number of outputs\n  1\n  >>> jnp.add.identity  # identity value, or None if no identity exists\n  0\n\n  Binary ufuncs like :obj:`jax.numpy.add` include  number of methods to\n  apply the function to arrays in different manners.\n\n  The :meth:`~ufunc.outer` method applies the function to the\n  pair-wise outer-product of the input array values:\n\n  >>> jnp.add.outer(x, x)\n  Array([[ 2,  3,  4,  5,  6],\n         [ 3,  4,  5,  6,  7],\n         [ 4,  5,  6,  7,  8],\n         [ 5,  6,  7,  8,  9],\n         [ 6,  7,  8,  9, 10]], dtype=int32)\n\n  The :meth:`ufunc.reduce` method performs a reduction over the array.\n  For example, :meth:`jnp.add.reduce` is equivalent to ``jnp.sum``:\n\n  >>> jnp.add.reduce(x)\n  Array(15, dtype=int32)\n\n  The :meth:`ufunc.accumulate` method performs a cumulative reduction\n  over the array. For example, :meth:`jnp.add.accumulate` is equivalent\n  to :func:`jax.numpy.cumulative_sum`:\n\n  >>> jnp.add.accumulate(x)\n  Array([ 1,  3,  6, 10, 15], dtype=int32)\n\n  The :meth:`ufunc.at` method applies the function at particular indices in the\n  array; for ``jnp.add`` the computation is similar to :func:`jax.lax.scatter_add`:\n\n  >>> jnp.add.at(x, 0, 100, inplace=False)\n  Array([101,   2,   3,   4,   5], dtype=int32)\n\n  And the :meth:`ufunc.reduceat` method performs a number of ``reduce``\n  operations between specified indices of an array; for ``jnp.add`` the\n  operation is similar to :func:`jax.ops.segment_sum`:\n\n  >>> jnp.add.reduceat(x, jnp.array([0, 2]))\n  Array([ 3, 12], dtype=int32)\n\n  In this case, the first element is ``x[0:2].sum()``, and the second element\n  is ``x[2:].sum()``.",
    "std_args": [
      "func",
      "nin",
      "nout",
      "name",
      "nargs",
      "identity",
      "call",
      "reduce",
      "accumulate",
      "at",
      "reduceat"
    ],
    "type": "class"
  },
  "ufunc_domain": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ufunc_fills": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "uint": {
    "description": "A JAX scalar constructor of type uint64.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "attribute"
  },
  "uint16": {
    "description": "A JAX scalar constructor of type uint16.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "attribute"
  },
  "uint2": {
    "description": "A JAX scalar constructor of type uint2.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "class"
  },
  "uint32": {
    "description": "A JAX scalar constructor of type uint32.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "attribute"
  },
  "uint32_to_float32": {
    "description": "The class representing a Python function.",
    "std_args": [
      "u"
    ],
    "type": "function"
  },
  "uint4": {
    "description": "A JAX scalar constructor of type uint4.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "class"
  },
  "uint64": {
    "description": "A JAX scalar constructor of type uint64.\n\nWhile NumPy defines scalar types for each data type, JAX represents\nscalars as zero-dimensional arrays.",
    "std_args": [
      "x"
    ],
    "type": "attribute"
  },
  "uintc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "uintp": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ulong": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ulonglong": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "unbound": {
    "description": "The class representing a Python function.",
    "std_args": [
      "args"
    ],
    "type": "function"
  },
  "unbox": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "undo_rmbadname": {
    "description": "The class representing a Python function.",
    "std_args": [
      "names"
    ],
    "type": "function"
  },
  "undo_rmbadname1": {
    "description": "The class representing a Python function.",
    "std_args": [
      "name"
    ],
    "type": "function"
  },
  "unflatten_end": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "index_ref",
      "inner_merge"
    ],
    "type": "function"
  },
  "unflatten_mapping": {
    "description": "Unflatten a mapping.",
    "std_args": [
      "xs",
      "sep"
    ],
    "type": "function"
  },
  "unflattened_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "unfold": {
    "description": "Extract sliding local blocks from a batched input tensor.",
    "std_args": [
      "input",
      "kernel_size",
      "dilation",
      "padding",
      "stride"
    ],
    "type": "function"
  },
  "unfreeze": {
    "description": "Unfreeze the Module's parameters or some of them.",
    "std_args": [
      "self",
      "recurse",
      "keys",
      "strict"
    ],
    "type": "function"
  },
  "uniform": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "uniform32_from_uint": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x",
      "bits"
    ],
    "type": "function"
  },
  "uniform32_from_uint32": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "uniform32_from_uint53": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "uniform32_from_uint64": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "uniform_": {
    "description": "Fill the input Tensor with values drawn from the uniform distribution.",
    "std_args": [
      "tensor",
      "a",
      "b",
      "generator"
    ],
    "type": "function"
  },
  "uniform_from_dsfmt": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "uniform_from_uint": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x",
      "bits"
    ],
    "type": "function"
  },
  "uniform_from_uint32": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "uniform_from_uint64": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "union1d": {
    "description": "Compute the set union of two 1D arrays.\n\nJAX implementation of :func:`numpy.union1d`.\n\nBecause the size of the output of ``union1d`` is data-dependent, the function\nis not typically compatible with :func:`~jax.jit` and other JAX transformations.\nThe JAX version adds the optional ``size`` argument which must be specified\nstatically for ``jnp.union1d`` to be used in such contexts.\n\nArgs:\n  ar1: first array of elements to be unioned.\n  ar2: second array of elements to be unioned\n  size: if specified, return only the first ``size`` sorted elements. If there are fewer\n    elements than ``size`` indicates, the return value will be padded with ``fill_value``.\n  fill_value: when ``size`` is specified and there are fewer than the indicated number of\n    elements, fill the remaining entries ``fill_value``. Defaults to the minimum value.\n\nReturns:\n  an array containing the union of elements in the input array.\n\nSee also:\n  - :func:`jax.numpy.intersect1d`: the set intersection of two 1D arrays.\n  - :func:`jax.numpy.setxor1d`: the set XOR of two 1D arrays.\n  - :func:`jax.numpy.setdiff1d`: the set difference of two 1D arrays.\n\nExamples:\n  Computing the union of two arrays:\n\n  >>> ar1 = jnp.array([1, 2, 3, 4])\n  >>> ar2 = jnp.array([3, 4, 5, 6])\n  >>> jnp.union1d(ar1, ar2)\n  Array([1, 2, 3, 4, 5, 6], dtype=int32)\n\n  Because the output shape is dynamic, this will fail under :func:`~jax.jit` and other\n  transformations:\n\n  >>> jax.jit(jnp.union1d)(ar1, ar2)  # doctest: +IGNORE_EXCEPTION_DETAIL\n  Traceback (most recent call last):\n     ...\n  ConcretizationTypeError: Abstract tracer value encountered where concrete value is expected: traced array with shape int32[4].\n  The error occurred while tracing the function union1d at /Users/vanderplas/github/jax-ml/jax/jax/_src/numpy/setops.py:101 for jit. This concrete value was not available in Python because it depends on the value of the argument ar1.\n\n  In order to ensure statically-known output shapes, you can pass a static ``size``\n  argument:\n\n  >>> jit_union1d = jax.jit(jnp.union1d, static_argnames=['size'])\n  >>> jit_union1d(ar1, ar2, size=6)\n  Array([1, 2, 3, 4, 5, 6], dtype=int32)\n\n  If ``size`` is too small, the union is truncated:\n\n  >>> jit_union1d(ar1, ar2, size=4)\n  Array([1, 2, 3, 4], dtype=int32)\n\n  If ``size`` is too large, then the output is padded with ``fill_value``:\n\n  >>> jit_union1d(ar1, ar2, size=8, fill_value=0)\n  Array([1, 2, 3, 4, 5, 6, 0, 0], dtype=int32)",
    "std_args": [
      "ar1",
      "ar2",
      "size",
      "fill_value"
    ],
    "type": "function"
  },
  "unit_frequencies": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "unit_weights": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "units": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "unmarkouterparen": {
    "description": "The class representing a Python function.",
    "std_args": [
      "line"
    ],
    "type": "function"
  },
  "unpack_sequence": {
    "description": "Unpack PackedSequence into a list of variable length Tensors.",
    "std_args": [
      "packed_sequences"
    ],
    "type": "function"
  },
  "unpad_sequence": {
    "description": "Unpad padded Tensor into a list of variable length Tensors.",
    "std_args": [
      "padded_sequences",
      "lengths",
      "batch_first"
    ],
    "type": "function"
  },
  "unravel_index": {
    "description": "Convert flat indices into multi-dimensional indices.\n\nJAX implementation of :func:`numpy.unravel_index`. The JAX version differs in\nits treatment of out-of-bound indices: unlike NumPy, negative indices are\nsupported, and out-of-bound indices are clipped to the nearest valid value.\n\nArgs:\n  indices: integer array of flat indices\n  shape: shape of multidimensional array to index into\n\nReturns:\n  Tuple of unraveled indices\n\nSee also:\n  :func:`jax.numpy.ravel_multi_index`: Inverse of this function.\n\nExamples:\n  Start with a 1D array values and indices:\n\n  >>> x = jnp.array([2., 3., 4., 5., 6., 7.])\n  >>> indices = jnp.array([1, 3, 5])\n  >>> print(x[indices])\n  [3. 5. 7.]\n\n  Now if ``x`` is reshaped, ``unravel_indices`` can be used to convert\n  the flat indices into a tuple of indices that access the same entries:\n\n  >>> shape = (2, 3)\n  >>> x_2D = x.reshape(shape)\n  >>> indices_2D = jnp.unravel_index(indices, shape)\n  >>> indices_2D\n  (Array([0, 1, 1], dtype=int32), Array([1, 0, 2], dtype=int32))\n  >>> print(x_2D[indices_2D])\n  [3. 5. 7.]\n\n  The inverse function, ``ravel_multi_index``, can be used to obtain the\n  original indices:\n\n  >>> jnp.ravel_multi_index(indices_2D, shape)\n  Array([1, 3, 5], dtype=int32)",
    "std_args": [
      "indices",
      "shape"
    ],
    "type": "function"
  },
  "unreplace_parenthesis": {
    "description": "Inverse of replace_parenthesis.",
    "std_args": [
      "s",
      "d"
    ],
    "type": "function"
  },
  "unroll": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "unsafe": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "unshare_mask": {
    "description": "Copy the mask and set the `sharedmask` flag to ``False``.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "unsignedinteger": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "attribute"
  },
  "unsorted_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "unstructured_to_structured": {
    "description": "Converts an n-D unstructured array into an (n-1)-D structured array.",
    "std_args": [
      "arr",
      "dtype",
      "names",
      "align",
      "copy",
      "casting"
    ],
    "type": "function"
  },
  "unwrap_random_key_data": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "update": {
    "description": "Update the :class:`~torch.nn.ParameterDict` with key-value pairs from ``parameters``, overwriting existing keys.",
    "std_args": [
      "self",
      "parameters"
    ],
    "type": "function"
  },
  "update_context": {
    "description": "Creates an :class:`UpdateContext` context manager which can be used to handle",
    "std_args": [
      "tag"
    ],
    "type": "function"
  },
  "update_context_stacks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "update_from_loval": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "box_state",
      "variable",
      "lo_vals"
    ],
    "type": "function"
  },
  "update_from_state": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "variable_state"
    ],
    "type": "function"
  },
  "update_infinity_moment": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "update_modules": {
    "description": "Replace the child modules of this :class:`Module` instance with the",
    "std_args": [
      "self",
      "modules",
      "strict"
    ],
    "type": "function"
  },
  "update_moment": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "update_moment_per_elem_norm": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "update_state": {
    "description": "",
    "std_args": [
      "self",
      "data"
    ],
    "type": "function"
  },
  "updatevars": {
    "description": "Returns last_name, the variable name without special chars, parenthesis",
    "std_args": [
      "typespec",
      "selector",
      "attrspec",
      "entitydecl"
    ],
    "type": "function"
  },
  "upper": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "upsample_bilinear": {
    "description": "Upsamples the input, using bilinear upsampling.",
    "std_args": [
      "input",
      "size",
      "scale_factor"
    ],
    "type": "function"
  },
  "upsample_cubic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x",
      "scale_factor",
      "align_corners"
    ],
    "type": "function"
  },
  "upsample_linear": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x",
      "scale_factor",
      "align_corners"
    ],
    "type": "function"
  },
  "upsample_nearest": {
    "description": "Upsamples the input, using nearest neighbours' pixel values.",
    "std_args": [
      "input",
      "size",
      "scale_factor"
    ],
    "type": "function"
  },
  "upscale_factor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "urlopen_stub": {
    "description": "Stub to replace urlopen for testing.",
    "std_args": [
      "url",
      "data"
    ],
    "type": "function"
  },
  "use2fortran": {
    "description": "The class representing a Python function.",
    "std_args": [
      "use",
      "tab"
    ],
    "type": "function"
  },
  "use_ascii": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "use_bias": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_eager_sharding": {
    "description": "Sets whether Variables should use eager sharding by default or not.",
    "std_args": [
      "value"
    ],
    "type": "function"
  },
  "use_fast_variance": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_hijax": {
    "description": "",
    "std_args": [
      "value"
    ],
    "type": "function"
  },
  "use_nested_tensor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_raw_key": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_raw_value": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_running_average": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_scale": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_side_stream_for_tensor_copies": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_unicode": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "useiso_c_binding": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "usemodule_rules": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "usepattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "userincludes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "usermodules": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ushort": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "using_eager_sharding": {
    "description": "Returns whether Variables are using eager sharding by default.",
    "std_args": [],
    "type": "function"
  },
  "using_hijax": {
    "description": "",
    "std_args": [],
    "type": "function"
  },
  "uuid": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "v_proj_weight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "valid_baseurl": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "valid_child_filter": {
    "description": "The class representing a Python function.",
    "std_args": [
      "module",
      "key",
      "value"
    ],
    "type": "function"
  },
  "valid_httpfile": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "valid_httpurl": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "valid_parameter_filter": {
    "description": "The class representing a Python function.",
    "std_args": [
      "module",
      "key",
      "value"
    ],
    "type": "function"
  },
  "valid_textfile": {
    "description": "The class representing a Python function.",
    "std_args": [
      "filedir"
    ],
    "type": "function"
  },
  "validate_modulename": {
    "description": "The class representing a Python function.",
    "std_args": [
      "pyf_files",
      "modulename"
    ],
    "type": "function"
  },
  "value": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "value_and_grad": {
    "description": "Evaluates value and gradient.",
    "std_args": [
      "func",
      "argnums",
      "has_aux"
    ],
    "type": "function"
  },
  "value_proj": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "values": {
    "description": "Return an iterable of the ParameterDict values.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "vander": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "var2fixfortran": {
    "description": "The class representing a Python function.",
    "std_args": [
      "vars",
      "a",
      "fa",
      "f90mode"
    ],
    "type": "function"
  },
  "var_type": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "variable_effect": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "variable_filter": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "variable_groups": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "variable_hijax_stack": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "variable_name_from_type": {
    "description": "Given an NNX Variable type, get its Linen-style collection name.",
    "std_args": [
      "typ",
      "allow_register"
    ],
    "type": "function"
  },
  "variable_type_from_name": {
    "description": "Given a Linen-style collection name, get or create its NNX Variable class.",
    "std_args": [
      "name",
      "base",
      "allow_register"
    ],
    "type": "function"
  },
  "variables": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "variance_scaling": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "variant": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "vars2fortran": {
    "description": "The class representing a Python function.",
    "std_args": [
      "block",
      "vars",
      "args",
      "tab",
      "as_interface"
    ],
    "type": "function"
  },
  "vars_as": {
    "description": "",
    "std_args": [
      "node",
      "is_hijax",
      "has_ref",
      "is_mutable",
      "only",
      "allow_duplicates"
    ],
    "type": "function"
  },
  "vdim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "vdot": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "function"
  },
  "vecmat": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "vector_to_parameters": {
    "description": "Copy slices of a vector into an iterable of parameters.",
    "std_args": [
      "vec",
      "parameters"
    ],
    "type": "function"
  },
  "vectorize": {
    "description": "Define a vectorized function with broadcasting.\n\n:func:`vectorize` is a convenience wrapper for defining vectorized\nfunctions with broadcasting, in the style of NumPy's\n`generalized universal functions <https://numpy.org/doc/stable/reference/c-api/generalized-ufuncs.html>`_.\nIt allows for defining functions that are automatically repeated across\nany leading dimensions, without the implementation of the function needing to\nbe concerned about how to handle higher dimensional inputs.\n\n:func:`jax.numpy.vectorize` has the same interface as\n:class:`numpy.vectorize`, but it is syntactic sugar for an auto-batching\ntransformation (:func:`vmap`) rather than a Python loop. This should be\nconsiderably more efficient, but the implementation must be written in terms\nof functions that act on JAX arrays.\n\nArgs:\n  pyfunc: function to vectorize.\n  excluded: optional set of integers representing positional arguments for\n    which the function will not be vectorized. These will be passed directly\n    to ``pyfunc`` unmodified.\n  signature: optional generalized universal function signature, e.g.,\n    ``(m,n),(n)->(m)`` for vectorized matrix-vector multiplication. If\n    provided, ``pyfunc`` will be called with (and expected to return) arrays\n    with shapes given by the size of corresponding core dimensions. By\n    default, pyfunc is assumed to take scalar arrays as input, and if\n    ``signature`` is ``None``, ``pyfunc`` can produce outputs of any shape.\n\nReturns:\n  Vectorized version of the given function.\n\nExamples:\n  Here are a few examples of how one could write vectorized linear algebra\n  routines using :func:`vectorize`:\n\n  >>> from functools import partial\n\n  >>> @partial(jnp.vectorize, signature='(k),(k)->(k)')\n  ... def cross_product(a, b):\n  ...   assert a.shape == b.shape and a.ndim == b.ndim == 1\n  ...   return jnp.array([a[1] * b[2] - a[2] * b[1],\n  ...                     a[2] * b[0] - a[0] * b[2],\n  ...                     a[0] * b[1] - a[1] * b[0]])\n\n  >>> @partial(jnp.vectorize, signature='(n,m),(m)->(n)')\n  ... def matrix_vector_product(matrix, vector):\n  ...   assert matrix.ndim == 2 and matrix.shape[1:] == vector.shape\n  ...   return matrix @ vector\n\n  These functions are only written to handle 1D or 2D arrays (the ``assert``\n  statements will never be violated), but with vectorize they support\n  arbitrary dimensional inputs with NumPy style broadcasting, e.g.,\n\n  >>> cross_product(jnp.ones(3), jnp.ones(3)).shape\n  (3,)\n  >>> cross_product(jnp.ones((2, 3)), jnp.ones(3)).shape\n  (2, 3)\n  >>> cross_product(jnp.ones((1, 2, 3)), jnp.ones((2, 1, 3))).shape\n  (2, 2, 3)\n  >>> matrix_vector_product(jnp.ones(3), jnp.ones(3))  # doctest: +IGNORE_EXCEPTION_DETAIL\n  Traceback (most recent call last):\n  ValueError: input with shape (3,) does not have enough dimensions for all\n  core dimensions ('n', 'k') on vectorized function with excluded=frozenset()\n  and signature='(n,k),(k)->(k)'\n  >>> matrix_vector_product(jnp.ones((2, 3)), jnp.ones(3)).shape\n  (2,)\n  >>> matrix_vector_product(jnp.ones((2, 3)), jnp.ones((4, 3))).shape\n  (4, 2)\n\n  Note that this has different semantics than `jnp.matmul`:\n\n  >>> jnp.matmul(jnp.ones((2, 3)), jnp.ones((4, 3)))  # doctest: +IGNORE_EXCEPTION_DETAIL\n  Traceback (most recent call last):\n  TypeError: dot_general requires contracting dimensions to have the same shape, got [3] and [4].",
    "std_args": [
      "pyfunc",
      "excluded",
      "signature"
    ],
    "type": "function"
  },
  "vectorized_map": {
    "description": "Parallel map of `function` on axis 0 of tensor(s) `elements`.\n\nSchematically, `vectorized_map` implements the following,\nin the case of a single tensor input `elements`:\n\n```python\ndef vectorized_map(function, elements):\n    outputs = []\n    for e in elements:\n        outputs.append(function(e))\n    return np.stack(outputs)\n```\n\nIn the case of an iterable of tensors `elements`,\nit implements the following:\n\n```python\ndef vectorized_map(function, elements):\n    batch_size = elements[0].shape[0]\n    outputs = []\n    for index in range(batch_size):\n        outputs.append(function([e[index] for e in elements]))\n    return np.stack(outputs)\n```\n\nIn this case, `function` is expected to take as input\na single list of tensor arguments.",
    "std_args": [
      "function",
      "elements"
    ],
    "type": "function"
  },
  "verbose": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "version": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "view_as_complex": {
    "description": "Converts a real tensor with shape `(..., 2)` to a complex tensor,\nwhere the last dimension represents the real and imaginary components\nof a complex tensor.\n\nArgs:\n    x: A real tensor with last dimension of size 2.\n\nReturns:\n    A complex tensor with shape `x.shape[:-1]`.\n\nExample:\n\n```\n>>> import numpy as np\n>>> from keras import ops\n\n>>> real_imag = np.array([[1.0, 2.0], [3.0, 4.0]])\n>>> complex_tensor = ops.view_as_complex(real_imag)\n>>> complex_tensor\narray([1.+2.j, 3.+4.j])\n```",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "view_as_real": {
    "description": "Converts a complex tensor to a real tensor with shape `(..., 2)`,\nwhere the last dimension represents the real and imaginary components.\n\nArgs:\n    x: A complex tensor.\n\nReturns:\n    A real tensor where the last dimension contains the\n    real and imaginary parts.\n\nExample:\n```\n>>> import numpy as np\n>>> from keras import ops\n\n>>> complex_tensor = np.array([1 + 2j, 3 + 4j])\n>>> real = ops.view_as_real(complex_tensor)\n>>> real\narray([[1., 2.],\n       [3., 4.]])\n```",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "visit_Attribute": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "node"
    ],
    "type": "function"
  },
  "visit_Call": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "node"
    ],
    "type": "function"
  },
  "visit_Name": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "node"
    ],
    "type": "function"
  },
  "vjp": {
    "description": "vjp(fun: Callable, primals: list[array], cotangents: list[array]) -> tuple[list[array], list[array]]",
    "std_args": [
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "vjp_flops": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "vmap": {
    "description": "Vectorizing map.",
    "std_args": [
      "func",
      "in_axes",
      "out_axes",
      "randomness"
    ],
    "type": "function"
  },
  "vocabulary_size": {
    "description": "Gets the current size of the layer's vocabulary.\n\nReturns:\n    The integer size of the vocabulary, including optional\n    mask and OOV indices.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "void": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "vonmises": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "vsplit": {
    "description": "Split an array into sub-arrays vertically.\n\nJAX implementation of :func:`numpy.vsplit`.\n\nRefer to the documentation of :func:`jax.numpy.split` for details; ``vsplit`` is\nequivalent to ``split`` with ``axis=0``.\n\nExamples:\n  1D array:\n\n  >>> x = jnp.array([1, 2, 3, 4, 5, 6])\n  >>> x1, x2 = jnp.vsplit(x, 2)\n  >>> print(x1, x2)\n  [1 2 3] [4 5 6]\n\n  2D array:\n\n  >>> x = jnp.array([[1, 2, 3, 4],\n  ...                [5, 6, 7, 8]])\n  >>> x1, x2 = jnp.vsplit(x, 2)\n  >>> print(x1, x2)\n  [[1 2 3 4]] [[5 6 7 8]]\n\nSee also:\n  - :func:`jax.numpy.split`: split an array along any axis.\n  - :func:`jax.numpy.hsplit`: split horizontally, i.e. along axis=1\n  - :func:`jax.numpy.dsplit`: split depth-wise, i.e. along axis=2\n  - :func:`jax.numpy.array_split`: like ``split``, but allows ``indices_or_sections``\n    to be an integer that does not evenly divide the size of the array.",
    "std_args": [
      "ary",
      "indices_or_sections"
    ],
    "type": "function"
  },
  "vstack": {
    "description": "Vertically stack arrays.\n\nJAX implementation of :func:`numpy.vstack`.\n\nFor arrays of two or more dimensions, this is equivalent to\n:func:`jax.numpy.concatenate` with ``axis=0``.\n\nArgs:\n  tup: a sequence of arrays to stack; each must have the same shape along all\n    but the first axis. If a single array is given it will be treated\n    equivalently to `tup = unstack(tup)`, but the implementation will avoid\n    explicit unstacking.\n  dtype: optional dtype of the resulting array. If not specified, the dtype\n    will be determined via type promotion rules described in :ref:`type-promotion`.\n\nReturns:\n  the stacked result.\n\nSee also:\n  - :func:`jax.numpy.stack`: stack along arbitrary axes\n  - :func:`jax.numpy.concatenate`: concatenation along existing axes.\n  - :func:`jax.numpy.hstack`: stack horizontally, i.e. along axis 1.\n  - :func:`jax.numpy.dstack`: stack depth-wise, i.e. along axis 2.\n\nExamples:\n  Scalar values:\n\n  >>> jnp.vstack([1, 2, 3])\n  Array([[1],\n         [2],\n         [3]], dtype=int32, weak_type=True)\n\n  1D arrays:\n\n  >>> x = jnp.arange(4)\n  >>> y = jnp.ones(4)\n  >>> jnp.vstack([x, y])\n  Array([[0., 1., 2., 3.],\n         [1., 1., 1., 1.]], dtype=float32)\n\n  2D arrays:\n\n  >>> x = x.reshape(1, 4)\n  >>> y = y.reshape(1, 4)\n  >>> jnp.vstack([x, y])\n  Array([[0., 1., 2., 3.],\n         [1., 1., 1., 1.]], dtype=float32)",
    "std_args": [
      "tup",
      "dtype"
    ],
    "type": "function"
  },
  "wald": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "warmup": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rg",
      "n"
    ],
    "type": "function"
  },
  "warmup_constant_schedule": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "warmup_cosine_decay_schedule": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "warmup_exponential_decay_schedule": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "warmup_init": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "warnings_errors_and_rng": {
    "description": "Filter out the wall of DeprecationWarnings.",
    "std_args": [
      "test"
    ],
    "type": "function"
  },
  "waves_per_eu": {
    "description": "ROCm-specific waves per execution unit.",
    "std_args": [],
    "type": "attribute"
  },
  "weekmask": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "weibull": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "weibull_min": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "weight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "weight_decay": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "weight_hh": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "weight_ih": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "weight_norm": {
    "description": "Apply weight normalization to a parameter in the given module.",
    "std_args": [
      "module",
      "name",
      "dim"
    ],
    "type": "function"
  },
  "weights": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "while_loop": {
    "description": "A Flax NNX transformation of `jax.lax.while_loop <https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.while_loop.html>`_.",
    "std_args": [
      "cond_fun",
      "body_fun",
      "init_val"
    ],
    "type": "function"
  },
  "will_sync_module_buffers": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "window": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "with_metadata": {
    "description": "The class representing a Python function.",
    "std_args": [
      "initializer",
      "set_value_hooks",
      "get_value_hooks",
      "create_value_hooks",
      "add_axis_hooks",
      "remove_axis_hooks",
      "metadata"
    ],
    "type": "function"
  },
  "with_no_outer_index": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "with_partitioning": {
    "description": "Same interface as Linen, but calls NNX `with_partitioning` within.",
    "std_args": [
      "fn",
      "names",
      "mesh"
    ],
    "type": "function"
  },
  "with_same_outer_index": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "word_pattern": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "wrap": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "wrap_array_like": {
    "description": "The class representing a Python function.",
    "std_args": [
      "result"
    ],
    "type": "function"
  },
  "wrapfuncs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "write": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "s"
    ],
    "type": "function"
  },
  "writelines": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "lines"
    ],
    "type": "function"
  },
  "wrt": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "x": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "x1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "x2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "x2_repeats": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "x3": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "xavier_normal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "xavier_normal_": {
    "description": "Fill the input `Tensor` with values using a Xavier normal distribution.",
    "std_args": [
      "tensor",
      "gain",
      "generator"
    ],
    "type": "function"
  },
  "xavier_uniform": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "xavier_uniform_": {
    "description": "Fill the input `Tensor` with values using a Xavier uniform distribution.",
    "std_args": [
      "tensor",
      "gain",
      "generator"
    ],
    "type": "function"
  },
  "xerbla": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "xlog1py": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "xlogy": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "xpu": {
    "description": "Move all model parameters and buffers to the XPU.",
    "std_args": [
      "self",
      "device"
    ],
    "type": "function"
  },
  "y": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "zero_grad": {
    "description": "Sets the gradients of all optimized parameters to zero.",
    "std_args": [],
    "type": "function"
  },
  "zero_infinity": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "zero_nans": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "zeros_": {
    "description": "Fill the input Tensor with the scalar value `0`.",
    "std_args": [
      "tensor"
    ],
    "type": "function"
  },
  "zeros_init": {
    "description": "Builds an initializer that returns a constant array full of zeros.",
    "std_args": [],
    "type": "function"
  },
  "zeta": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "zgelsd": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "zgeqrf": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "zip_descr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "zip_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "zipf": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "zungqr": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  }
}