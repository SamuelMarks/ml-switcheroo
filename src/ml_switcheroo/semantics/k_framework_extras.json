{
  "Adadelta": {
    "std_args": [
      "eps",
      "lr",
      "rho",
      "weight_decay"
    ]
  },
  "Adafactor": {
    "std_args": [
      "lr",
      "weight_decay"
    ]
  },
  "Adagrad": {
    "std_args": [
      "eps",
      "initial_accumulator_value",
      "lr",
      "weight_decay"
    ]
  },
  "Adam": {
    "std_args": [
      "amsgrad",
      "eps",
      "lr",
      "weight_decay"
    ]
  },
  "Adamax": {
    "std_args": [
      "eps",
      "lr",
      "weight_decay"
    ]
  },
  "Adamw": {
    "std_args": [
      "amsgrad",
      "eps",
      "lr",
      "weight_decay"
    ]
  },
  "Celu": {
    "std_args": [
      "alpha"
    ]
  },
  "Ctc": {
    "std_args": [
      "reduction"
    ]
  },
  "DataLoader": {
    "description": "Foundational PyTorch Data Loader. Explicitly unmapped to trigger Escape Hatch.",
    "std_args": [
      "dataset",
      "batch_size",
      "shuffle",
      "sampler"
    ]
  },
  "Elu": {
    "std_args": [
      "alpha"
    ]
  },
  "Gelu": {
    "std_args": [
      "approximate",
      "x"
    ]
  },
  "Glu": {
    "std_args": [
      "dim"
    ]
  },
  "Hardshrink": {
    "std_args": []
  },
  "Hardsigmoid": {
    "std_args": []
  },
  "Hardtanh": {
    "std_args": []
  },
  "Huber": {
    "std_args": [
      "delta",
      "reduction"
    ]
  },
  "Leakyrelu": {
    "std_args": [
      "negative_slope"
    ]
  },
  "Logsigmoid": {
    "std_args": []
  },
  "Logsoftmax": {
    "std_args": [
      "dim"
    ]
  },
  "Mish": {
    "std_args": []
  },
  "Muon": {
    "std_args": [
      "eps",
      "lr",
      "momentum",
      "nesterov",
      "ns_steps",
      "weight_decay"
    ]
  },
  "Nadam": {
    "std_args": [
      "eps",
      "lr",
      "weight_decay"
    ]
  },
  "Relu": {
    "std_args": []
  },
  "Relu6": {
    "std_args": []
  },
  "Rmsprop": {
    "std_args": [
      "centered",
      "eps",
      "lr",
      "momentum",
      "weight_decay"
    ]
  },
  "Selu": {
    "std_args": []
  },
  "Sgd": {
    "std_args": [
      "lr",
      "momentum",
      "nesterov",
      "weight_decay"
    ]
  },
  "Sigmoid": {
    "std_args": []
  },
  "Silu": {
    "std_args": []
  },
  "Softmax": {
    "std_args": [
      "dim",
      "x"
    ]
  },
  "Softplus": {
    "std_args": []
  },
  "Softshrink": {
    "std_args": []
  },
  "Softsign": {
    "std_args": []
  },
  "Tanh": {
    "std_args": []
  },
  "Tanhshrink": {
    "std_args": []
  },
  "TensorDataset": {
    "description": "Simple dataset wrapping tensors.",
    "std_args": [
      "tensors"
    ]
  },
  "Threshold": {
    "std_args": [
      "threshold"
    ]
  },
  "add": {
    "description": "Add with Alpha scaling support.",
    "std_args": [
      "x",
      "y",
      "alpha"
    ]
  },
  "add_": {
    "description": "In-place addition.",
    "std_args": [
      "x",
      "other",
      "alpha"
    ]
  },
  "cuda_is_available": {
    "description": "Checks if a CUDA device is available.",
    "std_args": []
  },
  "device": {
    "description": "Device placement object.",
    "std_args": [
      "type"
    ]
  },
  "dropout": {
    "description": "Stochastic Dropout.",
    "std_args": [
      "input",
      "p",
      "training",
      "inplace"
    ]
  },
  "eval": {
    "description": "Sets the module in evaluation mode.",
    "std_args": []
  },
  "init_process_group": {
    "description": "Distributed Training initialization.",
    "std_args": [
      "backend",
      "rank",
      "world_size"
    ]
  },
  "is_tensor": {
    "description": "Type check helper.",
    "std_args": [
      "obj"
    ]
  },
  "load": {
    "description": "Deserialization utility.",
    "std_args": [
      "f"
    ]
  },
  "manual_seed": {
    "description": "Seeding RNG. Maps to standard numpy seed often.",
    "std_args": [
      "seed"
    ]
  },
  "nnx_Param": {
    "description": "Flax NNX Parameter definition.",
    "std_args": [
      "value"
    ]
  },
  "no_grad": {
    "description": "Context manager to disable gradient calculation.",
    "std_args": []
  },
  "save": {
    "description": "Serialization utility. IO is often framework specific.",
    "std_args": [
      "obj",
      "f"
    ]
  },
  "set_printoptions": {
    "description": "Formatting utility for printing tensors.",
    "std_args": [
      "precision"
    ]
  },
  "train": {
    "description": "Sets the module in training mode.",
    "std_args": [
      "mode"
    ]
  }
}
