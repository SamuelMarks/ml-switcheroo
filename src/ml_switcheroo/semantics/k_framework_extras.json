{
  "Abs": {
    "description": "Calculates the absolute value.",
    "std_args": [
      "x"
    ]
  },
  "Adam": {
    "description": "Adaptive Moment Estimation optimizer.",
    "std_args": [
      "params",
      "lr",
      "beta1",
      "beta2",
      "eps",
      "weight_decay",
      "amsgrad"
    ]
  },
  "AdaptiveAvgPool1d": {
    "description": "Applies a 1D adaptive average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "output_size"
    ],
    "type": "class"
  },
  "AdaptiveAvgPool2d": {
    "description": "Applies a 2D adaptive average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "output_size"
    ],
    "type": "class"
  },
  "AdaptiveAvgPool3d": {
    "description": "Applies a 3D adaptive average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "output_size"
    ],
    "type": "class"
  },
  "AdaptiveLogSoftmaxWithLoss": {
    "description": "Efficient softmax approximation.",
    "std_args": [
      "self",
      "in_features",
      "n_classes",
      "cutoffs",
      "div_value",
      "head_bias",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "AdaptiveMaxPool1d": {
    "description": "Applies a 1D adaptive max pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "output_size",
      "return_indices"
    ],
    "type": "class"
  },
  "AdaptiveMaxPool2d": {
    "description": "Applies a 2D adaptive max pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "output_size",
      "return_indices"
    ],
    "type": "class"
  },
  "AdaptiveMaxPool3d": {
    "description": "Applies a 3D adaptive max pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "output_size",
      "return_indices"
    ],
    "type": "class"
  },
  "Add": {
    "description": "Element-wise addition.",
    "std_args": [
      "x",
      "y"
    ]
  },
  "Alphadropout": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "class"
  },
  "ArgMax": {
    "description": "Returns the indices of the maximum value of all elements in the input tensor.",
    "std_args": [
      "input",
      "dim",
      "keepdim"
    ]
  },
  "ArgMin": {
    "description": "Returns the indices of the minimum value of all elements in the input tensor.",
    "std_args": [
      "input",
      "dim",
      "keepdim"
    ]
  },
  "AuxOutput": {
    "description": "Auxiliary outputs from flex_attention operation.",
    "std_args": [],
    "type": "class"
  },
  "AuxRequest": {
    "description": "Request which auxiliary outputs to compute from flex_attention.",
    "std_args": [],
    "type": "class"
  },
  "AvgPool1d": {
    "description": "Applies a 1D average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "kernel_size",
      "stride",
      "padding",
      "ceil_mode",
      "count_include_pad"
    ],
    "type": "class"
  },
  "AvgPool2d": {
    "description": "Applies a 2D average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "kernel_size",
      "stride",
      "padding",
      "ceil_mode",
      "count_include_pad",
      "divisor_override"
    ],
    "type": "class"
  },
  "AvgPool3d": {
    "description": "Applies a 3D average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "kernel_size",
      "stride",
      "padding",
      "ceil_mode",
      "count_include_pad",
      "divisor_override"
    ],
    "type": "class"
  },
  "BCELoss": {
    "description": "Creates a criterion that measures the Binary Cross Entropy between the target and",
    "std_args": [
      "self",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "BCEWithLogitsLoss": {
    "description": "This loss combines a `Sigmoid` layer and the `BCELoss` in one single",
    "std_args": [
      "self",
      "weight",
      "size_average",
      "reduce",
      "reduction",
      "pos_weight"
    ],
    "type": "class"
  },
  "BLOCKS_ARE_CONTIGUOUS": {
    "description": "If True, guarantees that all blocks in the mask are contiguous.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_M": {
    "description": "Thread block size for the sequence length dimension of Q in forward pass.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_M1": {
    "description": "Thread block size for Q dimension in backward pass. Use as 'bwd_BLOCK_M1'.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_M2": {
    "description": "Thread block size for second Q dimension in backward pass. Use as 'bwd_BLOCK_M2'.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_N": {
    "description": "Thread block size for the sequence length dimension of K/V in forward pass.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_N1": {
    "description": "Thread block size for K/V dimension in backward pass. Use as 'bwd_BLOCK_N1'.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_N2": {
    "description": "Thread block size for second K/V dimension in backward pass. Use as 'bwd_BLOCK_N2'.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_SIZE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BasePruningMethod": {
    "description": "Abstract base class for creation of new pruning techniques.",
    "std_args": [],
    "type": "class"
  },
  "BatchNorm": {
    "description": "Batch Normalization.",
    "std_args": [
      "input",
      "eps"
    ]
  },
  "BatchNorm1d": {
    "description": "Applies Batch Normalization over a 2D or 3D input.",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "BatchNorm2d": {
    "description": "Applies Batch Normalization over a 4D input.",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "BatchNorm3d": {
    "description": "Applies Batch Normalization over a 5D input.",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "Bidirectional": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "attribute"
  },
  "BlockMask": {
    "description": "BlockMask is our format for representing a block-sparse attention mask.",
    "std_args": [
      "self",
      "seq_lengths",
      "kv_num_blocks",
      "kv_indices",
      "full_kv_num_blocks",
      "full_kv_indices",
      "q_num_blocks",
      "q_indices",
      "full_q_num_blocks",
      "full_q_indices",
      "BLOCK_SIZE",
      "mask_mod"
    ],
    "type": "class"
  },
  "Bool": {
    "description": "Boolean type.",
    "std_args": []
  },
  "Buffer": {
    "description": "A kind of Tensor that should not be considered a model",
    "std_args": [
      "self",
      "data",
      "requires_grad",
      "persistent"
    ],
    "type": "class"
  },
  "CTCLoss": {
    "description": "The Connectionist Temporal Classification loss.",
    "std_args": [
      "self",
      "blank",
      "reduction",
      "zero_infinity"
    ],
    "type": "class"
  },
  "Cache": {
    "description": "Container for mutable state.",
    "std_args": [
      "value"
    ]
  },
  "CastBool": {
    "description": "Cast tensor to bool",
    "metadata": {
      "target_type": "Bool"
    },
    "std_args": [
      "x"
    ]
  },
  "CastByte": {
    "description": "Cast tensor to uint8",
    "metadata": {
      "target_type": "UInt8"
    },
    "std_args": [
      "x"
    ]
  },
  "CastChar": {
    "description": "Cast tensor to int8/char (Keras context)",
    "metadata": {
      "target_type": "Int8"
    },
    "std_args": [
      "x"
    ]
  },
  "CastDouble": {
    "description": "Cast tensor to float64",
    "metadata": {
      "target_type": "Float64"
    },
    "std_args": [
      "x"
    ]
  },
  "CastFloat": {
    "description": "Cast tensor to float32",
    "metadata": {
      "target_type": "Float32"
    },
    "std_args": [
      "x"
    ]
  },
  "CastHalf": {
    "description": "Cast tensor to float16",
    "metadata": {
      "target_type": "Float16"
    },
    "std_args": [
      "x"
    ]
  },
  "CastInt": {
    "description": "Cast tensor to int32",
    "metadata": {
      "target_type": "Int32"
    },
    "std_args": [
      "x"
    ]
  },
  "CastLong": {
    "description": "Cast tensor to int64",
    "metadata": {
      "target_type": "Int64"
    },
    "std_args": [
      "x"
    ]
  },
  "CastShort": {
    "description": "Cast tensor to int16",
    "metadata": {
      "target_type": "Int16"
    },
    "std_args": [
      "x"
    ]
  },
  "CausalBias": {
    "description": "A bias representing causal attention patterns. For an overview of the bias structure, see the :class:`CausalVariant` enum.",
    "std_args": [
      "self",
      "variant",
      "seq_len_q",
      "seq_len_kv"
    ],
    "type": "class"
  },
  "CausalVariant": {
    "description": "Enum for causal variants used in attention mechanisms.",
    "std_args": [],
    "type": "class"
  },
  "Celu": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "alpha"
    ],
    "type": "class"
  },
  "CenterCrop": {
    "description": "Crops the given image at the center.",
    "std_args": [
      "size"
    ]
  },
  "ChannelShuffle": {
    "description": "Divides and rearranges the channels in a tensor.",
    "std_args": [
      "self",
      "groups"
    ],
    "type": "class"
  },
  "CircularPad1d": {
    "description": "Pads the input tensor using circular padding of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "CircularPad2d": {
    "description": "Pads the input tensor using circular padding of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "CircularPad3d": {
    "description": "Pads the input tensor using circular padding of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "Clamp": {
    "description": "Clamp all elements in input into the range [min, max].",
    "std_args": [
      "input",
      "min",
      "max"
    ]
  },
  "ClipGradNorm": {
    "description": "Clips gradient norm of an iterable of parameters.",
    "std_args": [
      "parameters",
      "max_norm"
    ]
  },
  "Compile": {
    "description": "JIT Alias.",
    "std_args": [
      "func"
    ],
    "type": "function"
  },
  "ConstantPad1d": {
    "description": "Pads the input tensor boundaries with a constant value.",
    "std_args": [
      "self",
      "padding",
      "value"
    ],
    "type": "class"
  },
  "ConstantPad2d": {
    "description": "Pads the input tensor boundaries with a constant value.",
    "std_args": [
      "self",
      "padding",
      "value"
    ],
    "type": "class"
  },
  "ConstantPad3d": {
    "description": "Pads the input tensor boundaries with a constant value.",
    "std_args": [
      "self",
      "padding",
      "value"
    ],
    "type": "class"
  },
  "Container": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "kwargs"
    ],
    "type": "class"
  },
  "Conv1d": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "Conv2d": {
    "description": "Applies a 2D convolution over an input signal composed of several input planes.",
    "std_args": [
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode"
    ],
    "type": "class"
  },
  "Conv3d": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "ConvT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ConvTranspose1d": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "output_padding",
      "groups",
      "bias",
      "dilation",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "ConvTranspose2d": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "output_padding",
      "groups",
      "bias",
      "dilation",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "ConvTranspose3d": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "output_padding",
      "groups",
      "bias",
      "dilation",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "CosineAnnealingLR": {
    "description": "Set the learning rate of each parameter group using a cosine annealing schedule.",
    "std_args": [
      "optimizer",
      "T_max"
    ]
  },
  "CosineEmbeddingLoss": {
    "description": "Creates a criterion that measures the loss given input tensors",
    "std_args": [
      "self",
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "CosineSimilarity": {
    "description": "Returns cosine similarity between :math:`x_1` and :math:`x_2`, computed along `dim`.",
    "std_args": [
      "self",
      "dim",
      "eps"
    ],
    "type": "class"
  },
  "CrossEntropyLoss": {
    "description": "Cross Entropy Loss.",
    "std_args": [
      "input",
      "target",
      "weight"
    ],
    "type": "class"
  },
  "CrossMapLRN2d": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "size",
      "alpha",
      "beta",
      "k"
    ],
    "type": "class"
  },
  "CustomFromMask": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "mask"
    ],
    "type": "class"
  },
  "DataLoader": {
    "description": "Foundational PyTorch Data Loader. Mapped to GenericDataLoader shim via Plugin.",
    "std_args": [
      "dataset",
      "batch_size",
      "shuffle",
      "sampler",
      "batch_sampler",
      "num_workers",
      "collate_fn",
      "pin_memory",
      "drop_last",
      "timeout",
      "worker_init_fn",
      "multiprocessing_context",
      "generator",
      "prefetch_factor",
      "persistent_workers",
      "pin_memory_device"
    ]
  },
  "DataParallel": {
    "description": "Implements data parallelism at the module level.",
    "std_args": [
      "self",
      "module",
      "device_ids",
      "output_device",
      "dim"
    ],
    "type": "class"
  },
  "DistributedDataParallel": {
    "description": "Implement distributed data parallelism based on ``torch.distributed`` at module level.",
    "std_args": [
      "self",
      "module",
      "device_ids",
      "output_device",
      "dim",
      "broadcast_buffers",
      "init_sync",
      "process_group",
      "bucket_cap_mb",
      "find_unused_parameters",
      "check_reduction",
      "gradient_as_bucket_view",
      "static_graph",
      "delay_all_reduce_named_params",
      "param_to_hook_all_reduce",
      "mixed_precision",
      "device_mesh",
      "skip_all_reduce_unused_params"
    ],
    "type": "class"
  },
  "DistributedDataParallelCPU": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "module",
      "device_ids",
      "output_device",
      "dim",
      "broadcast_buffers",
      "init_sync",
      "process_group",
      "bucket_cap_mb",
      "find_unused_parameters",
      "check_reduction",
      "gradient_as_bucket_view",
      "static_graph",
      "delay_all_reduce_named_params",
      "param_to_hook_all_reduce",
      "mixed_precision",
      "device_mesh",
      "skip_all_reduce_unused_params"
    ],
    "type": "class"
  },
  "Div": {
    "description": "Element-wise division.",
    "std_args": [
      "x",
      "y"
    ]
  },
  "Dropout": {
    "description": "Auto-discovered via Consensus (Score: 3.0)",
    "std_args": [
      "lr"
    ],
    "type": "attribute"
  },
  "Dropout1d": {
    "description": "Randomly zero out entire channels.",
    "std_args": [
      "self",
      "p",
      "inplace"
    ],
    "type": "class"
  },
  "Dropout2d": {
    "description": "Randomly zero out entire channels.",
    "std_args": [
      "self",
      "p",
      "inplace"
    ],
    "type": "class"
  },
  "Dropout3d": {
    "description": "Randomly zero out entire channels.",
    "std_args": [
      "self",
      "p",
      "inplace"
    ],
    "type": "class"
  },
  "Einsum": {
    "description": "Sums the product of the elements of the input operands along dimensions specified using a notation.",
    "std_args": [
      "equation",
      "operands"
    ]
  },
  "Elu": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "alpha"
    ],
    "type": "class"
  },
  "Embedding": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "class"
  },
  "EmbeddingBag": {
    "description": "Compute sums or means of 'bags' of embeddings, without instantiating the intermediate embeddings.",
    "std_args": [
      "self",
      "num_embeddings",
      "embedding_dim",
      "max_norm",
      "norm_type",
      "scale_grad_by_freq",
      "mode",
      "sparse",
      "_weight",
      "include_last_offset",
      "padding_idx",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "FORCE_USE_FLEX_ATTENTION": {
    "description": "If True, forces the use of the flex attention kernel instead of potentially using",
    "std_args": [],
    "type": "attribute"
  },
  "FeatureAlphaDropout": {
    "description": "Randomly masks out entire channels.",
    "std_args": [
      "self",
      "p",
      "inplace"
    ],
    "type": "class"
  },
  "Flatten": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "class"
  },
  "FlexKernelOptions": {
    "description": "Options for controlling the behavior of FlexAttention kernels.",
    "std_args": [],
    "type": "class"
  },
  "Float16": {
    "description": "16-bit floating point type (Half).",
    "std_args": []
  },
  "Float32": {
    "description": "32-bit floating point type.",
    "std_args": []
  },
  "Float64": {
    "description": "64-bit floating point type (Double).",
    "std_args": []
  },
  "Fold": {
    "description": "Combines an array of sliding local blocks into a large containing tensor.",
    "std_args": [
      "self",
      "output_size",
      "kernel_size",
      "dilation",
      "padding",
      "stride"
    ],
    "type": "class"
  },
  "FractionalMaxPool2d": {
    "description": "Applies a 2D fractional max pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "kernel_size",
      "output_size",
      "output_ratio",
      "return_indices",
      "_random_samples"
    ],
    "type": "class"
  },
  "FractionalMaxPool3d": {
    "description": "Applies a 3D fractional max pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "kernel_size",
      "output_size",
      "output_ratio",
      "return_indices",
      "_random_samples"
    ],
    "type": "class"
  },
  "GELU": {
    "description": "Gaussian Error Linear Unit.",
    "std_args": [
      "input"
    ],
    "type": "class"
  },
  "GRID_SAMPLE_INTERPOLATION_MODES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "GRID_SAMPLE_PADDING_MODES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Gather": {
    "description": "Gathers values along an axis specified by dim.",
    "std_args": [
      "input",
      "dim",
      "index"
    ],
    "type": "function"
  },
  "GaussianNLLLoss": {
    "description": "Gaussian negative log likelihood loss.",
    "std_args": [
      "self",
      "full",
      "eps",
      "reduction"
    ],
    "type": "class"
  },
  "Glu": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "dim"
    ],
    "type": "class"
  },
  "Grayscale": {
    "description": "Convert image to grayscale.",
    "std_args": [
      "num_output_channels"
    ]
  },
  "Groupnorm": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "dtype",
      "eps",
      "num_groups"
    ],
    "type": "class"
  },
  "Grucell": {
    "description": "Auto-discovered via Consensus (Score: 3.0)",
    "std_args": [
      "dtype"
    ],
    "type": "class"
  },
  "Hardtanh": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "class"
  },
  "HingeEmbeddingLoss": {
    "description": "Measures the loss given an input tensor :math:`x` and a labels tensor :math:`y`",
    "std_args": [
      "self",
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "HuberLoss": {
    "description": "Creates a criterion that uses a squared term if the absolute",
    "std_args": [
      "self",
      "reduction",
      "delta"
    ],
    "type": "class"
  },
  "Identity": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "kwargs"
    ],
    "type": "class"
  },
  "InstanceNorm1d": {
    "description": "Applies Instance Normalization.",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "InstanceNorm2d": {
    "description": "Applies Instance Normalization.",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "InstanceNorm3d": {
    "description": "Applies Instance Normalization.",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "Int16": {
    "description": "16-bit signed integer type (Short).",
    "std_args": []
  },
  "Int32": {
    "description": "32-bit signed integer type (Int).",
    "std_args": []
  },
  "Int64": {
    "description": "64-bit signed integer type (Long).",
    "std_args": []
  },
  "KLDivLoss": {
    "description": "The Kullback-Leibler divergence loss.",
    "std_args": [
      "self",
      "size_average",
      "reduce",
      "reduction",
      "log_target"
    ],
    "type": "class"
  },
  "L1Loss": {
    "description": "Creates a criterion that measures the mean absolute error (MAE) between each element in",
    "std_args": [
      "self",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "L1Unstructured": {
    "description": "Prune (currently unpruned) units in a tensor by zeroing out the ones with the lowest L1-norm.",
    "std_args": [
      "self",
      "amount"
    ],
    "type": "class"
  },
  "LOWER_RIGHT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "LPPool1d": {
    "description": "Applies a 1D power-average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "norm_type",
      "kernel_size",
      "stride",
      "ceil_mode"
    ],
    "type": "class"
  },
  "LPPool2d": {
    "description": "Applies a 2D power-average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "norm_type",
      "kernel_size",
      "stride",
      "ceil_mode"
    ],
    "type": "class"
  },
  "LPPool3d": {
    "description": "Applies a 3D power-average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "norm_type",
      "kernel_size",
      "stride",
      "ceil_mode"
    ],
    "type": "class"
  },
  "LayerNorm": {
    "description": "Applies Layer Normalization over a mini-batch of inputs.",
    "std_args": [
      "normalized_shape",
      "eps",
      "elementwise_affine",
      "bias"
    ],
    "type": "class"
  },
  "LazyBatchNorm1d": {
    "description": "A :class:`torch.nn.BatchNorm1d` module with lazy initialization.",
    "std_args": [
      "self",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyBatchNorm2d": {
    "description": "A :class:`torch.nn.BatchNorm2d` module with lazy initialization.",
    "std_args": [
      "self",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyBatchNorm3d": {
    "description": "A :class:`torch.nn.BatchNorm3d` module with lazy initialization.",
    "std_args": [
      "self",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyConv1d": {
    "description": "A :class:`torch.nn.Conv1d` module with lazy initialization of the ``in_channels`` argument.",
    "std_args": [
      "self",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyConv2d": {
    "description": "A :class:`torch.nn.Conv2d` module with lazy initialization of the ``in_channels`` argument.",
    "std_args": [
      "self",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyConv3d": {
    "description": "A :class:`torch.nn.Conv3d` module with lazy initialization of the ``in_channels`` argument.",
    "std_args": [
      "self",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyConvTranspose1d": {
    "description": "A :class:`torch.nn.ConvTranspose1d` module with lazy initialization of the ``in_channels`` argument.",
    "std_args": [
      "self",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "output_padding",
      "groups",
      "bias",
      "dilation",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyConvTranspose2d": {
    "description": "A :class:`torch.nn.ConvTranspose2d` module with lazy initialization of the ``in_channels`` argument.",
    "std_args": [
      "self",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "output_padding",
      "groups",
      "bias",
      "dilation",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyConvTranspose3d": {
    "description": "A :class:`torch.nn.ConvTranspose3d` module with lazy initialization of the ``in_channels`` argument.",
    "std_args": [
      "self",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "output_padding",
      "groups",
      "bias",
      "dilation",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyInstanceNorm1d": {
    "description": "A :class:`torch.nn.InstanceNorm1d` module with lazy initialization of the ``num_features`` argument.",
    "std_args": [
      "self",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyInstanceNorm2d": {
    "description": "A :class:`torch.nn.InstanceNorm2d` module with lazy initialization of the ``num_features`` argument.",
    "std_args": [
      "self",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyInstanceNorm3d": {
    "description": "A :class:`torch.nn.InstanceNorm3d` module with lazy initialization of the ``num_features`` argument.",
    "std_args": [
      "self",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyLinear": {
    "description": "A :class:`torch.nn.Linear` module where `in_features` is inferred.",
    "std_args": [
      "self",
      "out_features",
      "bias",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "Linear": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "dtype",
      "in_features",
      "out_features"
    ],
    "type": "class"
  },
  "LinearT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "LnStructured": {
    "description": "Prune entire (currently unpruned) channels in a tensor based on their L\\ ``n``-norm.",
    "std_args": [
      "self",
      "amount",
      "n",
      "dim"
    ],
    "type": "class"
  },
  "LoadStateDict": {
    "description": "Loading state utility for mappings.",
    "std_args": []
  },
  "LocalResponseNorm": {
    "description": "Applies local response normalization over an input signal.",
    "std_args": [
      "self",
      "size",
      "alpha",
      "beta",
      "k"
    ],
    "type": "class"
  },
  "Logsumexp": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "b",
      "dim",
      "keepdim",
      "return_sign",
      "where",
      "x"
    ],
    "type": "attribute"
  },
  "Lstmcell": {
    "description": "Auto-discovered via Consensus (Score: 3.0)",
    "std_args": [
      "dtype"
    ],
    "type": "class"
  },
  "MSELoss": {
    "description": "Mean Squared Error.",
    "std_args": [
      "input",
      "target"
    ],
    "type": "class"
  },
  "MarginRankingLoss": {
    "description": "Creates a criterion that measures the loss given",
    "std_args": [
      "self",
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "MaxPool1d": {
    "description": "Applies a 1D max pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "return_indices",
      "ceil_mode"
    ],
    "type": "class"
  },
  "MaxPool2d": {
    "description": "Applies a 2D max pooling over an input signal composed of several input planes.",
    "std_args": [
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "return_indices",
      "ceil_mode"
    ],
    "type": "class"
  },
  "MaxPool3d": {
    "description": "Applies a 3D max pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "return_indices",
      "ceil_mode"
    ],
    "type": "class"
  },
  "MaxUnpool1d": {
    "description": "Computes a partial inverse of :class:`MaxPool1d`.",
    "std_args": [
      "self",
      "kernel_size",
      "stride",
      "padding"
    ],
    "type": "class"
  },
  "MaxUnpool2d": {
    "description": "Computes a partial inverse of :class:`MaxPool2d`.",
    "std_args": [
      "self",
      "kernel_size",
      "stride",
      "padding"
    ],
    "type": "class"
  },
  "MaxUnpool3d": {
    "description": "Computes a partial inverse of :class:`MaxPool3d`.",
    "std_args": [
      "self",
      "kernel_size",
      "stride",
      "padding"
    ],
    "type": "class"
  },
  "Mean": {
    "description": "Calculates the mean value.",
    "std_args": [
      "x"
    ]
  },
  "Mish": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "x"
    ],
    "type": "class"
  },
  "Mul": {
    "description": "Element-wise multiplication.",
    "std_args": [
      "x",
      "y"
    ]
  },
  "MultiLabelMarginLoss": {
    "description": "Creates a criterion that optimizes a multi-class multi-classification",
    "std_args": [
      "self",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "MultiLabelSoftMarginLoss": {
    "description": "Creates a criterion that optimizes a multi-label one-versus-all",
    "std_args": [
      "self",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "MultiMarginLoss": {
    "description": "Creates a criterion that optimizes a multi-class classification hinge",
    "std_args": [
      "self",
      "p",
      "margin",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "MultiheadAttention": {
    "description": "Multi-head attention mechanism.",
    "std_args": [
      "embed_dim",
      "num_heads",
      "dropout",
      "bias",
      "add_bias_kv",
      "add_zero_attn",
      "kdim",
      "vdim",
      "batch_first"
    ],
    "type": "class"
  },
  "NLLLoss": {
    "description": "The negative log likelihood loss. It is useful to train a classification",
    "std_args": [
      "self",
      "weight",
      "size_average",
      "ignore_index",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "NLLLoss2d": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "weight",
      "size_average",
      "ignore_index",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "NamedShape": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "NonDynamicallyQuantizableLinear": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "in_features",
      "out_features",
      "bias",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "Normalize": {
    "description": "Normalize a tensor image with mean and standard deviation.",
    "std_args": [
      "mean",
      "std",
      "inplace"
    ],
    "type": "function"
  },
  "OneHot": {
    "description": "Takes LongTensor with index values of shape (*) and returns a tensor of shape (*, num_classes).",
    "std_args": [
      "tensor",
      "num_classes"
    ]
  },
  "OrderedDictWrapper": {
    "description": "A wrapper around a C++ OrderedDict.",
    "std_args": [
      "self",
      "cpp_module",
      "attr"
    ],
    "type": "class"
  },
  "PRESCALE_QK": {
    "description": "Whether to pre-scale QK by 1/sqrt(d) and change of base. This is slightly faster but",
    "std_args": [],
    "type": "attribute"
  },
  "PRUNING_TYPE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PackedSequence": {
    "description": "Holds the data and list of :attr:`batch_sizes` of a packed sequence.",
    "std_args": [],
    "type": "class"
  },
  "PackedSequence_": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Pad": {
    "description": "Pads input tensor.",
    "std_args": [
      "input",
      "pad",
      "mode",
      "value"
    ],
    "type": "function"
  },
  "PairwiseDistance": {
    "description": "Computes the pairwise distance between input vectors, or between columns of input matrices.",
    "std_args": [
      "self",
      "p",
      "eps",
      "keepdim"
    ],
    "type": "class"
  },
  "Param": {
    "description": "Container for trainable parameter.",
    "std_args": [
      "value"
    ]
  },
  "Parameter": {
    "description": "A kind of Tensor that is to be considered a module parameter.",
    "std_args": [
      "self",
      "data",
      "requires_grad"
    ],
    "type": "class"
  },
  "ParameterDict": {
    "description": "Holds parameters in a dictionary.",
    "std_args": [
      "self",
      "parameters"
    ],
    "type": "class"
  },
  "ParameterList": {
    "description": "Holds parameters in a list.",
    "std_args": [
      "self",
      "values"
    ],
    "type": "class"
  },
  "ParametrizationList": {
    "description": "A sequential container that holds and manages the original parameters or buffers of a parametrized :class:`torch.nn.Module`.",
    "std_args": [
      "self",
      "modules",
      "original",
      "unsafe"
    ],
    "type": "class"
  },
  "PixelShuffle": {
    "description": "Rearrange elements in a tensor according to an upscaling factor.",
    "std_args": [
      "self",
      "upscale_factor"
    ],
    "type": "class"
  },
  "PixelUnshuffle": {
    "description": "Reverse the PixelShuffle operation.",
    "std_args": [
      "self",
      "downscale_factor"
    ],
    "type": "class"
  },
  "PoissonNLLLoss": {
    "description": "Negative log likelihood loss with Poisson distribution of target.",
    "std_args": [
      "self",
      "log_input",
      "full",
      "size_average",
      "eps",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "Pow": {
    "description": "Element-wise power.",
    "std_args": [
      "x",
      "y"
    ]
  },
  "PruningContainer": {
    "description": "Container holding a sequence of pruning methods for iterative pruning.",
    "std_args": [
      "self",
      "args"
    ],
    "type": "class"
  },
  "RMSprop": {
    "description": "Root Mean Square Propagation optimizer.",
    "std_args": [
      "params",
      "lr",
      "rho",
      "eps",
      "weight_decay",
      "momentum",
      "centered"
    ]
  },
  "RNNBase": {
    "description": "Base class for RNN modules (RNN, LSTM, GRU).",
    "std_args": [
      "self",
      "mode",
      "input_size",
      "hidden_size",
      "num_layers",
      "bias",
      "batch_first",
      "dropout",
      "bidirectional",
      "proj_size",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "RNNCell": {
    "description": "An Elman RNN cell with tanh or ReLU non-linearity.",
    "std_args": [
      "self",
      "input_size",
      "hidden_size",
      "bias",
      "nonlinearity",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "ROWS_GUARANTEED_SAFE": {
    "description": "If True, guarantees that at least one value in each row is not masked out.",
    "std_args": [],
    "type": "attribute"
  },
  "RPC_AVAILABLE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "RReLU": {
    "description": "Applies the randomized leaky rectified linear unit function, element-wise.",
    "std_args": [
      "self",
      "lower",
      "upper",
      "inplace"
    ],
    "type": "class"
  },
  "RandomCrop": {
    "description": "Crop the given image at a random location.",
    "std_args": [
      "size",
      "padding",
      "pad_if_needed",
      "fill",
      "padding_mode"
    ]
  },
  "RandomHorizontalFlip": {
    "description": "Horizontally flip the image randomly with a given probability.",
    "std_args": [
      "p"
    ]
  },
  "RandomStructured": {
    "description": "Prune entire (currently unpruned) channels in a tensor at random.",
    "std_args": [
      "self",
      "amount",
      "dim"
    ],
    "type": "class"
  },
  "RandomUnstructured": {
    "description": "Prune (currently unpruned) units in a tensor at random.",
    "std_args": [
      "self",
      "amount"
    ],
    "type": "class"
  },
  "RandomVerticalFlip": {
    "description": "Vertically flip the image randomly with a given probability.",
    "std_args": [
      "p"
    ]
  },
  "ReflectionPad1d": {
    "description": "Pads the input tensor using the reflection of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ReflectionPad2d": {
    "description": "Pads the input tensor using the reflection of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ReflectionPad3d": {
    "description": "Pads the input tensor using the reflection of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "Relu6": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "class"
  },
  "ReplicationPad1d": {
    "description": "Pads the input tensor using replication of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ReplicationPad2d": {
    "description": "Pads the input tensor using replication of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ReplicationPad3d": {
    "description": "Pads the input tensor using replication of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "Reshape": {
    "description": "Returns a tensor with the same data and number of elements as input, but with the specified shape.",
    "std_args": [
      "input",
      "shape"
    ]
  },
  "Resize": {
    "description": "Resize the input image to the given size.",
    "std_args": [
      "size"
    ]
  },
  "Rmsnorm": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "dtype",
      "eps"
    ],
    "type": "class"
  },
  "Rnncellbase": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "class"
  },
  "SDPBackend": {
    "description": "An enum-like class that contains the different backends for scaled dot product attention.",
    "std_args": [],
    "type": "attribute"
  },
  "SGD": {
    "description": "Stochastic Gradient Descent optimizer.",
    "std_args": [
      "params",
      "lr",
      "momentum",
      "dampening",
      "weight_decay",
      "nesterov"
    ]
  },
  "Scatter": {
    "description": "Writes all values from the tensor src into indices specified.",
    "std_args": [
      "input",
      "dim",
      "index",
      "src"
    ],
    "type": "function"
  },
  "Selu": {
    "description": "Auto-discovered via Consensus (Score: 3.0)",
    "std_args": [],
    "type": "class"
  },
  "Sequential": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "class"
  },
  "Sigmoid": {
    "description": "Auto-discovered via Consensus (Score: 3.0)",
    "std_args": [
      "x"
    ],
    "type": "class"
  },
  "Silu": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "x"
    ],
    "type": "class"
  },
  "SmoothL1Loss": {
    "description": "Creates a criterion that uses a squared term if the absolute",
    "std_args": [
      "self",
      "size_average",
      "reduce",
      "reduction",
      "beta"
    ],
    "type": "class"
  },
  "SoftMarginLoss": {
    "description": "Creates a criterion that optimizes a two-class classification",
    "std_args": [
      "self",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "Softmax": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "kwargs"
    ],
    "type": "class"
  },
  "Softmax2d": {
    "description": "Applies SoftMax over features to each spatial location.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "Softplus": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "class"
  },
  "Softshrink": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "class"
  },
  "Softsign": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "class"
  },
  "SpectralNorm": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "name",
      "n_power_iterations",
      "dim",
      "eps"
    ],
    "type": "class"
  },
  "SpectralNormLoadStateDictPreHook": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "fn"
    ],
    "type": "class"
  },
  "SpectralNormStateDictHook": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "fn"
    ],
    "type": "class"
  },
  "Squeeze": {
    "description": "Returns a tensor with all the dimensions of input of size 1 removed.",
    "std_args": [
      "input",
      "dim"
    ]
  },
  "StepLR": {
    "description": "Decays the learning rate of each parameter group by gamma every step_size epochs.",
    "std_args": [
      "optimizer",
      "step_size",
      "gamma"
    ]
  },
  "Sub": {
    "description": "Element-wise subtraction.",
    "std_args": [
      "x",
      "y"
    ]
  },
  "Sum": {
    "description": "Calculates the sum value.",
    "std_args": [
      "x"
    ]
  },
  "SyncBatchNorm": {
    "description": "Applies Batch Normalization over a N-Dimensional input.",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "process_group",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "Synchronize": {
    "description": "Execution Barrier.",
    "std_args": []
  },
  "T": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "T_destination": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Tanhshrink": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "type": "class"
  },
  "Tensor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Threshold": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      "threshold"
    ],
    "type": "attribute"
  },
  "ToTensor": {
    "description": "Convert a PIL Image or numpy.ndarray to tensor.",
    "std_args": []
  },
  "TopK": {
    "description": "Returns the k largest elements of the given input tensor along a given dimension.",
    "std_args": [
      "input",
      "k",
      "dim",
      "largest",
      "sorted"
    ]
  },
  "TorchFunctional": {
    "description": "Abstract Functional Namespace (e.g. F in torch.nn.functional)",
    "std_args": []
  },
  "TripletMarginLoss": {
    "description": "Creates a criterion that measures the triplet loss given an input",
    "std_args": [
      "self",
      "margin",
      "p",
      "eps",
      "swap",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "TripletMarginWithDistanceLoss": {
    "description": "Creates a criterion that measures the triplet loss given input",
    "std_args": [
      "self",
      "distance_function",
      "margin",
      "swap",
      "reduction"
    ],
    "type": "class"
  },
  "UInt8": {
    "description": "8-bit unsigned integer type (Byte).",
    "std_args": []
  },
  "UPPER_LEFT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "USE_TMA": {
    "description": "Whether to use Tensor Memory Accelerator (TMA) on supported hardware.",
    "std_args": [],
    "type": "attribute"
  },
  "Unflatten": {
    "description": "Unflattens a tensor dim expanding it to a desired shape. For use with :class:`~nn.Sequential`.",
    "std_args": [
      "self",
      "dim",
      "unflattened_size"
    ],
    "type": "class"
  },
  "Unfold": {
    "description": "Extracts sliding local blocks from a batched input tensor.",
    "std_args": [
      "self",
      "kernel_size",
      "dilation",
      "padding",
      "stride"
    ],
    "type": "class"
  },
  "UninitializedBuffer": {
    "description": "A buffer that is not initialized.",
    "std_args": [
      "self",
      "data",
      "requires_grad",
      "persistent"
    ],
    "type": "class"
  },
  "UninitializedParameter": {
    "description": "A parameter that is not initialized.",
    "std_args": [
      "self",
      "data",
      "requires_grad"
    ],
    "type": "class"
  },
  "UninitializedTensorMixin": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Unsqueeze": {
    "description": "Returns a new tensor with a dimension of size one inserted at the specified position.",
    "std_args": [
      "input",
      "dim"
    ]
  },
  "UpsamplingBilinear2d": {
    "description": "Applies a 2D bilinear upsampling to an input signal composed of several input channels.",
    "std_args": [
      "self",
      "size",
      "scale_factor"
    ],
    "type": "class"
  },
  "UpsamplingNearest2d": {
    "description": "Applies a 2D nearest neighbor upsampling to an input signal composed of several input channels.",
    "std_args": [
      "self",
      "size",
      "scale_factor"
    ],
    "type": "class"
  },
  "Variable": {
    "description": "Generic state container.",
    "std_args": [
      "value"
    ]
  },
  "View": {
    "description": "Returns a new tensor with the same data as the self tensor but of a different shape.",
    "std_args": [
      "input",
      "shape"
    ]
  },
  "WARN_FOR_UNFUSED_KERNELS": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "WRITE_DQ": {
    "description": "Controls whether gradient scatters are done in the DQ iteration loop of the backward pass.",
    "std_args": [],
    "type": "attribute"
  },
  "WeightNorm": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "name",
      "dim"
    ],
    "type": "class"
  },
  "ZeroPad1d": {
    "description": "Pads the input tensor boundaries with zero.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ZeroPad2d": {
    "description": "Pads the input tensor boundaries with zero.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ZeroPad3d": {
    "description": "Pads the input tensor boundaries with zero.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "__imports__": {},
  "activation": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "activation_relu_or_gelu": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "adaptive_avg_pool1d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "adaptive_avg_pool2d": {
    "description": "Apply a 2D adaptive average pooling over an input signal composed of several input planes.",
    "std_args": [
      "input",
      "output_size"
    ],
    "type": "function"
  },
  "adaptive_avg_pool3d": {
    "description": "Apply a 3D adaptive average pooling over an input signal composed of several input planes.",
    "std_args": [
      "input",
      "output_size"
    ],
    "type": "function"
  },
  "adaptive_max_pool1d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "adaptive_max_pool1d_with_indices": {
    "description": "adaptive_max_pool1d(input, output_size, return_indices=False)",
    "std_args": [
      "input",
      "output_size",
      "return_indices"
    ],
    "type": "function"
  },
  "adaptive_max_pool2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "adaptive_max_pool2d_with_indices": {
    "description": "adaptive_max_pool2d(input, output_size, return_indices=False)",
    "std_args": [
      "input",
      "output_size",
      "return_indices"
    ],
    "type": "function"
  },
  "adaptive_max_pool3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "adaptive_max_pool3d_with_indices": {
    "description": "adaptive_max_pool3d(input, output_size, return_indices=False)",
    "std_args": [
      "input",
      "output_size",
      "return_indices"
    ],
    "type": "function"
  },
  "add_pruning_method": {
    "description": "Add a child pruning ``method`` to the container.",
    "std_args": [
      "self",
      "method"
    ],
    "type": "function"
  },
  "add_zero_attn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "affine": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "affine_grid": {
    "description": "Generate 2D or 3D flow field (sampling grid), given a batch of affine matrices :attr:`theta`.",
    "std_args": [
      "theta",
      "size",
      "align_corners"
    ],
    "type": "function"
  },
  "airy_ai": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "align_corners": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "all_weights": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "alpha": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "alpha_dropout": {
    "description": "Apply alpha dropout to the input.",
    "std_args": [
      "input",
      "p",
      "training",
      "inplace"
    ],
    "type": "function"
  },
  "amount": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "and_masks": {
    "description": "Returns a mask_mod that's the intersection of provided mask_mods",
    "std_args": [
      "mask_mods"
    ],
    "type": "function"
  },
  "append": {
    "description": "Append a given value at the end of the list.",
    "std_args": [
      "self",
      "value"
    ],
    "type": "function"
  },
  "apply": {
    "description": "Apply ``fn`` recursively to every submodule (as returned by ``.children()``) as well as self.",
    "std_args": [
      "self",
      "fn"
    ],
    "type": "function"
  },
  "apply_mask": {
    "description": "Simply handles the multiplication between the parameter being pruned and the generated mask.",
    "std_args": [
      "self",
      "module"
    ],
    "type": "function"
  },
  "apply_permutation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tensor",
      "permutation",
      "dim"
    ],
    "type": "function"
  },
  "approximate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "as_tuple": {
    "description": "Returns a tuple of the attributes of the BlockMask.",
    "std_args": [
      "self",
      "flatten"
    ],
    "type": "function"
  },
  "assert_int_or_pair": {
    "description": "The class representing a Python function.",
    "std_args": [
      "arg",
      "arg_name",
      "message"
    ],
    "type": "function"
  },
  "attr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "avg_pool1d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "avg_pool2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "avg_pool3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "batch_first": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "batch_norm": {
    "description": "Apply Batch Normalization for each channel across a batch of data.",
    "std_args": [
      "input",
      "running_mean",
      "running_var",
      "weight",
      "bias",
      "training",
      "momentum",
      "eps"
    ],
    "type": "function"
  },
  "batch_sizes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bessel_j0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bessel_j1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bessel_y0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bessel_y1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "beta": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bfloat16": {
    "description": "Casts all floating point parameters and buffers to ``bfloat16`` datatype.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "bias": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bias_hh": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bias_ih": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bias_k": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bias_v": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "binary_cross_entropy": {
    "description": "Compute Binary Cross Entropy between the target and input probabilities.",
    "std_args": [
      "input",
      "target",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "binary_cross_entropy_with_logits": {
    "description": "Compute Binary Cross Entropy between target and input logits.",
    "std_args": [
      "input",
      "target",
      "weight",
      "size_average",
      "reduce",
      "reduction",
      "pos_weight"
    ],
    "type": "function"
  },
  "bind": {
    "description": "The class representing a Python function.",
    "std_args": [
      "optional",
      "fn"
    ],
    "type": "function"
  },
  "blank": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "broadcast": {
    "description": "Broadcasts a tensor to specified GPU devices.",
    "std_args": [
      "tensor",
      "devices",
      "out"
    ],
    "type": "function"
  },
  "broadcast_bucket_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "broadcast_buffers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "broadcast_coalesced": {
    "description": "Broadcast a sequence of tensors to the specified GPUs.",
    "std_args": [
      "tensors",
      "devices",
      "buffer_size"
    ],
    "type": "function"
  },
  "bucket_bytes_cap": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bucket_bytes_cap_default": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "buffers": {
    "description": "Return an iterator over module buffers.",
    "std_args": [
      "self",
      "recurse"
    ],
    "type": "function"
  },
  "byte": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "cached": {
    "description": "Context manager that enables the caching system within parametrizations registered with :func:`register_parametrization`.",
    "std_args": [],
    "type": "function"
  },
  "calculate_gain": {
    "description": "Return the recommended gain value for the given nonlinearity function.",
    "std_args": [
      "nonlinearity",
      "param"
    ],
    "type": "function"
  },
  "call_super_init": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "causal_lower_right": {
    "description": "Creates a lower-right triangular causal bias.",
    "std_args": [
      "size"
    ],
    "type": "function"
  },
  "causal_upper_left": {
    "description": "Creates an upper-left triangular causal bias.",
    "std_args": [
      "size"
    ],
    "type": "function"
  },
  "ceil_mode": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "celu_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "channel_shuffle": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "char": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "chebyshev_polynomial_t": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebyshev_polynomial_u": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebyshev_polynomial_v": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "chebyshev_polynomial_w": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "check_forward_args": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "input",
      "hidden",
      "batch_sizes"
    ],
    "type": "function"
  },
  "check_hidden_size": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "hx",
      "expected_hidden_size",
      "msg"
    ],
    "type": "function"
  },
  "check_input": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "input",
      "batch_sizes"
    ],
    "type": "function"
  },
  "children": {
    "description": "Return an iterator over immediate children modules.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "cholesky_ex": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "clear": {
    "description": "Remove all items from the ParameterDict.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "clip_grad_norm": {
    "description": "Clip the gradient norm of an iterable of parameters.",
    "std_args": [
      "parameters",
      "max_norm",
      "norm_type",
      "error_if_nonfinite",
      "foreach"
    ],
    "type": "function"
  },
  "clip_grad_norm_": {
    "description": "Clip the gradient norm of an iterable of parameters.",
    "std_args": [
      "parameters",
      "max_norm",
      "norm_type",
      "error_if_nonfinite",
      "foreach"
    ],
    "type": "function"
  },
  "clip_grad_value_": {
    "description": "Clip the gradients of an iterable of parameters at specified value.",
    "std_args": [
      "parameters",
      "clip_value",
      "foreach"
    ],
    "type": "function"
  },
  "cls_to_become": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "common_notes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "compute_mask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "t",
      "default_mask"
    ],
    "type": "function"
  },
  "compute_weight": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "module"
    ],
    "type": "function"
  },
  "cond": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "constant_": {
    "description": "Fill the input Tensor with the value :math:`\\text{val}`.",
    "std_args": [
      "tensor",
      "val"
    ],
    "type": "function"
  },
  "consume_prefix_in_state_dict_if_present": {
    "description": "Strip the prefix in state_dict in place, if any.",
    "std_args": [
      "state_dict",
      "prefix"
    ],
    "type": "function"
  },
  "conv1d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "conv1d_input": {
    "description": "Compute the gradient of conv1d with respect to the input of the convolution.",
    "std_args": [
      "input_size",
      "weight",
      "grad_output",
      "stride",
      "padding",
      "dilation",
      "groups"
    ],
    "type": "function"
  },
  "conv1d_weight": {
    "description": "Compute the gradient of conv1d with respect to the weight of the convolution.",
    "std_args": [
      "input",
      "weight_size",
      "grad_output",
      "stride",
      "padding",
      "dilation",
      "groups"
    ],
    "type": "function"
  },
  "conv2d_input": {
    "description": "Compute the gradient of conv2d with respect to the input of the convolution.",
    "std_args": [
      "input_size",
      "weight",
      "grad_output",
      "stride",
      "padding",
      "dilation",
      "groups"
    ],
    "type": "function"
  },
  "conv2d_weight": {
    "description": "Compute the gradient of conv2d with respect to the weight of the convolution.",
    "std_args": [
      "input",
      "weight_size",
      "grad_output",
      "stride",
      "padding",
      "dilation",
      "groups"
    ],
    "type": "function"
  },
  "conv3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "conv3d_input": {
    "description": "Compute the gradient of conv3d with respect to the input of the convolution.",
    "std_args": [
      "input_size",
      "weight",
      "grad_output",
      "stride",
      "padding",
      "dilation",
      "groups"
    ],
    "type": "function"
  },
  "conv3d_weight": {
    "description": "Compute the gradient of conv3d with respect to the weight of the convolution.",
    "std_args": [
      "input",
      "weight_size",
      "grad_output",
      "stride",
      "padding",
      "dilation",
      "groups"
    ],
    "type": "function"
  },
  "conv_tbc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "conv_transpose1d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "conv_transpose2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "conv_transpose3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "convert_conv2d_weight_memory_format": {
    "description": "Convert ``memory_format`` of ``nn.Conv2d.weight`` to ``memory_format``.",
    "std_args": [
      "module",
      "memory_format"
    ],
    "type": "function"
  },
  "convert_conv3d_weight_memory_format": {
    "description": "Convert ``memory_format`` of ``nn.Conv3d.weight`` to ``memory_format``",
    "std_args": [
      "module",
      "memory_format"
    ],
    "type": "function"
  },
  "convert_sync_batchnorm": {
    "description": "Converts all :attr:`BatchNorm*D` layers in the model to :class:`torch.nn.SyncBatchNorm` layers.",
    "std_args": [
      "cls",
      "module",
      "process_group"
    ],
    "type": "function"
  },
  "convolution_notes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "copy": {
    "description": "Return a copy of this :class:`~torch.nn.ParameterDict` instance.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "cosine_embedding_loss": {
    "description": "Compute the cosine embedding loss.",
    "std_args": [
      "input1",
      "input2",
      "target",
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "cosine_similarity": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "count_include_pad": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cpp_dict": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cpu": {
    "description": "Move all model parameters and buffers to the CPU.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "create_block_mask": {
    "description": "This function creates a block mask tuple from a mask_mod function.",
    "std_args": [
      "mask_mod",
      "B",
      "H",
      "Q_LEN",
      "KV_LEN",
      "device",
      "BLOCK_SIZE",
      "_compile"
    ],
    "type": "function"
  },
  "create_mask": {
    "description": "This function creates a mask tensor from a mod_fn function.",
    "std_args": [
      "mod_fn",
      "B",
      "H",
      "Q_LEN",
      "KV_LEN",
      "device"
    ],
    "type": "function"
  },
  "create_nested_block_mask": {
    "description": "This function creates a nested tensor compatible block mask tuple from a mask_mod",
    "std_args": [
      "mask_mod",
      "B",
      "H",
      "q_nt",
      "kv_nt",
      "BLOCK_SIZE",
      "_compile"
    ],
    "type": "function"
  },
  "cross_entropy": {
    "description": "Compute the cross entropy loss between input logits and target.",
    "std_args": [
      "input",
      "target",
      "weight",
      "size_average",
      "ignore_index",
      "reduce",
      "reduction",
      "label_smoothing"
    ],
    "type": "function"
  },
  "ctc_loss": {
    "description": "Compute the Connectionist Temporal Classification loss.",
    "std_args": [
      "log_probs",
      "targets",
      "input_lengths",
      "target_lengths",
      "blank",
      "reduction",
      "zero_infinity"
    ],
    "type": "function"
  },
  "cuda": {
    "description": "Move all model parameters and buffers to the GPU.",
    "std_args": [
      "self",
      "device"
    ],
    "type": "function"
  },
  "custom_from_mask": {
    "description": "Prune tensor corresponding to parameter called ``name`` in ``module`` by applying the pre-computed mask in ``mask``.",
    "std_args": [
      "module",
      "name",
      "mask"
    ],
    "type": "function"
  },
  "cutoffs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "data": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "data_parallel": {
    "description": "Evaluate module(input) in parallel across the GPUs given in device_ids.",
    "std_args": [
      "module",
      "inputs",
      "device_ids",
      "output_device",
      "dim",
      "module_kwargs"
    ],
    "type": "function"
  },
  "data_ptr": {
    "description": "Get valid data pointer or buffer access.",
    "std_args": []
  },
  "decoder": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "delta": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "device": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "device_ids": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "device_mesh": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "device_type": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "digamma": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dilation": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dirac": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dirac_": {
    "description": "Fill the {3, 4, 5}-dimensional input `Tensor` with the Dirac delta function.",
    "std_args": [
      "tensor",
      "groups"
    ],
    "type": "function"
  },
  "distance_function": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "div_value": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "divisor_override": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "double": {
    "description": "Casts all floating point parameters and buffers to ``double`` datatype.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "downscale_factor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dropout1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dropout1d": {
    "description": "Randomly zero out entire channels (a channel is a 1D feature map).",
    "std_args": [
      "input",
      "p",
      "training",
      "inplace"
    ],
    "type": "function"
  },
  "dropout2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dropout2d": {
    "description": "Randomly zero out entire channels (a channel is a 2D feature map).",
    "std_args": [
      "input",
      "p",
      "training",
      "inplace"
    ],
    "type": "function"
  },
  "dropout3": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dropout3d": {
    "description": "Randomly zero out entire channels (a channel is a 3D feature map).",
    "std_args": [
      "input",
      "p",
      "training",
      "inplace"
    ],
    "type": "function"
  },
  "dump_patches": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "eig": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "eigvals": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "elementwise_affine": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "elu_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "embed_dim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "embedding_bag": {
    "description": "Compute sums, means or maxes of `bags` of embeddings.",
    "std_args": [
      "input",
      "weight",
      "offsets",
      "max_norm",
      "norm_type",
      "scale_grad_by_freq",
      "mode",
      "sparse",
      "per_sample_weights",
      "include_last_offset",
      "padding_idx"
    ],
    "type": "function"
  },
  "embedding_dim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "enable_grad": {
    "description": "Context-manager that enables gradient calculation.",
    "op_type": "context",
    "std_args": []
  },
  "enable_nested_tensor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "encoder": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "end_dim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "entr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "eps": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "erfc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "erfcx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "erfinv": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "eval": {
    "description": "Set the module in evaluation mode.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "exp": {
    "description": "Exponential.",
    "std_args": [
      "x"
    ]
  },
  "exp2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "expit": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "extend": {
    "description": "Append values from a Python iterable to the end of the list.",
    "std_args": [
      "self",
      "values"
    ],
    "type": "function"
  },
  "extra_repr": {
    "description": "Return the extra representation of the module.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "eye_": {
    "description": "Fill the 2-dimensional input `Tensor` with the identity matrix.",
    "std_args": [
      "tensor"
    ],
    "type": "function"
  },
  "factory_kwargs": {
    "description": "Return a canonicalized dict of factory kwargs.",
    "std_args": [
      "kwargs"
    ],
    "type": "function"
  },
  "feature_alpha_dropout": {
    "description": "Randomly masks out entire channels (a channel is a feature map).",
    "std_args": [
      "input",
      "p",
      "training",
      "inplace"
    ],
    "type": "function"
  },
  "fft2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "find_unused_parameters": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "flatten_parameters": {
    "description": "Reset parameter data pointer so that they can use faster code paths.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "flex_attention": {
    "description": "This function implements scaled dot product attention with an arbitrary attention score modification function.",
    "std_args": [
      "query",
      "key",
      "value",
      "score_mod",
      "block_mask",
      "scale",
      "enable_gqa",
      "return_lse",
      "kernel_options",
      "return_aux"
    ],
    "type": "function"
  },
  "float": {
    "description": "Casts all floating point parameters and buffers to ``float`` datatype.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "fn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fold": {
    "description": "Combine an array of sliding local blocks into a large containing tensor.",
    "std_args": [
      "input",
      "output_size",
      "kernel_size",
      "dilation",
      "padding",
      "stride"
    ],
    "type": "function"
  },
  "forward": {
    "description": "Auto-generated from flax_nnx_dynamic_wiring",
    "std_args": [],
    "type": "function"
  },
  "fractional_max_pool2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fractional_max_pool2d_with_indices": {
    "description": "fractional_max_pool2d(input, kernel_size, output_size=None, output_ratio=None, return_indices=False, _random_samples=None)",
    "std_args": [
      "input",
      "kernel_size",
      "output_size",
      "output_ratio",
      "return_indices",
      "_random_samples"
    ],
    "type": "function"
  },
  "fractional_max_pool3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fractional_max_pool3d_with_indices": {
    "description": "fractional_max_pool3d(input, kernel_size, output_size=None, output_ratio=None, return_indices=False, _random_samples=None)",
    "std_args": [
      "input",
      "kernel_size",
      "output_size",
      "output_ratio",
      "return_indices",
      "_random_samples"
    ],
    "type": "function"
  },
  "freeze": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "from_kv_blocks": {
    "description": "Creates a BlockMask instance from key-value block information.",
    "std_args": [
      "cls",
      "kv_num_blocks",
      "kv_indices",
      "full_kv_num_blocks",
      "full_kv_indices",
      "BLOCK_SIZE",
      "mask_mod",
      "seq_lengths",
      "compute_q_blocks"
    ],
    "type": "function"
  },
  "from_pretrained": {
    "description": "Create EmbeddingBag instance from given 2-dimensional FloatTensor.",
    "std_args": [
      "cls",
      "embeddings",
      "freeze",
      "max_norm",
      "norm_type",
      "scale_grad_by_freq",
      "mode",
      "sparse",
      "include_last_offset",
      "padding_idx"
    ],
    "type": "function"
  },
  "fromkeys": {
    "description": "Return a new ParameterDict with the keys provided.",
    "std_args": [
      "self",
      "keys",
      "default"
    ],
    "type": "function"
  },
  "full_kv_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "full_kv_num_blocks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "full_q_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "full_q_num_blocks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "functional_call": {
    "description": "Perform a functional call on the module by replacing the module parameters and buffers with the provided ones.",
    "std_args": [
      "module",
      "parameters_and_buffers",
      "args",
      "kwargs",
      "tie_weights",
      "strict"
    ],
    "type": "function"
  },
  "fuse_conv_bn_eval": {
    "description": "Fuse a convolutional module and a BatchNorm module into a single, new convolutional module.",
    "std_args": [
      "conv",
      "bn",
      "transpose"
    ],
    "type": "function"
  },
  "fuse_conv_bn_weights": {
    "description": "Fuse convolutional module parameters and BatchNorm module parameters into new convolutional module parameters.",
    "std_args": [
      "conv_w",
      "conv_b",
      "bn_rm",
      "bn_rv",
      "bn_eps",
      "bn_w",
      "bn_b",
      "transpose"
    ],
    "type": "function"
  },
  "fuse_linear_bn_eval": {
    "description": "Fuse a linear module and a BatchNorm module into a single, new linear module.",
    "std_args": [
      "linear",
      "bn"
    ],
    "type": "function"
  },
  "fuse_linear_bn_weights": {
    "description": "Fuse linear module parameters and BatchNorm module parameters into new linear module parameters.",
    "std_args": [
      "linear_w",
      "linear_b",
      "bn_rm",
      "bn_rv",
      "bn_eps",
      "bn_w",
      "bn_b"
    ],
    "type": "function"
  },
  "gammainc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "gammaincc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "gammaln": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "gaussian_nll_loss": {
    "description": "Compute the Gaussian negative log likelihood loss.",
    "std_args": [
      "input",
      "target",
      "var",
      "full",
      "eps",
      "reduction"
    ],
    "type": "function"
  },
  "generate_square_subsequent_mask": {
    "description": "Generate a square causal mask for the sequence.",
    "std_args": [
      "sz",
      "device",
      "dtype"
    ],
    "type": "function"
  },
  "get": {
    "description": "Return the parameter associated with key if present. Otherwise return default if provided, None if not.",
    "std_args": [
      "self",
      "key",
      "default"
    ],
    "type": "function"
  },
  "get_a_var": {
    "description": "The class representing a Python function.",
    "std_args": [
      "obj"
    ],
    "type": "function"
  },
  "get_buffer": {
    "description": "Return the buffer given by ``target`` if it exists, otherwise throw an error.",
    "std_args": [
      "self",
      "target"
    ],
    "type": "function"
  },
  "get_expected_cell_size": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "input",
      "batch_sizes"
    ],
    "type": "function"
  },
  "get_expected_hidden_size": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "input",
      "batch_sizes"
    ],
    "type": "function"
  },
  "get_extra_state": {
    "description": "Return any extra state to include in the module's state_dict.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_parameter": {
    "description": "Return the parameter given by ``target`` if it exists, otherwise throw an error.",
    "std_args": [
      "self",
      "target"
    ],
    "type": "function"
  },
  "global_unstructured": {
    "description": "Globally prunes tensors corresponding to all parameters in ``parameters`` by applying the specified ``pruning_method``.",
    "std_args": [
      "parameters",
      "pruning_method",
      "importance_scores",
      "kwargs"
    ],
    "type": "function"
  },
  "grad": {
    "description": "Evaluates gradient.",
    "std_args": [
      "func",
      "argnums",
      "has_aux"
    ]
  },
  "gradient_as_bucket_view": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "grid_sample": {
    "description": "Compute grid sample.",
    "std_args": [
      "input",
      "grid",
      "mode",
      "padding_mode",
      "align_corners"
    ],
    "type": "function"
  },
  "group_norm": {
    "description": "Apply Group Normalization for last certain number of dimensions.",
    "std_args": [
      "input",
      "num_groups",
      "weight",
      "bias",
      "eps"
    ],
    "type": "function"
  },
  "groups": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "gumbel_softmax": {
    "description": "Sample from the Gumbel-Softmax distribution (`Link 1`_  `Link 2`_) and optionally discretize.",
    "std_args": [
      "logits",
      "tau",
      "hard",
      "eps",
      "dim"
    ],
    "type": "function"
  },
  "half": {
    "description": "Casts all floating point parameters and buffers to ``half`` datatype.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "hardtanh_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "has_uninitialized_params": {
    "description": "Check if a module has parameters that are not initialized.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "head": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "head_bias": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "head_dim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "head_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermite_polynomial_h": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hermite_polynomial_he": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hfft2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hfftn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hidden_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hinge_embedding_loss": {
    "description": "Compute the hinge embedding loss.",
    "std_args": [
      "input",
      "target",
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "householder_product": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "huber_loss": {
    "description": "Compute the Huber loss, with optional weighting.",
    "std_args": [
      "input",
      "target",
      "reduction",
      "delta",
      "weight"
    ],
    "type": "function"
  },
  "i0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "i0e": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "i1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "i1e": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ifft2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ignore_index": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ihfft2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ihfftn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in1_features": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in2_features": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in_features": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in_proj_bias": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in_proj_weight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "include_last_offset": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "init": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "initialize_parameters": {
    "description": "Initialize parameters according to the input batch properties.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "inplace": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "insert": {
    "description": "Insert a given module before a given index in the list.",
    "std_args": [
      "self",
      "index",
      "module"
    ],
    "type": "function"
  },
  "instance_norm": {
    "description": "Apply Instance Normalization independently for each channel in every data sample within a batch.",
    "std_args": [
      "input",
      "running_mean",
      "running_var",
      "weight",
      "bias",
      "use_input_stats",
      "momentum",
      "eps"
    ],
    "type": "function"
  },
  "int": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "interpolate": {
    "description": "Down/up samples the input.",
    "std_args": [
      "input",
      "size",
      "scale_factor",
      "mode",
      "align_corners",
      "recompute_scale_factor",
      "antialias"
    ],
    "type": "function"
  },
  "inv_ex": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "invert_permutation": {
    "description": "Returns the inverse of ``permutation``.",
    "std_args": [
      "permutation"
    ],
    "type": "function"
  },
  "ipu": {
    "description": "Move all model parameters and buffers to the IPU.",
    "std_args": [
      "self",
      "device"
    ],
    "type": "function"
  },
  "irfft2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_cuda": {
    "description": "Return true if `self.data` stored on a gpu.",
    "std_args": [],
    "type": "attribute"
  },
  "is_lazy": {
    "description": "Returns whether ``param`` is an ``UninitializedParameter`` or ``UninitializedBuffer``.",
    "std_args": [
      "param"
    ],
    "type": "function"
  },
  "is_namedtuple": {
    "description": "The class representing a Python function.",
    "std_args": [
      "obj"
    ],
    "type": "function"
  },
  "is_parametrized": {
    "description": "Determine if a module has a parametrization.",
    "std_args": [
      "module",
      "tensor_name"
    ],
    "type": "function"
  },
  "is_pinned": {
    "description": "Return true if `self.data` stored on in pinned memory.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_pruned": {
    "description": "Check if a module is pruned by looking for pruning pre-hooks.",
    "std_args": [
      "module"
    ],
    "type": "function"
  },
  "is_tensor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "items": {
    "description": "Return an iterable of the ParameterDict key/value pairs.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "jit": {
    "description": "JIT Compilation.",
    "std_args": [
      "func",
      "static_argnums"
    ]
  },
  "join": {
    "description": "Context manager for training with uneven inputs across processes in DDP.",
    "std_args": [
      "self",
      "divide_by_initial_world_size",
      "enable",
      "throw_on_early_termination"
    ],
    "type": "function"
  },
  "join_device": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "join_hook": {
    "description": "DDP join hook enables training on uneven inputs by mirroring communications in forward and backward passes.",
    "std_args": [
      "self",
      "kwargs"
    ],
    "type": "function"
  },
  "join_process_group": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "k": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "k_proj_weight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kaiming_normal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kaiming_normal_": {
    "description": "Fill the input `Tensor` with values using a Kaiming normal distribution.",
    "std_args": [
      "tensor",
      "a",
      "mode",
      "nonlinearity",
      "generator"
    ],
    "type": "function"
  },
  "kaiming_uniform": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kaiming_uniform_": {
    "description": "Fill the input `Tensor` with values using a Kaiming uniform distribution.",
    "std_args": [
      "tensor",
      "a",
      "mode",
      "nonlinearity",
      "generator"
    ],
    "type": "function"
  },
  "kdim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "keepdim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kernel_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "keys": {
    "description": "Return an iterable of the ParameterDict keys.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "kl_div": {
    "description": "Compute the KL Divergence loss.",
    "std_args": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction",
      "log_target"
    ],
    "type": "function"
  },
  "kpack": {
    "description": "ROCm-specific kernel packing parameter.",
    "std_args": [],
    "type": "attribute"
  },
  "kv_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kv_num_blocks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "l1_loss": {
    "description": "Compute the L1 loss, with optional weighting.",
    "std_args": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction",
      "weight"
    ],
    "type": "function"
  },
  "l1_unstructured": {
    "description": "Prune tensor by removing units with the lowest L1-norm.",
    "std_args": [
      "module",
      "name",
      "amount",
      "importance_scores"
    ],
    "type": "function"
  },
  "label_smoothing": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "laguerre_polynomial_l": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lambd": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "layer_norm": {
    "description": "Apply Layer Normalization for last certain number of dimensions.",
    "std_args": [
      "input",
      "normalized_shape",
      "weight",
      "bias",
      "eps"
    ],
    "type": "function"
  },
  "layers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ldl_factor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ldl_factor_ex": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ldl_solve": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "leaky_relu": {
    "description": "leaky_relu(input, negative_slope=0.01, inplace=False) -> Tensor",
    "std_args": [
      "input",
      "negative_slope",
      "inplace"
    ],
    "type": "function"
  },
  "leaky_relu_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "legendre_polynomial_p": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "linear1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "linear2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ln_structured": {
    "description": "Prune tensor by removing channels with the lowest L\\ ``n``-norm along the specified dimension.",
    "std_args": [
      "module",
      "name",
      "amount",
      "n",
      "dim",
      "importance_scores"
    ],
    "type": "function"
  },
  "load_state_dict": {
    "description": "Copies parameters and buffers from state_dict into this module.",
    "std_args": [
      "state_dict",
      "strict"
    ],
    "type": "function"
  },
  "local_response_norm": {
    "description": "Apply local response normalization over an input signal.",
    "std_args": [
      "input",
      "size",
      "alpha",
      "beta",
      "k"
    ],
    "type": "function"
  },
  "log": {
    "description": "Logarithm.",
    "std_args": [
      "x"
    ]
  },
  "log_input": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "log_ndtr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "log_prob": {
    "description": "Compute log probabilities for all :math:`\\texttt{n\\_classes}`.",
    "std_args": [
      "self",
      "input"
    ],
    "type": "function"
  },
  "log_softmax": {
    "description": "Applies the LogSoftmax function to an n-dimensional input Tensor.",
    "std_args": [
      "input",
      "dim"
    ],
    "type": "attribute"
  },
  "log_target": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "logger": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "logit": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "long": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "lower": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lp_pool1d": {
    "description": "Apply a 1D power-average pooling over an input signal composed of several input planes.",
    "std_args": [
      "input",
      "norm_type",
      "kernel_size",
      "stride",
      "ceil_mode"
    ],
    "type": "function"
  },
  "lp_pool2d": {
    "description": "Apply a 2D power-average pooling over an input signal composed of several input planes.",
    "std_args": [
      "input",
      "norm_type",
      "kernel_size",
      "stride",
      "ceil_mode"
    ],
    "type": "function"
  },
  "lp_pool3d": {
    "description": "Apply a 3D power-average pooling over an input signal composed of several input planes.",
    "std_args": [
      "input",
      "norm_type",
      "kernel_size",
      "stride",
      "ceil_mode"
    ],
    "type": "function"
  },
  "lse": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lstsq": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lu": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lu_factor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lu_factor_ex": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lu_solve": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "margin": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "margin_ranking_loss": {
    "description": "Compute the margin ranking loss.",
    "std_args": [
      "input1",
      "input2",
      "target",
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "mask": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mask_check": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mask_mod": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "materialize": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "shape",
      "device",
      "dtype"
    ],
    "type": "function"
  },
  "matrix_exp": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "matrix_instr_nonkdim": {
    "description": "ROCm-specific matrix instruction non-K dimension.",
    "std_args": [],
    "type": "attribute"
  },
  "max": {
    "description": "Element-wise maximum or reduction.",
    "std_args": [
      "x"
    ]
  },
  "max_norm": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "max_pool1d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "max_pool1d_with_indices": {
    "description": "max_pool1d(input, kernel_size, stride=None, padding=0, dilation=1, ceil_mode=False, return_indices=False)",
    "std_args": [
      "input",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "ceil_mode",
      "return_indices"
    ],
    "type": "function"
  },
  "max_pool2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "max_pool2d_with_indices": {
    "description": "max_pool2d(input, kernel_size, stride=None, padding=0, dilation=1, ceil_mode=False, return_indices=False)",
    "std_args": [
      "input",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "ceil_mode",
      "return_indices"
    ],
    "type": "function"
  },
  "max_pool3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "max_pool3d_with_indices": {
    "description": "max_pool3d(input, kernel_size, stride=None, padding=0, dilation=1, ceil_mode=False, return_indices=False)",
    "std_args": [
      "input",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "ceil_mode",
      "return_indices"
    ],
    "type": "function"
  },
  "max_scores": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "max_unpool1d": {
    "description": "Compute a partial inverse of :class:`MaxPool1d`.",
    "std_args": [
      "input",
      "indices",
      "kernel_size",
      "stride",
      "padding",
      "output_size"
    ],
    "type": "function"
  },
  "max_unpool2d": {
    "description": "Compute a partial inverse of :class:`MaxPool2d`.",
    "std_args": [
      "input",
      "indices",
      "kernel_size",
      "stride",
      "padding",
      "output_size"
    ],
    "type": "function"
  },
  "max_unpool3d": {
    "description": "Compute a partial inverse of :class:`MaxPool3d`.",
    "std_args": [
      "input",
      "indices",
      "kernel_size",
      "stride",
      "padding",
      "output_size"
    ],
    "type": "function"
  },
  "max_val": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "merge_masks": {
    "description": "Determine mask type and combine masks if necessary.",
    "std_args": [
      "self",
      "attn_mask",
      "key_padding_mask",
      "query"
    ],
    "type": "function"
  },
  "min": {
    "description": "Element-wise minimum or reduction.",
    "std_args": [
      "x"
    ]
  },
  "min_val": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mixed_precision": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mode": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "modified_bessel_i0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "modified_bessel_i1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "modified_bessel_k0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "modified_bessel_k1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "modules": {
    "description": "Return an iterator over all modules in the network.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "mse_loss": {
    "description": "Compute the element-wise mean squared error, with optional weighting.",
    "std_args": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction",
      "weight"
    ],
    "type": "function"
  },
  "mtia": {
    "description": "Move all model parameters and buffers to the MTIA.",
    "std_args": [
      "self",
      "device"
    ],
    "type": "function"
  },
  "multi_dot": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "multi_head_attention_forward": {
    "description": "Forward method for MultiHeadAttention.",
    "std_args": [
      "query",
      "key",
      "value",
      "embed_dim_to_check",
      "num_heads",
      "in_proj_weight",
      "in_proj_bias",
      "bias_k",
      "bias_v",
      "add_zero_attn",
      "dropout_p",
      "out_proj_weight",
      "out_proj_bias",
      "training",
      "key_padding_mask",
      "need_weights",
      "attn_mask",
      "use_separate_proj_weight",
      "q_proj_weight",
      "k_proj_weight",
      "v_proj_weight",
      "static_k",
      "static_v",
      "average_attn_weights",
      "is_causal"
    ],
    "type": "function"
  },
  "multi_margin_loss": {
    "description": "Compute the multi margin loss, with optional weighting.",
    "std_args": [
      "input",
      "target",
      "p",
      "margin",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "multigammaln": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "multihead_attn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "multilabel_margin_loss": {
    "description": "Compute the multilabel margin loss.",
    "std_args": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "multilabel_soft_margin_loss": {
    "description": "Compute the multilabel soft margin loss.",
    "std_args": [
      "input",
      "target",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "n": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "n_classes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "n_clusters": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "n_power_iterations": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "name": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "named_buffers": {
    "description": "Return an iterator over module buffers, yielding both the name of the buffer as well as the buffer itself.",
    "std_args": [
      "self",
      "prefix",
      "recurse",
      "remove_duplicate"
    ],
    "type": "function"
  },
  "named_children": {
    "description": "Return an iterator over immediate children modules, yielding both the name of the module as well as the module itself.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "named_modules": {
    "description": "Return an iterator over all modules in the network, yielding both the name of the module as well as the module itself.",
    "std_args": [
      "self",
      "memo",
      "prefix",
      "remove_duplicate"
    ],
    "type": "function"
  },
  "named_parameters": {
    "description": "Return an iterator over module parameters, yielding both the name of the parameter as well as the parameter itself.",
    "std_args": [
      "self",
      "prefix",
      "recurse",
      "remove_duplicate"
    ],
    "type": "function"
  },
  "native_channel_shuffle": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ndtr": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ndtri": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "negative_slope": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nhead": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nll_loss": {
    "description": "Compute the negative log likelihood loss.",
    "std_args": [
      "input",
      "target",
      "weight",
      "size_average",
      "ignore_index",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "no_grad": {
    "description": "Context-manager that disabled gradient calculation.",
    "op_type": "context",
    "std_args": []
  },
  "no_sync": {
    "description": "Context manager to disable gradient synchronizations across DDP processes.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "nonlinearity": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "noop_mask": {
    "description": "Returns a noop mask_mod",
    "std_args": [
      "batch",
      "head",
      "token_q",
      "token_kv"
    ],
    "type": "function"
  },
  "norm": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "norm1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "norm2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "norm3": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "norm_first": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "norm_type": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "normal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "normal_": {
    "description": "Fill the input Tensor with values drawn from the normal distribution.",
    "std_args": [
      "tensor",
      "mean",
      "std",
      "generator"
    ],
    "type": "function"
  },
  "normalized_shape": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ntensors": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_channels": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_embeddings": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_groups": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_heads": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_layers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_parameters": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_stages": {
    "description": "Number of pipeline stages in the CUDA kernel. Higher values may improve performance",
    "std_args": [],
    "type": "attribute"
  },
  "num_warps": {
    "description": "Number of warps to use in the CUDA kernel. Higher values may improve performance",
    "std_args": [],
    "type": "attribute"
  },
  "numel": {
    "description": "Returns the number of elements (not accounting for sparsity) in the mask.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "one_hot": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ones_": {
    "description": "Fill the input Tensor with the scalar value `1`.",
    "std_args": [
      "tensor"
    ],
    "type": "function"
  },
  "or_masks": {
    "description": "Returns a mask_mod that's the union of provided mask_mods",
    "std_args": [
      "mask_mods"
    ],
    "type": "function"
  },
  "original": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "orthogonal": {
    "description": "Apply an orthogonal or unitary parametrization to a matrix or a batch of matrices.",
    "std_args": [
      "module",
      "name",
      "orthogonal_map",
      "use_trivialization"
    ],
    "type": "function"
  },
  "orthogonal_": {
    "description": "Fill the input `Tensor` with a (semi) orthogonal matrix.",
    "std_args": [
      "tensor",
      "gain",
      "generator"
    ],
    "type": "function"
  },
  "out_channels": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "out_features": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "out_proj": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_device": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_ratio": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "p": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pack_padded_sequence": {
    "description": "Packs a Tensor containing padded sequences of variable length.",
    "std_args": [
      "input",
      "lengths",
      "batch_first",
      "enforce_sorted"
    ],
    "type": "function"
  },
  "pack_sequence": {
    "description": "Packs a list of variable length Tensors.",
    "std_args": [
      "sequences",
      "enforce_sorted"
    ],
    "type": "function"
  },
  "pad_packed_sequence": {
    "description": "Pad a packed batch of variable length sequences.",
    "std_args": [
      "sequence",
      "batch_first",
      "padding_value",
      "total_length"
    ],
    "type": "function"
  },
  "pad_sequence": {
    "description": "Pad a list of variable length Tensors with :attr:`padding_value`.",
    "std_args": [
      "sequences",
      "batch_first",
      "padding_value",
      "padding_side"
    ],
    "type": "function"
  },
  "padding": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "padding_idx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pairwise_distance": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "parallel_apply": {
    "description": "Apply each `module` in :attr:`modules` in parallel on each of :attr:`devices`.",
    "std_args": [
      "modules",
      "inputs",
      "kwargs_tup",
      "devices"
    ],
    "type": "function"
  },
  "parameters": {
    "description": "Returns an iterator over module parameters.",
    "std_args": [
      "recurse"
    ],
    "type": "function"
  },
  "parameters_to_ignore": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "parameters_to_vector": {
    "description": "Flatten an iterable of parameters into a single vector.",
    "std_args": [
      "parameters"
    ],
    "type": "function"
  },
  "pdist": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "permute_dims": {
    "description": "Permutes tensor dimensions.",
    "std_args": [
      "input",
      {
        "is_variadic": true,
        "name": "dims",
        "type": "int"
      }
    ]
  },
  "permute_hidden": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "hx",
      "permutation"
    ],
    "type": "function"
  },
  "persistent": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pin_memory": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "pixel_shuffle": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pixel_unshuffle": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "poisson_nll_loss": {
    "description": "Compute the Poisson negative log likelihood loss.",
    "std_args": [
      "input",
      "target",
      "log_input",
      "full",
      "size_average",
      "eps",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "polygamma": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pop": {
    "description": "Remove key from the ParameterDict and return its parameter.",
    "std_args": [
      "self",
      "key"
    ],
    "type": "function"
  },
  "popitem": {
    "description": "Remove and return the last inserted `(key, parameter)` pair from the ParameterDict.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "pos_weight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "predict": {
    "description": "Return the class with the highest probability for each example in the input minibatch.",
    "std_args": [
      "self",
      "input"
    ],
    "type": "function"
  },
  "process_group": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "proj_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "prune": {
    "description": "Compute and returns a pruned version of input tensor ``t``.",
    "std_args": [
      "self",
      "t",
      "default_mask",
      "importance_scores"
    ],
    "type": "function"
  },
  "psi": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "q_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "q_num_blocks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "q_proj_weight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "randn": {
    "description": "Returns a tensor filled with random numbers from a normal distribution.",
    "std_args": [
      "shape"
    ]
  },
  "random_structured": {
    "description": "Prune tensor by removing random channels along the specified dimension.",
    "std_args": [
      "module",
      "name",
      "amount",
      "dim"
    ],
    "type": "function"
  },
  "random_unstructured": {
    "description": "Prune tensor by removing random (currently unpruned) units.",
    "std_args": [
      "module",
      "name",
      "amount"
    ],
    "type": "function"
  },
  "recompute_scale_factor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "reduce_add": {
    "description": "Sum tensors from multiple GPUs.",
    "std_args": [
      "inputs",
      "destination"
    ],
    "type": "function"
  },
  "reduce_add_coalesced": {
    "description": "Sum tensors from multiple GPUs.",
    "std_args": [
      "inputs",
      "destination",
      "buffer_size"
    ],
    "type": "function"
  },
  "register_backward_hook": {
    "description": "Register a backward hook on the module.",
    "std_args": [
      "self",
      "hook"
    ],
    "type": "function"
  },
  "register_buffer": {
    "description": "Registers a persistent buffer.",
    "std_args": [
      "name",
      "tensor",
      "persistent"
    ],
    "type": "function"
  },
  "register_comm_hook": {
    "description": "Register communication hook for user-defined DDP aggregation of gradients across multiple workers.",
    "std_args": [
      "self",
      "state",
      "hook"
    ],
    "type": "function"
  },
  "register_forward_hook": {
    "description": "Register a forward hook on the module.",
    "std_args": [
      "self",
      "hook",
      "prepend",
      "with_kwargs",
      "always_call"
    ],
    "type": "function"
  },
  "register_forward_pre_hook": {
    "description": "Register a forward pre-hook on the module.",
    "std_args": [
      "self",
      "hook",
      "prepend",
      "with_kwargs"
    ],
    "type": "function"
  },
  "register_full_backward_hook": {
    "description": "Register a backward hook on the module.",
    "std_args": [
      "self",
      "hook",
      "prepend"
    ],
    "type": "function"
  },
  "register_full_backward_pre_hook": {
    "description": "Register a backward pre-hook on the module.",
    "std_args": [
      "self",
      "hook",
      "prepend"
    ],
    "type": "function"
  },
  "register_load_state_dict_post_hook": {
    "description": "Register a post-hook to be run after module's :meth:`~nn.Module.load_state_dict` is called.",
    "std_args": [
      "self",
      "hook"
    ],
    "type": "function"
  },
  "register_load_state_dict_pre_hook": {
    "description": "Register a pre-hook to be run before module's :meth:`~nn.Module.load_state_dict` is called.",
    "std_args": [
      "self",
      "hook"
    ],
    "type": "function"
  },
  "register_module_backward_hook": {
    "description": "Register a backward hook common to all the modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_module_buffer_registration_hook": {
    "description": "Register a buffer registration hook common to all modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_module_forward_hook": {
    "description": "Register a global forward hook for all the modules.",
    "std_args": [
      "hook",
      "with_kwargs",
      "always_call"
    ],
    "type": "function"
  },
  "register_module_forward_pre_hook": {
    "description": "Register a forward pre-hook common to all modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_module_full_backward_hook": {
    "description": "Register a backward hook common to all the modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_module_full_backward_pre_hook": {
    "description": "Register a backward pre-hook common to all the modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_module_module_registration_hook": {
    "description": "Register a module registration hook common to all modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_module_parameter_registration_hook": {
    "description": "Register a parameter registration hook common to all modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_parameter": {
    "description": "Registers a learnable parameter.",
    "std_args": [
      "name",
      "param"
    ],
    "type": "function"
  },
  "register_parametrization": {
    "description": "Register a parametrization to a tensor in a module.",
    "std_args": [
      "module",
      "tensor_name",
      "parametrization",
      "unsafe"
    ],
    "type": "function"
  },
  "register_state_dict_post_hook": {
    "description": "Register a post-hook for the :meth:`~torch.nn.Module.state_dict` method.",
    "std_args": [
      "self",
      "hook"
    ],
    "type": "function"
  },
  "register_state_dict_pre_hook": {
    "description": "Register a pre-hook for the :meth:`~torch.nn.Module.state_dict` method.",
    "std_args": [
      "self",
      "hook"
    ],
    "type": "function"
  },
  "relu": {
    "description": "Rectified Linear Unit.",
    "std_args": [
      "input"
    ],
    "type": "class"
  },
  "relu_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "remove": {
    "description": "Remove the pruning reparameterization from a module and the pruning method from the forward hook.",
    "std_args": [
      "module",
      "name"
    ],
    "type": "function"
  },
  "remove_parametrizations": {
    "description": "Remove the parametrizations on a tensor in a module.",
    "std_args": [
      "module",
      "tensor_name",
      "leave_parametrized"
    ],
    "type": "function"
  },
  "remove_spectral_norm": {
    "description": "Remove the spectral normalization reparameterization from a module.",
    "std_args": [
      "module",
      "name"
    ],
    "type": "function"
  },
  "remove_weight_norm": {
    "description": "Remove the weight normalization reparameterization from a module.",
    "std_args": [
      "module",
      "name"
    ],
    "type": "function"
  },
  "replicate": {
    "description": "The class representing a Python function.",
    "std_args": [
      "network",
      "devices",
      "detach"
    ],
    "type": "function"
  },
  "require_backward_grad_sync": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "require_forward_param_sync": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "requires_grad_": {
    "description": "Change if autograd should record operations on parameters in this module.",
    "std_args": [
      "self",
      "requires_grad"
    ],
    "type": "function"
  },
  "reset_parameters": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "reshape_weight_to_matrix": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "weight"
    ],
    "type": "function"
  },
  "return_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rfft2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "right_inverse": {
    "description": "Call the ``right_inverse`` methods of the parametrizations in the inverse registration order.",
    "std_args": [
      "self",
      "value"
    ],
    "type": "function"
  },
  "rms_norm": {
    "description": "Apply Root Mean Square Layer Normalization.",
    "std_args": [
      "input",
      "normalized_shape",
      "weight",
      "eps"
    ],
    "type": "function"
  },
  "rrelu": {
    "description": "rrelu(input, lower=1./8, upper=1./3, training=False, inplace=False) -> Tensor",
    "std_args": [
      "input",
      "lower",
      "upper",
      "training",
      "inplace"
    ],
    "type": "function"
  },
  "rrelu_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scale_factor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scale_grad_by_freq": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scaled_dot_product_attention": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scaled_modified_bessel_k0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scaled_modified_bessel_k1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scatter_kwargs": {
    "description": "Scatter with support for kwargs dictionary.",
    "std_args": [
      "inputs",
      "kwargs",
      "target_gpus",
      "dim"
    ],
    "type": "function"
  },
  "sdpa_kernel": {
    "description": "Context manager to select which backend to use for scaled dot product attention.",
    "std_args": [
      "backends",
      "set_priority"
    ],
    "type": "function"
  },
  "self_attn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "selu_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "seq_len_kv": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "seq_len_q": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "seq_lengths": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "set_extra_state": {
    "description": "Set extra state contained in the loaded `state_dict`.",
    "std_args": [
      "self",
      "state"
    ],
    "type": "function"
  },
  "setdefault": {
    "description": "Set the default for a key in the Parameterdict.",
    "std_args": [
      "self",
      "key",
      "default"
    ],
    "type": "function"
  },
  "share_memory": {
    "description": "See :meth:`torch.Tensor.share_memory_`.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "share_memory_": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "shifted_chebyshev_polynomial_t": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "shifted_chebyshev_polynomial_u": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "shifted_chebyshev_polynomial_v": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "shifted_chebyshev_polynomial_w": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "short": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "shortlist_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sinc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "size": {
    "description": "Get tensor shape",
    "std_args": []
  },
  "skip_all_reduce_unused_params": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "skip_init": {
    "description": "Given a module class object and args / kwargs, instantiate the module without initializing parameters / buffers.",
    "std_args": [
      "module_cls",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "smooth_l1_loss": {
    "description": "Compute the Smooth L1 loss.",
    "std_args": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction",
      "beta"
    ],
    "type": "function"
  },
  "soft_margin_loss": {
    "description": "Compute the soft margin loss.",
    "std_args": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "softmax": {
    "description": "Applies the Softmax function to an n-dimensional input Tensor.",
    "std_args": [
      "input",
      "dim"
    ],
    "type": "attribute"
  },
  "solve_ex": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "solve_triangular": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sorted_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sparse": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sparse_": {
    "description": "Fill the 2D input `Tensor` as a sparse matrix.",
    "std_args": [
      "tensor",
      "sparsity",
      "std",
      "generator"
    ],
    "type": "function"
  },
  "sparsity": {
    "description": "Computes the percentage of blocks that are sparse (i.e. not computed)",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "spectral_norm": {
    "description": "Apply spectral normalization to a parameter in the given module.",
    "std_args": [
      "module",
      "name",
      "n_power_iterations",
      "eps",
      "dim"
    ],
    "type": "function"
  },
  "spherical_bessel_j0": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sqrt": {
    "description": "Square root.",
    "std_args": [
      "x"
    ]
  },
  "square": {
    "description": "Square.",
    "std_args": [
      "x"
    ]
  },
  "src_device_obj": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "start_dim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "state_dict": {
    "description": "Returns a dictionary containing a whole state of the module.",
    "std_args": [
      "destination",
      "prefix",
      "keep_vars"
    ],
    "type": "function"
  },
  "static_graph": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "step": {
    "description": "Performs a single optimization step.",
    "std_args": []
  },
  "stride": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "swap": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tail": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tensorinv": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "tensorsolve": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "threshold_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "to": {
    "description": "Move and/or cast the parameters and buffers.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "to_dense": {
    "description": "Returns a dense block that is equivalent to the block mask.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "to_empty": {
    "description": "Move the parameters and buffers to the specified device without copying storage.",
    "std_args": [
      "self",
      "device",
      "recurse"
    ],
    "type": "function"
  },
  "to_kwargs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "inputs",
      "kwargs",
      "device_id"
    ],
    "type": "function"
  },
  "to_string": {
    "description": "Returns a string representation of the block mask. Quite nifty.",
    "std_args": [
      "self",
      "grid_size",
      "limit"
    ],
    "type": "function"
  },
  "torch.utils": {
    "description": "Torch Utilities Namespace",
    "std_args": []
  },
  "torch.utils.data": {
    "description": "Torch Data Utilities Namespace",
    "std_args": []
  },
  "train": {
    "description": "Set the module in training mode.",
    "std_args": [
      "self",
      "mode"
    ],
    "type": "function"
  },
  "training": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "transfer_parametrizations_and_params": {
    "description": "Transfer parametrizations and the parameters they parametrize from :attr:`from_module` to :attr:`to_module`.",
    "std_args": [
      "from_module",
      "to_module",
      "tensor_name"
    ],
    "type": "function"
  },
  "triplet_margin_loss": {
    "description": "Compute the triplet loss between given input tensors and a margin greater than 0.",
    "std_args": [
      "anchor",
      "positive",
      "negative",
      "margin",
      "p",
      "eps",
      "swap",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "triplet_margin_with_distance_loss": {
    "description": "Compute the triplet margin loss for input tensors using a custom distance function.",
    "std_args": [
      "anchor",
      "positive",
      "negative",
      "distance_function",
      "margin",
      "swap",
      "reduction"
    ],
    "type": "function"
  },
  "trunc_normal_": {
    "description": "Fill the input Tensor with values drawn from a truncated normal distribution.",
    "std_args": [
      "tensor",
      "mean",
      "std",
      "a",
      "b",
      "generator"
    ],
    "type": "function"
  },
  "type": {
    "description": "Casts all parameters and buffers to :attr:`dst_type`.",
    "std_args": [
      "self",
      "dst_type"
    ],
    "type": "function"
  },
  "type_before_parametrizations": {
    "description": "Return the module type before parametrizations were applied and if not, then it returns the module type.",
    "std_args": [
      "module"
    ],
    "type": "function"
  },
  "unflattened_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "unfold": {
    "description": "Extract sliding local blocks from a batched input tensor.",
    "std_args": [
      "input",
      "kernel_size",
      "dilation",
      "padding",
      "stride"
    ],
    "type": "function"
  },
  "uniform": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "uniform_": {
    "description": "Fill the input Tensor with values drawn from the uniform distribution.",
    "std_args": [
      "tensor",
      "a",
      "b",
      "generator"
    ],
    "type": "function"
  },
  "unpack_sequence": {
    "description": "Unpack PackedSequence into a list of variable length Tensors.",
    "std_args": [
      "packed_sequences"
    ],
    "type": "function"
  },
  "unpad_sequence": {
    "description": "Unpad padded Tensor into a list of variable length Tensors.",
    "std_args": [
      "padded_sequences",
      "lengths",
      "batch_first"
    ],
    "type": "function"
  },
  "unsafe": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "unsorted_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "update": {
    "description": "Update the :class:`~torch.nn.ParameterDict` with key-value pairs from ``parameters``, overwriting existing keys.",
    "std_args": [
      "self",
      "parameters"
    ],
    "type": "function"
  },
  "upper": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "upsample_bilinear": {
    "description": "Upsamples the input, using bilinear upsampling.",
    "std_args": [
      "input",
      "size",
      "scale_factor"
    ],
    "type": "function"
  },
  "upsample_nearest": {
    "description": "Upsamples the input, using nearest neighbours' pixel values.",
    "std_args": [
      "input",
      "size",
      "scale_factor"
    ],
    "type": "function"
  },
  "upscale_factor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_nested_tensor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_side_stream_for_tensor_copies": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "v_proj_weight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "value": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "value_and_grad": {
    "description": "Evaluates value and gradient.",
    "std_args": [
      "func",
      "argnums",
      "has_aux"
    ]
  },
  "values": {
    "description": "Return an iterable of the ParameterDict values.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "vander": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "variant": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "vdim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "vector_to_parameters": {
    "description": "Copy slices of a vector into an iterable of parameters.",
    "std_args": [
      "vec",
      "parameters"
    ],
    "type": "function"
  },
  "vmap": {
    "description": "Vectorizing map.",
    "std_args": [
      "func",
      "in_axes",
      "out_axes",
      "randomness"
    ]
  },
  "waves_per_eu": {
    "description": "ROCm-specific waves per execution unit.",
    "std_args": [],
    "type": "attribute"
  },
  "weight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "weight_hh": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "weight_ih": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "weight_norm": {
    "description": "Apply weight normalization to a parameter in the given module.",
    "std_args": [
      "module",
      "name",
      "dim"
    ],
    "type": "function"
  },
  "will_sync_module_buffers": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "xavier_normal": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "xavier_normal_": {
    "description": "Fill the input `Tensor` with values using a Xavier normal distribution.",
    "std_args": [
      "tensor",
      "gain",
      "generator"
    ],
    "type": "function"
  },
  "xavier_uniform": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "xavier_uniform_": {
    "description": "Fill the input `Tensor` with values using a Xavier uniform distribution.",
    "std_args": [
      "tensor",
      "gain",
      "generator"
    ],
    "type": "function"
  },
  "xlog1py": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "xlogy": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "xpu": {
    "description": "Move all model parameters and buffers to the XPU.",
    "std_args": [
      "self",
      "device"
    ],
    "type": "function"
  },
  "zero_grad": {
    "description": "Sets the gradients of all optimized parameters to zero.",
    "std_args": [],
    "type": "function"
  },
  "zero_infinity": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "zeros_": {
    "description": "Fill the input Tensor with the scalar value `0`.",
    "std_args": [
      "tensor"
    ],
    "type": "function"
  },
  "zeta": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  }
}