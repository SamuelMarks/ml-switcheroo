{
  "Adam": {
    "description": "Adaptive Moment Estimation optimizer.",
    "std_args": [
      "params",
      "lr",
      "beta1",
      "beta2",
      "eps",
      "weight_decay",
      "amsgrad"
    ]
  },
  "CenterCrop": {
    "description": "Crops the given image at the center.",
    "std_args": [
      "size"
    ]
  },
  "ClipGradNorm": {
    "description": "Clips gradient norm of an iterable of parameters.",
    "std_args": [
      "parameters",
      "max_norm"
    ]
  },
  "Compile": {
    "description": "JIT Alias.",
    "std_args": [
      "func"
    ]
  },
  "CosineAnnealingLR": {
    "description": "Set the learning rate of each parameter group using a cosine annealing schedule.",
    "std_args": [
      "optimizer",
      "T_max"
    ]
  },
  "CudaAvailable": {
    "description": "Checks if a CUDA device is available.",
    "return_type": "bool",
    "std_args": []
  },
  "DataLoader": {
    "description": "Foundational PyTorch Data Loader. Mapped to GenericDataLoader shim via Plugin.",
    "std_args": [
      "dataset",
      "batch_size",
      "shuffle",
      "sampler",
      "batch_sampler",
      "num_workers",
      "collate_fn",
      "pin_memory",
      "drop_last",
      "timeout",
      "worker_init_fn",
      "multiprocessing_context",
      "generator",
      "prefetch_factor",
      "persistent_workers",
      "pin_memory_device"
    ]
  },
  "Device": {
    "description": "Abstract Device placement context.",
    "std_args": [
      "type",
      "index"
    ]
  },
  "Grayscale": {
    "description": "Convert image to grayscale.",
    "std_args": [
      "num_output_channels"
    ]
  },
  "Load": {
    "description": "Deserialize object from disk.",
    "std_args": [
      "f"
    ]
  },
  "Normalize": {
    "description": "Normalize a tensor image with mean and standard deviation.",
    "std_args": [
      "mean",
      "std",
      "inplace"
    ]
  },
  "RMSprop": {
    "description": "Root Mean Square Propagation optimizer.",
    "std_args": [
      "params",
      "lr",
      "rho",
      "eps",
      "weight_decay",
      "momentum",
      "centered"
    ]
  },
  "RandomCrop": {
    "description": "Crop the given image at a random location.",
    "std_args": [
      "size",
      "padding",
      "pad_if_needed",
      "fill",
      "padding_mode"
    ]
  },
  "RandomHorizontalFlip": {
    "description": "Horizontally flip the image randomly with a given probability.",
    "std_args": [
      "p"
    ]
  },
  "RandomVerticalFlip": {
    "description": "Vertically flip the image randomly with a given probability.",
    "std_args": [
      "p"
    ]
  },
  "Resize": {
    "description": "Resize the input image to the given size.",
    "std_args": [
      "size"
    ]
  },
  "SGD": {
    "description": "Stochastic Gradient Descent optimizer.",
    "std_args": [
      "params",
      "lr",
      "momentum",
      "dampening",
      "weight_decay",
      "nesterov"
    ]
  },
  "Save": {
    "description": "Serialize object to disk.",
    "std_args": [
      "obj",
      "f"
    ]
  },
  "StepLR": {
    "description": "Decays the learning rate of each parameter group by gamma every step_size epochs.",
    "std_args": [
      "optimizer",
      "step_size",
      "gamma"
    ]
  },
  "Synchronize": {
    "description": "Execution Barrier.",
    "std_args": []
  },
  "ToTensor": {
    "description": "Convert a PIL Image or numpy.ndarray to tensor.",
    "std_args": []
  },
  "__comment__": "DO NOT EDIT. Auto-generated from standards_internal.py migration.",
  "__imports__": {},
  "enable_grad": {
    "description": "Context-manager that enables gradient calculation.",
    "op_type": "context",
    "std_args": []
  },
  "grad": {
    "description": "Evaluates gradient.",
    "std_args": [
      "func",
      "argnums",
      "has_aux"
    ]
  },
  "jit": {
    "description": "JIT Compilation.",
    "std_args": [
      "func",
      "static_argnums"
    ]
  },
  "no_grad": {
    "description": "Context-manager that disabled gradient calculation.",
    "op_type": "context",
    "std_args": []
  },
  "permute_dims": {
    "description": "Permute tensor dimensions.",
    "operation": "permute_dims",
    "std_args": [
      "x",
      {
        "is_variadic": true,
        "name": "axes"
      }
    ],
    "variants": {
      "jax": {
        "api": "jax.numpy.transpose",
        "pack_to_tuple": "axes"
      },
      "numpy": {
        "api": "numpy.transpose",
        "pack_to_tuple": "axes"
      },
      "tensorflow": {
        "api": "tf.transpose",
        "pack_to_tuple": "perm"
      },
      "torch": {
        "api": "torch.permute"
      }
    }
  },
  "step": {
    "description": "Performs a single optimization step.",
    "std_args": []
  },
  "torch.utils": {
    "description": "Torch Utilities Namespace",
    "std_args": []
  },
  "torch.utils.data": {
    "description": "Torch Data Utilities Namespace",
    "std_args": []
  },
  "value_and_grad": {
    "description": "Evaluates value and gradient.",
    "std_args": [
      "func",
      "argnums",
      "has_aux"
    ]
  },
  "vmap": {
    "description": "Vectorizing map.",
    "std_args": [
      "func",
      "in_axes",
      "out_axes",
      "randomness"
    ]
  },
  "zero_grad": {
    "description": "Sets the gradients of all optimized parameters to zero.",
    "std_args": []
  }
}