{
  "Abs": {
    "description": "Absolute Value",
    "operation": "Abs",
    "std_args": [
      "x"
    ],
    "variants": {
      "jax": {
        "api": "jax.numpy.abs"
      },
      "torch": {
        "api": "torch.abs"
      }
    }
  },
  "BatchNorm": {
    "description": "Batch Normalization.",
    "std_args": [
      "input",
      "eps"
    ]
  },
  "Bool": {
    "description": "Type Bool",
    "operation": "Bool",
    "std_args": [],
    "variants": {
      "jax": {
        "api": "jax.numpy.bool_"
      },
      "keras": {
        "api": "bool"
      },
      "numpy": {
        "api": "numpy.bool_"
      },
      "torch": {
        "api": "torch.bool"
      }
    }
  },
  "Cache": {
    "description": "Container for mutable state.",
    "std_args": [
      "value"
    ]
  },
  "CastFloat": {
    "description": "Cast to Float",
    "operation": "CastFloat",
    "std_args": [
      "x"
    ],
    "variants": {
      "jax": {
        "api": "astype",
        "requires_plugin": "type_methods"
      },
      "torch": {
        "api": "float"
      }
    }
  },
  "CastHalf": {
    "description": "Cast to Half",
    "operation": "CastHalf",
    "std_args": [
      "x"
    ],
    "variants": {
      "mlx": {
        "api": "astype",
        "requires_plugin": "type_methods"
      },
      "torch": {
        "api": "half"
      }
    }
  },
  "CastLong": {
    "description": "Cast to Long",
    "operation": "CastLong",
    "std_args": [
      "x"
    ],
    "variants": {
      "numpy": {
        "api": "astype",
        "requires_plugin": "type_methods"
      },
      "torch": {
        "api": "long"
      }
    }
  },
  "ComplexOp": {
    "description": "Desc",
    "std_args": [],
    "variants": {}
  },
  "Conv2d": {
    "description": "Applies a 2D convolution over an input signal composed of several input planes.",
    "std_args": [
      "in_channels",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode"
    ]
  },
  "CrossEntropyLoss": {
    "description": "Cross Entropy Loss.",
    "std_args": [
      "input",
      "target",
      "weight"
    ]
  },
  "Dropout": {
    "description": "During training, randomly zeroes some of the elements of the input tensor with probability p.",
    "std_args": [
      "p",
      "inplace"
    ]
  },
  "Embedding": {
    "description": "Lookup table for storing embeddings.",
    "std_args": [
      "num_embeddings",
      "embedding_dim",
      "padding_idx",
      "max_norm",
      "norm_type",
      "scale_grad_by_freq",
      "sparse"
    ]
  },
  "Float16": {
    "description": "Type Float16",
    "operation": "Float16",
    "std_args": [],
    "variants": {
      "mlx": {
        "api": "mlx.core.float16"
      },
      "torch": {
        "api": "torch.float16"
      }
    }
  },
  "Float32": {
    "description": "Type Float32",
    "operation": "Float32",
    "std_args": [],
    "variants": {
      "jax": {
        "api": "jax.numpy.float32"
      },
      "keras": {
        "api": "numpy.float32"
      },
      "numpy": {
        "api": "numpy.float32"
      },
      "torch": {
        "api": "torch.float32"
      }
    }
  },
  "GELU": {
    "description": "Gaussian Error Linear Unit.",
    "std_args": [
      "input"
    ]
  },
  "InferredOp": {
    "description": "Auto Op",
    "std_args": [],
    "variants": {}
  },
  "Int64": {
    "description": "Type Int64",
    "operation": "Int64",
    "std_args": [],
    "variants": {
      "jax": {
        "api": "jax.numpy.int64"
      },
      "numpy": {
        "api": "numpy.int64"
      },
      "tensorflow": {
        "api": "tf.int64"
      },
      "torch": {
        "api": "torch.int64"
      }
    }
  },
  "LayerNorm": {
    "description": "Applies Layer Normalization over a mini-batch of inputs.",
    "std_args": [
      "normalized_shape",
      "eps",
      "elementwise_affine",
      "bias"
    ]
  },
  "Linear": {
    "description": "Applies a linear transformation to the incoming data",
    "std_args": [
      "in_features",
      "out_features",
      "bias"
    ]
  },
  "LoadStateDict": {
    "description": "Loading state utility for mappings.",
    "std_args": []
  },
  "MSELoss": {
    "description": "Mean Squared Error.",
    "std_args": [
      "input",
      "target"
    ]
  },
  "MaxPool2d": {
    "description": "Applies a 2D max pooling over an input signal composed of several input planes.",
    "std_args": [
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "return_indices",
      "ceil_mode"
    ]
  },
  "Mean": {
    "description": "Definition for Mean",
    "operation": "Mean",
    "std_args": [
      "x"
    ],
    "variants": {
      "jax": {
        "api": "jax.numpy.mean"
      },
      "keras": {
        "api": "keras.ops.mean"
      },
      "mlx": {
        "api": "mlx.core.mean"
      },
      "numpy": {
        "api": "numpy.mean"
      },
      "tensorflow": {
        "api": "tf.math.reduce_mean"
      },
      "torch": {
        "api": "torch.mean"
      }
    }
  },
  "MultiheadAttention": {
    "description": "Multi-head attention mechanism.",
    "std_args": [
      "embed_dim",
      "num_heads",
      "dropout",
      "bias",
      "add_bias_kv",
      "add_zero_attn",
      "kdim",
      "vdim",
      "batch_first"
    ]
  },
  "NewOp": {
    "description": "A new operation",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Param": {
    "description": "Container for trainable parameter.",
    "std_args": [
      "value"
    ]
  },
  "ReLU": {
    "description": "Rectified Linear Unit.",
    "std_args": []
  },
  "Sequential": {
    "description": "A sequential container.",
    "std_args": [
      "layers"
    ]
  },
  "Variable": {
    "description": "Generic state container.",
    "std_args": [
      "value"
    ]
  },
  "__comment__": "DO NOT EDIT. Auto-generated from standards_internal.py migration.",
  "load_state_dict": {
    "description": "Copies parameters and buffers from state_dict into this module.",
    "std_args": [
      "state_dict",
      "strict"
    ]
  },
  "log_softmax": {
    "description": "Applies the LogSoftmax function to an n-dimensional input Tensor.",
    "std_args": [
      "input",
      "dim"
    ]
  },
  "parameters": {
    "description": "Returns an iterator over module parameters.",
    "std_args": [
      "recurse"
    ]
  },
  "register_buffer": {
    "description": "Registers a persistent buffer.",
    "std_args": [
      "name",
      "tensor",
      "persistent"
    ]
  },
  "register_parameter": {
    "description": "Registers a learnable parameter.",
    "std_args": [
      "name",
      "param"
    ]
  },
  "softmax": {
    "description": "Applies the Softmax function to an n-dimensional input Tensor.",
    "std_args": [
      "input",
      "dim"
    ]
  },
  "state_dict": {
    "description": "Returns a dictionary containing a whole state of the module.",
    "std_args": [
      "destination",
      "prefix",
      "keep_vars"
    ]
  }
}