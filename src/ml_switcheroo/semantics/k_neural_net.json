{
  "A": {
    "description": "Auto-generated from flax_nnx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "ALiBi": {
    "description": "Attention with Linear Biases (ALiBi) layer.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "AMax": {
    "description": "Return the maximum of an array or maximum along an axis.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "AMin": {
    "description": "Return the minimum of an array or minimum along an axis.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Abs": {
    "description": "Computes the absolute value element-wise.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Abs_": {
    "description": "Computes the absolute value element-wise (In-place).",
    "is_inplace": true,
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Absolute": {
    "description": "Alias for Abs.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "AcceleratorError": {
    "description": "Exception raised while executing on device.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "AccumulateN": {
    "description": "Returns the element-wise sum of a list of tensors. (Deprecated -> AddN)",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "inputs",
        "type": "List[Tensor]"
      }
    ],
    "variants": {}
  },
  "Acos": {
    "description": "Computes the inverse cosine (arccosine).",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Acos_": {
    "description": "Computes the inverse cosine (arccosine) in-place.",
    "is_inplace": true,
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Acosh": {
    "description": "Computes the inverse hyperbolic cosine.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Acosh_": {
    "description": "Computes the inverse hyperbolic cosine in-place.",
    "is_inplace": true,
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ActivationLayer": {
    "description": "Applies an activation function to an output.",
    "op_type": "class",
    "std_args": [
      {
        "doc": "Name of activation function or callable.",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "activation",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "ActivityRegularization": {
    "description": "Layer that applies an update to the cost function based input activity.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "l1",
        "type": "float"
      },
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "l2",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Adadelta": {
    "description": "Optimizer that implements the Adadelta algorithm.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.001,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "learning_rate",
        "type": "float"
      },
      {
        "default": 0.95,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "rho",
        "type": "float"
      },
      {
        "default": "1e-07",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "epsilon",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight_decay",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Adafactor": {
    "description": "Optimizer that implements the Adafactor algorithm.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.001,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "learning_rate",
        "type": "float"
      },
      {
        "default": -0.8,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta_2_decay",
        "type": "float"
      },
      {
        "default": "1e-30",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "epsilon_1",
        "type": "float"
      },
      {
        "default": 0.001,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "epsilon_2",
        "type": "float"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "clip_threshold",
        "type": "float"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "relative_step",
        "type": "boolean"
      }
    ],
    "variants": {}
  },
  "Adagrad": {
    "description": "Optimizer that implements the Adagrad algorithm.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.001,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "learning_rate",
        "type": "float"
      },
      {
        "default": 0.1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "initial_accumulator_value",
        "type": "float"
      },
      {
        "default": "1e-07",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "epsilon",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight_decay",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Adam": {
    "description": "Optimizer that implements the Adam algorithm.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.001,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "learning_rate",
        "type": "float"
      },
      {
        "default": 0.9,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta_1",
        "type": "float"
      },
      {
        "default": 0.999,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta_2",
        "type": "float"
      },
      {
        "default": "1e-07",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "epsilon",
        "type": "float"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "amsgrad",
        "type": "boolean"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight_decay",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "AdamW": {
    "description": "Optimizer that implements the AdamW algorithm.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.001,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "learning_rate",
        "type": "float"
      },
      {
        "default": 0.004,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight_decay",
        "type": "float"
      },
      {
        "default": 0.9,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta_1",
        "type": "float"
      },
      {
        "default": 0.999,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta_2",
        "type": "float"
      },
      {
        "default": "1e-07",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "epsilon",
        "type": "float"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "amsgrad",
        "type": "boolean"
      }
    ],
    "variants": {}
  },
  "Adamax": {
    "description": "Optimizer that implements the Adamax algorithm.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.001,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "learning_rate",
        "type": "float"
      },
      {
        "default": 0.9,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta_1",
        "type": "float"
      },
      {
        "default": 0.999,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta_2",
        "type": "float"
      },
      {
        "default": "1e-07",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "epsilon",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight_decay",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Adamw": {
    "description": "Auto-discovered via Consensus (Score: 4.0)",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "eps",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "lr",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight_decay",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "AdaptedTransformerFeedForward": {
    "description": "A wrapper for MultitaskResidualAdapter inserted before residual connections.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_dims",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hidden_dims",
        "type": "int"
      },
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dropout_prob",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "AdaptiveAveragePooling1D": {
    "description": "Adaptive average pooling operation for 1D temporal or spatial data.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "output_size",
        "type": "Union[int, Tuple[int]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "AdaptiveAveragePooling2D": {
    "description": "Adaptive average pooling operation for 2D spatial data.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "output_size",
        "type": "Union[int, Tuple[int, int]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "AdaptiveAveragePooling3D": {
    "description": "Adaptive average pooling operation for 3D volumetric data.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "output_size",
        "type": "Union[int, Tuple[int, int, int]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "AdaptiveAvgPool1d": {
    "description": "Applies a 1D adaptive average pooling over an input signal.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "rank": 3,
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "output_size",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "AdaptiveAvgPool2d": {
    "description": "Applies a 2D adaptive average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "output_size"
    ],
    "type": "class"
  },
  "AdaptiveAvgPool3d": {
    "description": "Applies a 3D adaptive average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "output_size"
    ],
    "type": "class"
  },
  "AdaptiveGradClipState": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "AdaptiveLogSoftmaxWithLoss": {
    "description": "Efficient softmax approximation.",
    "std_args": [
      "self",
      "in_features",
      "n_classes",
      "cutoffs",
      "div_value",
      "head_bias",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "AdaptiveMaxPool1d": {
    "description": "Applies a 1D adaptive max pooling over an input signal.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "rank": 3,
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "output_size",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "AdaptiveMaxPool2d": {
    "description": "Applies a 2D adaptive max pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "output_size",
      "return_indices"
    ],
    "type": "class"
  },
  "AdaptiveMaxPool3d": {
    "description": "Applies a 3D adaptive max pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "output_size",
      "return_indices"
    ],
    "type": "class"
  },
  "AdaptiveMaxPooling1D": {
    "description": "Adaptive max pooling operation for 1D temporal or spatial data.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "output_size",
        "type": "Union[int, Tuple[int]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "AdaptiveMaxPooling2D": {
    "description": "Adaptive max pooling operation for 2D spatial data.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "output_size",
        "type": "Union[int, Tuple[int, int]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "AdaptiveMaxPooling3D": {
    "description": "Adaptive max pooling operation for 3D volumetric data.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "output_size",
        "type": "Union[int, Tuple[int, int, int]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "Add": {
    "description": "Adds other to input, scaled by alpha.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "alpha",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "AddDecayedWeightsState": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "AddLayer": {
    "description": "Layer that adds a list of inputs.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "AddN": {
    "description": "Returns the element-wise sum of a list of tensors.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "inputs",
        "type": "List[Tensor]"
      }
    ],
    "variants": {}
  },
  "AddNoiseState": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Addbmm": {
    "description": "Performs batch matrix-matrix product of matrices with reduced add step.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "batch1",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "batch2",
        "type": "Tensor"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta",
        "type": "float"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "alpha",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Addcdiv": {
    "description": "Performs element-wise division of tensor1 by tensor2, multiplies by value, adds to input.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tensor1",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tensor2",
        "type": "Tensor"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Addcmul": {
    "description": "Performs the element-wise multiplication of tensor1 by tensor2, multiplies the result by the scalar value and adds it to input.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tensor1",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tensor2",
        "type": "Tensor"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "AdditiveAttention": {
    "description": "Additive attention layer, a.k.a. Bahdanau-style attention.",
    "op_type": "class",
    "std_args": [
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "use_scale",
        "type": "bool"
      },
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dropout",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Addmm": {
    "description": "Performs a matrix multiplication of the matrices mat1 and mat2. The matrix input is added to the final result.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mat1",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mat2",
        "type": "Tensor"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta",
        "type": "float"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "alpha",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Addmv": {
    "description": "Performs a matrix-vector product of the matrix mat and the vector vec. The vector input is added to the final result.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mat",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "vec",
        "type": "Tensor"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta",
        "type": "float"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "alpha",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Addmv_": {
    "description": "In-place version of Addmv.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mat",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "vec",
        "type": "Tensor"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta",
        "type": "float"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "alpha",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Addr": {
    "description": "Performs the outer-product of vectors vec1 and vec2 and adds it to the matrix input.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "vec1",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "vec2",
        "type": "Tensor"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta",
        "type": "float"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "alpha",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Adjoint": {
    "description": "Returns a view of the tensor conjugated and with the last two dimensions transposed.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "AffineGrid": {
    "description": "Generates a 2D or 3D flow field (sampling grid), given a batch of affine matrices theta (https://pytorch.org/docs/stable/generated/torch.nn.functional.affine_grid.html). An affine matrix `theta` is applied to a position tensor represented in its homogeneous expression. Here is an example in 3D: ``` ...",
    "from": "Operators.md",
    "std_args": [
      [
        "theta",
        "Any"
      ],
      [
        "size",
        "Any"
      ],
      [
        "align_corners",
        "int"
      ]
    ]
  },
  "AffineGridGenerator": {
    "description": "Generates a 2D or 3D flow field (sampling grid), given a batch of affine matrices.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "theta",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "List[int]"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "align_corners",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "AggregationType": {
    "description": "Enum for aggregation types (SUM, AVG).",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "AliasCopy": {
    "description": "Returns a copy of the input tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "AliasDb": {
    "description": "JIT Alias Database.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "AlignTensors": {
    "description": "Reshapes tensors to match the broadcast shape of the inputs.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "tensors",
        "type": "List[Tensor]"
      }
    ],
    "variants": {}
  },
  "All": {
    "description": "Tests if all elements in input evaluate to True.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "AllClose": {
    "description": "Returns True if two arrays are element-wise equal within a tolerance.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b",
        "type": "Tensor"
      },
      {
        "default": "1e-05",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "rtol",
        "type": "float"
      },
      {
        "default": "1e-08",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "atol",
        "type": "float"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "equal_nan",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "AllToShardedLinear": {
    "description": "Distributed linear layer where result is sharded across the group.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "in_features",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "out_features",
        "type": "int"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "group",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Allclose": {
    "description": "Checks if all elements in input and other are approximately unequal.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      },
      {
        "default": "1e-05",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "rtol",
        "type": "float"
      },
      {
        "default": "1e-08",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "atol",
        "type": "float"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "equal_nan",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "AlphaDropout": {
    "description": "Applies Alpha Dropout to the input.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.5,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "p",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "AlphaDropout_": {
    "description": "In-place version of AlphaDropout.",
    "is_inplace": true,
    "op_type": "class",
    "std_args": [
      {
        "default": 0.5,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "p",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Alphadropout": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "variants": {}
  },
  "Amax": {
    "description": "Returns the maximum value of each slice of the input tensor in the given dimension(s).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Amin": {
    "description": "Returns the minimum value of each slice of the input tensor in the given dimension(s).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Aminmax": {
    "description": "Computes the minimum and maximum values of the input tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "And": {
    "description": "Returns the tensor resulted from performing the `and` logical operation elementwise on the input tensors `A` and `B` (with Numpy-style broadcasting support). This operator supports **multidirectional (i.e., Numpy-style) broadcasting**; for more details please check [the doc](Broadcasting.md).",
    "from": "Operators.md",
    "std_args": [
      [
        "A",
        "Tensor"
      ],
      [
        "B",
        "Tensor"
      ]
    ]
  },
  "Angle": {
    "description": "Computes the element-wise angle (in radians) of the given input tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Any": {
    "description": "Tests if any element in input evaluates to True.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "AnyType": {
    "description": "JIT Any Type.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Append": {
    "description": "Append values to the end of an array.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "arr",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "values",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ApplyAlongAxis": {
    "description": "Apply a function to 1-D slices along the given axis.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "func1d",
        "type": "Callable"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "arr",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ApplyIfFiniteState": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "ApplyOverAxes": {
    "description": "Apply a function repeatedly over multiple axes.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "func",
        "type": "Callable"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axes",
        "type": "List[int]"
      }
    ],
    "variants": {}
  },
  "ApproxMaxK": {
    "description": "Returns max k values and their indices using approximate search (TPU optimized).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "operand",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "k",
        "type": "int"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "reduction_dimension",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ApproxMinK": {
    "description": "Returns min k values and their indices using approximate search.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "operand",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "k",
        "type": "int"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "reduction_dimension",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Arange": {
    "description": "Returns a 1-D tensor of values from the interval [start, end) taken with common difference step.",
    "std_args": [
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "start",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "end",
        "type": "float"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "step",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Arccos": {
    "description": "Computes the inverse cosine (arccos) of each element.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Arccos_": {
    "description": "In-place version of Arccos.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Arccosh": {
    "description": "Computes the inverse hyperbolic cosine (arccosh) of each element.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Arccosh_": {
    "description": "In-place version of Arccosh.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Arcsin": {
    "description": "Computes the inverse sine (arcsin) of each element.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Arcsin_": {
    "description": "In-place version of Arcsin.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Arcsinh": {
    "description": "Computes the inverse hyperbolic sine (arcsinh) of each element.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Arcsinh_": {
    "description": "In-place version of Arcsinh.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Arctan": {
    "description": "Computes the inverse tangent (arctan) of each element.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Arctan2": {
    "description": "Computes the element-wise arc tangent of input / other.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Arctan_": {
    "description": "In-place version of Arctan.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Arctanh": {
    "description": "Returns the inverse hyperbolic tangent of the elements of the input tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Arctanh_": {
    "description": "In-place version of Arctanh.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "AreDeterministicAlgorithmsEnabled": {
    "description": "Returns True if global deterministic flag is turned on.",
    "return_type": "boolean",
    "std_args": [],
    "variants": {}
  },
  "ArgMax": {
    "description": "Returns the index with the largest value across axes of a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ArgMin": {
    "description": "Returns the index with the smallest value across axes of a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ArgPartition": {
    "description": "Perform an indirect partition along the given axis.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kth",
        "type": "int"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ArgSort": {
    "description": "Returns the indices that would sort an array.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ArgWhere": {
    "description": "Find the indices of array elements that are non-zero, grouped by element.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Argmax": {
    "description": "Returns the indices of the maximum value of all elements in the input tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Argmin": {
    "description": "Returns the indices of the minimum value of all elements in the input tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Argsort": {
    "description": "Returns the indices that sort a tensor along a given dimension.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "descending",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stable",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Argument": {
    "description": "JIT Argument specification.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "ArgumentSpec": {
    "description": "JIT Argument Specification.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Argwhere": {
    "description": "Returns a tensor containing the indices of all non-zero elements.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Array": {
    "description": "Constructs a tensor from data.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "object",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Dtype"
      }
    ],
    "variants": {}
  },
  "Array2String": {
    "description": "Return a string representation of an array.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "ArrayAt": {
    "description": "Interface for indexed updates (JAX style).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ArrayEqual": {
    "description": "True if two arrays have the same shape and elements.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a1",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a2",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ArrayEquiv": {
    "description": "Returns True if input arrays are shape consistent and all elements equal.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a1",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a2",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "ArrayIterator": {
    "description": "Iterator over an array's first dimension.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ArrayLike": {
    "description": "Type hint for array-compatible objects.",
    "std_args": [],
    "variants": {}
  },
  "ArrayRepr": {
    "description": "Return the string representation of an array.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "arr",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "ArraySplit": {
    "description": "Split an array into multiple sub-arrays.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ary",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "indices_or_sections",
        "type": "Union[int, List[int]]"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ArrayStr": {
    "description": "Return a string representation of the data in an array.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "AsAnyArray": {
    "description": "Convert the input to an ndarray, but pass ndarray subclasses through.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "AsArray": {
    "description": "Converts obj to a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "obj",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "dtype"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "device",
        "type": "Device"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "copy",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "requires_grad",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "AsArrayChkFinite": {
    "description": "Convert the input to an array, checking for NaNs or Infs.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "dtype"
      }
    ],
    "variants": {}
  },
  "AsArrayVars": {
    "description": "Converts specific variables.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "node",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "AsContiguousArray": {
    "description": "Return a contiguous array (ndim >= 1) in memory (C order).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "AsFortranArray": {
    "description": "Return an array (ndim >= 1) laid out in Fortran order in memory.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "AsHijaxVars": {
    "description": "Converts specific variables.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "node",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "AsImmutableVars": {
    "description": "Converts specific variables.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "node",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "AsMatrix": {
    "description": "Interpret the input as a matrix.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "AsMutableVars": {
    "description": "Converts specific variables.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "node",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "AsPytreeVars": {
    "description": "Converts specific variables.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "node",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "AsRefVars": {
    "description": "Converts a Variable or structure of Variables to Variables with has_ref=True.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "node",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "AsStrided": {
    "description": "Create a view of an existing tensor with specified size, stride and storage_offset.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "Sequence[int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "Sequence[int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "storage_offset",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "AsStridedCopy": {
    "description": "as_strided operation, but output is freshly created.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "Sequence[int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "Sequence[int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "storage_offset",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "AsStridedScatter": {
    "description": "Embeds values into input using strides.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "src",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "Sequence[int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "Sequence[int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "storage_offset",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "AsStrided_": {
    "description": "In-place version of as_strided.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "Sequence[int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "Sequence[int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "storage_offset",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "AsTensor": {
    "description": "Converts data into a tensor, sharing data and preserving autograd history if possible.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "dtype"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "device",
        "type": "Device"
      }
    ],
    "variants": {}
  },
  "Asin": {
    "description": "Returns the arcsine of the elements.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Asin_": {
    "description": "In-place version of Asin.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Asinh": {
    "description": "Returns the inverse hyperbolic sine.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Asinh_": {
    "description": "In-place version of Asinh.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "AssertClose": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Astype": {
    "description": "Copies an array to a specified data type.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "dtype"
      }
    ],
    "variants": {}
  },
  "AsyncEval": {
    "description": "Asynchronously evaluate an array or tree of arrays.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "tensors",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "AtLeast1D": {
    "description": "Convert inputs to arrays with at least one dimension.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "arys",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "AtLeast2D": {
    "description": "Convert inputs to arrays with at least two dimensions.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "arys",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "AtLeast3D": {
    "description": "Convert inputs to arrays with at least three dimensions.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "arys",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Atan": {
    "description": "Returns the arctangent.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Atan2": {
    "description": "Element-wise arctangent of y / x.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Atan_": {
    "description": "In-place version of Atan.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Atanh": {
    "description": "Returns the inverse hyperbolic tangent.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Atanh_": {
    "description": "In-place version of Atanh.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Atleast1d": {
    "description": "Returns a 1-dimensional view of each input tensor with zero dimensions.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "tensors",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Atleast2d": {
    "description": "Returns a 2-dimensional view.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "tensors",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Atleast3d": {
    "description": "Returns a 3-dimensional view.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "tensors",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Atom": {
    "description": "Auto-generated from numpy_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Attention": {
    "description": "Computes scaled dot product attention on query, key and value tensors, using an optional attention mask if passed. This operator covers self and cross variants of the attention operation based on sequence lengths of K, Q and V. For self attention, `kv_sequence_length` equals to `q_sequence_length`. ...",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "Q",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "K",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "V",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "attn_mask",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "past_key",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "past_value",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "nonpad_kv_seqlen",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "is_causal",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kv_num_heads",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "q_num_heads",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "qk_matmul_output_mode",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "scale",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "softcap",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "softmax_precision",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "AttentionLayer": {
    "description": "Dot-product attention layer, a.k.a. Luong-style attention.",
    "op_type": "class",
    "std_args": [
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "use_scale",
        "type": "bool"
      },
      {
        "default": "dot",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "score_mode",
        "options": [
          "dot",
          "concat"
        ],
        "type": "str"
      },
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dropout",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "seed",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "AttentionProjection": {
    "description": "Layer that computes multi-head projection for dot-product attention.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_heads",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim_per_head",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "is_output",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "AugMix": {
    "description": "Performs the AugMix data augmentation technique.",
    "op_type": "class",
    "std_args": [
      {
        "default": [
          0,
          255
        ],
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value_range",
        "type": "Tuple[int, int]"
      },
      {
        "default": 3,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_chains",
        "type": "int"
      },
      {
        "default": 3,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "chain_depth",
        "type": "int"
      },
      {
        "default": 0.3,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "factor",
        "type": "float"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "alpha",
        "type": "float"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "all_ops",
        "type": "bool"
      },
      {
        "default": "bilinear",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "interpolation",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "seed",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "AutoContrast": {
    "description": "Performs the auto-contrast operation on an image.",
    "op_type": "class",
    "std_args": [
      {
        "default": [
          0,
          255
        ],
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value_range",
        "type": "Tuple[int, int]"
      }
    ],
    "variants": {}
  },
  "Autocast": {
    "description": "Context manager or decorator to allow regions of script to run in mixed precision.",
    "op_type": "context",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "device_type",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "dtype"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "enabled",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "cache_enabled",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "AutocastDecrementNesting": {
    "description": "Decrement nesting count for autocast.",
    "std_args": [],
    "variants": {}
  },
  "AutocastIncrementNesting": {
    "description": "Increment nesting count for autocast.",
    "std_args": [],
    "variants": {}
  },
  "AutodiffCheckpointType": {
    "description": "Enumeration for JAX checkpoint types.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "AuxOutput": {
    "description": "Auto-generated from flax_nnx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "AuxRequest": {
    "description": "Request which auxiliary outputs to compute from flex_attention.",
    "std_args": [],
    "type": "class"
  },
  "Average": {
    "description": "Compute the weighted average along the specified axis.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weights",
        "type": "Tensor"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "returned",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "AverageGradients": {
    "description": "Average the gradients across distributed processes.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "gradients",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "AverageLayer": {
    "description": "Averages a list of inputs element-wise.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "AveragePool": {
    "description": "AveragePool consumes an input tensor X and applies average pooling across the tensor according to kernel sizes, stride sizes, and pad lengths. average pooling consisting of computing the average on all values of a subset of the input tensor according to the kernel size and downsampling the data into...",
    "from": "Operators.md",
    "std_args": [
      [
        "X",
        "Tensor"
      ],
      [
        "auto_pad",
        "str"
      ],
      [
        "ceil_mode",
        "int"
      ],
      [
        "count_include_pad",
        "int"
      ],
      [
        "dilations",
        "List[int]"
      ],
      [
        "kernel_shape",
        "List[int]"
      ],
      [
        "pads",
        "List[int]"
      ],
      [
        "strides",
        "List[int]"
      ]
    ]
  },
  "AveragePooling1D": {
    "description": "Average pooling for temporal data.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "pool_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "strides",
        "type": "int"
      },
      {
        "default": "valid",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "AveragePooling2D": {
    "description": "Average pooling operation for 2D spatial data.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "pool_size",
        "type": "Union[int, Tuple[int, int]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "strides",
        "type": "Union[int, Tuple[int, int]]"
      },
      {
        "default": "valid",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "AveragePooling3D": {
    "description": "Average pooling operation for 3D volumetric data.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "pool_size",
        "type": "Union[int, Tuple[int, int, int]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "strides",
        "type": "Union[int, Tuple[int, int, int]]"
      },
      {
        "default": "valid",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "Avg": {
    "description": "Aggregation constant for Average.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "AvgPool": {
    "description": "Pools the input by taking the average over a window.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "inputs",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "window_shape",
        "type": "Tuple[int, ...]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "strides",
        "type": "Tuple[int, ...]"
      },
      {
        "default": "VALID",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "AvgPool1D": {
    "description": "Alias for AveragePooling1D.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "pool_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "strides",
        "type": "int"
      },
      {
        "default": "valid",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "AvgPool1d": {
    "description": "Applies a 1D average pooling.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ceil_mode",
        "type": "bool"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "count_include_pad",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "AvgPool2D": {
    "description": "Alias for AveragePooling2D.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "pool_size",
        "type": "Union[int, Tuple[int, int]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "strides",
        "type": "Union[int, Tuple[int, int]]"
      },
      {
        "default": "valid",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "AvgPool2d": {
    "description": "Applies 2D average pooling.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "Union[int, Tuple[int, int]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "Union[int, Tuple[int, int]]"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "Union[int, Tuple[int, int]]"
      }
    ],
    "variants": {}
  },
  "AvgPool3D": {
    "description": "Alias for AveragePooling3D.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "pool_size",
        "type": "Union[int, Tuple[int, int, int]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "strides",
        "type": "Union[int, Tuple[int, int, int]]"
      },
      {
        "default": "valid",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "AvgPool3d": {
    "description": "Applies 3D average pooling.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "Union[int, Tuple[int, int, int]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "Union[int, Tuple[int, int, int]]"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "Union[int, Tuple[int, int, int]]"
      }
    ],
    "variants": {}
  },
  "Avgpool": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "AwaitType": {
    "description": "JIT Await Type.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "B": {
    "description": "Auto-generated from flax_nnx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "BACKEND": {
    "description": "Selects a specific kernel backend.",
    "std_args": [],
    "type": "attribute"
  },
  "BCELoss": {
    "description": "Creates a criterion that measures the Binary Cross Entropy between the target and",
    "std_args": [
      "self",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "BCEWithLogitsLoss": {
    "description": "This loss combines a `Sigmoid` layer and the `BCELoss` in one single",
    "std_args": [
      "self",
      "weight",
      "size_average",
      "reduce",
      "reduction",
      "pos_weight"
    ],
    "type": "class"
  },
  "BFloat16": {
    "description": "Data type constant for brain floating point 16.",
    "std_args": [],
    "variants": {}
  },
  "BFloat16Storage": {
    "description": "Storage for BFloat16 data.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "BFloat16Tensor": {
    "description": "Constructs a Tensor with bfloat16 data type.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "BLOCKS_ARE_CONTIGUOUS": {
    "description": "If True, guarantees that all blocks in the mask are contiguous.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_M": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "BLOCK_M1": {
    "description": "Thread block size for Q dimension in backward pass. Use as 'bwd_BLOCK_M1'.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_M2": {
    "description": "Thread block size for second Q dimension in backward pass. Use as 'bwd_BLOCK_M2'.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_N": {
    "description": "Thread block size for the sequence length dimension of K/V in forward pass.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_N1": {
    "description": "Thread block size for K/V dimension in backward pass. Use as 'bwd_BLOCK_N1'.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_N2": {
    "description": "Thread block size for second K/V dimension in backward pass. Use as 'bwd_BLOCK_N2'.",
    "std_args": [],
    "type": "attribute"
  },
  "BLOCK_SIZE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Baddbmm": {
    "description": "Performs a batch matrix-matrix product of matrices in batch1 and batch2. input is added to final result.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "batch1",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "batch2",
        "type": "Tensor"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta",
        "type": "float"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "alpha",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Bartlett": {
    "description": "Return the Bartlett window.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "M",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "BartlettWindow": {
    "description": "Computes the Bartlett window function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "window_length",
        "type": "int"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "periodic",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "BaseActivation": {
    "description": "Base class for activation functions.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "BaseNormalization": {
    "description": "Base class for normalization layers.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "BasePruningMethod": {
    "description": "Abstract base class for creation of new pruning techniques.",
    "std_args": [],
    "type": "class"
  },
  "BaseRepr": {
    "description": "Return a string representation of a number in the given base system.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "number",
        "type": "int"
      },
      {
        "default": 2,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "base",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "BatchNorm": {
    "description": "Applies Batch Normalization to the input.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "running_mean",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "running_var",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "Tensor"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "training",
        "type": "bool"
      },
      {
        "default": 0.1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "momentum",
        "type": "float"
      },
      {
        "default": "1e-5",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "eps",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "BatchNorm1d": {
    "description": "Applies Batch Normalization over a 2D or 3D input.",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "BatchNorm2d": {
    "description": "Applies Batch Normalization over a 4D input.",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "BatchNorm3d": {
    "description": "Applies Batch Normalization over a 5D input.",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "BatchNormBackwardElemt": {
    "description": "Internal operation for BatchNorm backward elementwise steps.",
    "std_args": [
      "grad_out",
      "input",
      "mean",
      "invstd",
      "weight",
      "sum_dy",
      "sum_dy_x_mu"
    ],
    "variants": {}
  },
  "BatchNormBackwardReduce": {
    "description": "Internal operation for BatchNorm backward reduction steps.",
    "std_args": [
      "grad_out",
      "input",
      "mean",
      "invstd",
      "weight",
      "input_g_qs",
      "weight_g_qs"
    ],
    "variants": {}
  },
  "BatchNormElemt": {
    "description": "Internal operation for BatchNorm forward elementwise steps.",
    "std_args": [
      "input",
      "weight",
      "bias",
      "mean",
      "invstd",
      "eps"
    ],
    "variants": {}
  },
  "BatchNormGatherStats": {
    "description": "Internal operation for BatchNorm statistics gathering.",
    "std_args": [
      "input",
      "mean",
      "invstd",
      "running_mean",
      "running_var",
      "momentum",
      "eps",
      "count"
    ],
    "variants": {}
  },
  "BatchNormGatherStatsWithCounts": {
    "description": "Internal operation for BatchNorm statistics gathering with counts.",
    "std_args": [
      "input",
      "mean",
      "invstd",
      "running_mean",
      "running_var",
      "momentum",
      "eps",
      "counts"
    ],
    "variants": {}
  },
  "BatchNormStats": {
    "description": "Internal operation for BatchNorm statistics calculation.",
    "std_args": [
      "input",
      "eps"
    ],
    "variants": {}
  },
  "BatchNormUpdateStats": {
    "description": "Internal operation for BatchNorm statistics update.",
    "std_args": [
      "input",
      "running_mean",
      "running_var",
      "momentum"
    ],
    "variants": {}
  },
  "BatchNormalization": {
    "description": "Layer that normalizes its inputs.",
    "op_type": "class",
    "std_args": [
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "default": 0.99,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "momentum",
        "type": "float"
      },
      {
        "default": 0.001,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "epsilon",
        "type": "float"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "center",
        "type": "bool"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "scale",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "BatchStat": {
    "description": "Wrapper for Batch Statistics state.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "BenchmarkConfig": {
    "description": "Configuration for benchmarks.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "BenchmarkExecutionStats": {
    "description": "Execution statistics for benchmarks.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Bernoulli": {
    "description": "Draws binary random numbers (0 or 1) from a Bernoulli distribution.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "generator",
        "type": "Optional[Generator]"
      }
    ],
    "variants": {}
  },
  "BertModel": {
    "description": "BERT Model base task.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mask_token_id",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "BesselI0": {
    "description": "Modified Bessel function of order 0.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "BesselI0e": {
    "description": "Exponentially scaled modified Bessel function of order 0.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "BesselI1": {
    "description": "Modified Bessel function of order 1.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "BesselI1e": {
    "description": "Exponentially scaled modified Bessel function of order 1.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Betainc": {
    "description": "Compute the regularized incomplete beta integral.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Bfloat16": {
    "description": "Bfloat16 data type.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "BiTemperedLoss": {
    "description": "Bi-tempered logistic loss for noisy labels.",
    "op_type": "class",
    "std_args": [
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "t1",
        "type": "float"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "t2",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Bias": {
    "description": "Simple learnable bias layer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dims",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Bidirectional": {
    "description": "Bidirectional wrapper for RNNs.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "layer",
        "type": "Any"
      },
      {
        "default": "concat",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "merge_mode",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "Bilinear": {
    "description": "Applies a bilinear transformation to the incoming data.",
    "std_args": [
      "input1",
      "input2",
      "weight",
      "bias"
    ],
    "variants": {}
  },
  "BinaryCrossEntropyWithLogits": {
    "description": "Computes Binary Cross Entropy with Logits.",
    "std_args": [
      "input",
      "target",
      "weight",
      "pos_weight",
      "reduction"
    ],
    "variants": {}
  },
  "BinaryCrossentropy": {
    "description": "Computes the cross-entropy loss between true labels and predicted labels.",
    "op_type": "class",
    "std_args": [
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "from_logits",
        "type": "bool"
      },
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "label_smoothing",
        "type": "float"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "default": "sum_over_batch_size",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "reduction",
        "options": [
          "sum",
          "sum_over_batch_size",
          "mean",
          "none"
        ],
        "type": "str"
      },
      {
        "default": "binary_crossentropy",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "name",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "BinaryFocalCrossentropy": {
    "description": "Computes focal cross-entropy loss between true labels and predictions.",
    "op_type": "class",
    "std_args": [
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "apply_class_balancing",
        "type": "bool"
      },
      {
        "default": 0.25,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "alpha",
        "type": "float"
      },
      {
        "default": 2.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "gamma",
        "type": "float"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "from_logits",
        "type": "bool"
      },
      {
        "default": "sum_over_batch_size",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "reduction",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "BinaryRepr": {
    "description": "Return the binary representation of the input number as a string.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "width",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Bincount": {
    "description": "Count the frequency of each value in an array of non-negative ints.",
    "std_args": [
      "input",
      "weights",
      "minlength"
    ],
    "variants": {}
  },
  "Binomial": {
    "description": "Draws samples from a binomial distribution.",
    "std_args": [
      "count",
      "prob",
      "generator"
    ],
    "variants": {}
  },
  "Bit": {
    "description": "Internal bit casting/representation.",
    "std_args": [
      "x"
    ],
    "variants": {}
  },
  "BitCast": {
    "description": "View (Reinterpret Cast) the array as a different type.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Dtype"
      }
    ],
    "variants": {}
  },
  "BitShift": {
    "description": "Bitwise shift operator performs element-wise operation. For each input element, if the attribute \"direction\" is \"RIGHT\", this operator moves its binary representation toward the right side so that the input value is effectively decreased. If the attribute \"direction\" is \"LEFT\", bits of binary repres...",
    "from": "Operators.md",
    "std_args": [
      [
        "X",
        "Tensor"
      ],
      [
        "Y",
        "Tensor"
      ],
      [
        "direction",
        "str"
      ]
    ]
  },
  "Bits16": {
    "description": "Internal bit casting.",
    "std_args": [
      "x"
    ],
    "variants": {}
  },
  "Bits1x8": {
    "description": "Internal bit packing.",
    "std_args": [
      "x"
    ],
    "variants": {}
  },
  "Bits2x4": {
    "description": "Internal bit packing.",
    "std_args": [
      "x"
    ],
    "variants": {}
  },
  "Bits4x2": {
    "description": "Internal bit packing.",
    "std_args": [
      "x"
    ],
    "variants": {}
  },
  "Bits8": {
    "description": "Internal bit packing.",
    "std_args": [
      "x"
    ],
    "variants": {}
  },
  "BitwiseAnd": {
    "description": "Computes the bitwise specified AND of input and other.",
    "std_args": [
      "input",
      "other"
    ],
    "variants": {}
  },
  "BitwiseCount": {
    "description": "Computes the number of 1-bits in the absolute value of x.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "BitwiseInvert": {
    "description": "Compute bit-wise inversion, or bit-wise NOT, element-wise.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "BitwiseLeftShift": {
    "description": "Computes the left arithmetic shift of input by other bits.",
    "std_args": [
      "input",
      "other"
    ],
    "variants": {}
  },
  "BitwiseNot": {
    "description": "Computes the bitwise NOT of the given input tensor.",
    "std_args": [
      "input"
    ],
    "variants": {}
  },
  "BitwiseOr": {
    "description": "Computes the bitwise OR of input and other.",
    "std_args": [
      "input",
      "other"
    ],
    "variants": {}
  },
  "BitwiseRightShift": {
    "description": "Computes the right arithmetic shift of input by other bits.",
    "std_args": [
      "input",
      "other"
    ],
    "variants": {}
  },
  "BitwiseXor": {
    "description": "Computes the bitwise XOR of input and other.",
    "std_args": [
      "input",
      "other"
    ],
    "variants": {}
  },
  "Blackman": {
    "description": "Return a Blackman window of size M.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "M",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "BlackmanWindow": {
    "description": "Blackman window function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "window_length",
        "type": "int"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "periodic",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Block": {
    "description": "JIT Block.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "BlockDiag": {
    "description": "Create a block diagonal matrix from provided tensors.",
    "std_args": [
      "tensors"
    ],
    "variants": {}
  },
  "BlockMask": {
    "description": "BlockMask is our format for representing a block-sparse attention mask.",
    "std_args": [
      "self",
      "seq_lengths",
      "kv_num_blocks",
      "kv_indices",
      "full_kv_num_blocks",
      "full_kv_indices",
      "q_num_blocks",
      "q_indices",
      "full_q_num_blocks",
      "full_q_indices",
      "BLOCK_SIZE",
      "mask_mod"
    ],
    "type": "class"
  },
  "BlockMaskedMM": {
    "description": "Matrix multiplication with block masking.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b",
        "type": "Tensor"
      },
      {
        "default": 64,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "block_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mask_out",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mask_lhs",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mask_rhs",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "BlockWise128x128": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BlockWise1x128": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BlockWise1x16": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "BlockWise1x32": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Bmm": {
    "description": "Performs a batch matrix-matrix product.",
    "std_args": [
      "input",
      "mat2"
    ],
    "variants": {}
  },
  "Bool": {
    "description": "Boolean data type identifier.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "BoolScalar": {
    "description": "Explicit Boolean scalar constructor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "BoolStorage": {
    "description": "Storage for Boolean data.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "BoolTensor": {
    "description": "Constructs a Tensor with boolean data type.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "BoolType": {
    "description": "JIT Bool Type.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "BregmanPCA": {
    "description": "Online Bregman PCA layer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_components",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_dims",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "BroadcastArrays": {
    "description": "Broadcast any number of arrays against each other.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "arrays",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "BroadcastLike": {
    "description": "Produce an object that mimics broadcasting.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "arrays",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "BroadcastShapes": {
    "description": "Calculates the shape resulting from broadcasting multiple shapes together.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "shapes",
        "type": "List[Tuple[int, ...]]"
      }
    ],
    "variants": {}
  },
  "BroadcastTensors": {
    "description": "Broadcasts the given tensors according to broadcasting semantics.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "tensors",
        "type": "List[Tensor]"
      }
    ],
    "variants": {}
  },
  "BroadcastTo": {
    "description": "Broadcasts a tensor to a new shape.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "shape",
        "type": "Tuple[int, ...]"
      }
    ],
    "variants": {}
  },
  "Bucketize": {
    "description": "Returns the indices of the buckets to which each value in the input belongs.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "boundaries",
        "type": "Tensor"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "out_int32",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "right",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Buffer": {
    "description": "A kind of Tensor that should not be considered a model",
    "std_args": [
      "self",
      "data",
      "requires_grad",
      "persistent"
    ],
    "type": "class"
  },
  "BufferDict": {
    "description": "Dictionary of buffers.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "BuildMatrix": {
    "description": "Build a matrix object from a string, nested sequence, or array.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "obj",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ldict",
        "type": "dict"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "gdict",
        "type": "dict"
      }
    ],
    "variants": {}
  },
  "BusDayCalendar": {
    "description": "A business day calendar object.",
    "op_type": "class",
    "std_args": [
      {
        "default": "1111100",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weekmask",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "holidays",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "BusDayCount": {
    "description": "Counts the number of valid days between begindates and enddates.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "begindates",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "enddates",
        "type": "Any"
      },
      {
        "default": "1111100",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weekmask",
        "type": "Any"
      },
      {
        "default": [],
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "holidays",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "BusDayOffset": {
    "description": "Applies an offset counted in valid days.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dates",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "offsets",
        "type": "Any"
      },
      {
        "default": "raise",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "roll",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "ByteStorage": {
    "description": "Storage for Byte (UInt8) data.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "ByteTensor": {
    "description": "Constructs a Tensor with uint8 data type (Byte).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "ByteType": {
    "description": "Signed integer type, compatible with C char (Alias for int8 usually).",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "BytesType": {
    "description": "Byte string type.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "C": {
    "description": "Auto-generated from flax_nnx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "CColIndicesCopy": {
    "description": "Copies the column indices of a sparse matrix.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "CELU": {
    "description": "Applies the CELU activation function.",
    "op_type": "class",
    "std_args": [
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "alpha",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "CTCLoss": {
    "description": "CTC (Connectionist Temporal Classification) loss.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_true",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_pred",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Cache": {
    "description": "Wrapper for autoregressive cache state.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "CachedPartial": {
    "description": "Create a partial from a NNX transformed function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "f",
        "type": "Callable"
      }
    ],
    "variants": {}
  },
  "Call": {
    "description": "Calls a method underlying graph node defined by a (GraphDef, State) pair.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "graphdef_state",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "CallStack": {
    "description": "JIT Call Stack.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "CanCast": {
    "description": "Determines if a type conversion is allowed under casting rules.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "from_dtype",
        "type": "DType"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "to_dtype",
        "type": "DType"
      }
    ],
    "variants": {}
  },
  "Capsule": {
    "description": "JIT Capsule.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Carry": {
    "description": "Helper for scan carry state.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "CartesianProd": {
    "description": "Performs cartesian product of the given sequence of tensors.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "tensors",
        "type": "List[Tensor]"
      }
    ],
    "variants": {}
  },
  "Cast": {
    "description": "The operator casts the elements of a given input tensor to a data type specified by the 'to' argument and returns an output tensor of the same size in the converted type. The 'to' argument must be one of the data types specified in the 'DataType' enum field in the TensorProto message. Casting from s...",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "round_mode",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "saturate",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "to",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "CastBFloat16": {
    "description": "Casts input to bfloat16.",
    "std_args": [
      "x"
    ],
    "variants": {}
  },
  "CastBool": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "CastByte": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "CastChar": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "CastDouble": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "CastFloat": {
    "description": "Definition for CastFloat",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "CastHalf": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "CastInt": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "CastInt64": {
    "description": "Casts tensor to 64-bit integer type.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "CastLike": {
    "description": "The operator casts the elements of a given input tensor (the first input) to the same data type as the elements of the second input tensor. See documentation of the Cast operator for further details.",
    "from": "Operators.md",
    "std_args": [
      [
        "input",
        "Any"
      ],
      [
        "target_type",
        "Any"
      ],
      [
        "round_mode",
        "str"
      ],
      [
        "saturate",
        "int"
      ]
    ]
  },
  "CastLong": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "CastShort": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "CategoricalCrossentropy": {
    "description": "Computes the crossentropy loss between the labels and predictions.",
    "op_type": "class",
    "std_args": [
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "from_logits",
        "type": "bool"
      },
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "label_smoothing",
        "type": "float"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "default": "sum_over_batch_size",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "reduction",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "CategoricalFocalCrossentropy": {
    "description": "Computes the alpha balanced focal crossentropy loss.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.25,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "alpha",
        "type": "float"
      },
      {
        "default": 2.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "gamma",
        "type": "float"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "from_logits",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "CategoricalGeneralizedCrossEntropy": {
    "description": "Computes the Generalized Cross Entropy loss.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.5,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "q",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "CategoricalHinge": {
    "description": "Computes the categorical hinge loss.",
    "op_type": "class",
    "std_args": [
      {
        "default": "sum_over_batch_size",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "reduction",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "CategoryEncoding": {
    "description": "A preprocessing layer which encodes integer features.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_tokens",
        "type": "int"
      },
      {
        "default": "multi_hot",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "output_mode",
        "type": "str"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "sparse",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "CausalBias": {
    "description": "A bias representing causal attention patterns. For an overview of the bias structure, see the :class:`CausalVariant` enum.",
    "std_args": [
      "self",
      "variant",
      "seq_len_q",
      "seq_len_kv"
    ],
    "type": "class"
  },
  "CausalDepthwiseConv1D": {
    "description": "Causal depth-wise convolution applied to a 1-d sequence.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hidden_dims",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "CausalMask": {
    "description": "Computes and returns causal mask.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_t",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "CausalSegmentMask": {
    "description": "Computes the masks which combines causal masking and segment masks.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "segment_ids",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "causal_attention_mask",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "CausalVariant": {
    "description": "Enum for causal variants used in attention mechanisms.",
    "std_args": [],
    "type": "class"
  },
  "Cbrt": {
    "description": "Return the cube-root of an array, element-wise.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Cdist": {
    "description": "Computes batched the p-norm distance between each pair of the two collections of row vectors.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x1",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x2",
        "type": "Tensor"
      },
      {
        "default": 2.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "p",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Ceil": {
    "description": "Returns the ceiling of the input, element-wise.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "CeilInplace": {
    "description": "Returns the ceiling of the input, element-wise, in-place.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Celu": {
    "description": "Applies the Continuously Differentiable Exponential Linear Unit.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "alpha",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "CeluInplace": {
    "description": "Applies CELU in-place.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "alpha",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "CenterCrop": {
    "description": "A preprocessing layer which crops images.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "height",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "width",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "CenterCropPad": {
    "description": "Center crop or pad an input to given dimensions. The crop/pad dimensions can be specified for a subset of the `axes`; unspecified dimensions will remain unchanged. If the input dimensions are larger than the target crop dimensions, a centered cropping window will be extracted from the input. The sta...",
    "from": "Operators.md",
    "std_args": [
      [
        "input_data",
        "Tensor"
      ],
      [
        "shape",
        "Any"
      ],
      [
        "axes",
        "List[int]"
      ]
    ]
  },
  "ChainMatmul": {
    "description": "Performs matrix multiplication of N tensors.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "matrices",
        "type": "List[Tensor]"
      }
    ],
    "variants": {}
  },
  "ChannelShuffle": {
    "description": "Divides channels in a tensor of shape (*, C, H, W) into g groups and rearranges them.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "groups",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ChannelsLast": {
    "description": "Memory format constant.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "ChannelsLast3d": {
    "description": "Memory format constant for 3D.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "CharStorage": {
    "description": "Storage for Char (Int8) data.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "CharTensor": {
    "description": "Constructs a Tensor with int8 data type (Char).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "CharacterType": {
    "description": "Abstract base class of all character string scalar types.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "CheckPytree": {
    "description": "Checks if a pytree is valid.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "pytree",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Checkify": {
    "description": "Reference-aware version of `jax.experimental.checkify`. Checks for errors (like NaN/Inf) during execution.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "f",
        "type": "Callable"
      },
      {
        "default": "frozenset({<class 'jax._src.checkify.FailedCheckError'>})",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "errors",
        "type": "frozenset"
      }
    ],
    "variants": {}
  },
  "Checkpoint": {
    "description": "Checkpoint logic for gradient reduction.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "function",
        "type": "Callable"
      },
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Cholesky": {
    "description": "Computes the Cholesky decomposition of a symmetric positive-definite matrix.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "upper",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "CholeskyInverse": {
    "description": "Computes the inverse of a symmetric positive-definite matrix using its Cholesky factor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "upper",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "CholeskySolve": {
    "description": "Solves a linear system of equations with a positive semidefinite matrix to be inverted given its Cholesky factor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input2",
        "type": "Tensor"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "upper",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Choose": {
    "description": "Construct an array from an index array and a list of arrays to choose from.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "choices",
        "type": "List[Tensor]"
      }
    ],
    "variants": {}
  },
  "ChooseQParamsOptimized": {
    "description": "Quantization utility.",
    "std_args": [],
    "variants": {}
  },
  "Chunk": {
    "description": "Splits a tensor into a specific number of chunks.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "chunks",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "CifgLstmCellSimple": {
    "description": "Coupled Input and Forget Gate (CIFG) LSTM Cell.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hidden_size",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "CircleLoss": {
    "description": "Computes Circle Loss between integer labels and L2-normalized embeddings.",
    "op_type": "class",
    "std_args": [
      {
        "default": 80.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "gamma",
        "type": "float"
      },
      {
        "default": 0.4,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "margin",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "CircularPad1d": {
    "description": "Pads the input tensor using circular padding of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "CircularPad2d": {
    "description": "Pads the input tensor using circular padding of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "CircularPad3d": {
    "description": "Pads the input tensor using circular padding of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "Clamp": {
    "description": "Clamps all elements in input into the range [min, max].",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "min",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "max",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "ClampInplace": {
    "description": "Clamps elements in-place.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "min",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "max",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "ClampMax": {
    "description": "Clamps elements with only an upper bound.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "max",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "ClampMaxInplace": {
    "description": "Clamps elements with only an upper bound in-place.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "max",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "ClampMin": {
    "description": "Clamps all elements in input into the range [min, infinity].",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "min",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "ClampMin_": {
    "description": "In-place version of ClampMin.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "min",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "ClassProperty": {
    "description": "Decorator that converts a method into a read-only class property.",
    "op_type": "decorator",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "func",
        "type": "Callable"
      }
    ],
    "variants": {}
  },
  "ClassType": {
    "description": "JIT Class Type.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "ClassificationMLPModel": {
    "description": "Simple MLP model for Classification.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "ClassificationModel": {
    "description": "Classification task for images/video.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "ClearAutocastCache": {
    "description": "Clears the cache used by autocast.",
    "std_args": [],
    "variants": {}
  },
  "ClearCache": {
    "description": "Clear the memory cache.",
    "std_args": [],
    "variants": {}
  },
  "Clip": {
    "description": "Alias for Clamp. Clamps elements to range [min, max].",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "min",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "max",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "ClipByGlobalNormState": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "ClipGradNorm": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "ClipState": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Clip_": {
    "description": "In-place version of Clip.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "min",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "max",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Clone": {
    "description": "Returns a copy of the input tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Code": {
    "description": "JIT Code object.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Col2Im": {
    "description": "The operator rearranges column blocks back into a multidimensional image Col2Im behaves similarly to PyTorch's fold https://pytorch.org/docs/stable/generated/torch.nn.Fold.html, but it only supports *batched* multi-dimensional image tensors. Another implementation in Python with N-dimension support ...",
    "from": "Operators.md",
    "std_args": [
      [
        "input",
        "Tensor"
      ],
      [
        "image_shape",
        "int"
      ],
      [
        "block_shape",
        "int"
      ],
      [
        "dilations",
        "List[int]"
      ],
      [
        "pads",
        "List[int]"
      ],
      [
        "strides",
        "List[int]"
      ]
    ]
  },
  "ColIndicesCopy": {
    "description": "Returns column indices of sparse tensor (copy).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ColumnConcatenation": {
    "description": "Translates slice objects to concatenation along the second axis (np.c_).",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "arrays",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "ColumnStack": {
    "description": "Stack 1-D arrays as columns into a 2-D array.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tensors",
        "type": "List[Tensor]"
      }
    ],
    "variants": {}
  },
  "Combinations": {
    "description": "Compute combinations of length r of the given tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 2,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "r",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "with_replacement",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "CombineMasks": {
    "description": "Combine attention masks using logical AND.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "masks",
        "type": "Array"
      },
      {
        "default": "float32",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Dtype"
      }
    ],
    "variants": {}
  },
  "CommonType": {
    "description": "Return a scalar type which is common to the input arrays.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "arrays",
        "type": "List[Array]"
      }
    ],
    "variants": {}
  },
  "CompilationUnit": {
    "description": "JIT Compilation Unit.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Compile": {
    "description": "Optimizes the given model/function.",
    "op_type": "decorator",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "model",
        "type": "Callable"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "fullgraph",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "CompiledWithCxx11Abi": {
    "description": "Returns whether PyTorch was built with _GLIBCXX_USE_CXX11_ABI=1.",
    "std_args": [],
    "variants": {}
  },
  "CompleteArgumentSpec": {
    "description": "JIT Complete Argument Specification.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Complex": {
    "description": "Constructs a complex tensor from real and imaginary parts.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "real",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "imag",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Complex128": {
    "description": "Complex 128-bit dtype.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Complex32": {
    "description": "Complex 32-bit dtype (half precision complex).",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Complex64": {
    "description": "Complex 64-bit dtype.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "ComplexDouble": {
    "description": "Complex number type composed of two double-precision floating-point numbers.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "ComplexDoubleStorage": {
    "description": "Storage for Complex Double (complex128) data.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "ComplexFloatStorage": {
    "description": "Storage for Complex Float (complex64) data.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "ComplexFloating": {
    "description": "Abstract base class of all complex number scalar types that are made up of floating-point numbers.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "ComplexHalf": {
    "description": "Half-precision complex data type.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "ComplexLongDouble": {
    "description": "Complex number type composed of two extended-precision floating-point numbers.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "ComplexType": {
    "description": "JIT Complex Type.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "ComplexWarning": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Compress": {
    "description": "Return selected slices of an array along given axis.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "condition",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ComputeAttentionMasksForExtendStep": {
    "description": "Computes attention mask from paddings, segment masks etc for extend_step.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "time_step",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "seq_len",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ComputeAttentionMasksForFprop": {
    "description": "Computes attention mask from paddings, segment masks etc for fprop.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "inputs",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "paddings",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ComputeCv": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "ComputeMoments": {
    "description": "Computes mean and variance over the valid data points in inputs.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "inputs",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "reduce_over_dims",
        "type": "List[int]"
      }
    ],
    "variants": {}
  },
  "Concat": {
    "description": "Alias of Cat. Concatenates tensors along a dimension.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tensors",
        "type": "List[Tensor]"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ConcatFromSequence": {
    "description": "Concatenate a sequence of tensors into a single tensor. All input tensors must have the same shape, except for the dimension size of the axis to concatenate on. By default 'new_axis' is 0, the behavior is similar to numpy.concatenate. When 'new_axis' is 1, the behavior is similar to numpy.stack.",
    "from": "Operators.md",
    "std_args": [
      [
        "input_sequence",
        "Any"
      ],
      [
        "axis",
        "int"
      ],
      [
        "new_axis",
        "int"
      ]
    ]
  },
  "Concatenate": {
    "description": "Alias of Cat. Concatenates tensors along a dimension.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tensors",
        "type": "List[Tensor]"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ConcatenateLayer": {
    "description": "Concatenates a list of inputs.",
    "op_type": "class",
    "std_args": [
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ConcreteModuleType": {
    "description": "Internal PyTorch type representing a concrete module type for JIT.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "ConcreteModuleTypeBuilder": {
    "description": "Builder class for ConcreteModuleType.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Cond": {
    "description": "Conditional execution (structured control flow).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "pred",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "true_fn",
        "type": "Callable"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "false_fn",
        "type": "Callable"
      },
      {
        "default": [],
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "operands",
        "type": "List[Any]"
      }
    ],
    "variants": {}
  },
  "ConditionallyMaskState": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "ConditionallyTransformState": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Conformer": {
    "description": "Conformer layer (CNN + Transformer).",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "model_dims",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ConfusionMatrix": {
    "description": "Computes the confusion matrix from predictions and labels.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "labels",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "predictions",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_classes",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Conj": {
    "description": "Returns a view of input with a flipped conjugate bit.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ConjPhysical": {
    "description": "Computes the element-wise conjugate of the given input tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ConjPhysical_": {
    "description": "In-place version of ConjPhysical.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Conjugate": {
    "description": "Return the complex conjugate, element-wise.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Constant": {
    "description": "This operator produces a constant tensor. Exactly one of the provided attributes, either value, sparse_value, or value_* must be specified.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "sparse_value",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value_float",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value_floats",
        "type": "List[float]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value_int",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value_ints",
        "type": "List[int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value_string",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value_strings",
        "type": "List[str]"
      }
    ],
    "variants": {}
  },
  "ConstantOfShape": {
    "description": "Generate a tensor with given value and shape.",
    "from": "Operators.md",
    "std_args": [
      [
        "input",
        "Any"
      ],
      [
        "value",
        "Tensor"
      ]
    ]
  },
  "ConstantPad1d": {
    "description": "Pads the input tensor boundaries with a constant value.",
    "std_args": [
      "self",
      "padding",
      "value"
    ],
    "type": "class"
  },
  "ConstantPad2d": {
    "description": "Pads the input tensor boundaries with a constant value.",
    "std_args": [
      "self",
      "padding",
      "value"
    ],
    "type": "class"
  },
  "ConstantPad3d": {
    "description": "Pads the input tensor boundaries with a constant value.",
    "std_args": [
      "self",
      "padding",
      "value"
    ],
    "type": "class"
  },
  "ConstantPadNd": {
    "description": "Pads a tensor with a constant value.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "pad",
        "type": "List[int]"
      },
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "ConstructFloat16": {
    "description": "Constructor/Cast for Float16.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "ConstructFloat32": {
    "description": "Constructor/Cast for Float32.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "ConstructFloat64": {
    "description": "Constructor/Cast for Float64.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Container": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "kwargs"
    ],
    "type": "class"
  },
  "Contiguous": {
    "description": "Force an array to be row contiguous.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ContiguousFormat": {
    "description": "Memory format constant.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "ControlDependency": {
    "description": "Insert dependencies between arrays in the graph.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "inputs",
        "type": "Union[Tensor, Sequence[Tensor]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dependencies",
        "type": "Union[Tensor, Sequence[Tensor]]"
      }
    ],
    "variants": {}
  },
  "ControlVariate": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Conv": {
    "description": "Convolutional layer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "in_features",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "out_features",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "Union[int, Tuple[int]]"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "strides",
        "type": "Union[int, Tuple[int]]"
      },
      {
        "default": "SAME",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "Union[str, int, Tuple[int]]"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "use_bias",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Conv1D": {
    "description": "1D convolution layer (e.g. temporal convolution).",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "filters",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "Union[int, Tuple[int]]"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "strides",
        "type": "int"
      },
      {
        "default": "valid",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "str"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dilation_rate",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "groups",
        "type": "int"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "use_bias",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Conv1DTranspose": {
    "description": "1D transposed convolution layer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "filters",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "Union[int, Tuple[int]]"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "strides",
        "type": "int"
      },
      {
        "default": "valid",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "str"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dilation_rate",
        "type": "int"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "use_bias",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Conv1d": {
    "description": "Applies a 1D convolution over an input signal.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "rank": 3,
        "shape_spec": "[B, C_in, L]",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "rank": 3,
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "Tensor"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dilation",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "groups",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Conv2D": {
    "description": "2D convolution layer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "filters",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "Union[int, Tuple[int, int]]"
      },
      {
        "default": [
          1,
          1
        ],
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "strides",
        "type": "Union[int, Tuple[int, int]]"
      },
      {
        "default": "valid",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "str"
      },
      {
        "default": [
          1,
          1
        ],
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dilation_rate",
        "type": "Union[int, Tuple[int, int]]"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "groups",
        "type": "int"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "use_bias",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Conv2DTranspose": {
    "description": "2D transposed convolution layer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "filters",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "Union[int, Tuple[int, int]]"
      },
      {
        "default": [
          1,
          1
        ],
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "strides",
        "type": "Union[int, Tuple[int, int]]"
      },
      {
        "default": "valid",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "str"
      },
      {
        "default": [
          1,
          1
        ],
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dilation_rate",
        "type": "Union[int, Tuple[int, int]]"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "use_bias",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Conv2d": {
    "description": "Applies a 2D convolution.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "rank": 4,
        "shape_spec": "[B, C_in, H, W]",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "rank": 4,
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "Tensor"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dilation",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "groups",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Conv3DTranspose": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Conv3d": {
    "description": "Applies a 3D convolution.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "rank": 5,
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "Tensor"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dilation",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "groups",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ConvBNAct": {
    "description": "Fused Block: Convolution -> BatcNorm -> Activation.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "ConvBNActWithPadding": {
    "description": "Fused Block with Padding support.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "ConvInteger": {
    "description": "The integer convolution operator consumes an input tensor, its zero-point, a filter, and its zero-point, and computes the output. The production MUST never overflow. The accumulation may overflow if and only if in 32 bits.",
    "from": "Operators.md",
    "std_args": [
      [
        "x",
        "Any"
      ],
      [
        "w",
        "Any"
      ],
      [
        "x_zero_point",
        "Any"
      ],
      [
        "w_zero_point",
        "Any"
      ],
      [
        "auto_pad",
        "str"
      ],
      [
        "dilations",
        "List[int]"
      ],
      [
        "group",
        "int"
      ],
      [
        "kernel_shape",
        "List[int]"
      ],
      [
        "pads",
        "List[int]"
      ],
      [
        "strides",
        "List[int]"
      ]
    ]
  },
  "ConvLSTM1D": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "ConvLSTM1d": {
    "description": "1D Convolutional LSTM.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hidden_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "int | Tuple[int]"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "ConvLSTM2D": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "ConvLSTM2d": {
    "description": "2D Convolutional LSTM.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hidden_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "int | Tuple[int, int]"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "ConvLSTM3D": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "ConvLSTM3d": {
    "description": "3D Convolutional LSTM.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hidden_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "int | Tuple[int, int, int]"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "ConvT": {
    "description": "Auto-generated from flax_nnx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "ConvTbc": {
    "description": "Applies a 1D convolution over input (Time, Batch, Channels).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "shape_spec": "[T, B, C]",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "pad",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ConvTranspose": {
    "description": "Transposed Convolutional layer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "in_features",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "out_features",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "Union[int, Tuple[int]]"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "strides",
        "type": "Union[int, Tuple[int]]"
      },
      {
        "default": "SAME",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "Union[str, int, Tuple[int]]"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "use_bias",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "ConvTranspose1d": {
    "description": "Applies a 1D transposed convolution operator.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "Tensor"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "output_padding",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "groups",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dilation",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ConvTranspose2d": {
    "description": "Applies a 2D transposed convolution operator.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "Tensor"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "output_padding",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "groups",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dilation",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ConvTranspose3d": {
    "description": "Applies a 3D transposed convolution operator over an input image.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "rank": 5,
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "rank": 5,
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "Tensor"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "Union[int, Tuple[int, int, int]]"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "Union[int, Tuple[int, int, int]]"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "output_padding",
        "type": "Union[int, Tuple[int, int, int]]"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "groups",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dilation",
        "type": "Union[int, Tuple[int, int, int]]"
      }
    ],
    "variants": {}
  },
  "ConvertPaddingsToMask": {
    "description": "Converts binary paddings to a logit mask ready to add to attention matrix.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "paddings",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Convolution": {
    "description": "Generic convolution operator.",
    "std_args": [
      "input",
      "weight",
      "bias",
      "stride",
      "padding",
      "dilation",
      "groups"
    ],
    "variants": {}
  },
  "Convolution1D": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Convolution1DTranspose": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Convolution2D": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Convolution2DTranspose": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Convolution3D": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Convolution3DTranspose": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Convolution3d": {
    "description": "3D convolution layer (Verbose Alias).",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "in_channels",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "out_channels",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "int | Tuple[int, int, int]"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "int | Tuple[int, int, int]"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Convolution3dTranspose": {
    "description": "3D transposed convolution layer (Verbose Alias).",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "in_channels",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "out_channels",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "int | Tuple[int, int, int]"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "int | Tuple[int, int, int]"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Convolve": {
    "description": "Returns the discrete, linear convolution of two one-dimensional sequences.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "rank": 1,
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "v",
        "rank": 1,
        "type": "Array"
      },
      {
        "default": "full",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mode",
        "options": [
          "full",
          "valid",
          "same"
        ],
        "type": "str"
      }
    ],
    "variants": {}
  },
  "Copy": {
    "description": "Return an array copy of the given object.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "CopyTo": {
    "description": "Copies values from one array to another, broadcasting as necessary.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dst",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "src",
        "type": "Array"
      },
      {
        "default": "same_kind",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "casting",
        "type": "str"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "where",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "Copysign": {
    "description": "Create a new floating-point tensor with the magnitude of input and the sign of other.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Corrcoef": {
    "description": "Estimates the Pearson product-moment correlation coefficient matrix.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Correlate": {
    "description": "Cross-correlation of two 1-dimensional sequences.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "v",
        "type": "Array"
      },
      {
        "default": "valid",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mode",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "Cos": {
    "description": "Returns a new tensor with the cosine of the elements of input.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Cos_": {
    "description": "In-place cosine operation.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Cosh": {
    "description": "Returns a new tensor with the hyperbolic cosine of the elements.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Cosh_": {
    "description": "In-place hyperbolic cosine.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "CosineAnnealingLR": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "CosineEmbeddingLoss": {
    "description": "Creates a criterion that measures the loss given input tensors x1, x2 and a Tensor label y.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input1",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input2",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "target",
        "type": "Tensor"
      },
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "margin",
        "type": "float"
      },
      {
        "default": "mean",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "reduction",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "CosineSimilarity": {
    "description": "Returns cosine similarity between x1 and x2, computed along dim.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x1",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x2",
        "type": "Tensor"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "default": "1e-8",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "eps",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "CosineSimilarityLoss": {
    "description": "Computes the cosine similarity between labels and predictions. Note: Keras defaults to negative similarity (loss).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_true",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_pred",
        "type": "Tensor"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Cosinesimilarity": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "CountNonzero": {
    "description": "Counts the number of non-zero values in the tensor input along the given dim.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "Union[int, Tuple[int]]"
      }
    ],
    "variants": {}
  },
  "Cov": {
    "description": "Estimates the covariance matrix of the variables given by the input matrix.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "correction",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Cropping1D": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Cropping1d": {
    "description": "Cropping layer for 1D input.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "cropping",
        "type": "int | Tuple[int, int]"
      }
    ],
    "variants": {}
  },
  "Cropping2D": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Cropping2d": {
    "description": "Cropping layer for 2D input.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "cropping",
        "type": "int | Tuple[int, int] | Tuple[Tuple[int, int], Tuple[int, int]]"
      }
    ],
    "variants": {}
  },
  "Cropping3D": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Cropping3d": {
    "description": "Cropping layer for 3D data.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "cropping",
        "type": "int | Tuple[int, int, int] | Tuple[Tuple[int, int], ...]"
      }
    ],
    "variants": {}
  },
  "Cross": {
    "description": "Returns the cross product of vectors in dimension dim of input and other.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "CrossEntropyLoss": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "CrossMapLRN2d": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "size",
      "alpha",
      "beta",
      "k"
    ],
    "type": "class"
  },
  "CrowIndicesCopy": {
    "description": "Copies the crow indices of a sparse tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Csingle": {
    "description": "Complex number type composed of two single-precision floating-point numbers.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "CtcLoss": {
    "description": "Connectionist Temporal Classification loss.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "log_probs",
        "type": "Any"
      },
      "targets",
      "input_lengths",
      "target_lengths"
    ],
    "variants": {}
  },
  "CubeRoot": {
    "description": "Return the cube-root of an array, element-wise.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "CubedReLU": {
    "description": "Activation: max(0, x)^3.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "CudaAvailable": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "CudnnAffineGridGenerator": {
    "description": "CuDNN Affine Grid Generator.",
    "std_args": [
      "theta",
      "N",
      "C",
      "H",
      "W"
    ],
    "variants": {}
  },
  "CudnnBatchNorm": {
    "description": "CuDNN Batch Normalization.",
    "std_args": [
      "input",
      "weight",
      "bias",
      "running_mean",
      "running_var"
    ],
    "variants": {}
  },
  "CudnnConvolution": {
    "description": "CuDNN Convolution.",
    "std_args": [
      "input",
      "weight"
    ],
    "variants": {}
  },
  "CudnnConvolutionAddRelu": {
    "description": "CuDNN Fused Convolution Add ReLU.",
    "std_args": [
      "input",
      "weight",
      "z",
      "bias"
    ],
    "variants": {}
  },
  "CudnnConvolutionRelu": {
    "description": "CuDNN Fused Convolution ReLU.",
    "std_args": [
      "input",
      "weight",
      "bias"
    ],
    "variants": {}
  },
  "CudnnConvolutionTranspose": {
    "description": "CuDNN Transposed Convolution.",
    "std_args": [
      "input",
      "weight"
    ],
    "variants": {}
  },
  "CudnnGridSampler": {
    "description": "CuDNN Grid Sampler.",
    "std_args": [
      "input",
      "grid"
    ],
    "variants": {}
  },
  "CudnnIsAcceptable": {
    "description": "Check if tensor is acceptable for CuDNN.",
    "std_args": [
      "tensor"
    ],
    "variants": {}
  },
  "CumSum": {
    "description": "Performs cumulative sum of the input elements along the given axis. By default, it will do the sum inclusively meaning the first element is copied as is. Through an `exclusive` attribute, this behavior can change to exclude the first element. It can also perform summation in the opposite direction o...",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "exclusive",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "reverse",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Cummax": {
    "description": "Returns a tuple (values, indices) where values is the cumulative maximum.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Cummin": {
    "description": "Returns a tuple (values, indices) where values is the cumulative minimum.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Cumprod": {
    "description": "Returns the cumulative product.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Dtype"
      }
    ],
    "variants": {}
  },
  "Cumsum": {
    "description": "Returns the cumulative sum.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Dtype"
      }
    ],
    "variants": {}
  },
  "CumulativeProd": {
    "description": "Array API compatible alternative for cumprod.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "include_initial",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "CumulativeSum": {
    "description": "Array API compatible alternative for cumsum.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "include_initial",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "CumulativeTrapezoid": {
    "description": "Cumulatively computes the trapezoidal rule.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dx",
        "type": "float"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "CurrentUpdateContext": {
    "description": "Returns the current active UpdateContext for the given tag.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tag",
        "type": "Hashable"
      }
    ],
    "variants": {}
  },
  "CustomAutograd": {
    "description": "Decorator for custom gradient definitions.",
    "op_type": "decorator",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "fn",
        "type": "Callable"
      }
    ],
    "variants": {}
  },
  "CustomFromMask": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "mask"
    ],
    "type": "class"
  },
  "CustomVjp": {
    "description": "Define custom Vision-Jacobian Product (backward pass) for valid differentiation.",
    "op_type": "decorator",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "fun",
        "type": "Callable"
      },
      {
        "default": "()",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "nondiff_argnums",
        "type": "tuple"
      }
    ],
    "variants": {}
  },
  "CutMix": {
    "description": "CutMix data augmentation.",
    "op_type": "class",
    "std_args": [
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "factor",
        "type": "float | Tuple[float, float]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "seed",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "CvExpectedValue": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "CvState": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "DFT": {
    "description": "Computes the discrete Fourier Transform (DFT) of the input. Assuming the input has shape `[M, N]`, where `N` is the dimension over which the DFT is computed and `M` denotes the conceptual \"all other dimensions,\" the DFT `y[m, k]` of shape `[M, N]` is defined as $$y[m, k] = \\sum_{n=0}^{N-1} e^{-2 \\pi...",
    "from": "Operators.md",
    "std_args": [
      [
        "input",
        "Any"
      ],
      [
        "dft_length",
        "Any"
      ],
      [
        "axis",
        "int"
      ],
      [
        "inverse",
        "int"
      ],
      [
        "onesided",
        "int"
      ]
    ]
  },
  "DSplit": {
    "description": "Split array into multiple sub-arrays along the 3rd axis (depth).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ary",
        "rank": 3,
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "indices_or_sections",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "DStack": {
    "description": "Stack arrays in sequence depth wise (along third axis).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tup",
        "type": "List[Tensor]"
      }
    ],
    "variants": {}
  },
  "Data": {
    "description": "Annotates an attribute as pytree data.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "DataLoader": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "DataParallel": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Dataclass": {
    "description": "Decorator to create a dataclass that is automatically registered as a PyTree node.",
    "op_type": "decorator",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "cls",
        "type": "Type"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "init",
        "type": "bool"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "repr",
        "type": "bool"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "eq",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "frozen",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Datetime64": {
    "description": "NumPy datetime type.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Any"
      },
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "DatetimeAsString": {
    "description": "Convert an array of datetimes into an array of strings.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "arr",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "unit",
        "type": "str"
      },
      {
        "default": "naive",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "timezone",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "DatetimeData": {
    "description": "Get information about the step size of a date or time type.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "DeepCopyMemoTable": {
    "description": "Internal helper for deepcopy operations in PyTorch.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "DefaultGenerator": {
    "description": "Returns the default random number generator.",
    "std_args": [],
    "variants": {}
  },
  "DeformConv": {
    "description": "Performs deformable convolution as described in https://arxiv.org/abs/1703.06211 and https://arxiv.org/abs/1811.11168. This operator specification supports the general N-D case. Note that most common use cases have 2D or 3D data.",
    "from": "Operators.md",
    "std_args": [
      [
        "X",
        "Tensor"
      ],
      [
        "W",
        "Tensor"
      ],
      [
        "offset",
        "Tensor"
      ],
      [
        "B",
        "Tensor"
      ],
      [
        "mask",
        "Tensor"
      ],
      [
        "dilations",
        "List[int]"
      ],
      [
        "group",
        "int"
      ],
      [
        "kernel_shape",
        "List[int]"
      ],
      [
        "offset_group",
        "int"
      ],
      [
        "pads",
        "List[int]"
      ],
      [
        "strides",
        "List[int]"
      ]
    ]
  },
  "Deg2Rad": {
    "description": "Convert angles from degrees to radians.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Deg2Rad_": {
    "description": "Converts angles from degrees to radians in-place.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Deg2rad": {
    "description": "Returns a new tensor with each of the elements of input converted from angles in degrees to radians.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Degrees": {
    "description": "Convert angles from radians to degrees.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "out",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "Delete": {
    "description": "Return a new array with sub-arrays along an axis deleted.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "arr",
        "type": "Tensor"
      },
      {
        "doc": "Indicate indices of sub-arrays to remove.",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "obj",
        "type": "Union[int, slice, Tensor]"
      },
      {
        "default": "None",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Dense": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "DepthToSpace": {
    "description": "DepthToSpace rearranges (permutes) data from depth into blocks of spatial data. This is the reverse transformation of SpaceToDepth. More specifically, this op outputs a copy of the input tensor where values from the depth dimension are moved in spatial blocks to the height and width dimensions. By d...",
    "from": "Operators.md",
    "std_args": [
      [
        "input",
        "Tensor"
      ],
      [
        "blocksize",
        "int"
      ],
      [
        "mode",
        "str"
      ]
    ]
  },
  "DepthwiseConv1D": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "DepthwiseConv1d": {
    "description": "1D Depthwise Convolution.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "DepthwiseConv2D": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "DepthwiseConv2d": {
    "description": "2D depthwise convolution layer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "int | Tuple[int, int]"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "int | Tuple[int, int]"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "depth_multiplier",
        "type": "int"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Dequantize": {
    "description": "Returns an fp32 Tensor by dequantizing a quantized Tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tensor",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "DequantizeLinear": {
    "description": "The linear dequantization operator. It consumes a quantized tensor, a scale, and a zero point to compute the full-precision tensor. The dequantization formula is `y = (x - x_zero_point) * x_scale`. `x_scale` and `x_zero_point` must have the same shape, determining the quantization's granularity: a s...",
    "from": "Operators.md",
    "std_args": [
      [
        "x",
        "Any"
      ],
      [
        "x_scale",
        "Any"
      ],
      [
        "x_zero_point",
        "Any"
      ],
      [
        "axis",
        "int"
      ],
      [
        "block_size",
        "int"
      ],
      [
        "output_dtype",
        "int"
      ]
    ]
  },
  "DeserializationStorageContext": {
    "description": "Context manager/helper for deserialization storage resolution.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "DeserializeLayer": {
    "description": "Returns a Keras layer object via its configuration.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "config",
        "type": "dict"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "custom_objects",
        "type": "dict"
      }
    ],
    "variants": {}
  },
  "DeserializeLoss": {
    "description": "Deserializes a serialized loss class/function instance.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "name",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "custom_objects",
        "type": "dict"
      }
    ],
    "variants": {}
  },
  "DeserializeOptimizer": {
    "description": "Returns a Keras optimizer object via its configuration.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "config",
        "type": "Dict"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "custom_objects",
        "type": "Dict"
      }
    ],
    "variants": {}
  },
  "Det": {
    "description": "Computes the determinant of a square matrix or batch of matrices.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "rank": 2,
        "shape_spec": "[..., N, N]",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Detach": {
    "description": "Returns a new Tensor, detached from the current graph. The result will never require gradient.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "DetachCopy": {
    "description": "Returns a new Tensor, detached from the current graph and copied.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Detach_": {
    "description": "Detaches the Tensor from the graph in-place.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Device": {
    "description": "Constructs a device object.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "type",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "index",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "DeviceCpu": {
    "description": "Returns the CPU device object.",
    "std_args": [],
    "variants": {}
  },
  "DeviceObjType": {
    "description": "Internal type definition for Device objects.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "DeviceType": {
    "description": "Enumeration of device types.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "values",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Diag": {
    "description": "If input is a vector, returns a diagonal matrix. If input is a matrix, returns the diagonal.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "diagonal",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "DiagEmbed": {
    "description": "Creates a tensor whose diagonals of certain 2D planes are filled by input.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "offset",
        "type": "int"
      },
      {
        "default": -2,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim1",
        "type": "int"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim2",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "DiagIndices": {
    "description": "Return the indices to access the main diagonal of an array.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "n",
        "type": "int"
      },
      {
        "default": 2,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ndim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "DiagIndicesFrom": {
    "description": "Return the indices to access the main diagonal of an n-dimensional array.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "arr",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Diagflat": {
    "description": "Creates a diagonal matrix with the flattened input as the diagonal.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "offset",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Diagonal": {
    "description": "Returns a partial view of input with the diagonal elements appended.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "offset",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim1",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim2",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "DiagonalCopy": {
    "description": "Returns a fresh copy of the diagonal view.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "offset",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim1",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim2",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "DiagonalScatter": {
    "description": "Embeds vales into the diagonal.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "src",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "offset",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim1",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim2",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "DiceLoss": {
    "description": "Computes the Dice loss value between y_true and y_pred.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_true",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_pred",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "DictType": {
    "description": "Type representation for Dictionaries in TorchScript.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Diff": {
    "description": "Computes the n-th discrete difference along the given dimension.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "n",
        "type": "int"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "prepend",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "append",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "DiffState": {
    "description": "Differential State wrapper.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Digamma": {
    "description": "Computes the logarithmic derivative of the gamma function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Digitize": {
    "description": "Return the indices of the bins to which each value in input array belongs.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bins",
        "type": "Tensor"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "right",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "DisableCompile": {
    "description": "Globally disable compilation.",
    "std_args": [],
    "variants": {}
  },
  "DisableTorchFunction": {
    "description": "Context manager that disables __torch_function__ handling.",
    "op_type": "context",
    "std_args": [],
    "variants": {}
  },
  "DisableTorchFunctionSubclass": {
    "description": "Context manager that disables __torch_function__ for subclasses.",
    "op_type": "context",
    "std_args": [],
    "variants": {}
  },
  "Discretization": {
    "description": "Buckets continuous features by ranges.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bin_boundaries",
        "type": "List[float]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_bins",
        "type": "int"
      },
      {
        "default": 0.01,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "epsilon",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "DispatchKey": {
    "description": "Enumeration of Dispatch Keys for the PyTorch dispatcher.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "DispatchKeySet": {
    "description": "Container for a set of DispatchKeys.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Display": {
    "description": "Display objects using Treescope pretty-printer.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Dist": {
    "description": "Returns the p-norm of (input - other).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      },
      {
        "default": 2.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "p",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "DistributedDataParallel": {
    "description": "Implement distributed data parallelism based on ``torch.distributed`` at module level.",
    "std_args": [
      "self",
      "module",
      "device_ids",
      "output_device",
      "dim",
      "broadcast_buffers",
      "init_sync",
      "process_group",
      "bucket_cap_mb",
      "find_unused_parameters",
      "check_reduction",
      "gradient_as_bucket_view",
      "static_graph",
      "delay_all_reduce_named_params",
      "param_to_hook_all_reduce",
      "mixed_precision",
      "device_mesh",
      "skip_all_reduce_unused_params"
    ],
    "type": "class"
  },
  "DistributedDataParallelCPU": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "module",
      "device_ids",
      "output_device",
      "dim",
      "broadcast_buffers",
      "init_sync",
      "process_group",
      "bucket_cap_mb",
      "find_unused_parameters",
      "check_reduction",
      "gradient_as_bucket_view",
      "static_graph",
      "delay_all_reduce_named_params",
      "param_to_hook_all_reduce",
      "mixed_precision",
      "device_mesh",
      "skip_all_reduce_unused_params"
    ],
    "type": "class"
  },
  "DistributedSum": {
    "description": "Enum value for Sum reduction in distributed operations.",
    "std_args": [],
    "variants": {}
  },
  "Div": {
    "description": "Divides input by other element-wise.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "rounding_mode",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "DivMod": {
    "description": "Return element-wise quotient and remainder simultaneously.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x1",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x2",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Divide": {
    "description": "Alias for Div.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "rounding_mode",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "DivideNoNan": {
    "description": "Computes a safe divide which returns 0 if `y` (denominator) is zero.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Divmod": {
    "description": "Return element-wise quotient and remainder simultaneously.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x1",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x2",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Dot": {
    "description": "Computes the dot product of two 1D tensors.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "rank": 1,
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tensor",
        "rank": 1,
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "DotList": {
    "description": "Functional interface to the Dot layer.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "inputs",
        "type": "List[Tensor]"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axes",
        "type": "Union[int, Tuple[int, int]]"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "normalize",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "DotProductAttention": {
    "description": "Computes dot-product attention given query, key, and value.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "query",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "key",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mask",
        "type": "Any"
      },
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dropout_rate",
        "type": "float"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "is_causal",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "DotProductAttentionWithContext": {
    "description": "Attention with local/global context constraints.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "left_context",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "right_context",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "DotProductAttentionWithContextXL": {
    "description": "Transformer-XL style attention with context.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "rel_pos_emb_dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "DotProductAttentionXL": {
    "description": "Transformer-XL attention.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Double": {
    "description": "Casts tensor to float64.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "DoubleStorage": {
    "description": "Storage class for float64 data.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "DoubleTensor": {
    "description": "Legacy constructor for float64 tensors.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Dropout": {
    "description": "Applies random dropout.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 0.5,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "p",
        "type": "float"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "training",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "inplace",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Dropout1d": {
    "description": "Randomly zero out entire channels.",
    "std_args": [
      "self",
      "p",
      "inplace"
    ],
    "type": "class"
  },
  "Dropout2d": {
    "description": "Applies 2D Dropout (channel-wise) to the input.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.5,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "p",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Dropout3d": {
    "description": "Applies 3D Dropout (channel-wise) to the input.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.5,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "p",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Dropout_": {
    "description": "In-place dropout.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 0.5,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "p",
        "type": "float"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "training",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Dsmm": {
    "description": "Performs a matrix multiplication of the sparse matrix input and the dense matrix mat2.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mat2",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Dsplit": {
    "description": "Splits tensor depthwise.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "indices_or_sections",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Dstack": {
    "description": "Stacks tensors in sequence depthwise.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tensors",
        "type": "List[Tensor]"
      }
    ],
    "variants": {}
  },
  "Dtype": {
    "description": "Data Type class.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "DtypeCategory": {
    "description": "Category of data types.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "values",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "DtypeLikeInexact": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "DtypeObject": {
    "description": "Object dtype indicator.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "DynamicQuantizeLinear": {
    "description": "A Function to fuse calculation for Scale, Zero Point and FP32->8Bit conversion of FP32 Input data. Outputs Scale, ZeroPoint and Quantized Input for a given FP32 Input. Scale is calculated as: ``` y_scale = (maximum(0, max(x)) - minimum(0, min(x))) / (qmax - qmin) ``` * where qmax and qmin are max an...",
    "from": "Operators.md",
    "std_args": [
      [
        "x",
        "Any"
      ]
    ]
  },
  "E": {
    "description": "Eulers number.",
    "std_args": [],
    "variants": {}
  },
  "ELU": {
    "description": "Exponential Linear Unit activation.",
    "op_type": "class",
    "std_args": [
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "alpha",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Ediff1d": {
    "description": "The differences between consecutive elements of an array.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ary",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "to_end",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "to_begin",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Eig": {
    "description": "Computes the eigenvalues and eigenvectors of a real square matrix.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "eigenvectors",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Einsum": {
    "description": "Einstein summation.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "equation",
        "type": "str"
      },
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "operands",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "EinsumDense": {
    "description": "Layer that uses einsum.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "equation",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "output_shape",
        "type": "int | Tuple[int, ...]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias_axes",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "EinsumLayer": {
    "description": "Layer that computes an einsum and optional bias.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "equation",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "EinsumOp": {
    "description": "Functional einsum operation wrapper.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "EinsumPath": {
    "description": "Evaluates the lowest cost contraction order for an einsum expression.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "subscripts",
        "type": "str"
      },
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "operands",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Elu": {
    "description": "Applies the Exponential Linear Unit.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "alpha",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "EmaState": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Embed": {
    "description": "Embedding Module.",
    "std_args": [
      "self",
      "num_embeddings",
      "features",
      "dtype",
      "param_dtype",
      "embedding_init",
      "promote_dtype",
      "rngs",
      "embedding_metadata"
    ],
    "type": "class"
  },
  "Embedding": {
    "description": "Functional embedding lookup.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "EmbeddingBag": {
    "description": "Computes sums or means of bags of embeddings, without instantiating the intermediate embeddings.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "offsets",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "max_norm",
        "type": "float"
      },
      {
        "default": 2.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "norm_type",
        "type": "float"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "scale_grad_by_freq",
        "type": "bool"
      },
      {
        "default": "mean",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mode",
        "type": "str"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "sparse",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "per_sample_weights",
        "type": "Tensor"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "include_last_offset",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding_idx",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "EmbeddingRenorm_": {
    "description": "Updates embedding weights in-place to enforce max norm.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "max_norm",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "norm_type",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Empty": {
    "description": "Returns a tensor filled with uninitialized data.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "List[int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Dtype"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "device",
        "type": "Device"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "requires_grad",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "EmptyLike": {
    "description": "Returns an uninitialized tensor with the same size as input.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Dtype"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "device",
        "type": "Device"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "requires_grad",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "EmptyPermuted": {
    "description": "Creates an uninitialized tensor with a specified physical layout.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "List[int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "physical_layout",
        "type": "List[int]"
      }
    ],
    "variants": {}
  },
  "EmptyQuantized": {
    "description": "Creates an uninitialized quantized tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "List[int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "qtensor",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "EmptyStrided": {
    "description": "Creates an uninitialized tensor with specified size and strides.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "List[int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "List[int]"
      }
    ],
    "variants": {}
  },
  "EnableCompile": {
    "description": "Globally enable compilation.",
    "std_args": [],
    "variants": {}
  },
  "EnableGrad": {
    "description": "Context-manager that enables gradient calculation.",
    "op_type": "context",
    "std_args": [],
    "variants": {}
  },
  "EnumType": {
    "description": "Internal type definition for Enums in TorchScript.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Equal": {
    "description": "Returns the truth value of (x == y) element-wise.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "EqualAggregate": {
    "description": "True if two tensors have the same size and elements, False otherwise.",
    "return_type": "bool",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "EqualElementwise": {
    "description": "Computes element-wise equality.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Equalization": {
    "description": "Histogram equalization.",
    "op_type": "class",
    "std_args": [
      {
        "default": [
          0,
          255
        ],
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value_range",
        "type": "Tuple[float, float]"
      },
      {
        "default": 256,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bins",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Erf": {
    "description": "Computes the error function of each element.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ErfInv": {
    "description": "Compute inverse error function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Erf_": {
    "description": "In-place Erf.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Erfc": {
    "description": "Computes the complementary error function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ErfcInv": {
    "description": "Computes the inverse of complementary error function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Erfc_": {
    "description": "In-place Erfc.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Erfinv": {
    "description": "Computes the inverse error function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ErrorReport": {
    "description": "Internal wrapper for error reporting.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Errstate": {
    "description": "Context manager for floating-point error handling.",
    "op_type": "context",
    "std_args": [],
    "variants": {}
  },
  "EuclideanNorm": {
    "description": "Computes the Euclidean norm of elements across dimensions.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "EulerGamma": {
    "description": "Euler-Mascheroni constant.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Eval": {
    "description": "Evaluates arrays or trees of arrays, forcing materialization.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "EvalMode": {
    "description": "Creates a new node/module set to evaluation mode (deterministic=True).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "node",
        "type": "Module"
      }
    ],
    "variants": {}
  },
  "EvalShape": {
    "description": "Computes the shape/dtype of a function without performing actual computation.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "f",
        "type": "Callable"
      },
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Event": {
    "description": "CUDA event wrapper for synchronization and timing.",
    "op_type": "class",
    "std_args": [
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "enable_timing",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "blocking",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "interprocess",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "ExcludeDispatchKeyGuard": {
    "description": "Guard disabling specific dispatch keys.",
    "op_type": "context",
    "std_args": [],
    "variants": {}
  },
  "ExecutionPlan": {
    "description": "Internal representation of an execution plan.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Exp": {
    "description": "Computes the exponential of each element.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Exp2": {
    "description": "Computes the base-2 exponential of each element.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Exp2_": {
    "description": "In-place Exp2.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Exp_": {
    "description": "In-place Exp.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Expand": {
    "description": "Broadcast the input tensor following the given shape and the broadcast rule. The broadcast rule is similar to numpy.array(input) * numpy.ones(shape): Dimensions are right alignment; Two corresponding dimensions must have the same value, or one of them is equal to 1. Also, this operator is similar to...",
    "from": "Operators.md",
    "std_args": [
      [
        "input",
        "Tensor"
      ],
      [
        "shape",
        "int"
      ]
    ]
  },
  "ExpandCopy": {
    "description": "Expands the tensor to size.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "List[int]"
      }
    ],
    "variants": {}
  },
  "ExpandDims": {
    "description": "Expand the shape of an array.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ExperimentalEnableNumpyBehavior": {
    "description": "Enables NumPy behavior on Tensors (TensorFlow specific).",
    "std_args": [],
    "variants": {}
  },
  "Expm1": {
    "description": "Computes exp(x) - 1.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Expm1_": {
    "description": "In-place Expm1.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ExportFunction": {
    "description": "Export an MLX function (MLX Specific).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "file",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "fun",
        "type": "Callable"
      },
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "ExportToDot": {
    "description": "Export a graph to DOT format for visualization.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "file",
        "type": "str"
      },
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Exporter": {
    "description": "Context manager to export execution traces.",
    "op_type": "context",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "file",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "fun",
        "type": "Callable"
      }
    ],
    "variants": {}
  },
  "Extract": {
    "description": "Return the elements of an array that satisfy some condition.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "condition",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "arr",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Eye": {
    "description": "Returns a 2-D tensor with ones on the diagonal.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "n",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "m",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Dtype"
      }
    ],
    "variants": {}
  },
  "EyeLike": {
    "description": "Generate a 2D tensor (matrix) with ones on the diagonal and zeros everywhere else. Only 2D tensors are supported, i.e. input T1 must be of rank 2. The shape of the output tensor is the same as the input tensor. The data type can be specified by the 'dtype' argument. If 'dtype' is not specified, then...",
    "from": "Operators.md",
    "std_args": [
      [
        "input",
        "Any"
      ],
      [
        "dtype",
        "int"
      ],
      [
        "k",
        "int"
      ]
    ]
  },
  "FInfo": {
    "description": "Get information on floating-point types.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Dtype"
      }
    ],
    "variants": {}
  },
  "FORCE_USE_FLEX_ATTENTION": {
    "description": "If True, forces the use of the flex attention kernel instead of potentially using",
    "std_args": [],
    "type": "attribute"
  },
  "FRnn": {
    "description": "Generic RNN layer wrapper.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "cell",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Fabs": {
    "description": "Compute the absolute values element-wise.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "FakeQuantizePerChannelAffine": {
    "description": "Simulates quantization per channel.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "scale",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "zero_point",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "quant_min",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "quant_max",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "FakeQuantizePerTensorAffine": {
    "description": "Simulates quantization per tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "scale",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "zero_point",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "quant_min",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "quant_max",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "False_": {
    "description": "Boolean type (True or False), stored as a byte. Legacy Numpy definition.",
    "std_args": [
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "FatalError": {
    "description": "Exception class for fatal errors.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "FbgemmLinearFp16Weight": {
    "description": "FBGEMM linear with FP16 weights.",
    "std_args": [],
    "variants": {}
  },
  "FbgemmLinearFp16WeightFp32Activation": {
    "description": "FBGEMM linear with FP16 weights and FP32 activation.",
    "std_args": [],
    "variants": {}
  },
  "FbgemmLinearInt8Weight": {
    "description": "FBGEMM linear with Int8 weights.",
    "std_args": [],
    "variants": {}
  },
  "FbgemmLinearInt8WeightFp32Activation": {
    "description": "FBGEMM linear with Int8 weights and FP32 activation.",
    "std_args": [],
    "variants": {}
  },
  "FbgemmLinearQuantizeWeight": {
    "description": "FBGEMM linear weight quantization.",
    "std_args": [],
    "variants": {}
  },
  "FbgemmPackGemmMatrixFp16": {
    "description": "Packs a GEMM matrix in FP16 for FBGEMM.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "K",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "N",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "FbgemmPackQuantizedMatrix": {
    "description": "Packs a quantized matrix for FBGEMM.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "K",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "N",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "FeatureAlphaDropout": {
    "description": "Randomly masks out entire channels (a channel is a feature map) given a batch of multi-channel input.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 0.5,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "p",
        "type": "float"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "training",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "inplace",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "FeatureAlphaDropout_": {
    "description": "In-place version of FeatureAlphaDropout.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 0.5,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "p",
        "type": "float"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "training",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "FeatureDropout": {
    "description": "Randomly masks out entire channels (spatial dropout).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 0.5,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "p",
        "type": "float"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "training",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "inplace",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "FeatureDropout_": {
    "description": "In-place version of FeatureDropout.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 0.5,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "p",
        "type": "float"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "training",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "FeedForward": {
    "description": "Feedforward layer with activation (usually Linear -> Act -> Linear).",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "in_features",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "out_features",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hidden_dims",
        "type": "int"
      },
      {
        "default": "relu",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "activation",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "FileCheck": {
    "description": "Testing utility for verifying file contents.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Fill": {
    "description": "Creates a tensor filled with a scalar value.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "FillDiagonal": {
    "description": "Fill the main diagonal of the given array of any dimensionality.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "val",
        "type": "Any"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "wrap",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Fill_": {
    "description": "In-place fill.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "FilterAll": {
    "description": "Filter that matches if all sub-filters match.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "filters",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "FilterAny": {
    "description": "Filter that matches if any sub-filter matches.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "filters",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "FilterEverything": {
    "description": "Filter matching everything.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "FilterState": {
    "description": "Filter a State into one or more States based on types/predicates.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "state",
        "type": "State"
      },
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "filters",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "FindDuplicates": {
    "description": "Finds duplicate nodes or node leaves in the given node graph.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "node",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Finfo": {
    "description": "Machine limits for floating point types.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Fix": {
    "description": "Rounds the input towards zero. Alias for trunc.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Fix_": {
    "description": "In-place version of fix.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "FlatState": {
    "description": "Flat state container.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Flatnonsense": {
    "description": "Return indices of nonzero elements in a flattened array",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "int | None"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "fill_value",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Flatnonzero": {
    "description": "Return indices that are non-zero in the flattened version of a.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "Flatten": {
    "description": "Flattens input by reshaping a range of dimensions into a single dimension.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": "0",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "start_dim",
        "type": "int"
      },
      {
        "default": "-1",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "end_dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "FlaxLayer": {
    "description": "Keras Layer wrapping Flax.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "module",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "FlexKernelOptions": {
    "description": "Options for controlling the behavior of FlexAttention kernels.",
    "std_args": [],
    "type": "class"
  },
  "Flexible": {
    "description": "Flexible data type base class.",
    "std_args": [],
    "variants": {}
  },
  "Flip": {
    "description": "Reverse the order of an n-D tensor along given axis in dims.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dims",
        "type": "List[int]"
      }
    ],
    "variants": {}
  },
  "Fliplr": {
    "description": "Flip tensor in the left/right direction.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Flipud": {
    "description": "Flip tensor in the up/down direction.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Float": {
    "description": "Single precision float type.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Float16": {
    "description": "Half precision float type.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Float32": {
    "description": "Single precision float type.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Float4E2m1fnX2": {
    "description": "FP4 type.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Float4_e2m1fn": {
    "description": "Float4_e2m1fn data type constructor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Float64": {
    "description": "Double precision float type.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Float8E4m3fn": {
    "description": "FP8 type E4M3FN.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Float8E4m3fnuz": {
    "description": "FP8 type E4M3FNUZ.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Float8E5m2": {
    "description": "FP8 type E5M2.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Float8E5m2fnuz": {
    "description": "FP8 type E5M2FNUZ.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Float8E8m0fnu": {
    "description": "FP8 type E8M0FNU.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Float8_e3m4": {
    "description": "Float8_e3m4 data type constructor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Float8_e4m3": {
    "description": "Float8_e4m3 data type constructor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Float8_e4m3b11fnuz": {
    "description": "Float8_e4m3b11fnuz data type constructor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Float8_e4m3fn": {
    "description": "Float8_e4m3fn data type constructor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Float8_e4m3fnuz": {
    "description": "Float8_e4m3fnuz data type constructor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Float8_e5m2": {
    "description": "Float8_e5m2 data type constructor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Float8_e5m2fnuz": {
    "description": "Float8_e5m2fnuz data type constructor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Float8_e8m0fnu": {
    "description": "Float8_e8m0fnu data type constructor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "FloatPower": {
    "description": "Raises input to the power of exponent, elementwise, in double precision.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "exponent",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "FloatStorage": {
    "description": "Storage class for float32 data.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "FloatTensor": {
    "description": "Legacy constructor for float32 tensors.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "FloatType": {
    "description": "Internal type definition for floats.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Float_": {
    "description": "Alias for float64.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Floating": {
    "description": "Generic floating point type category.",
    "return_type": "Dtype",
    "std_args": [],
    "variants": {}
  },
  "Floor": {
    "description": "Floor of the elements.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "FloorDivide": {
    "description": "Computes input divided by other, elementwise, and floors the result.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "FloorMod": {
    "description": "Returns element-wise remainder of division.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Floor_": {
    "description": "In-place floor.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Fmax": {
    "description": "Element-wise maximum of input and other, ignoring NaNs.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Fmin": {
    "description": "Computes the element-wise minimum of input and other, favoring non-NaN values.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Fmod": {
    "description": "Computes the element-wise floating-point remainder of division.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Fold": {
    "description": "Combines an array of sliding local blocks into a large containing tensor.",
    "std_args": [
      "self",
      "output_size",
      "kernel_size",
      "dilation",
      "padding",
      "stride"
    ],
    "type": "class"
  },
  "ForiLoop": {
    "description": "Functional loop from lower to upper bound.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "lower",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "upper",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "body_fun",
        "type": "Callable"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "init_val",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Fork": {
    "description": "Creates a task for TorchScript execution.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "func",
        "type": "Any"
      },
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "ForkRngs": {
    "description": "Forks the (nested) Rng states of the given node.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "node",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "split",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "FormatFloatPositional": {
    "description": "Format a floating-point scalar as a decimal string in positional notation.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "precision",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "FormatFloatScientific": {
    "description": "Format a floating-point scalar as a decimal string in scientific notation.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "precision",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Frac": {
    "description": "Computes the fractional portion of each element.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Frac_": {
    "description": "In-place version of Frac.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "FractionalMaxPool2d": {
    "description": "Applies a 2D fractional max pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "kernel_size",
      "output_size",
      "output_ratio",
      "return_indices",
      "_random_samples"
    ],
    "type": "class"
  },
  "FractionalMaxPool3d": {
    "description": "Applies a 3D fractional max pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "kernel_size",
      "output_size",
      "output_ratio",
      "return_indices",
      "_random_samples"
    ],
    "type": "class"
  },
  "Frexp": {
    "description": "Decomposes input into mantissa and exponent.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "FrobeniusNorm": {
    "description": "Calculates the Frobenius norm of a matrix.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "List[int]"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "FromBuffer": {
    "description": "Interpret a buffer as a 1-dimensional array.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "buffer",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "count",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "offset",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "FromDlpack": {
    "description": "Converts a tensor from an external library into a Tensor via DLPack.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ext_tensor",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "FromFile": {
    "description": "Creates a CPU tensor with a storage backed by a memory-mapped file.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "filename",
        "type": "str"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "FromFlatState": {
    "description": "Convert flat state object into State object.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "flat_state",
        "type": "Mapping"
      }
    ],
    "variants": {}
  },
  "FromFunction": {
    "description": "Construct an array by executing a function over each coordinate.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "function",
        "type": "Callable"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "shape",
        "type": "Tuple[int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "FromIter": {
    "description": "Create a new 1-dimensional array from an iterable object.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "iter",
        "type": "Iterable"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "FromNumpy": {
    "description": "Creates a Tensor from a numpy.ndarray.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ndarray",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "FromPyFunc": {
    "description": "Create a JAX ufunc from an arbitrary JAX-compatible scalar function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "func",
        "type": "Callable"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "nin",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "nout",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "identity",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "FromRegex": {
    "description": "Construct an array from a text file, using regular expression parsing.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "file",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "regexp",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "FromString": {
    "description": "A new 1-D array initialized from text data in a string.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "string",
        "type": "str"
      },
      {
        "default": "float",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "type"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "count",
        "type": "int"
      },
      {
        "default": "",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "sep",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "FromTree": {
    "description": "Reconstructs object from tree definition.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tree",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Frombuffer": {
    "description": "Creates a 1-dimensional Tensor from an object that implements the buffer protocol.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "buffer",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "count",
        "type": "Any"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "offset",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Ftrl": {
    "description": "Optimizer that implements the FTRL algorithm.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.001,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "learning_rate",
        "type": "float"
      },
      {
        "default": -0.5,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "learning_rate_power",
        "type": "float"
      },
      {
        "default": 0.1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "initial_accumulator_value",
        "type": "float"
      },
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "l1_regularization_strength",
        "type": "float"
      },
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "l2_regularization_strength",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Full": {
    "description": "Creates a tensor of size filled with fill_value.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "List[int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "fill_value",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "FullLike": {
    "description": "Returns a tensor with the same size as input filled with fill_value.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "fill_value",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "FullSoftmax": {
    "description": "Applies Softmax function to an n-dimensional input Tensor, optionally computing CrossEntropy.",
    "op_type": "class",
    "std_args": [
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "FunctionExporter": {
    "description": "Context for exporting function traces.",
    "std_args": [],
    "variants": {}
  },
  "FunctionSchema": {
    "description": "Internal schema representation for functions.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "FusedMovingAvgObsFakeQuant": {
    "description": "Quantization utility (Fused Moving Avg Fake Quant).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "FusedMultiplyAdd": {
    "description": "Auto-generated from rdna_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Future": {
    "description": "Wrapper for future results (JIT/Async).",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "FutureType": {
    "description": "Internal type definiton for Futures.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "GELU": {
    "description": "Applies the Gaussian Error Linear Units function.",
    "op_type": "class",
    "std_args": [
      {
        "default": "none",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "approximate",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "GLU": {
    "description": "Applies the Gated Linear Unit function.",
    "op_type": "class",
    "std_args": [
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "GRID_SAMPLE_INTERPOLATION_MODES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "GRID_SAMPLE_PADDING_MODES": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "GRU": {
    "description": "Applies a multi-layer gated recurrent unit (GRU) RNN to an input sequence.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hidden_size",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_layers",
        "type": "int"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "bool"
      },
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dropout",
        "type": "float"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bidirectional",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "GRUCell": {
    "description": "Cell class for the GRU layer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hidden_size",
        "type": "int"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "GShardSharedEmbeddingSoftmax": {
    "description": "Softmax layer with embedding lookup and Gaussian init used in GShard.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "in_features",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_classes",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Gather": {
    "description": "Gathers values along an axis specified by dim.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "index",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "GatherElements": {
    "description": "GatherElements takes two inputs `data` and `indices` of the same rank r >= 1 and an optional attribute `axis` that identifies an axis of `data` (by default, the outer-most axis, that is axis 0). It is an indexing operation that produces its output by indexing into the input data tensor at index posi...",
    "from": "Operators.md",
    "std_args": [
      [
        "data",
        "Tensor"
      ],
      [
        "indices",
        "Any"
      ],
      [
        "axis",
        "int"
      ]
    ]
  },
  "GatherMM": {
    "description": "Matrix multiplication with matrix-level gather.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "lhs_indices",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "rhs_indices",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "GatherND": {
    "description": "Given `data` tensor of rank `r` >= 1, `indices` tensor of rank `q` >= 1, and `batch_dims` integer `b`, this operator gathers slices of `data` into an output tensor of rank `q + r - indices_shape[-1] - 1 - b`. `indices` is an q-dimensional integer tensor, best thought of as a `(q-1)`-dimensional tens...",
    "from": "Operators.md",
    "std_args": [
      [
        "data",
        "Tensor"
      ],
      [
        "indices",
        "int"
      ],
      [
        "batch_dims",
        "int"
      ]
    ]
  },
  "GatherQMM": {
    "description": "Perform quantized matrix multiplication with matrix-level gather.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "w",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "scales",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "biases",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "lhs_indices",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "rhs_indices",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "GaussianDropout": {
    "description": "Apply multiplicative 1-centered Gaussian noise.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "rate",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "seed",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "GaussianNLLLoss": {
    "description": "Gaussian negative log likelihood loss.",
    "std_args": [
      "self",
      "full",
      "eps",
      "reduction"
    ],
    "type": "class"
  },
  "GaussianNoise": {
    "description": "Apply additive zero-centered Gaussian noise.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stddev",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "seed",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Gaussiannll": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Gcd": {
    "description": "Computes the element-wise greatest common divisor (GCD).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Gcd_": {
    "description": "In-place GCD.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Ge": {
    "description": "Computes input >= other element-wise.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Gelu": {
    "description": "Applies the Gaussian Error Linear Units function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "default": "none",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "approximate",
        "options": [
          "none",
          "tanh"
        ],
        "type": "str"
      }
    ],
    "variants": {}
  },
  "GeluApprox": {
    "description": "An approximation to Gaussian Error Linear Unit (Tanh based).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "GeluFastApprox": {
    "description": "A fast approximation to GELU (Sigmoid based).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Gemm": {
    "description": "General Matrix multiplication: https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms#Level_3 * A' = transpose(A) if transA else A * B' = transpose(B) if transB else B Compute Y = alpha * A' * B' + beta * C, where input tensor A has shape (M, K) or (K, M), input tensor B has shape (K, N) or ...",
    "from": "Operators.md",
    "std_args": [
      [
        "A",
        "Tensor"
      ],
      [
        "B",
        "Tensor"
      ],
      [
        "C",
        "Tensor"
      ],
      [
        "alpha",
        "float"
      ],
      [
        "beta",
        "float"
      ],
      [
        "transA",
        "int"
      ],
      [
        "transB",
        "int"
      ]
    ]
  },
  "GenFromTxt": {
    "description": "Load data from a text file, with missing values handled as specified.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "fname",
        "type": "str"
      },
      {
        "default": "float",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "type"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "delimiter",
        "type": "Optional[str]"
      }
    ],
    "variants": {}
  },
  "GeneralConv": {
    "description": "General convolution over an input with several channels.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "type": "Tensor"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "Union[int, Sequence[int]]"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "Union[int, Sequence[int]]"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_dilation",
        "type": "Union[int, Sequence[int]]"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_dilation",
        "type": "Union[int, Sequence[int]]"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "groups",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "flip",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Generator": {
    "description": "Pseudo-random number generator state.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Generic": {
    "description": "Base class for numpy scalar types.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "GeomSpace": {
    "description": "Return numbers spaced evenly on a log scale (a geometric progression).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "start",
        "type": "number"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stop",
        "type": "number"
      },
      {
        "default": 50,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Geomspace": {
    "description": "Return numbers spaced evenly on a log scale (a geometric progression).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "start",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stop",
        "type": "float"
      },
      {
        "default": 50,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num",
        "type": "int"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "endpoint",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Geqrf": {
    "description": "Computes a QR decomposition of input (low-level LAPACK).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Ger": {
    "description": "Outer product of two vectors.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "vec2",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "GetAbstractModel": {
    "description": "Get Abstract model definition.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "init_fn",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mesh",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "GetActiveMemory": {
    "description": "Get the actively used memory in bytes.",
    "return_type": "int",
    "std_args": [],
    "variants": {}
  },
  "GetAutocastCpuDtype": {
    "description": "Get autocast CPU dtype.",
    "std_args": [],
    "variants": {}
  },
  "GetAutocastDtype": {
    "description": "Get autocast dtype.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "device_type",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "GetAutocastGpuDtype": {
    "description": "Get autocast GPU dtype.",
    "std_args": [],
    "variants": {}
  },
  "GetAutocastIpuDtype": {
    "description": "Get autocast IPU dtype.",
    "std_args": [],
    "variants": {}
  },
  "GetAutocastXlaDtype": {
    "description": "Get autocast XLA dtype.",
    "std_args": [],
    "variants": {}
  },
  "GetBigramIds": {
    "description": "Generate bi-gram ids from uni-gram ids.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ids",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "vocab_size",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "GetBufSize": {
    "description": "Return the size of the buffer used in ufuncs.",
    "std_args": [],
    "variants": {}
  },
  "GetCacheMemory": {
    "description": "Get the cache size in bytes.",
    "return_type": "int",
    "std_args": [],
    "variants": {}
  },
  "GetDefaultDevice": {
    "description": "Gets the default device.",
    "std_args": [],
    "variants": {}
  },
  "GetDefaultDtype": {
    "description": "Get the current default floating point dtype.",
    "std_args": [],
    "variants": {}
  },
  "GetDefaultStream": {
    "description": "Get the device's default stream.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "device",
        "type": "Device"
      }
    ],
    "variants": {}
  },
  "GetDeterministicDebugMode": {
    "description": "Returns the current value of the debug mode for deterministic operations.",
    "std_args": [],
    "variants": {}
  },
  "GetDevice": {
    "description": "Returns the device index of a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "GetDeviceModule": {
    "description": "Returns the module associated with a given device.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "device",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "GetErr": {
    "description": "Get the current way of handling floating-point errors.",
    "std_args": [],
    "variants": {}
  },
  "GetErrCall": {
    "description": "Return the current callback function used on floating-point errors.",
    "std_args": [],
    "variants": {}
  },
  "GetFilePath": {
    "description": "Returns the path to a file embedded in the binary.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "path",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "GetFloat32MatmulPrecision": {
    "description": "Returns the current value of float32 matrix multiplication precision.",
    "return_type": "str",
    "std_args": [],
    "variants": {}
  },
  "GetInclude": {
    "description": "Return the directory that contains the NumPy *.h header files.",
    "std_args": [],
    "variants": {}
  },
  "GetLoss": {
    "description": "Retrieves a Keras loss as a function/Loss class instance.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "identifier",
        "type": "Union[str, dict]"
      }
    ],
    "variants": {}
  },
  "GetNamedSharding": {
    "description": "Construct named sharding for distributed computation.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tree",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mesh",
        "type": "jax.sharding.Mesh"
      }
    ],
    "variants": {}
  },
  "GetNumInteropThreads": {
    "description": "Returns the number of threads used for inter-op parallelism on CPU.",
    "return_type": "int",
    "std_args": [],
    "variants": {}
  },
  "GetNumThreads": {
    "description": "Returns the number of threads used for parallelizing CPU operations.",
    "return_type": "int",
    "std_args": [],
    "variants": {}
  },
  "GetOptimizer": {
    "description": "Retrieves a Keras Optimizer instance.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "identifier",
        "type": "Union[str, Dict]"
      }
    ],
    "variants": {}
  },
  "GetPartitionSpec": {
    "description": "Extracts a PartitionSpec tree from a PyTree.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tree",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "GetPeakMemory": {
    "description": "Get the peak amount of used memory in bytes.",
    "return_type": "int",
    "std_args": [],
    "variants": {}
  },
  "GetPrintOptions": {
    "description": "Return the current print options.",
    "std_args": [],
    "variants": {}
  },
  "GetPrintoptions": {
    "description": "Return current print options.",
    "std_args": [],
    "variants": {}
  },
  "GetRngState": {
    "description": "Returns the random number generator state.",
    "return_type": "Tensor",
    "std_args": [],
    "variants": {}
  },
  "GetState": {
    "description": "Retrieves the state (parameters/variables) from a model node.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "node",
        "type": "Any"
      },
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "filters",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "GlobalAveragePool": {
    "description": "GlobalAveragePool consumes an input tensor X and applies average pooling across the values in the same channel. This is equivalent to AveragePool with kernel size equal to the spatial dimension of input tensor.",
    "from": "Operators.md",
    "std_args": [
      [
        "X",
        "Tensor"
      ]
    ]
  },
  "GlobalAveragePooling1D": {
    "description": "Global average pooling operation for temporal data.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "options": [
          "channels_last",
          "channels_first"
        ],
        "type": "str"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "GlobalAveragePooling2D": {
    "description": "Global average pooling operation for 2D data.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "GlobalAveragePooling3D": {
    "description": "Global average pooling operation for 3D data.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "GlobalAvgPool1D": {
    "description": "Alias for GlobalAveragePooling1D.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "GlobalAvgPool2D": {
    "description": "Alias for GlobalAveragePooling2D.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "GlobalAvgPool3D": {
    "description": "Alias for GlobalAveragePooling3D.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "GlobalLpPool": {
    "description": "GlobalLpPool consumes an input tensor X and applies lp pool pooling across the values in the same channel. This is equivalent to LpPool with kernel size equal to the spatial dimension of input tensor.",
    "from": "Operators.md",
    "std_args": [
      [
        "X",
        "Tensor"
      ],
      [
        "p",
        "int"
      ]
    ]
  },
  "GlobalMaxPool": {
    "description": "GlobalMaxPool consumes an input tensor X and applies max pooling across the values in the same channel. This is equivalent to MaxPool with kernel size equal to the spatial dimension of input tensor.",
    "from": "Operators.md",
    "std_args": [
      [
        "X",
        "Tensor"
      ]
    ]
  },
  "GlobalMaxPool1D": {
    "description": "Global max pooling operation for temporal data.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "GlobalMaxPool2D": {
    "description": "Global max pooling operation for 2D data.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "GlobalMaxPool3D": {
    "description": "Global max pooling operation for 3D data.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "GlobalMaxPooling1D": {
    "description": "Alias for GlobalMaxPool1D.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "GlobalMaxPooling2D": {
    "description": "Alias for GlobalMaxPool2D.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "GlobalMaxPooling3D": {
    "description": "Alias for GlobalMaxPool3D.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "GlobalPooling": {
    "description": "Performs global pooling over the input.",
    "op_type": "class",
    "std_args": [
      {
        "default": "AVG",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "pooling_type",
        "type": "str"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Glu": {
    "description": "Applies the gated linear unit function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Gpu": {
    "description": "GPU Device Identifier.",
    "return_type": "Device",
    "std_args": [],
    "variants": {}
  },
  "Grad": {
    "description": "Returns a function which computes the gradient.",
    "op_type": "decorator",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "fun",
        "type": "Callable"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "argnums",
        "type": "Union[int, list[int]]"
      }
    ],
    "variants": {}
  },
  "GradScaler": {
    "description": "Utility for gradient scaling in mixed precision training.",
    "op_type": "class",
    "std_args": [
      {
        "default": 65536.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "init_scale",
        "type": "float"
      },
      {
        "default": 2.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "growth_factor",
        "type": "float"
      },
      {
        "default": 0.5,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "backoff_factor",
        "type": "float"
      },
      {
        "default": 2000,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "growth_interval",
        "type": "int"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "enabled",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Gradient": {
    "description": "Estimates the gradient of a function in one or more dimensions.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "spacing",
        "type": "Union[int, List[float]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "Optional[int]"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "edge_order",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Graph": {
    "description": "Internal representation of a TorchScript graph.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "GraphDef": {
    "description": "Graph Definition container.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "GraphExecutorState": {
    "description": "Internal state of the graph executor.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "GraphState": {
    "description": "Graph State container.",
    "std_args": [],
    "variants": {}
  },
  "Graphdef": {
    "description": "Get the GraphDef of the given graph node.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "node",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Grayscale": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Greater": {
    "description": "Computes input > other element-wise.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "GreaterEqual": {
    "description": "Computes input >= other element-wise.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "GreaterOrEqual": {
    "description": "Returns the tensor resulted from performing the `greater_equal` logical operation elementwise on the input tensors `A` and `B` (with Numpy-style broadcasting support). This operator supports **multidirectional (i.e., Numpy-style) broadcasting**; for more details please check [the doc](Broadcasting.m...",
    "from": "Operators.md",
    "std_args": [
      [
        "A",
        "Tensor"
      ],
      [
        "B",
        "Tensor"
      ]
    ]
  },
  "GridSample": {
    "description": "Given an input `X` and a flow-field `grid`, computes the output `Y` using `X` values and pixel locations from the `grid`. For spatial input `X` with shape (N, C, H, W), the `grid` will have shape (N, H_out, W_out, 2), the output `Y` will have shape (N, C, H_out, W_out). For volumetric input `X` with...",
    "from": "Operators.md",
    "std_args": [
      [
        "X",
        "Any"
      ],
      [
        "grid",
        "Any"
      ],
      [
        "align_corners",
        "int"
      ],
      [
        "mode",
        "str"
      ],
      [
        "padding_mode",
        "str"
      ]
    ]
  },
  "GridSampler": {
    "description": "Performs grid sampling for 2D or 3D inputs.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "grid",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "interpolation_mode",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding_mode",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "align_corners",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "GridSampler2d": {
    "description": "Performs 2D grid sampling.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "grid",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "interpolation_mode",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding_mode",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "align_corners",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "GridSampler3d": {
    "description": "Performs 3D grid sampling.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "grid",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "interpolation_mode",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding_mode",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "align_corners",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Group": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "GroupNorm": {
    "description": "Applies Group Normalization.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_groups",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "type": "Optional[Tensor]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "Optional[Tensor]"
      },
      {
        "default": "1e-05",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "eps",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "GroupNormalization": {
    "description": "Group normalization layer.",
    "op_type": "class",
    "std_args": [
      {
        "default": 32,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "groups",
        "type": "int"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "default": 0.001,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "epsilon",
        "type": "float"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "center",
        "type": "bool"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "scale",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "GroupQueryAttention": {
    "description": "Grouped Query Attention layer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "head_dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_query_heads",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_key_value_heads",
        "type": "int"
      },
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dropout",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "GroupedQueryAttention": {
    "description": "Dot-product attention sharing keys and values across heads.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "embed_dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_heads",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_kv_heads",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Groupnorm": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "eps",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_groups",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Gru": {
    "description": "Applies a multi-layer gated recurrent unit (GRU) RNN to an input sequence.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hx",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "params",
        "type": "List[Tensor]"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "has_biases",
        "type": "bool"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_layers",
        "type": "int"
      },
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dropout",
        "type": "float"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "train",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bidirectional",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "batch_first",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "GruCell": {
    "description": "A gated recurrent unit (GRU) cell.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hx",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "w_ih",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "w_hh",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b_ih",
        "type": "Optional[Tensor]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b_hh",
        "type": "Optional[Tensor]"
      }
    ],
    "variants": {}
  },
  "Grucell": {
    "description": "Auto-discovered via Consensus (Score: 3.0)",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Gt": {
    "description": "Computes input > other element-wise.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "HSplit": {
    "description": "Split an array into multiple sub-arrays horizontally (column-wise).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ary",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "indices_or_sections",
        "type": "Union[int, List[int]]"
      }
    ],
    "variants": {}
  },
  "HStack": {
    "description": "Stack arrays in sequence horizontally (column wise).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tup",
        "type": "List[Array]"
      }
    ],
    "variants": {}
  },
  "HadamardTransform": {
    "description": "Perform the Walsh-Hadamard transform along the final axis.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "scale",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Half": {
    "description": "Casts the input tensor to 16-bit floating point.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "HalfStorage": {
    "description": "Contiguous storage for float16 data.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "wrap_storage",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "device",
        "type": "Any"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "_internal",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "HalfTensor": {
    "description": "Legacy constructor for Float16 tensor.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kwargs",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Hamming": {
    "description": "Return a Hamming window of size M.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "M",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "HammingWindow": {
    "description": "Computes the Hamming window.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "window_length",
        "type": "int"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "periodic",
        "type": "bool"
      },
      {
        "default": 0.54,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "alpha",
        "type": "float"
      },
      {
        "default": 0.46,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "HannWindow": {
    "description": "Computes the Hann window.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "window_length",
        "type": "int"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "periodic",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "Hanning": {
    "description": "Return a Hanning window of size M.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "M",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "HardShrink": {
    "description": "Applies the HardShrink activation function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "default": 0.5,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "lambd",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "HardSigmoid": {
    "description": "Hard Sigmoid activation function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "HardSilu": {
    "description": "Hard SiLU (swish) activation function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "HardSwish": {
    "description": "Applies the hardswish function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "HardTanh": {
    "description": "Applies the HardTanh function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "default": -1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "min_val",
        "type": "float"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "max_val",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Hardmax": {
    "description": "The operator computes the hardmax values for the given input: Hardmax(element in input, axis) = 1 if the element is the first maximum value along the specified axis, 0 otherwise The \"axis\" attribute indicates the dimension along which Hardmax will be performed. The output tensor has the same shape a...",
    "from": "Operators.md",
    "std_args": [
      [
        "input",
        "Tensor"
      ],
      [
        "axis",
        "int"
      ]
    ]
  },
  "Hardshrink": {
    "description": "Applies the hard shrinkage function element-wise.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 0.5,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "lambd",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Hardswish": {
    "description": "Applies the Hardswish function.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Hardtanh": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "variants": {}
  },
  "HasLapack": {
    "description": "Checks if LAPACK is available.",
    "return_type": "bool",
    "std_args": [],
    "variants": {}
  },
  "HasMkl": {
    "description": "Checks if MKL is available.",
    "return_type": "bool",
    "std_args": [],
    "variants": {}
  },
  "HasOpenmp": {
    "description": "Checks if OpenMP is available.",
    "return_type": "bool",
    "std_args": [],
    "variants": {}
  },
  "HasSpectral": {
    "description": "Checks if spectral ops are available.",
    "return_type": "bool",
    "std_args": [],
    "variants": {}
  },
  "HashTensor": {
    "description": "Computes a hash of the tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mode",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "HashedCrossing": {
    "description": "A preprocessing layer which crosses features using the hashing trick.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_bins",
        "type": "int"
      },
      {
        "default": "int",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "output_mode",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "Hashing": {
    "description": "A preprocessing layer which hashes and bins categorical features.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_bins",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mask_value",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Heaviside": {
    "description": "Computes the Heaviside step function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "values",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "HingeEmbeddingLoss": {
    "description": "Measures the loss given an input tensor and a labels tensor (-1 or 1).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "target",
        "type": "Tensor"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "margin",
        "type": "float"
      },
      {
        "default": "mean",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "reduction",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "HingeLoss": {
    "description": "Computes the hinge loss between y_true & y_pred.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_true",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_pred",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Histc": {
    "description": "Computes the histogram of a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 100,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bins",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "min",
        "type": "float"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "max",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Histogram": {
    "description": "Computes a histogram of the values in a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 100,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bins",
        "type": "Union[int, Tensor]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "range",
        "type": "Optional[Tuple[float, float]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "type": "Optional[Tensor]"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "density",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Histogram2d": {
    "description": "Compute the bi-dimensional histogram of two data samples.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y",
        "type": "Array"
      },
      {
        "default": 10,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bins",
        "type": "Union[int, Array]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "range",
        "type": "Optional[Array]"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "density",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weights",
        "type": "Optional[Array]"
      }
    ],
    "variants": {}
  },
  "HistogramBinEdges": {
    "description": "Function to calculate only the edges of the bins used by the histogram function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Array"
      },
      {
        "default": 10,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bins",
        "type": "Union[int, str]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "range",
        "type": "Optional[Tuple[float, float]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weights",
        "type": "Optional[Array]"
      }
    ],
    "variants": {}
  },
  "HistogramDd": {
    "description": "Compute the multidimensional histogram of some data.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "sample",
        "type": "Array"
      },
      {
        "default": 10,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bins",
        "type": "Union[int, Array]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "range",
        "type": "Optional[Array]"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "density",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weights",
        "type": "Optional[Array]"
      }
    ],
    "variants": {}
  },
  "Histogramdd": {
    "description": "Computes a multi-dimensional histogram of the values in a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bins",
        "type": "Union[int, List[int], List[Tensor]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "range",
        "type": "Optional[List[float]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "type": "Optional[Tensor]"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "density",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Hsmm": {
    "description": "Hidden Semi-Markov Model (likely specialized/internal).",
    "std_args": [],
    "variants": {}
  },
  "Hsplit": {
    "description": "Splits a tensor horizontally into multiple tensors.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "indices_or_sections",
        "type": "Union[int, List[int]]"
      }
    ],
    "variants": {}
  },
  "Hspmm": {
    "description": "Performs sparse matrix multiplication.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mat1",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mat2",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Hstack": {
    "description": "Stacks tensors in sequence horizontally (column wise).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tensors",
        "type": "List[Tensor]"
      }
    ],
    "variants": {}
  },
  "HuberLoss": {
    "description": "Computes Huber loss value.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_true",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_pred",
        "type": "Tensor"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "delta",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Hypot": {
    "description": "Given the legs of a right triangle, return its hypotenuse.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "I0": {
    "description": "Computes the modified Bessel function of the first kind of order 0.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "I0_": {
    "description": "In-place version of I0.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "IInfo": {
    "description": "Machine limits for integer types.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "int_type",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "INTEGER": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "IODescriptor": {
    "description": "Description of IO descriptor.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Identity": {
    "description": "Return the identity array.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "n",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Optional[str]"
      }
    ],
    "variants": {}
  },
  "IdentityNorm": {
    "description": "Return the input as-is with BaseNormalization-compatible HParams.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "If": {
    "description": "If conditional",
    "from": "Operators.md",
    "std_args": [
      [
        "cond",
        "Any"
      ],
      [
        "else_branch",
        "Any"
      ],
      [
        "then_branch",
        "Any"
      ]
    ]
  },
  "Igamma": {
    "description": "Calculates the lower regularized incomplete gamma function.",
    "std_args": [
      {
        "doc": "a parameter",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "doc": "x parameter",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Igammac": {
    "description": "Calculates the upper regularized incomplete gamma function.",
    "std_args": [
      {
        "doc": "a parameter",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "doc": "x parameter",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Iinfo": {
    "description": "Machine limits for integer types.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "type",
        "type": "Union[str, dtype]"
      }
    ],
    "variants": {}
  },
  "Imag": {
    "description": "Returns a new tensor containing imaginary values of the self tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ImageDecoder": {
    "description": "Loads and decodes and image from a file. If it can't decode for any reason (e.g. corrupted encoded stream, invalid format, it will return an empty matrix). The following image formats are supported: * BMP * JPEG (note: Lossless JPEG support is optional) * JPEG2000 * TIFF * PNG * WebP * Portable imag...",
    "from": "Operators.md",
    "std_args": [
      [
        "encoded_stream",
        "Any"
      ],
      [
        "pixel_format",
        "str"
      ]
    ]
  },
  "ImportFunction": {
    "description": "Import a function from a serialized file format (MLX specific, mapping to JIT/SavedModel load).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "file",
        "type": "str"
      },
      {
        "default": "cpu",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "map_location",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "ImportIrModule": {
    "description": "Imports a TorchScript IR module. Not supported in functional frameworks.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "cu",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "filename",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "InTopK": {
    "description": "Outputs whether the targets are in the top `K` predictions.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "targets",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "predictions",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "k",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "IndexAdd": {
    "description": "Accumulate values into tensor at indices.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "index",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "source",
        "type": "Tensor"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "alpha",
        "type": "number"
      }
    ],
    "variants": {}
  },
  "IndexCopy": {
    "description": "Copies elements from source into input at indices.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "index",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "source",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "IndexExp": {
    "description": "A nicer way to build up index tuples for arrays.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "IndexExpression": {
    "description": "A nicer way to build up index tuples for arrays (s_).",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "IndexFill": {
    "description": "Fills elements at indices with value.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "index",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "number"
      }
    ],
    "variants": {}
  },
  "IndexPut": {
    "description": "Puts values into tensor at indices (tuple).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "indices",
        "type": "Tuple[Tensor]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "values",
        "type": "Tensor"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "accumulate",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "IndexPut_": {
    "description": "In-place version of IndexPut.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "indices",
        "type": "Tuple[Tensor]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "values",
        "type": "Tensor"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "accumulate",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "IndexReduce": {
    "description": "Reduce values into tensor (e.g. mean, max).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "index",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "source",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "reduce",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "IndexSelect": {
    "description": "Returns a new tensor which indexes the input tensor along dimension dim using the entries in index.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "index",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Indices": {
    "description": "Return an array representing the indices of a grid.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dimensions",
        "type": "Tuple[int]"
      },
      {
        "default": "int",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "DType"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "sparse",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Inexact": {
    "description": "Abstract base class for inexact types (floating point).",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Inf": {
    "description": "Infinity constant.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "InferenceMode": {
    "description": "Context manager that enables or disables inference mode (gradient isolation).",
    "op_type": "context",
    "std_args": [
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mode",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "InferredType": {
    "description": "JIT internal type inference helper.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Infinite": {
    "description": "Floating point positive infinity value.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Info": {
    "description": "Get help information for an array, function, class, or module. Interactive use only.",
    "std_args": [
      "object",
      "maxwidth",
      "output",
      "toplevel"
    ],
    "variants": {}
  },
  "InitNumThreads": {
    "description": "Initializes the number of parallel threads used on the current thread.",
    "std_args": [],
    "variants": {}
  },
  "InitialSeed": {
    "description": "Returns the initial seed for generating random numbers.",
    "std_args": [],
    "variants": {}
  },
  "Initializer": {
    "description": "Variable initializer type.",
    "std_args": [],
    "variants": {}
  },
  "InjectHyperparamsState": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "InjectStatefulHyperparamsState": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Inner": {
    "description": "Computes the dot product for 1D tensors. For higher dimensions, sums product of elements along last dim.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Input": {
    "description": "Used to instantiate a Keras tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "shape",
        "type": "tuple"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "batch_size",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "InputLayer": {
    "description": "Layer to be used as an entry point into a Network.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_shape",
        "type": "tuple"
      }
    ],
    "variants": {}
  },
  "InputSpec": {
    "description": "Specifies the rank, dtype and shape of every input to a layer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "shape",
        "type": "tuple"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ndim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Insert": {
    "description": "Insert values along the given axis before the given indices.",
    "std_args": [
      "arr",
      "obj",
      "values",
      "axis"
    ],
    "variants": {}
  },
  "InstanceNorm": {
    "description": "Applies Instance Normalization.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "running_mean",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "running_var",
        "type": "Tensor"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "use_input_stats",
        "type": "bool"
      },
      {
        "default": 0.1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "momentum",
        "type": "float"
      },
      {
        "default": "1e-05",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "eps",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "InstanceNorm1d": {
    "description": "Applies Instance Normalization.",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "InstanceNorm2d": {
    "description": "Applies Instance Normalization.",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "InstanceNorm3d": {
    "description": "Applies Instance Normalization.",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "InstanceNormalization": {
    "description": "Carries out instance normalization as described in the paper https://arxiv.org/abs/1607.08022. y = scale * (x - mean) / sqrt(variance + epsilon) + B, where mean and variance are computed per instance per channel.",
    "from": "Operators.md",
    "std_args": [
      [
        "input",
        "Tensor"
      ],
      [
        "scale",
        "Tensor"
      ],
      [
        "B",
        "Tensor"
      ],
      [
        "epsilon",
        "float"
      ]
    ]
  },
  "Instancenorm": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "eps",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_features",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Int": {
    "description": "32-bit integer type.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Int16": {
    "description": "16-bit integer type.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Int16Tensor": {
    "description": "Constructor/Type for 16-bit integer tensors.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Int3": {
    "description": "3-bit integer data type (Quantization).",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Int32": {
    "description": "32-bit integer data type.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Int4": {
    "description": "4-bit integer data type (Quantization).",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Int5": {
    "description": "5-bit integer data type (Quantization).",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Int6": {
    "description": "6-bit integer data type (Quantization).",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Int64": {
    "description": "64-bit integer data type (Long).",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Int7": {
    "description": "7-bit integer data type (Quantization).",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Int8": {
    "description": "8-bit integer data type (Byte/Char).",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "IntRepr": {
    "description": "Returns the integer representation of a quantized tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "IntStorage": {
    "description": "Contiguous storage for int32 data.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "wrap_storage",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "device",
        "type": "Any"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "_internal",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "IntTensor": {
    "description": "Legacy constructor for Int32 tensor.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kwargs",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "IntType": {
    "description": "JIT type representing Int.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Int_": {
    "description": "Default integer type (maps to Int64 typically).",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Intc": {
    "description": "Signed integer type compatible with C int.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Integer": {
    "description": "Abstract base class of all integer scalar types.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "IntegerLookup": {
    "description": "A preprocessing layer that maps integers to (possibly encoded) indices.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "max_tokens",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mask_token",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "InterfaceType": {
    "description": "JIT type representing Interface.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Intermediate": {
    "description": "Intermediate variable wrapper (sow).",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Interp": {
    "description": "One-dimensional linear interpolation.",
    "std_args": [
      "x",
      "xp",
      "fp",
      "left",
      "right",
      "period"
    ],
    "variants": {}
  },
  "Intersect1d": {
    "description": "Find the intersection of two arrays.",
    "std_args": [
      "ar1",
      "ar2",
      "assume_unique",
      "return_indices"
    ],
    "variants": {}
  },
  "Intp": {
    "description": "Integer used for indexing (pointer size).",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Inverse": {
    "description": "Computes the inverse of a square matrix.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "rank": 2,
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "InverseShortTimeFourierTransform": {
    "description": "Inverse short time Fourier Transform.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "rank": 3,
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "n_fft",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hop_length",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "win_length",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "window",
        "type": "Tensor"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "center",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "normalized",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "onesided",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "length",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "return_complex",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Invert": {
    "description": "Compute bit-wise inversion, or bit-wise NOT, element-wise.",
    "std_args": [
      "x"
    ],
    "variants": {}
  },
  "InvertPermutation": {
    "description": "Computes the inverse permutation of a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "IsAnomalyCheckNanEnabled": {
    "description": "Returns True if anomaly check for NaNs is enabled.",
    "std_args": [],
    "variants": {}
  },
  "IsAnomalyEnabled": {
    "description": "Returns True if anomaly detection is enabled.",
    "std_args": [],
    "variants": {}
  },
  "IsAutocastCacheEnabled": {
    "description": "Returns True if autocast cache is enabled.",
    "std_args": [],
    "variants": {}
  },
  "IsAutocastCpuEnabled": {
    "description": "Returns True if autocast is enabled on CPU.",
    "std_args": [],
    "variants": {}
  },
  "IsAutocastEnabled": {
    "description": "Returns True if autocast is enabled.",
    "std_args": [],
    "variants": {}
  },
  "IsAutocastIpuEnabled": {
    "description": "Returns True if autocast is enabled on IPU.",
    "std_args": [],
    "variants": {}
  },
  "IsAutocastXlaEnabled": {
    "description": "Returns True if autocast is enabled on XLA.",
    "std_args": [],
    "variants": {}
  },
  "IsAvailable": {
    "description": "Check if the accelerator backend is available.",
    "std_args": [],
    "variants": {}
  },
  "IsBusDay": {
    "description": "Calculates which of the given dates are valid days.",
    "std_args": [
      "dates",
      "weekmask",
      "holidays",
      "busdaycal",
      "out"
    ],
    "variants": {}
  },
  "IsClose": {
    "description": "Returns a new tensor with boolean elements representing if each element of input is close to other.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      },
      {
        "default": "1e-05",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "rtol",
        "type": "float"
      },
      {
        "default": "1e-08",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "atol",
        "type": "float"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "equal_nan",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "IsComplex": {
    "description": "Returns True if the data type of the tensor is complex.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "IsComplexObj": {
    "description": "Check for a complex type or an array of complex numbers (scalar result).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "IsConj": {
    "description": "Returns True if the tensor is a conjugated tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "IsDType": {
    "description": "Determine if a provided dtype is of a specified data type kind.",
    "std_args": [
      "dtype",
      "kind"
    ],
    "variants": {}
  },
  "IsData": {
    "description": "Checks if a value is a registered data type (Flax NNX specific).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "IsDeterministicAlgorithmsWarnOnlyEnabled": {
    "description": "Returns True if the global deterministic flag is set to warn only.",
    "std_args": [],
    "variants": {}
  },
  "IsDistributed": {
    "description": "Returns True if the DistributedRPC framework is initialized.",
    "std_args": [],
    "variants": {}
  },
  "IsDtype": {
    "description": "Returns True if the array data type is of the specified kind.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "DType"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kind",
        "type": "str | DType"
      }
    ],
    "variants": {}
  },
  "IsFinite": {
    "description": "Returns a new tensor with boolean elements representing if each element is finite.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "IsFloatingPoint": {
    "description": "Returns True if the data type of the tensor is a floating point type.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "IsFortran": {
    "description": "Check if the array is Fortran contiguous but not C contiguous.",
    "std_args": [
      "a"
    ],
    "variants": {}
  },
  "IsGradEnabled": {
    "description": "Returns True if grad mode is currently enabled.",
    "std_args": [],
    "variants": {}
  },
  "IsIn": {
    "description": "Tests if each element of elements is in test_elements.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "elements",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "test_elements",
        "type": "Tensor"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "assume_unique",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "invert",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "IsInf": {
    "description": "Tests if each element of input is infinite.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "IsInference": {
    "description": "Returns True if input is an inference tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "IsInferenceModeEnabled": {
    "description": "Returns True if inference mode is currently enabled.",
    "std_args": [],
    "variants": {}
  },
  "IsNaN": {
    "description": "Returns a new tensor with boolean elements representing if each element is NaN.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "IsNaT": {
    "description": "Test element-wise for NaT (not a time).",
    "std_args": [
      "x"
    ],
    "variants": {}
  },
  "IsNan": {
    "description": "Returns which elements of x are NaN.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "IsNeg": {
    "description": "Checks if elements are negative.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "IsNegInf": {
    "description": "Tests if each element of input is negative infinity.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "IsNonDecreasing": {
    "description": "Returns `True` if `x` is non-decreasing.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "IsNonZero": {
    "description": "Returns True if the input is a single element tensor which is not equal to zero.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "IsPosInf": {
    "description": "Tests if each element of input is positive infinity.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "IsReal": {
    "description": "Returns a new tensor with boolean elements representing if each element is real-valued.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "IsRealObj": {
    "description": "Return True if x is a not complex type or an array of complex numbers.",
    "std_args": [
      "x"
    ],
    "variants": {}
  },
  "IsSameSize": {
    "description": "Returns True if two tensors have the same size.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "IsScalar": {
    "description": "Returns True if the type of num is a scalar type.",
    "std_args": [
      "num"
    ],
    "variants": {}
  },
  "IsSigned": {
    "description": "Returns True if the tensor is a signed data type.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "IsStorage": {
    "description": "Returns True if the object is a storage object.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "obj",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "IsStrictlyIncreasing": {
    "description": "Returns `True` if `x` is strictly increasing.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "IsSubDtype": {
    "description": "Returns True if first argument is a typecode lower/equal in type hierarchy.",
    "std_args": [
      "arg1",
      "arg2"
    ],
    "variants": {}
  },
  "IsTensor": {
    "description": "Returns True if obj is a PyTorch tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "obj",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "IsVulkanAvailable": {
    "description": "Returns True if the backend is available.",
    "return_type": "bool",
    "std_args": [],
    "variants": {}
  },
  "IsWarnAlwaysEnabled": {
    "description": "Returns True if the global warn_always flag is turned on.",
    "return_type": "bool",
    "std_args": [],
    "variants": {}
  },
  "Isclose": {
    "description": "Return a boolean array where two arrays are element-wise equal within a tolerance.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b",
        "type": "Tensor"
      },
      {
        "default": "1e-05",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "rtol",
        "type": "float"
      },
      {
        "default": "1e-08",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "atol",
        "type": "float"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "equal_nan",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Isin": {
    "description": "Calculates element in test_elements, broadcasting over element only.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "element",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "test_elements",
        "type": "Tensor"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "assume_unique",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "invert",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "IterChildren": {
    "description": "Iterates over immediate children modules/layers.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "module",
        "type": "Module"
      }
    ],
    "variants": {}
  },
  "IterGraph": {
    "description": "Iterates over all nested nodes and leaves of the graph.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "node",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "IterModules": {
    "description": "Recursively iterates over all nested Modules.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "module",
        "type": "Module"
      }
    ],
    "variants": {}
  },
  "Iterable": {
    "description": "Check whether or not an object can be iterated over.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Ix_": {
    "description": "Construct an open mesh from multiple sequences.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "JITException": {
    "description": "Common base class for all non-exit exceptions in JIT.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "JVP": {
    "description": "Compute the Jacobian-vector product.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "func",
        "type": "Callable"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "primals",
        "type": "List[Tensor]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tangents",
        "type": "List[Tensor]"
      }
    ],
    "variants": {}
  },
  "Jagged": {
    "description": "Creates a jagged tensor.",
    "std_args": [],
    "variants": {}
  },
  "JaxLayer": {
    "description": "Keras Layer that wraps a JAX model.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "call_fn",
        "type": "callable"
      }
    ],
    "variants": {}
  },
  "Jit": {
    "description": "Just-In-Time compilation decorator/function.",
    "op_type": "decorator",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "fun",
        "type": "Callable"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "static_argnums",
        "type": "Optional[Union[int, Sequence[int]]]"
      }
    ],
    "variants": {}
  },
  "KLDivLoss": {
    "description": "The Kullback-Leibler divergence loss.",
    "std_args": [
      "self",
      "size_average",
      "reduce",
      "reduction",
      "log_target"
    ],
    "type": "class"
  },
  "KLDivergence": {
    "description": "Computes Kullback-Leibler divergence loss between y_true & y_pred.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_true",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_pred",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "KLDivergenceLoss": {
    "description": "Computes Kullback-Leibler divergence loss.",
    "op_type": "class",
    "std_args": [
      {
        "default": "sum_over_batch_size",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "reduction",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "Kaiser": {
    "description": "Return the Kaiser window.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "M",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "KaiserWindow": {
    "description": "Computes the Kaiser window.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "window_length",
        "type": "int"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "periodic",
        "type": "bool"
      },
      {
        "default": 12.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "KlDiv": {
    "description": "The Kullback-Leibler divergence Loss.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "target",
        "type": "Tensor"
      },
      {
        "default": "mean",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "reduction",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "Kldiv": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Kron": {
    "description": "Computes the Kronecker product.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "KthValue": {
    "description": "Returns the k-th smallest element.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "k",
        "type": "int"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "L1": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "L1Loss": {
    "description": "Creates a criterion that measures the mean absolute error (MAE) between each element in",
    "std_args": [
      "self",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "L1Unstructured": {
    "description": "Prune (currently unpruned) units in a tensor by zeroing out the ones with the lowest L1-norm.",
    "std_args": [
      "self",
      "amount"
    ],
    "type": "class"
  },
  "L2Normalize": {
    "description": "Normalizes along dimension `axis` using an L2 norm.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "default": "1e-12",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "epsilon",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "LBeta": {
    "description": "Computes ln(|Beta(x)|), reducing along the last dimension.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "LOWER_RIGHT": {
    "description": "Auto-generated from flax_nnx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "LPPool1d": {
    "description": "Applies a 1D power-average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "norm_type",
      "kernel_size",
      "stride",
      "ceil_mode"
    ],
    "type": "class"
  },
  "LPPool2d": {
    "description": "Applies a 2D power-average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "norm_type",
      "kernel_size",
      "stride",
      "ceil_mode"
    ],
    "type": "class"
  },
  "LPPool3d": {
    "description": "Applies a 3D power-average pooling over an input signal composed of several input planes.",
    "std_args": [
      "self",
      "norm_type",
      "kernel_size",
      "stride",
      "ceil_mode"
    ],
    "type": "class"
  },
  "LRN": {
    "description": "Local Response Normalization proposed in the [AlexNet paper](https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf). It normalizes over local input regions. The local region is defined across the channels. For an element `X[n, c, d1, ..., dk]` in a ten...",
    "from": "Operators.md",
    "std_args": [
      [
        "X",
        "Tensor"
      ],
      [
        "alpha",
        "float"
      ],
      [
        "beta",
        "float"
      ],
      [
        "bias",
        "float"
      ],
      [
        "size",
        "int"
      ]
    ]
  },
  "LSTM": {
    "description": "Applies a multi-layer long short-term memory (LSTM) RNN.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hidden_size",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_layers",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "LSTMCell": {
    "description": "A long short-term memory (LSTM) cell.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hidden_size",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "LU": {
    "description": "Computes the LU factorization.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "A",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "LUSolve": {
    "description": "Solves a system of equations using LU factorization.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "LU_data",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "LU_pivots",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Lamb": {
    "description": "Optimizer that implements the Lamb algorithm.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.001,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "learning_rate",
        "type": "float"
      },
      {
        "default": 0.9,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta_1",
        "type": "float"
      },
      {
        "default": 0.999,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta_2",
        "type": "float"
      },
      {
        "default": "1e-07",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "epsilon",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight_decay",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Lambda": {
    "description": "Wraps arbitrary expressions as a Layer object.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "function",
        "type": "callable"
      }
    ],
    "variants": {}
  },
  "LanguageModel": {
    "description": "Language Model base task.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "LanguageModelContinuousBatching": {
    "description": "Language model that uses continuous batching.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "LanguageModelDPO": {
    "description": "Contains a pair of TransformerLM for direct preference optimization.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "LanguageModelType": {
    "description": "Enumerator for Language Model Types.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Layer": {
    "description": "Base class for all layers.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "LayerNorm": {
    "description": "Applies Layer Normalization.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "normalized_shape",
        "type": "List[int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "Tensor"
      },
      {
        "default": "1e-05",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "eps",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "LayerNormalization": {
    "description": "Layer normalization layer.",
    "op_type": "class",
    "std_args": [
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "Any"
      },
      {
        "default": 0.001,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "epsilon",
        "type": "float"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "center",
        "type": "bool"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "scale",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "LayerNormalizedLstmCellSimple": {
    "description": "LSTM cell with Layer Normalization.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hidden_size",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "LayerWrapper": {
    "description": "Abstract wrapper base class.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "layer",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "LayerwiseShardablePipelined": {
    "description": "A layer that implements pipelining across stages.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_stages",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Layout": {
    "description": "Layout type constant.",
    "std_args": [],
    "variants": {}
  },
  "LazyBatchNorm1d": {
    "description": "A :class:`torch.nn.BatchNorm1d` module with lazy initialization.",
    "std_args": [
      "self",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyBatchNorm2d": {
    "description": "A :class:`torch.nn.BatchNorm2d` module with lazy initialization.",
    "std_args": [
      "self",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyBatchNorm3d": {
    "description": "A :class:`torch.nn.BatchNorm3d` module with lazy initialization.",
    "std_args": [
      "self",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyConv1d": {
    "description": "A :class:`torch.nn.Conv1d` module with lazy initialization of the ``in_channels`` argument.",
    "std_args": [
      "self",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyConv2d": {
    "description": "A :class:`torch.nn.Conv2d` module with lazy initialization of the ``in_channels`` argument.",
    "std_args": [
      "self",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyConv3d": {
    "description": "A :class:`torch.nn.Conv3d` module with lazy initialization of the ``in_channels`` argument.",
    "std_args": [
      "self",
      "out_channels",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "groups",
      "bias",
      "padding_mode",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyConvTranspose1d": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "LazyConvTranspose2d": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "LazyConvTranspose3d": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "LazyInstanceNorm1d": {
    "description": "A :class:`torch.nn.InstanceNorm1d` module with lazy initialization of the ``num_features`` argument.",
    "std_args": [
      "self",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyInstanceNorm2d": {
    "description": "A :class:`torch.nn.InstanceNorm2d` module with lazy initialization of the ``num_features`` argument.",
    "std_args": [
      "self",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyInstanceNorm3d": {
    "description": "A :class:`torch.nn.InstanceNorm3d` module with lazy initialization of the ``num_features`` argument.",
    "std_args": [
      "self",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyLinear": {
    "description": "A :class:`torch.nn.Linear` module where `in_features` is inferred.",
    "std_args": [
      "self",
      "out_features",
      "bias",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "LazyModuleMixin": {
    "description": "A mixin for modules that lazily initialize parameters, also known as \"lazy modules\".",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "class"
  },
  "Lcm": {
    "description": "Computes the element-wise least common multiple.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Lcm_": {
    "description": "In-place LCM.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "LdExp": {
    "description": "Returns x1 * 2**x2, element-wise.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x1",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x2",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Ldexp": {
    "description": "Multiplies input by 2 ** other.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Ldexp_": {
    "description": "In-place ldexp.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Le": {
    "description": "Computes input <= other element-wise.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "LeakyReLU": {
    "description": "Applies the LeakyReLU activation function.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.01,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "negative_slope",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "LeakyRelu": {
    "description": "Applies the Leaky Rectified Linear Unit.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "default": 0.01,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "negative_slope",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "LeftShift": {
    "description": "Shift the bits of an integer to the left.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x1",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x2",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "LegacyContiguousFormat": {
    "description": "Memory format constant.",
    "std_args": [],
    "variants": {}
  },
  "Lerp": {
    "description": "Linear interpolation.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "end",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Less": {
    "description": "Computes input < other element-wise.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "LessEqual": {
    "description": "Alias for Le.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "LessOrEqual": {
    "description": "Returns the tensor resulted from performing the `less_equal` logical operation elementwise on the input tensors `A` and `B` (with Numpy-style broadcasting support). This operator supports **multidirectional (i.e., Numpy-style) broadcasting**; for more details please check [the doc](Broadcasting.md).",
    "from": "Operators.md",
    "std_args": [
      [
        "A",
        "Tensor"
      ],
      [
        "B",
        "Tensor"
      ]
    ]
  },
  "LexSort": {
    "description": "Perform an indirect stable sort using a sequence of keys.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keys",
        "type": "Tensor"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Lexsort": {
    "description": "Perform an indirect sort using a sequence of keys.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keys",
        "type": "Tensor | Sequence[Tensor]"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Lgamma": {
    "description": "Computes natural logarithm of gamma function.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "LiftedModule": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "LightConv1D": {
    "description": "Lightweight 1D convolution layer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "in_channels",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "LinSpace": {
    "description": "Return evenly spaced numbers over a specified interval.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "start",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stop",
        "type": "float"
      },
      {
        "default": 50,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num",
        "type": "int"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "endpoint",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "retstep",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Dtype"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Linear": {
    "description": "Applies a linear transformation to the incoming data.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "in_features",
        "rank": 0,
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "out_features",
        "rank": 0,
        "type": "int"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "LinearGeneral": {
    "description": "Flexible linear layer with axis specification.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "in_features",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "out_features",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "Union[int, Tuple[int]]"
      }
    ],
    "variants": {}
  },
  "LinearT": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Linspace": {
    "description": "Creates start-to-end evenly spaced steps.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "start",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "end",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "steps",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Lion": {
    "description": "Optimizer that implements the Lion algorithm.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.001,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "learning_rate",
        "type": "float"
      },
      {
        "default": 0.9,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta_1",
        "type": "float"
      },
      {
        "default": 0.99,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta_2",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight_decay",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "List": {
    "description": "Auto-generated from flax_nnx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "ListAdd": {
    "description": "Functional interface to the Add layer (elementwise sum). Takes a list of tensors.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "inputs",
        "type": "List[Tensor]"
      }
    ],
    "variants": {}
  },
  "ListAverage": {
    "description": "Functional interface to the Average layer. Takes a list of tensors.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "inputs",
        "type": "List[Tensor]"
      }
    ],
    "variants": {}
  },
  "ListConcatenate": {
    "description": "Functional interface to the Concatenate layer.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "inputs",
        "type": "List[Tensor]"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ListMaximum": {
    "description": "Functional interface to the Maximum layer.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "inputs",
        "type": "List[Tensor]"
      }
    ],
    "variants": {}
  },
  "ListMinimum": {
    "description": "Functional interface to the Minimum layer.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "inputs",
        "type": "List[Tensor]"
      }
    ],
    "variants": {}
  },
  "ListMultiply": {
    "description": "Functional interface to the Multiply layer.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "inputs",
        "type": "List[Tensor]"
      }
    ],
    "variants": {}
  },
  "ListSubtract": {
    "description": "Functional interface to the Subtract layer.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "inputs",
        "type": "List[Tensor]"
      }
    ],
    "variants": {}
  },
  "ListType": {
    "description": "JIT type representing List.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "LiteScriptModule": {
    "description": "JIT module optimized for mobile.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "LittleEndian": {
    "description": "Check if system is little endian.",
    "std_args": [],
    "variants": {}
  },
  "LnStructured": {
    "description": "Prune entire (currently unpruned) channels in a tensor based on their L\\ ``n``-norm.",
    "std_args": [
      "self",
      "amount",
      "n",
      "dim"
    ],
    "type": "class"
  },
  "LoRA": {
    "description": "A standalone LoRA (Low-Rank Adaptation) layer adapter.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "in_features",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "lora_rank",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "out_features",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "base_module",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "LoRALinear": {
    "description": "A Linear layer with built-in LoRA adaptation.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "in_features",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "out_features",
        "type": "int"
      },
      {
        "default": 8,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "lora_rank",
        "type": "int"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "LoRAParam": {
    "description": "Parameter type specific to LoRA layers.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Load": {
    "description": "Loads a serialized object or weights from a file.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "f",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "map_location",
        "type": "Any"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weights_only",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "LoadTxt": {
    "description": "Load data from a text file.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "fname",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "LobPCG": {
    "description": "Finds the k largest/smallest eigenvalues using LOBPCG.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "A",
        "type": "Tensor"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "k",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "B",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "LocalResponseNorm": {
    "description": "Applies local response normalization over an input signal.",
    "std_args": [
      "self",
      "size",
      "alpha",
      "beta",
      "k"
    ],
    "type": "class"
  },
  "LocalSelfAttention": {
    "description": "Local Attention with given left and right context.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_heads",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "window_size",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "LocalSelfAttentionAlibi": {
    "description": "Local version of non-trainable relative bias position encoding (ALiBi).",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "LocalSelfAttentionRelativeBias": {
    "description": "Local version of trainable relative bias position encoding.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "LocalSelfAttentionXL": {
    "description": "Local version of transformer-xl self attention.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "LockingLogger": {
    "description": "Internal locking logger.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Log": {
    "description": "Computes the natural logarithm element-wise.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Log10": {
    "description": "Computes the base-10 logarithm element-wise.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Log10_": {
    "description": "Computes the base-10 logarithm element-wise in-place.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Log1p": {
    "description": "Computes the natural logarithm of (1 + input) element-wise.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Log1p_": {
    "description": "Computes log1p in-place.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Log2": {
    "description": "Computes the base-2 logarithm element-wise.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Log2_": {
    "description": "Computes base-2 logarithm in-place.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "LogAddExp": {
    "description": "Logarithm of the sum of exponentiations of the inputs.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "LogAddExp2": {
    "description": "Logarithm of sum of exponentiations in base-2.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "LogCoshLoss": {
    "description": "Logarithm of the hyperbolic cosine of the prediction error.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_true",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_pred",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "LogCumSumExp": {
    "description": "Logarithm of the cumulative summation of exponentiation.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "LogDet": {
    "description": "Calculates log determinant of a square matrix.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "LogSigmoid": {
    "description": "Computes log sigmoid of x element-wise.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "LogSoftmax": {
    "description": "Applies the LogSoftmax function to an n-dimensional input Tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "LogSpace": {
    "description": "Creates a tensor with values spaced evenly on a logarithmic scale.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "start",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "end",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "steps",
        "type": "int"
      },
      {
        "default": 10.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "base",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "LogSumExp": {
    "description": "Returns the log of summed exponentials of each row.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Log_": {
    "description": "Computes natural logarithm in-place.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Logaddexp": {
    "description": "Logarithm of the sum of exponentiations of the inputs.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x1",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x2",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Logaddexp2": {
    "description": "Logarithm of the sum of exponentiations of the inputs in base-2.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x1",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x2",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Logcosh": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "LoggerBase": {
    "description": "Base class for loggers.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "LogicalAnd": {
    "description": "Element-wise logical AND.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "LogicalAxisRules": {
    "description": "Context manager for setting logical to mesh axis bindings.",
    "op_type": "context",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "rules",
        "type": "Sequence"
      }
    ],
    "variants": {}
  },
  "LogicalNot": {
    "description": "Element-wise logical NOT.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "LogicalOr": {
    "description": "Element-wise logical OR.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "LogicalXor": {
    "description": "Element-wise logical XOR.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Logit": {
    "description": "Inverse of the sigmoid function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "eps",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Logit_": {
    "description": "In-place logit.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "eps",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Logsigmoid": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Logspace": {
    "description": "Return numbers spaced evenly on a log scale.",
    "std_args": [
      "start",
      "stop",
      {
        "default": 50,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num",
        "type": "Any"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "endpoint",
        "type": "Any"
      },
      {
        "default": 10.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "base",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Logsumexp": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "return_sign",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "where",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "LongLong": {
    "description": "Signed integer type, compatible with C long long (typically 64-bit).",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "LongStorage": {
    "description": "Contiguous storage for int64 data.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "wrap_storage",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "device",
        "type": "Any"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "_internal",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "LongTensor": {
    "description": "Legacy constructor for Int64 tensor.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kwargs",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Loop": {
    "description": "Generic Looping construct. This loop has multiple termination conditions: 1) Trip count. Iteration count specified at runtime. Set by specifying the input M. Optional. Set to empty string to omit. Note that a static trip count (specified at graph construction time) can be specified by passing in a c...",
    "from": "Operators.md",
    "std_args": [
      [
        "M",
        "Any"
      ],
      [
        "cond",
        "Any"
      ],
      [
        "v_initial",
        "Any"
      ],
      [
        "body",
        "Any"
      ]
    ]
  },
  "Loss": {
    "description": "Loss base class.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "LossScaleOptimizer": {
    "description": "An optimizer that dynamically scales the loss to prevent underflow.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "inner_optimizer",
        "type": "Any"
      },
      {
        "default": 32768.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "initial_scale",
        "type": "float"
      },
      {
        "default": 2000,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dynamic_growth_steps",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "LpNormalization": {
    "description": "Given a matrix, apply Lp-normalization along the provided axis.",
    "from": "Operators.md",
    "std_args": [
      [
        "input",
        "Tensor"
      ],
      [
        "axis",
        "int"
      ],
      [
        "p",
        "int"
      ]
    ]
  },
  "LpPool": {
    "description": "LpPool consumes an input tensor X and applies Lp pooling across the tensor according to kernel sizes, stride sizes, and pad lengths. Lp pooling consisting of computing the Lp norm on all values of a subset of the input tensor according to the kernel size and downsampling the data into the output ten...",
    "from": "Operators.md",
    "std_args": [
      [
        "X",
        "Tensor"
      ],
      [
        "auto_pad",
        "str"
      ],
      [
        "ceil_mode",
        "int"
      ],
      [
        "dilations",
        "List[int]"
      ],
      [
        "kernel_shape",
        "List[int]"
      ],
      [
        "p",
        "int"
      ],
      [
        "pads",
        "List[int]"
      ],
      [
        "strides",
        "List[int]"
      ]
    ]
  },
  "LstSq": {
    "description": "Computes the solution to the least squares problem.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "A",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "LstmCellSimple": {
    "description": "A long short-term memory (LSTM) cell.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hidden_size",
        "type": "int"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "LstmFrnn": {
    "description": "A FRNN for LSTMCellSimple cell.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Lstmcell": {
    "description": "Auto-discovered via Consensus (Score: 3.0)",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Lt": {
    "description": "Computes input < other element-wise.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "LuUnpack": {
    "description": "Unpacks the LU decomposition into P, L, U matrices.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "LU_data",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "LU_pivots",
        "type": "Tensor"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "unpack_data",
        "type": "bool"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "unpack_pivots",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "M": {
    "description": "Auto-generated from flax_nnx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "MA": {
    "description": "Auto-generated from flax_nnx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "MGrid": {
    "description": "Returns a dense multi-dimensional 'meshgrid'.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "MLPBlock": {
    "description": "Multilayer perceptron block composed of multiple FeedForward layers.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "in_features",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hidden_features",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "out_features",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "MSELoss": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "MakeAttentionMask": {
    "description": "Creates mask for attention weights (Flax utility).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "query_input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "key_input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "MakeCausalMask": {
    "description": "Creates causal mask for self-attention.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ManualSeed": {
    "description": "Sets the seed for generating random numbers.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "seed",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "MapState": {
    "description": "Maps a function over a State object.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "f",
        "type": "Callable"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "state",
        "type": "State"
      }
    ],
    "variants": {}
  },
  "MarginRankingLoss": {
    "description": "Creates a criterion that measures the loss given inputs x1, x2, two 1D mini-batch Tensors, and a label 1D mini-batch tensor y.",
    "std_args": [
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "margin",
        "type": "float"
      },
      {
        "default": "mean",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "reduction",
        "options": [
          "none",
          "mean",
          "sum"
        ],
        "type": "str"
      }
    ],
    "variants": {}
  },
  "Marginranking": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "MaskIndices": {
    "description": "Return the indices to access (n, n) arrays, given a masking function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "n",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mask_func",
        "type": "Callable"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "k",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "MaskedFill": {
    "description": "Fills elements of self tensor with value where mask is True.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "dtype": "bool",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mask",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "MaskedLmDataAugmenter": {
    "description": "Performs data augmentation according to the BERT paper.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "vocab_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mask_prob",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "MaskedNode": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "MaskedScatter": {
    "description": "Copies elements from source into self tensor at positions where the mask is True.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mask",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "source",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "MaskedSelect": {
    "description": "Returns a new 1-D tensor which indexes the input tensor according to the boolean mask.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mask",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "MaskedState": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Masking": {
    "description": "Masks a sequence by using a mask value to skip timesteps.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mask_value",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "MatMul": {
    "description": "Matrix product of two tensors.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "MatMulInteger": {
    "description": "Matrix product that behaves like [numpy.matmul](https://numpy.org/doc/stable/reference/generated/numpy.matmul.html). The production MUST never overflow. The accumulation may overflow if and only if in 32 bits.",
    "from": "Operators.md",
    "std_args": [
      [
        "A",
        "Any"
      ],
      [
        "B",
        "Any"
      ],
      [
        "a_zero_point",
        "Any"
      ],
      [
        "b_zero_point",
        "Any"
      ]
    ]
  },
  "Matmul": {
    "description": "Matrix product of two arrays.",
    "std_args": [
      "x1",
      "x2"
    ],
    "variants": {}
  },
  "Matrix": {
    "description": "Returns a matrix from an array-like object. (Deprecated in NumPy, maps to Array creation).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "MatrixExp": {
    "description": "Computes the matrix exponential.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "MatrixPower": {
    "description": "Computes the n-th power of a square matrix.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "n",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "MatrixRank": {
    "description": "Returns the numerical rank of a 2-D tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tol",
        "type": "float"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "symmetric",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "MatrixTranspose": {
    "description": "Transposes a matrix (or a stack of matrices) swapping the last two dimensions.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Matvec": {
    "description": "Matrix-vector dot product.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x1",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x2",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Max": {
    "description": "Returns the maximum value of all elements in the input tensor, or values and indices along dim.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "MaxNumBoundingBoxes": {
    "description": "Ensure the maximum number of bounding boxes.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "max_number",
        "type": "int"
      },
      {
        "default": -1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "fill_value",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "MaxPool": {
    "description": "Pools the input by taking the maximum of a window slice.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "inputs",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "window_shape",
        "type": "Union[int, Tuple[int, ...]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "strides",
        "type": "Union[int, Tuple[int, ...]]"
      },
      {
        "default": "VALID",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "MaxPool1d": {
    "description": "Applies a 1D max pooling over an input signal.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "MaxPool1dWithIndices": {
    "description": "Returns max pool values and indices.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "MaxPool2d": {
    "description": "Applies a 2D max pooling over an input signal.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "Union[int, Tuple[int, int]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "Union[int, Tuple[int, int]]"
      }
    ],
    "variants": {}
  },
  "MaxPool3d": {
    "description": "Applies a 3D max pooling over an input signal.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "MaxPooling1D": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "MaxPooling1d": {
    "description": "Max pooling operation for 1D temporal data (Alias).",
    "op_type": "class",
    "std_args": [
      {
        "default": 2,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "pool_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "strides",
        "type": "int"
      },
      {
        "default": "valid",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "MaxPooling2D": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "MaxPooling2d": {
    "description": "Max pooling operation for 2D spatial data (Alias).",
    "op_type": "class",
    "std_args": [
      {
        "default": [
          2,
          2
        ],
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "pool_size",
        "type": "Union[int, Tuple[int, int]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "strides",
        "type": "Union[int, Tuple[int, int]]"
      },
      {
        "default": "valid",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "MaxPooling3D": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "MaxPooling3d": {
    "description": "Max pooling operation for 3D data (Alias).",
    "op_type": "class",
    "std_args": [
      {
        "default": [
          2,
          2,
          2
        ],
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "pool_size",
        "type": "Union[int, Tuple[int, int, int]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "strides",
        "type": "Union[int, Tuple[int, int, int]]"
      },
      {
        "default": "valid",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "MaxRoiPool": {
    "description": "ROI max pool consumes an input tensor X and region of interests (RoIs) to apply max pooling across each RoI, to produce output 4-D tensor of shape (num_rois, channels, pooled_shape[0], pooled_shape[1]).",
    "from": "Operators.md",
    "std_args": [
      [
        "X",
        "Tensor"
      ],
      [
        "rois",
        "Tensor"
      ],
      [
        "pooled_shape",
        "List[int]"
      ],
      [
        "spatial_scale",
        "float"
      ]
    ]
  },
  "MaxUnpool": {
    "description": "MaxUnpool essentially computes the partial inverse of the MaxPool op. The input information to this op is typically the output information from a MaxPool op. The first input tensor X is the tensor that needs to be unpooled, which is typically the pooled tensor (first output) from MaxPool. The second...",
    "from": "Operators.md",
    "std_args": [
      [
        "X",
        "Any"
      ],
      [
        "I",
        "Any"
      ],
      [
        "output_shape",
        "Any"
      ],
      [
        "kernel_shape",
        "List[int]"
      ],
      [
        "pads",
        "List[int]"
      ],
      [
        "strides",
        "List[int]"
      ]
    ]
  },
  "MaxUnpool1d": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "MaxUnpool2d": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "MaxUnpool3d": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Maximum": {
    "description": "Computes the element-wise maximum of input and other.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Maxpool": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "MayShareMemory": {
    "description": "Determine if two arrays might share memory.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Mean": {
    "description": "Returns the mean value of all elements in the input tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "MeanAbsoluteError": {
    "description": "Computes the mean absolute error between labels and predictions.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_true",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_pred",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "MeanAbsolutePercentageError": {
    "description": "Computes the mean absolute percentage error between y_true & y_pred.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_true",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_pred",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "MeanSquaredError": {
    "description": "Computes the mean squared error between labels and predictions.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_true",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_pred",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "MeanSquaredLogarithmicError": {
    "description": "Computes the mean squared logarithmic error between y_true & y_pred.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_true",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_pred",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "MeanVarianceNormalization": {
    "description": "A MeanVarianceNormalization Function: Perform mean variance normalization on the input tensor X using formula: `(X-EX)/sqrt(E(X-EX)^2)`",
    "from": "Operators.md",
    "std_args": [
      [
        "X",
        "Tensor"
      ],
      [
        "axes",
        "List[int]"
      ]
    ]
  },
  "Median": {
    "description": "Returns the median of the values in input.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "MelSpectrogram": {
    "description": "A preprocessing layer to convert raw audio signals to Mel spectrograms.",
    "op_type": "class",
    "std_args": [
      {
        "default": 2048,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "fft_length",
        "type": "int"
      },
      {
        "default": 512,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "sequence_stride",
        "type": "int"
      },
      {
        "default": 128,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_mel_bins",
        "type": "int"
      },
      {
        "default": 16000,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "sampling_rate",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "MelWeightMatrix": {
    "description": "Generate a MelWeightMatrix that can be used to re-weight a Tensor containing a linearly sampled frequency spectra (from DFT or STFT) into num_mel_bins frequency information based on the [lower_edge_hertz, upper_edge_hertz] range on the mel scale. This function defines the mel scale in terms of a fre...",
    "from": "Operators.md",
    "std_args": [
      [
        "num_mel_bins",
        "Any"
      ],
      [
        "dft_length",
        "Any"
      ],
      [
        "sample_rate",
        "Any"
      ],
      [
        "lower_edge_hertz",
        "Any"
      ],
      [
        "upper_edge_hertz",
        "Any"
      ],
      [
        "output_datatype",
        "int"
      ]
    ]
  },
  "Memmap": {
    "description": "Create a memory-map to an array stored in a binary file on disk.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "filename",
        "type": "str"
      },
      {
        "default": "uint8",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "str"
      },
      {
        "default": "r+",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mode",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "shape",
        "type": "Tuple[int]"
      }
    ],
    "variants": {}
  },
  "MemoryFormat": {
    "description": "Enum for memory layout.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Merge": {
    "description": "Merges a GraphDef and State back into a module (NNX Functional API).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "graphdef",
        "type": "GraphDef"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "state",
        "type": "State"
      }
    ],
    "variants": {}
  },
  "MergeContext": {
    "description": "Merges context tags.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ctxtag",
        "type": "Hashable"
      }
    ],
    "variants": {}
  },
  "MergeState": {
    "description": "Merges multiple State objects.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "state",
        "type": "Mapping"
      },
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "states",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "MergeTypeFromTypeComment": {
    "description": "Internal JIT utility.",
    "std_args": [],
    "variants": {}
  },
  "Meshgrid": {
    "description": "Creates grids of coordinates specified by the 1D inputs.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "tensors",
        "type": "Any"
      },
      {
        "default": "ij",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "indexing",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "Metric": {
    "description": "Base class for metrics.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Mgrid": {
    "description": "Return dense multi-dimensional 'meshgrid'.",
    "std_args": [],
    "variants": {}
  },
  "Min": {
    "description": "Returns the minimum value of elements in the input tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "MinPool": {
    "description": "Pools the input by taking the minimum of a window slice.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "inputs",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "window_shape",
        "type": "Union[int, Tuple[int, ...]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "strides",
        "type": "Union[int, Tuple[int, ...]]"
      },
      {
        "default": "VALID",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "MinScalarType": {
    "description": "Returns the data type with the smallest size and scalar kind which can hold its value.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "MinTypeCode": {
    "description": "Return the character for the minimum-size type to which given types can be safely cast.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "typechars",
        "type": "List[str]"
      }
    ],
    "variants": {}
  },
  "Minimum": {
    "description": "Computes the element-wise minimum of input and other.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "MiopenBatchNorm": {
    "description": "Backend specific batch norm.",
    "std_args": [],
    "variants": {}
  },
  "MiopenConvolution": {
    "description": "Backend specific convolution.",
    "std_args": [],
    "variants": {}
  },
  "MiopenConvolutionAddRelu": {
    "description": "Backend specific fused convolution.",
    "std_args": [],
    "variants": {}
  },
  "MiopenConvolutionRelu": {
    "description": "Backend specific fused convolution.",
    "std_args": [],
    "variants": {}
  },
  "MiopenConvolutionTranspose": {
    "description": "Backend specific convolution transpose.",
    "std_args": [],
    "variants": {}
  },
  "MiopenDepthwiseConvolution": {
    "description": "Backend specific depthwise convolution.",
    "std_args": [],
    "variants": {}
  },
  "MiopenRnn": {
    "description": "Backend specific RNN.",
    "std_args": [],
    "variants": {}
  },
  "Mish": {
    "description": "Applies the Mish function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "MixUp": {
    "description": "MixUp implements the MixUp data augmentation technique.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.2,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "alpha",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "MkldnnAdaptiveAvgPool2d": {
    "description": "Applies adaptive average pooling (MKLDNN backend optimization).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "output_size",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "MkldnnConvolution": {
    "description": "Applies 2D convolution (MKLDNN backend optimization).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dilation",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "groups",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "MkldnnLinearBackwardWeights": {
    "description": "Computes backward pass for linear weights (MKLDNN).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "grad_output",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias_defined",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "MkldnnMaxPool2d": {
    "description": "Applies max pooling 2D (MKLDNN).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dilation",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ceil_mode",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "MkldnnMaxPool3d": {
    "description": "Applies max pooling 3D (MKLDNN).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "MkldnnRnnLayer": {
    "description": "Applies RNN layer (MKLDNN).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight0",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight1",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Mm": {
    "description": "Performs matrix multiplication (no broadcasting).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mat2",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Mod": {
    "description": "Element-wise remainder of division.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Mode": {
    "description": "Returns the mode value and indices starting with the first dimension.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "ModelAndOptimizer": {
    "description": "Container combining model and optimizer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "model",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "optimizer",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Modf": {
    "description": "Return the fractional and integral parts of an array, element-wise.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Module": {
    "description": "Base class for Neural Network modules.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "ModuleBase": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "ModuleContext": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "module_stack"
    ],
    "type": "class"
  },
  "ModuleDefApply": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "ModuleDeprecationWarning": {
    "description": "Module deprecation warning.",
    "std_args": [],
    "type": "class"
  },
  "ModuleDict": {
    "description": "Holds submodules in a dictionary.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "modules",
        "type": "Dict[str, Module]"
      }
    ],
    "variants": {}
  },
  "ModuleList": {
    "description": "Ordered list of sub-modules.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "modules",
        "type": "List"
      }
    ],
    "variants": {}
  },
  "ModuleMeta": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "ModuleStackEntry": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "module",
      "in_compact",
      "type_counter"
    ],
    "type": "class"
  },
  "ModuleState": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "mapping",
      "_copy"
    ],
    "type": "class"
  },
  "ModuleWrapper": {
    "description": "A subclass of ``torch.nn.Module`` that wraps a C++ frontend module and delegates all access.",
    "std_args": [
      "self",
      "cpp_module"
    ],
    "type": "class"
  },
  "MoveAxis": {
    "description": "Move axes of an array to new positions.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "source",
        "type": "int | List[int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "destination",
        "type": "int | List[int]"
      }
    ],
    "variants": {}
  },
  "Moveaxis": {
    "description": "Moves dimensions of input at positions source to destination.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "source",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "destination",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Movedim": {
    "description": "Moves the dimension(s) of input at the position(s) in source to the position(s) in destination.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "source",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "destination",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Mse": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Msort": {
    "description": "Sorts the elements of the input tensor along its first dimension in ascending order.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Mul": {
    "description": "Multiplies input by other.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "MultiHeadAttention": {
    "description": "Computes Multi-Head Attention.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "embed_dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_heads",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "MultiLabelMarginLoss": {
    "description": "Creates a criterion that optimizes a multi-class multi-classification",
    "std_args": [
      "self",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "MultiLabelSoftMarginLoss": {
    "description": "Creates a criterion that optimizes a multi-label one-versus-all",
    "std_args": [
      "self",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "MultiMarginLoss": {
    "description": "Creates a criterion that optimizes a multi-class classification hinge",
    "std_args": [
      "self",
      "p",
      "margin",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "MultiMetric": {
    "description": "Container for multiple metrics.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "metrics",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "MultiSteps": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "MultiStepsState": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "MultiTransformState": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "MultiheadAttention": {
    "description": "Dot-product attention with multiple heads.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "embed_dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_heads",
        "type": "int"
      },
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dropout",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Multinomial": {
    "description": "Returns a tensor where each row contains num_samples indices sampled from the multinomial probability distribution.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_samples",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "replacement",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Multiply": {
    "description": "Alias for Mul.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "MultiplyNoNan": {
    "description": "Computes product x*y, returns 0 if y is 0 (safe against NaNs in x).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "MultitaskResidualAdapter": {
    "description": "A multitask residual adapter layer.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Muon": {
    "description": "Optimizer that implements the Muon algorithm.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.001,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "learning_rate",
        "type": "float"
      },
      {
        "default": 0.95,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "momentum",
        "type": "float"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "nesterov",
        "type": "boolean"
      }
    ],
    "variants": {}
  },
  "Mv": {
    "description": "Performs a matrix-vector product of the matrix input and the vector vec.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "vec",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Mvlgamma": {
    "description": "Computes the multivariate log-gamma function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "p",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "NLLLoss": {
    "description": "The negative log likelihood loss. It is useful to train a classification",
    "std_args": [
      "self",
      "weight",
      "size_average",
      "ignore_index",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "NLLLoss2d": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "weight",
      "size_average",
      "ignore_index",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "NONE": {
    "description": "Auto-generated from flax_nnx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "NO_SWIZZLE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Nadam": {
    "description": "Optimizer that implements the Nadam algorithm.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.001,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "learning_rate",
        "type": "float"
      },
      {
        "default": 0.9,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta_1",
        "type": "float"
      },
      {
        "default": 0.999,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta_2",
        "type": "float"
      },
      {
        "default": "1e-07",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "epsilon",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "NamedShape": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Names": {
    "description": "Auto-generated from flax_nnx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Nan": {
    "description": "Returns a tensor filled with NaN values.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Dtype"
      }
    ],
    "variants": {}
  },
  "NanArgMax": {
    "description": "Return the indices of the maximum values in the specified axis ignoring NaNs.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "NanArgMin": {
    "description": "Return the indices of the minimum values in the specified axis ignoring NaNs.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "NanCumProd": {
    "description": "Return the cumulative product of array elements over a given axis treating NaNs as one.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "NanCumSum": {
    "description": "Return the cumulative sum of array elements over a given axis treating NaNs as zero.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "NanCumprod": {
    "description": "Cumulative product of elements along an axis, ignoring NaN values.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int | None"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "DType | None"
      }
    ],
    "variants": {}
  },
  "NanCumsum": {
    "description": "Cumulative sum of elements along an axis, ignoring NaN values.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int | None"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "DType | None"
      }
    ],
    "variants": {}
  },
  "NanMax": {
    "description": "Return the maximum of an array or maximum along an axis, ignoring any NaNs.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Array"
      },
      {
        "default": "None",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "default": "False",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "NanMean": {
    "description": "Computes the mean of all non-NaN elements.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "NanMedian": {
    "description": "Returns the median of the values in input, ignoring NaNs.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "NanMin": {
    "description": "Return minimum of an array or minimum along an axis, ignoring any NaNs.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Array"
      },
      {
        "default": "None",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "default": "False",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "NanPercentile": {
    "description": "Compute the qth percentile of the data along the specified axis, ignoring nan values.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "q",
        "type": "float"
      },
      {
        "default": "None",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "default": "False",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "NanProd": {
    "description": "Computes the product of array elements over a given axis, treating NaNs as ones.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Dtype"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "NanQuantile": {
    "description": "Computes the q-th quantile of the values in input, ignoring NaNs.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "q",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "NanStd": {
    "description": "Compute the standard deviation along the specified axis, while ignoring NaNs.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Array"
      },
      {
        "default": "None",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "default": "None",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Dtype"
      },
      {
        "default": "0",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ddof",
        "type": "int"
      },
      {
        "default": "False",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "NanSum": {
    "description": "Returns the sum of all elements, treating NaNs as zero.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "NanToNum": {
    "description": "Replaces NaN, positive infinity, and negative infinity values in input with valid numbers.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "nan",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "posinf",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "neginf",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "NanToNum_": {
    "description": "In-place version of nan_to_num.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "nan",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "NanVar": {
    "description": "Compute the variance along the specified axis, while ignoring NaNs.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Array"
      },
      {
        "default": "None",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "default": "None",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Dtype"
      },
      {
        "default": "0",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ddof",
        "type": "int"
      },
      {
        "default": "False",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Narrow": {
    "description": "Returns a new tensor that is a narrowed version of input tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "start",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "length",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "NarrowCopy": {
    "description": "Same as narrow except this returns a copy rather than shared storage.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "start",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "length",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "NativeBatchNorm": {
    "description": "Native batch normalization (often internal, maps to standard BN).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "running_mean",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "running_var",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "training",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "momentum",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "eps",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "NativeChannelShuffle": {
    "description": "Native kernel level implementation of the channel_shuffle.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "groups",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "NativeDropout": {
    "description": "Native dropout implementation.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "p",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "train",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "NativeGroupNorm": {
    "description": "Native group normalization.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "N",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "C",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "HxW",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "group",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "eps",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "NativeLayerNorm": {
    "description": "Native layer normalization.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "normalized_shape",
        "type": "List[int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "eps",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "NativeNorm": {
    "description": "Native norm operation (Internal).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "rank": 1,
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "NdArray": {
    "description": "Constructor for an array object.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "shape",
        "type": "Tuple[int]"
      },
      {
        "default": "None",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Dtype"
      }
    ],
    "variants": {}
  },
  "NdEnumerate": {
    "description": "Multidimensional index iterator.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "arr",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "NdIndex": {
    "description": "An N-dimensional iterator object to index arrays.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "shape",
        "type": "Tuple[int]"
      }
    ],
    "variants": {}
  },
  "NdIter": {
    "description": "Efficient multi-dimensional iterator object.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "op",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "Ndim": {
    "description": "Return the number of dimensions of an array.",
    "op_type": "attribute",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Ndtri": {
    "description": "Inverse error function / Quantile of Standard Normal.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Neg": {
    "description": "Neg takes one input data (Tensor<T>) and produces one output data (Tensor<T>) where each element flipped sign, y = -x, is applied to the tensor elementwise.",
    "std_args": [
      [
        "X",
        "Tensor"
      ]
    ],
    "type": "attribute"
  },
  "Negative": {
    "description": "Returns a new tensor with the negative of the elements of input.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "NegativeAlias": {
    "description": "Alias for Negative.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "NegativeAlias_": {
    "description": "In-place alias for Negative.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "NegativeLogLikelihoodLoss": {
    "description": "A NegativeLogLikelihoodLoss operator computes (weighted) negative log likelihood loss. Its \"input\" tensor has the shape of (N, C, d1, d2, ..., dk) where k >= 0. The \"input\" tensor contains log-probabilities for input[n, :, d_1, d_2,..., d_k] being in a class of [0, C). The operator's \"target\" input ...",
    "from": "Operators.md",
    "std_args": [
      [
        "input",
        "Tensor"
      ],
      [
        "target",
        "Any"
      ],
      [
        "weight",
        "Tensor"
      ],
      [
        "ignore_index",
        "int"
      ],
      [
        "reduction",
        "str"
      ]
    ]
  },
  "Negative_": {
    "description": "In-place version of Negative.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "NestedIters": {
    "description": "Create nditers for use in nested loops.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "op",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axes",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "NewAxis": {
    "description": "Attribute representing a new axis (None).",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "NextAfter": {
    "description": "Return the next floating-point value after input towards other.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Ngrammer": {
    "description": "Implements a generic N-grammer layer which looks up latent bi-gram id.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Nll": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "NoGrad": {
    "description": "Context manager that disables gradient calculation.",
    "op_type": "context",
    "std_args": [],
    "variants": {}
  },
  "Node": {
    "description": "JIT Graph Node.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "NodeStates": {
    "description": "Internal state storage for graph nodes.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "states",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "NonDynamicallyQuantizableLinear": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "in_features",
      "out_features",
      "bias",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "NonMaxSuppression": {
    "description": "Filter out boxes that have high intersection-over-union (IOU) overlap with previously selected boxes. Bounding boxes with score less than score_threshold are removed. Bounding box format is indicated by attribute center_point_box. Note that this algorithm is agnostic to where the origin is in the co...",
    "from": "Operators.md",
    "std_args": [
      [
        "boxes",
        "float"
      ],
      [
        "scores",
        "float"
      ],
      [
        "max_output_boxes_per_class",
        "int"
      ],
      [
        "iou_threshold",
        "float"
      ],
      [
        "score_threshold",
        "float"
      ],
      [
        "center_point_box",
        "int"
      ]
    ]
  },
  "NonNegativeParamsState": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "NonZero": {
    "description": "Returns a tensor containing the indices of all non-zero elements of input.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "NonZeroStatic": {
    "description": "Non-zero indices extraction (static). Internal/Legacy.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "NoneType": {
    "description": "JIT type representing None.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "NoopLogger": {
    "description": "Internal no-op logger.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Nop": {
    "description": "Auto-generated from numpy_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Norm": {
    "description": "Returns the matrix norm or vector norm of a given tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": "2",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "p",
        "type": "float"
      },
      {
        "default": "None",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "default": "False",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "NormExceptDim": {
    "description": "Calculates norm over all dimensions except dim.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Normal": {
    "description": "Returns a tensor of random numbers drawn from separate normal distributions.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mean",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "std",
        "type": "Tensor"
      },
      {
        "default": "None",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "List[int]"
      }
    ],
    "variants": {}
  },
  "Normalization": {
    "description": "A preprocessing layer that normalizes continuous features.",
    "op_type": "class",
    "std_args": [
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mean",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "variance",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Normalize": {
    "description": "Auto-generated from flax_nnx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Not": {
    "description": "Filter predicate for negation.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "filter",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "NotEqual": {
    "description": "Computes element-wise inequality comparison.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "NotEqualAlias": {
    "description": "Alias for NotEqual.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Nothing": {
    "description": "Sentinel value.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "NuclearNorm": {
    "description": "Computes the nuclear norm of a matrix.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Number": {
    "description": "Abstract base class of all numeric scalar types. (Type Definition)",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "NumberType": {
    "description": "JIT type representing Number.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Numel": {
    "description": "Returns the total number of elements in the input tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "OGrid": {
    "description": "An instance which returns an open multi-dimensional meshgrid.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Object": {
    "description": "Base class for NNX objects that are not Pytrees.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Object_": {
    "description": "Any Python object type.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "OfType": {
    "description": "Filter predicate matching a specific type.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "type",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "OneHot": {
    "description": "One-hot encodes the given indices.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_classes",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Ones": {
    "description": "Returns a tensor filled with the scalar value 1.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "List[int]"
      },
      {
        "default": "None",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "DType"
      }
    ],
    "variants": {}
  },
  "OnesLike": {
    "description": "Returns a tensor filled with the scalar value 1, with the same size as input.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": "None",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "DType"
      }
    ],
    "variants": {}
  },
  "OperatorInfo": {
    "description": "Metadata for operators.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "OptArray": {
    "description": "Optimizer state for an array.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "OptState": {
    "description": "Optimizer state variable type.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "OptVariable": {
    "description": "Optimizer variable type.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "OptaxTest": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "OptimizedLSTMCell": {
    "description": "LSTM Cell with optimized fused operations.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "features",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Optimizer": {
    "description": "Abstract optimizer base class.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Optional": {
    "description": "Constructs an optional-type value containing either an empty optional of a certain type specified by the attribute, or a non-empty value containing the input element.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "type",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "OptionalGetElement": {
    "description": "If the input is a tensor or sequence type, it returns the input. If the input is an optional type, it outputs the element in the input. It is an error if the input is an empty optional-type (i.e. does not have an element) and the behavior is undefined in this case.",
    "from": "Operators.md",
    "std_args": [
      [
        "input",
        "Any"
      ]
    ]
  },
  "OptionalHasElement": {
    "description": "Returns true if (1) the input is an optional-type and contains an element, or, (2) the input is a tensor or sequence type. If the input is not provided or is an empty optional-type, this op returns false.",
    "from": "Operators.md",
    "std_args": [
      [
        "input",
        "Any"
      ]
    ]
  },
  "OptionalType": {
    "description": "JIT type representing Optional[T].",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Or": {
    "description": "Returns the tensor resulted from performing the `or` logical operation elementwise on the input tensors `A` and `B` (with Numpy-style broadcasting support). This operator supports **multidirectional (i.e., Numpy-style) broadcasting**; for more details please check [the doc](Broadcasting.md).",
    "from": "Operators.md",
    "std_args": [
      [
        "A",
        "Tensor"
      ],
      [
        "B",
        "Tensor"
      ]
    ]
  },
  "OrderedDictWrapper": {
    "description": "A wrapper around a C++ OrderedDict.",
    "std_args": [
      "self",
      "cpp_module",
      "attr"
    ],
    "type": "class"
  },
  "OrgQr": {
    "description": "Computes the orthogonal matrix Q of a QR factorization.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tau",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "OrmQr": {
    "description": "Multiplies a matrix by the orthogonal matrix Q of a QR factorization.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tau",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "OutOfMemoryError": {
    "description": "Exception raised when device is out of memory.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Outer": {
    "description": "Outer product of input and vec2.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "vec2",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Output": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PRESCALE_QK": {
    "description": "Whether to pre-scale QK by 1/sqrt(d) and change of base. This is slightly faster but",
    "std_args": [],
    "type": "attribute"
  },
  "PRUNING_TYPE": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "PReLU": {
    "description": "Applies the element-wise Parametric ReLU.",
    "op_type": "class",
    "std_args": [
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_parameters",
        "type": "int"
      },
      {
        "default": 0.25,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "init",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "PRelu": {
    "description": "PRelu takes input data (Tensor<T>) and slope tensor as input, and produces one output data (Tensor<T>) where the function `f(x) = slope * x for x < 0`, `f(x) = x for x >= 0`., is applied to the data tensor elementwise. This operator supports **unidirectional broadcasting** (tensor slope should be un...",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "X",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "slope",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "PackBits": {
    "description": "Packs the elements of a binary-valued array into bits in a uint8 array.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Array"
      },
      {
        "default": "None",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "default": "'big'",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bitorder",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "PackedSequence": {
    "description": "Holds the data and list of :attr:`batch_sizes` of a packed sequence.",
    "std_args": [],
    "type": "class"
  },
  "PackedSequence_": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Pad": {
    "description": "Pad an array.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "array",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "pad_width",
        "type": "Sequence"
      },
      {
        "default": "constant",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mode",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "PairwiseDistance": {
    "description": "Computes the pairwise distance between vectors.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x1",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x2",
        "type": "Tensor"
      },
      {
        "default": "2.0",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "p",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Param": {
    "description": "Variable type for learnable parameters.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Parameter": {
    "description": "Auto-generated from flax_nnx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "ParameterDict": {
    "description": "Holds parameters in a dictionary.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "parameters",
        "type": "Dict[str, Any]"
      }
    ],
    "variants": {}
  },
  "ParameterList": {
    "description": "Auto-generated from flax_nnx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "ParametrizationList": {
    "description": "A sequential container that holds and manages the original parameters or buffers of a parametrized :class:`torch.nn.Module`.",
    "std_args": [
      "self",
      "modules",
      "original",
      "unsafe"
    ],
    "type": "class"
  },
  "ParseIr": {
    "description": "Internal JIT parser.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "ParseSchema": {
    "description": "Internal JIT parser for schemas.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "schema",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "ParseTypeComment": {
    "description": "Internal JIT parser for type comments.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "arg0",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "Partition": {
    "description": "Return a partitioned copy of an array.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kth",
        "type": "int"
      },
      {
        "default": "-1",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "PartitionName": {
    "description": "String conversion utility.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "obj",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "PartitionState": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "PathContains": {
    "description": "Path filter predicate.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "key",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "PcaLowRank": {
    "description": "Performs linear PCA on a low-rank matrix.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "A",
        "type": "Tensor"
      },
      {
        "default": "None",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "q",
        "type": "int"
      },
      {
        "default": "True",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "center",
        "type": "bool"
      },
      {
        "default": "2",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "niter",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Pdist": {
    "description": "Computes the p-norm distance between every pair of row vectors.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": "2",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "p",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "PerChannelAffine": {
    "description": "Per channel affine quantization (internal).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "PerChannelAffineFloatQParams": {
    "description": "Per channel affine quantization with float params (internal).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "PerChannelSymmetric": {
    "description": "Quantization utility for per-channel symmetric schemes.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "PerDimScale": {
    "description": "A layer to scale individual dims of the input.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "PerTensorAffine": {
    "description": "Quantization utility for per-tensor affine schemes.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "PerTensorSymmetric": {
    "description": "Quantization utility for per-tensor symmetric schemes.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Percentile": {
    "description": "Compute the q-th percentile of the data along the specified axis.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "q",
        "type": "float"
      },
      {
        "default": "None",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "Optional[Union[int, Tuple[int]]]"
      },
      {
        "default": "False",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Permute": {
    "description": "Returns a view of the original tensor input with its dimensions permuted.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dims",
        "type": "List[int]"
      }
    ],
    "variants": {}
  },
  "PermuteCopy": {
    "description": "Performs the same operation as permute, but output is freshly created.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dims",
        "type": "List[int]"
      }
    ],
    "variants": {}
  },
  "PermuteDims": {
    "description": "Permutes the dimensions of an array.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axes",
        "type": "Tuple[int]"
      }
    ],
    "variants": {}
  },
  "Perturbation": {
    "description": "Variable type for perturbations.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Pi": {
    "description": "The mathematical constant Pi.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Piecewise": {
    "description": "Evaluate a piecewise-defined function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "condlist",
        "type": "List[Array]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "funclist",
        "type": "List[Callable]"
      }
    ],
    "variants": {}
  },
  "Pinverse": {
    "description": "Computes the pseudoinverse (Moore-Penrose inverse) of a matrix.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": "1e-15",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "rcond",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Pipeline": {
    "description": "Applies a series of layers to an input.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "layers",
        "type": "List"
      }
    ],
    "variants": {}
  },
  "PipelinedTransformer": {
    "description": "A pipelined Transformer layer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "model_dims",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_layers",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "PixelShuffle": {
    "description": "Rearranges elements in a tensor of shape (*, C x r^2, H, W) to (*, C, H x r, W x r).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "upscale_factor",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "PixelUnshuffle": {
    "description": "Reverses the PixelShuffle operation.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "downscale_factor",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Place": {
    "description": "Change elements of an array based on conditional and input values.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "arr",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mask",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "vals",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "Pmap": {
    "description": "Parallel map over devices.",
    "op_type": "decorator",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "f",
        "type": "Callable"
      }
    ],
    "variants": {}
  },
  "Poisson": {
    "description": "Returns a tensor of the same size as input with each element sampled from a Poisson distribution.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "generator",
        "type": "Optional[Generator]"
      }
    ],
    "variants": {}
  },
  "PoissonLoss": {
    "description": "Computes the Poisson loss between y_true and y_pred.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_true",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_pred",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "PoissonNLLLoss": {
    "description": "Negative log likelihood loss with Poisson distribution of target.",
    "std_args": [
      "self",
      "log_input",
      "full",
      "size_average",
      "eps",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "PoissonNllLoss": {
    "description": "Poisson Negative Log Likelihood Loss.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "target",
        "type": "Tensor"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "log_input",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "full",
        "type": "bool"
      },
      {
        "default": "1e-08",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "eps",
        "type": "float"
      },
      {
        "default": "mean",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "reduction",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "Polar": {
    "description": "Constructs a complex tensor from polar coordinates.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "abs",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "angle",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Poly": {
    "description": "Find the coefficients of a polynomial with the given sequence of roots.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "seq_of_zeros",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "Poly1d": {
    "description": "A one-dimensional polynomial class.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "c_or_r",
        "type": "Array"
      },
      {
        "default": "False",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "r",
        "type": "bool"
      },
      {
        "default": "None",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "variable",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "PolyAdd": {
    "description": "Find the sum of two polynomials.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a1",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a2",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "PolyDer": {
    "description": "Return the derivative of the specified order of a polynomial.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "p",
        "type": "Array"
      },
      {
        "default": "1",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "m",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "PolyDiv": {
    "description": "Returns the quotient and remainder of polynomial division.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "u",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "v",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "PolyFit": {
    "description": "Least squares polynomial fit.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "deg",
        "type": "int"
      },
      {
        "default": "None",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "rcond",
        "type": "float"
      },
      {
        "default": "False",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "full",
        "type": "bool"
      },
      {
        "default": "None",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "w",
        "type": "Array"
      },
      {
        "default": "False",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "cov",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "PolyInt": {
    "description": "Return an antiderivative (indefinite integral) of a polynomial.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "p",
        "type": "Array"
      },
      {
        "default": "1",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "m",
        "type": "int"
      },
      {
        "default": "None",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "k",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "PolyMul": {
    "description": "Find the product of two polynomials.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a1",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a2",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "PolySub": {
    "description": "Difference (subtraction) of two polynomials.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a1",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a2",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "PolyVal": {
    "description": "Evaluate a polynomial at specific values.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "p",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "Polygamma": {
    "description": "Computes the polygamma function psi^(n)(x).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "n",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Polyint": {
    "description": "Returns the coefficients of the integration of specified order of a polynomial.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "p",
        "type": "Tensor"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "m",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "k",
        "type": "int | Tensor | None"
      }
    ],
    "variants": {}
  },
  "Polymul": {
    "description": "Returns the product of two polynomials.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a1",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a2",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Polysub": {
    "description": "Returns the difference of two polynomials.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a1",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a2",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Polyval": {
    "description": "Evaluate a polynomial at specific values.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "coeffs",
        "type": "List[Tensor]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Pool": {
    "description": "Helper function to define pooling functions.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "inputs",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "init",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "reduce_fn",
        "type": "Callable"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "window_shape",
        "type": "Tuple"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "strides",
        "type": "Tuple"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "Pooling": {
    "description": "Pooling layer, performing max or average pooling.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "window_shape",
        "type": "Sequence[int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "window_stride",
        "type": "Sequence[int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "pooling_type",
        "options": [
          "MAX",
          "AVG"
        ],
        "type": "str"
      }
    ],
    "variants": {}
  },
  "Pooling1D": {
    "description": "Pooling layer over dimension 1.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "window",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "int"
      },
      {
        "default": "AVG",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "pooling_type",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "Pop": {
    "description": "Pops variable types from the graph node.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "node",
        "type": "Module"
      },
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "filters",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "PositionalEmbedding": {
    "description": "Generates position embedding for a given 1-d sequence.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "embedding_dims",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "max_timescale",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "PositionalEmbedding2D": {
    "description": "Generates 2-d position embedding for sequence of flattened patches.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "embedding_dims",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Positive": {
    "description": "Returns input. Equivalent to +input.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Pow": {
    "description": "Takes the power of each element in input with exponent.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "exponent",
        "type": "Union[Tensor, float]"
      }
    ],
    "variants": {}
  },
  "Power": {
    "description": "First array elements raised to powers from second array, element-wise.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x1",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x2",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Prelu": {
    "description": "Applies element-wise PReLU function: max(0,x) + weight * min(0,x).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "PrepareMultiprocessingEnvironment": {
    "description": "PyTorch specific utility for multiprocessing setup.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "path",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "PreserveFormat": {
    "description": "Preservation logic, likely profiling or internal. No standard equivalent.",
    "std_args": [],
    "variants": {}
  },
  "PrintOptions": {
    "description": "Context manager for setting print options.",
    "op_type": "context",
    "std_args": [],
    "variants": {}
  },
  "Printoptions": {
    "description": "Context manager for setting print options.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "var_keyword",
        "name": "kwargs",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "PrivateOps": {
    "description": "Internal private operations registry.",
    "std_args": [],
    "variants": {}
  },
  "Prod": {
    "description": "Returns the product of all elements in the input tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "Optional[int]"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "ProfilerAllowCudagraphCuptiLazyReinitCuda12": {
    "description": "PyTorch internal profiler configuration.",
    "std_args": [],
    "variants": {}
  },
  "ProjectLastDim": {
    "description": "Linear projection on the last dim of the input Tensor using Einsum.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "inputs",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "PromoteTypes": {
    "description": "Returns the dtype with the smallest size and scalar kind that is not smaller than either type1 or type2.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "type1",
        "type": "DType"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "type2",
        "type": "DType"
      }
    ],
    "variants": {}
  },
  "PruningContainer": {
    "description": "Container holding a sequence of pruning methods for iterative pruning.",
    "std_args": [
      "self",
      "args"
    ],
    "type": "class"
  },
  "Ptp": {
    "description": "Range of values (maximum - minimum) along an axis.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Pure": {
    "description": "Returns a new tree with all Variable objects replaced with inner values.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tree",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "PureState": {
    "description": "Helper for tuple/state construction.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Put": {
    "description": "Copies value into input at indices.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "index",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "source",
        "type": "Tensor"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "accumulate",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "PutAlongAxis": {
    "description": "Put values into the destination array by matching 1d index and data slices.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "arr",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "indices",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "values",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "PutMask": {
    "description": "Changes elements of an array based on conditional and input values.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mask",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "values",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "PyObjectType": {
    "description": "JIT type representing generic Python object.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "PyTorchFileReader": {
    "description": "Internal file reader.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "PyTorchFileWriter": {
    "description": "Internal file writer.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Pytree": {
    "description": "Base class for Pytree-registered objects.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "QInt32": {
    "description": "Quantized Int32 Dtype.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "QInt32Storage": {
    "description": "Contiguous storage for quantized int32 data.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "wrap_storage",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "device",
        "type": "Any"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "_internal",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "QInt8": {
    "description": "Quantized Int8 Dtype.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "QInt8Storage": {
    "description": "Contiguous storage for quantized int8 data.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "wrap_storage",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "device",
        "type": "Any"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "_internal",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "QLinearConv": {
    "description": "The convolution operator consumes a quantized input tensor, its scale and zero point, a quantized filter, its scale and zero point, and output's scale and zero point, and computes the quantized output. Each scale and zero-point pair must have same shape. It means they must be either scalars (per ten...",
    "from": "Operators.md",
    "std_args": [
      [
        "x",
        "Any"
      ],
      [
        "x_scale",
        "float"
      ],
      [
        "x_zero_point",
        "Any"
      ],
      [
        "w",
        "Any"
      ],
      [
        "w_scale",
        "float"
      ],
      [
        "w_zero_point",
        "Any"
      ],
      [
        "y_scale",
        "float"
      ],
      [
        "y_zero_point",
        "Any"
      ],
      [
        "B",
        "Any"
      ],
      [
        "auto_pad",
        "str"
      ],
      [
        "dilations",
        "List[int]"
      ],
      [
        "group",
        "int"
      ],
      [
        "kernel_shape",
        "List[int]"
      ],
      [
        "pads",
        "List[int]"
      ],
      [
        "strides",
        "List[int]"
      ]
    ]
  },
  "QLinearMatMul": {
    "description": "Matrix product that behaves like [numpy.matmul](https://numpy.org/doc/stable/reference/generated/numpy.matmul.html). It consumes two quantized input tensors, their scales and zero points, scale and zero point of output, and computes the quantized output. The quantization formula is y = saturate((x /...",
    "from": "Operators.md",
    "std_args": [
      [
        "a",
        "Any"
      ],
      [
        "a_scale",
        "Any"
      ],
      [
        "a_zero_point",
        "Any"
      ],
      [
        "b",
        "Any"
      ],
      [
        "b_scale",
        "Any"
      ],
      [
        "b_zero_point",
        "Any"
      ],
      [
        "y_scale",
        "Any"
      ],
      [
        "y_zero_point",
        "Any"
      ]
    ]
  },
  "QPerChannelAxis": {
    "description": "Quantization utility for accessing per-channel axis.",
    "std_args": [],
    "variants": {}
  },
  "QPerChannelScales": {
    "description": "Quantization utility for accessing per-channel scales.",
    "std_args": [],
    "variants": {}
  },
  "QPerChannelZeroPoints": {
    "description": "Quantization utility for accessing per-channel zero points.",
    "std_args": [],
    "variants": {}
  },
  "QQLinear": {
    "description": "Quantized Linear layer (Quantized input + weights).",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "in_features",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "out_features",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bits",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "QScale": {
    "description": "Quantization utility: returns scale of a quantized tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "QScheme": {
    "description": "Class defining quantization schemes used in PyTorch.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "QUInt2x4Storage": {
    "description": "Storage for quantized 2x4 int8 tensors.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "QUInt4x2Storage": {
    "description": "Storage for quantized 4x2 int8 tensors.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "QUInt8Storage": {
    "description": "Storage for quantized int8 tensors.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "QZeroPoint": {
    "description": "Quantization utility: returns zero_point of a quantized tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Qqmm": {
    "description": "Quantized Matrix Multiplication.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "w",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "scales",
        "type": "Tensor | None"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "group_size",
        "type": "int | None"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bits",
        "type": "int | None"
      },
      {
        "default": "nvfp4",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mode",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "Qr": {
    "description": "Computes the QR decomposition of input.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "some",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Quantile": {
    "description": "Computes the q-th quantiles of each row of the input tensor along the dimension dim.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "q",
        "type": "float"
      },
      {
        "default": "None",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "default": "False",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "bool"
      },
      {
        "default": "'linear'",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "interpolation",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "Quantize": {
    "description": "Quantize the sub-modules of a module according to a predicate.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "model",
        "type": "Module"
      },
      {
        "default": 64,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "group_size",
        "type": "int"
      },
      {
        "default": 4,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bits",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "QuantizeLinear": {
    "description": "The linear quantization operator consumes a high-precision tensor, a scale, and a zero point to compute the low-precision/quantized tensor. The scale factor and zero point must have the same shape, determining the quantization granularity. The quantization formula is `y = saturate((x / y_scale) + y_...",
    "from": "Operators.md",
    "std_args": [
      [
        "x",
        "Any"
      ],
      [
        "y_scale",
        "Any"
      ],
      [
        "y_zero_point",
        "Any"
      ],
      [
        "axis",
        "int"
      ],
      [
        "block_size",
        "int"
      ],
      [
        "output_dtype",
        "int"
      ],
      [
        "precision",
        "int"
      ],
      [
        "saturate",
        "int"
      ]
    ]
  },
  "QuantizePerChannel": {
    "description": "Converts a float tensor to a per-channel quantized tensor with given scales and zero points.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "scales",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "zero_points",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "QuantizePerTensor": {
    "description": "Converts a float tensor to a quantized tensor with given scale and zero point.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "scale",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "zero_point",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "QuantizePerTensorDynamic": {
    "description": "Converts a float tensor to a quantized tensor with scale and zero_point calculated dynamically.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      },
      {
        "default": "False",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "reduce_range",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "QuantizeVector": {
    "description": "Vector quantization.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "latent",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "codebook",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "QuantizedAllToShardedLinear": {
    "description": "Quantized distributed linear layer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "in_features",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "out_features",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "QuantizedBatchNorm": {
    "description": "Applies batch normalization on a quantized tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mean",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "var",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "eps",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "output_scale",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "output_zero_point",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "QuantizedEmbedding": {
    "description": "Embedding layer with quantized weights.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_embeddings",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "embedding_dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "QuantizedGru": {
    "description": "Applies a multi-layer quantized GRU RNN to an input sequence.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "batch_sizes",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hx",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "params",
        "type": "List[Tensor]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "has_biases",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_layers",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dropout",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "train",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bidirectional",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "QuantizedGruCell": {
    "description": "Applies a quantized GRU cell to inputs.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hx",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "w_ih",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "w_hh",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b_ih",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b_hh",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "packed_ih",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "packed_hh",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "col_offsets",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "scale",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "zero_point",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "QuantizedLinear": {
    "description": "Applies a linear transformation with quantized weights.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "in_features",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "out_features",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bits",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "QuantizedLstm": {
    "description": "Applies a multi-layer quantized LSTM RNN to an input sequence.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "batch_sizes",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hx",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "params",
        "type": "List[Tensor]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "has_biases",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_layers",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dropout",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "train",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bidirectional",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "QuantizedLstmCell": {
    "description": "Applies a quantized LSTM cell to inputs.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hx",
        "type": "Tuple[Tensor, Tensor]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "w_ih",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "w_hh",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b_ih",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b_hh",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "packed_ih",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "packed_hh",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "col_offsets",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "scale",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "zero_point",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "QuantizedMatmul": {
    "description": "Matrix multiplication with a quantized weight matrix.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "w",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "scales",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "biases",
        "type": "Tensor | None"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "transpose",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "group_size",
        "type": "int | None"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bits",
        "type": "int | None"
      },
      {
        "default": "affine",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mode",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "QuantizedMaxPool1d": {
    "description": "Applies a 1D max pooling over an input quantized tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "Union[int, List[int]]"
      },
      {
        "default": "[]",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "Union[int, List[int]]"
      },
      {
        "default": "0",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "Union[int, List[int]]"
      },
      {
        "default": "1",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dilation",
        "type": "Union[int, List[int]]"
      },
      {
        "default": "False",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ceil_mode",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "QuantizedMaxPool2d": {
    "description": "Applies a 2D max pooling over an input quantized tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "Union[int, List[int]]"
      },
      {
        "default": "[]",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "Union[int, List[int]]"
      },
      {
        "default": "0",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "Union[int, List[int]]"
      },
      {
        "default": "1",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dilation",
        "type": "Union[int, List[int]]"
      },
      {
        "default": "False",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ceil_mode",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "QuantizedMaxPool3d": {
    "description": "Applies a 3D max pooling over an input quantized tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "Union[int, List[int]]"
      },
      {
        "default": "[]",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "Union[int, List[int]]"
      },
      {
        "default": "0",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "Union[int, List[int]]"
      },
      {
        "default": "1",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dilation",
        "type": "Union[int, List[int]]"
      },
      {
        "default": "False",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ceil_mode",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "QuantizedRnnReluCell": {
    "description": "Applies a quantized RNN cell with ReLU non-linearity to inputs.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hx",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "w_ih",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "w_hh",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b_ih",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b_hh",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "packed_ih",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "packed_hh",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "col_offsets",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "scale",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "zero_point",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "QuantizedRnnTanhCell": {
    "description": "Applies a quantized RNN cell with Tanh non-linearity to inputs.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hx",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "w_ih",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "w_hh",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b_ih",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b_hh",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "packed_ih",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "packed_hh",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "col_offsets",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "scale",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "zero_point",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "QuantizedShardedToAllLinear": {
    "description": "Quantized distributed linear layer (gather).",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "in_features",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "out_features",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Quint2x4": {
    "description": "Data type for quint2x4 quantized tensors.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Quint4x2": {
    "description": "Data type for quint4x2 quantized tensors.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Quint8": {
    "description": "Data type for quint8 quantized tensors.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "RMSNorm": {
    "description": "Applies Root Mean Square Normalization.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "default": "1e-5",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "eps",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "RMSNormalization": {
    "description": "Root Mean Square (RMS) Normalization layer.",
    "op_type": "class",
    "std_args": [
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "default": "1e-6",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "epsilon",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "RMSprop": {
    "description": "Optimizer that implements the RMSprop algorithm.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.001,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "learning_rate",
        "type": "float"
      },
      {
        "default": 0.9,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "rho",
        "type": "float"
      },
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "momentum",
        "type": "float"
      },
      {
        "default": "1e-07",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "epsilon",
        "type": "float"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "centered",
        "type": "boolean"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight_decay",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "RNN": {
    "description": "Elman recurrent layer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hidden_size",
        "type": "int"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bias",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "RNNBase": {
    "description": "Auto-generated from flax_nnx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "RNNCell": {
    "description": "An Elman RNN cell with tanh or ReLU non-linearity.",
    "std_args": [
      "self",
      "input_size",
      "hidden_size",
      "bias",
      "nonlinearity",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "RNNCellBase": {
    "description": "Base class for RNN Cells.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "ROWS_GUARANTEED_SAFE": {
    "description": "If True, guarantees that at least one value in each row is not masked out.",
    "std_args": [],
    "type": "attribute"
  },
  "RPC_AVAILABLE": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "RReLU": {
    "description": "Applies the randomized leaky rectified linear unit function, element-wise.",
    "std_args": [
      "self",
      "lower",
      "upper",
      "inplace"
    ],
    "type": "class"
  },
  "RRefType": {
    "description": "Type hint for Remote References (RPC).",
    "std_args": [],
    "variants": {}
  },
  "R_": {
    "description": "Translates slice objects to concatenation along the first axis.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Rad2Deg": {
    "description": "Returns a new tensor with each of the elements of input converted from angles in radians to degrees.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Rad2Deg_": {
    "description": "In-place version of rad2deg.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Rad2deg": {
    "description": "Convert angles from radians to degrees.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Radians": {
    "description": "Convert angles from degrees to radians.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "Rand": {
    "description": "Returns a tensor filled with random numbers from a uniform distribution on [0, 1).",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "int"
      },
      {
        "default": "None",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "RandAugment": {
    "description": "RandAugment performs the Rand Augment operation on input images.",
    "op_type": "class",
    "std_args": [
      {
        "default": 2,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_ops",
        "type": "int"
      },
      {
        "default": 9,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "magnitude",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "RandInt": {
    "description": "Returns a tensor filled with random integers generated uniformly between low (inclusive) and high (exclusive).",
    "std_args": [
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "low",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "high",
        "type": "int"
      },
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "RandIntLike": {
    "description": "Returns a tensor with the same shape as Tensor input filled with random integers.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "low",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "high",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "RandLike": {
    "description": "Returns a tensor with the same size as input that is filled with random numbers from a uniform distribution.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": "None",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "RandPerm": {
    "description": "Returns a random permutation of integers from 0 to n - 1.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "n",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Randn": {
    "description": "Returns a tensor filled with random numbers from a normal distribution with mean 0 and variance 1.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "RandnLike": {
    "description": "Returns a tensor with the same size as input that is filled with random numbers from a normal distribution.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "RandomBrightness": {
    "description": "A preprocessing layer which randomly adjusts brightness during training.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "factor",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "RandomColorDegeneration": {
    "description": "Randomly performs the color degeneration operation on given images.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "factor",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "RandomColorJitter": {
    "description": "Randomly apply brightness, contrast, saturation and hue image processing.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "brightness_factor",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "contrast_factor",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "saturation_factor",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hue_factor",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "RandomContrast": {
    "description": "A preprocessing layer which randomly adjusts contrast during training.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "factor",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "RandomCrop": {
    "description": "A preprocessing layer which randomly crops images during training.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "height",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "width",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "RandomElasticTransform": {
    "description": "A preprocessing layer that applies random elastic transformations.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "RandomErasing": {
    "description": "Random Erasing data augmentation technique.",
    "op_type": "class",
    "std_args": [
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "factor",
        "type": "float"
      },
      {
        "default": [
          0.02,
          0.33
        ],
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "scale",
        "type": "Tuple[float, float]"
      }
    ],
    "variants": {}
  },
  "RandomFlip": {
    "description": "A preprocessing layer which randomly flips images during training.",
    "op_type": "class",
    "std_args": [
      {
        "default": "horizontal_and_vertical",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mode",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "RandomGaussianBlur": {
    "description": "Applies random Gaussian blur to images for data augmentation.",
    "op_type": "class",
    "std_args": [
      {
        "default": 3,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "int"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "sigma",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "RandomGrayscale": {
    "description": "Preprocessing layer for random conversion of RGB images to grayscale.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.5,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "factor",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "RandomHorizontalFlip": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "RandomHue": {
    "description": "Randomly adjusts the hue on given images.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "factor",
        "type": "float"
      },
      {
        "default": [
          0,
          255
        ],
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value_range",
        "type": "Tuple[int, int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "seed",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "RandomInvert": {
    "description": "Preprocessing layer for random inversion of image colors.",
    "op_type": "class",
    "std_args": [
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "factor",
        "type": "float"
      },
      {
        "default": [
          0,
          255
        ],
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value_range",
        "type": "Tuple[int, int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "seed",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "RandomNormal": {
    "description": "Generate a tensor with random values drawn from a normal distribution. The shape of the tensor is specified by the `shape` argument and the parameter of the normal distribution specified by `mean` and `scale`. The data type is specified by the 'dtype' argument. The 'dtype' argument must be one of th...",
    "from": "Operators.md",
    "std_args": [
      [
        "dtype",
        "int"
      ],
      [
        "mean",
        "float"
      ],
      [
        "scale",
        "float"
      ],
      [
        "seed",
        "float"
      ],
      [
        "shape",
        "List[int]"
      ]
    ]
  },
  "RandomNormalLike": {
    "description": "Generate a tensor with random values drawn from a normal distribution. The shape of the output tensor is copied from the shape of the input tensor, and the parameters of the normal distribution are specified by `mean` and `scale`. The data type is specified by the 'dtype' argument, or copied from th...",
    "from": "Operators.md",
    "std_args": [
      [
        "input",
        "Any"
      ],
      [
        "dtype",
        "int"
      ],
      [
        "mean",
        "float"
      ],
      [
        "scale",
        "float"
      ],
      [
        "seed",
        "float"
      ]
    ]
  },
  "RandomPerspective": {
    "description": "A preprocessing layer that applies random perspective transformations.",
    "op_type": "class",
    "std_args": [
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "factor",
        "type": "float"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "scale",
        "type": "float"
      },
      {
        "default": "bilinear",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "interpolation",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "seed",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "RandomPosterization": {
    "description": "Reduces the number of bits for each color channel.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "factor",
        "type": "int"
      },
      {
        "default": [
          0,
          255
        ],
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value_range",
        "type": "Tuple[int, int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "seed",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "RandomRotation": {
    "description": "Randomly rotates images during training.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "factor",
        "type": "float"
      },
      {
        "default": "reflect",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "fill_mode",
        "type": "str"
      },
      {
        "default": "bilinear",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "interpolation",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "seed",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "RandomSaturation": {
    "description": "Randomly adjusts the saturation on given images.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "factor",
        "type": "float"
      },
      {
        "default": [
          0,
          255
        ],
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value_range",
        "type": "Tuple[int, int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "seed",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "RandomSharpness": {
    "description": "Randomly performs the sharpness operation on given images.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "factor",
        "type": "float"
      },
      {
        "default": [
          0,
          255
        ],
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value_range",
        "type": "Tuple[int, int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "seed",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "RandomShear": {
    "description": "Randomly applies shear transformations.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x_factor",
        "type": "float"
      },
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_factor",
        "type": "float"
      },
      {
        "default": "bilinear",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "interpolation",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "seed",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "RandomStructured": {
    "description": "Prune entire (currently unpruned) channels in a tensor at random.",
    "std_args": [
      "self",
      "amount",
      "dim"
    ],
    "type": "class"
  },
  "RandomTranslation": {
    "description": "Randomly translates images.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "height_factor",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "width_factor",
        "type": "float"
      },
      {
        "default": "bilinear",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "interpolation",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "seed",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "RandomUniform": {
    "description": "Generate a tensor with random values drawn from a uniform distribution. The shape of the tensor is specified by the `shape` argument and the range by `low` and `high`. The data type is specified by the 'dtype' argument. The 'dtype' argument must be one of the data types specified in the 'DataType' e...",
    "from": "Operators.md",
    "std_args": [
      [
        "dtype",
        "int"
      ],
      [
        "high",
        "float"
      ],
      [
        "low",
        "float"
      ],
      [
        "seed",
        "float"
      ],
      [
        "shape",
        "List[int]"
      ]
    ]
  },
  "RandomUniformLike": {
    "description": "Generate a tensor with random values drawn from a uniform distribution. The shape of the output tensor is copied from the shape of the input tensor, and the parameters of the uniform distribution are specified by `low` and `high`. The data type is specified by the 'dtype' argument, or copied from th...",
    "from": "Operators.md",
    "std_args": [
      [
        "input",
        "Any"
      ],
      [
        "dtype",
        "int"
      ],
      [
        "high",
        "float"
      ],
      [
        "low",
        "float"
      ],
      [
        "seed",
        "float"
      ]
    ]
  },
  "RandomUnstructured": {
    "description": "Prune (currently unpruned) units in a tensor at random.",
    "std_args": [
      "self",
      "amount"
    ],
    "type": "class"
  },
  "RandomVectorQuantizer": {
    "description": "Random quantization for BEST-RQ.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "projection_dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "RandomVerticalFlip": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "RandomZoom": {
    "description": "Randomly zooms images.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "height_factor",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "width_factor",
        "type": "float"
      },
      {
        "default": "bilinear",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "interpolation",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "seed",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Range": {
    "description": "Returns a 1-D tensor of size floor((end - start) / step) + 1 with values from start to end with step step.",
    "std_args": [
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "start",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "end",
        "type": "float"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "step",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Ravel": {
    "description": "Return a contiguous flattened tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "RavelMultiIndex": {
    "description": "Converts a tuple of index arrays into an array of flat indices, applying boundary modes to the multi-index.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "multi_index",
        "type": "Tuple[Array]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dims",
        "type": "Tuple[int]"
      },
      {
        "default": "raise",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mode",
        "options": [
          "raise",
          "wrap",
          "clip"
        ],
        "type": "str"
      },
      {
        "default": "C",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "order",
        "options": [
          "C",
          "F"
        ],
        "type": "str"
      }
    ],
    "variants": {}
  },
  "ReLU": {
    "description": "Rectified Linear Unit activation layer.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "ReLU2": {
    "description": "Applies the ReLU activation capped at 2, or squared ReLU depending on framework interpretation.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "ReLU6": {
    "description": "ReLU6 activation layer.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "ReadVitals": {
    "description": "Reads internal system vitals. Internal utility.",
    "std_args": [],
    "variants": {}
  },
  "Real": {
    "description": "Returns the real part of a complex tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "RealIfClose": {
    "description": "If input is complex with all imaginary parts close to zero, return real parts.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Array"
      },
      {
        "default": "100",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tol",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "RecArray": {
    "description": "Construct an ndarray that allows field access using attributes.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "shape",
        "type": "Tuple[int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "buf",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Reciprocal": {
    "description": "Returns a new tensor with the reciprocal of the elements of input.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ReciprocalNoNan": {
    "description": "Safe reciprocal, returns 0 where input is 0.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Reciprocal_": {
    "description": "In-place version of Reciprocal.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Record": {
    "description": "A data-type scalar that allows field access as attribute lookup.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "length_or_data",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "RecursiveMap": {
    "description": "Recursively applies a function to all nodes and leaves.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "f",
        "type": "Callable"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "node",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "ReduceL1": {
    "description": "Computes the L1 norm of the input tensor's elements along the provided axes. The resulting tensor has the same rank as the input if `keepdims` equals 1. If `keepdims` equals 0, then the resulting tensor has the reduced dimension pruned. Input tensors of rank zero are valid. Reduction over an empty s...",
    "from": "Operators.md",
    "std_args": [
      [
        "data",
        "Tensor"
      ],
      [
        "axes",
        "int"
      ],
      [
        "keepdims",
        "int"
      ],
      [
        "noop_with_empty_axes",
        "int"
      ]
    ]
  },
  "ReduceL2": {
    "description": "Computes the L2 norm of the input tensor's elements along the provided axes. The resulting tensor has the same rank as the input if `keepdims` equals 1. If `keepdims` equals 0, then the resulting tensor has the reduced dimension pruned. Input tensors of rank zero are valid. Reduction over an empty s...",
    "from": "Operators.md",
    "std_args": [
      [
        "data",
        "Tensor"
      ],
      [
        "axes",
        "int"
      ],
      [
        "keepdims",
        "int"
      ],
      [
        "noop_with_empty_axes",
        "int"
      ]
    ]
  },
  "ReduceLogSum": {
    "description": "Computes the log sum of the input tensor's elements along the provided axes. The resulting tensor has the same rank as the input if `keepdims` equals 1. If `keepdims` equals 0, then the resulting tensor has the reduced dimension pruned. Input tensors of rank zero are valid. Reduction over an empty s...",
    "from": "Operators.md",
    "std_args": [
      [
        "data",
        "Tensor"
      ],
      [
        "axes",
        "int"
      ],
      [
        "keepdims",
        "int"
      ],
      [
        "noop_with_empty_axes",
        "int"
      ]
    ]
  },
  "ReduceLogSumExp": {
    "description": "Computes the log sum exponent of the input tensor's elements along the provided axes. The resulting tensor has the same rank as the input if `keepdims` equals 1. If `keepdims` equals 0, then the resulting tensor has the reduced dimension pruned. Input tensors of rank zero are valid. Reduction over a...",
    "from": "Operators.md",
    "std_args": [
      [
        "data",
        "Tensor"
      ],
      [
        "axes",
        "int"
      ],
      [
        "keepdims",
        "int"
      ],
      [
        "noop_with_empty_axes",
        "int"
      ]
    ]
  },
  "ReduceMax": {
    "description": "Computes the max of the input tensor's elements along the provided axes. The resulting tensor has the same rank as the input if `keepdims` equals 1. If `keepdims` equals 0, then the resulting tensor has the reduced dimension pruned. Input tensors of rank zero are valid. Reduction over an empty set o...",
    "from": "Operators.md",
    "std_args": [
      [
        "data",
        "Tensor"
      ],
      [
        "axes",
        "int"
      ],
      [
        "keepdims",
        "int"
      ],
      [
        "noop_with_empty_axes",
        "int"
      ]
    ]
  },
  "ReduceMean": {
    "description": "Computes the mean of the input tensor's elements along the provided axes. The resulting tensor has the same rank as the input if `keepdims` equals 1. If `keepdims` equals 0, then the resulting tensor has the reduced dimension pruned. Input tensors of rank zero are valid. Reduction over an empty set ...",
    "from": "Operators.md",
    "std_args": [
      [
        "data",
        "Tensor"
      ],
      [
        "axes",
        "int"
      ],
      [
        "keepdims",
        "int"
      ],
      [
        "noop_with_empty_axes",
        "int"
      ]
    ]
  },
  "ReduceMin": {
    "description": "Computes the minimum of elements across dimensions of a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int | List[int]"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "ReduceProd": {
    "description": "Computes the product of elements across dimensions of a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int | List[int]"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "ReduceStd": {
    "description": "Computes the standard deviation of elements across dimensions of a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int | List[int]"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "ReduceSum": {
    "description": "Computes the sum of elements across dimensions of a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int | List[int]"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "ReduceSumSquare": {
    "description": "Computes the sum square of the input tensor's elements along the provided axes. The resulting tensor has the same rank as the input if `keepdims` equals 1. If `keepdims` equals 0, then the resulting tensor has the reduced dimension pruned. Input tensors of rank zero are valid. Reduction over an empt...",
    "from": "Operators.md",
    "std_args": [
      [
        "data",
        "Tensor"
      ],
      [
        "axes",
        "int"
      ],
      [
        "keepdims",
        "int"
      ],
      [
        "noop_with_empty_axes",
        "int"
      ]
    ]
  },
  "ReduceVariance": {
    "description": "Computes the variance of elements across dimensions of a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int | List[int]"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Reduction": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ReflectionPad1d": {
    "description": "Pads the input tensor using the reflection of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ReflectionPad2d": {
    "description": "Pads the input tensor using the reflection of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ReflectionPad3d": {
    "description": "Pads the input tensor using the reflection of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "RegexFullMatch": {
    "description": "RegexFullMatch performs a full regex match on each element of the input tensor. If an element fully matches the regex pattern specified as an attribute, the corresponding element in the output is True and it is False otherwise. [RE2](https://github.com/google/re2/wiki/Syntax) regex syntax is used.",
    "from": "Operators.md",
    "std_args": [
      [
        "X",
        "Any"
      ],
      [
        "pattern",
        "str"
      ]
    ]
  },
  "RegisterDataType": {
    "description": "Registers a type as pytree data type recognized by Object.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "type_",
        "type": "type"
      }
    ],
    "variants": {}
  },
  "RegisterVariableName": {
    "description": "Register a pair of Linen collection name and its NNX type.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "name",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "typ",
        "type": "type"
      }
    ],
    "variants": {}
  },
  "RelativeBias": {
    "description": "A layer for Relative Attention Bias.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_heads",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Relu": {
    "description": "Applies the rectified linear unit function element-wise.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Relu2": {
    "description": "Applies the ReLU\u00b2 activation function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Relu6": {
    "description": "Applies the Rectified Linear Unit 6.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Relu_": {
    "description": "In-place version of Relu.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Remainder": {
    "description": "Computes the element-wise remainder of division.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Remat": {
    "description": "Applies gradient checkpointing (rematerialization) to a function to save memory at the cost of compute.",
    "op_type": "decorator",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "f",
        "type": "Callable"
      }
    ],
    "variants": {}
  },
  "Renorm": {
    "description": "Renormalizes sub-tensors along a dimension.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "p",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "maxnorm",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Repeat": {
    "description": "Repeat elements of an array.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "repeats",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "RepeatInterleave": {
    "description": "Repeat elements of a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "repeats",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "RepeatVector": {
    "description": "Repeats the input n times.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "n",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ReplaceByPureDict": {
    "description": "Updates the state of a module/node using a dictionary of values.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "state",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "pure_dict",
        "type": "dict"
      }
    ],
    "variants": {}
  },
  "ReplicationPad1d": {
    "description": "Pads the input tensor using replication of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ReplicationPad2d": {
    "description": "Pads the input tensor using replication of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ReplicationPad3d": {
    "description": "Pads the input tensor using replication of the input boundary.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "Require": {
    "description": "Return an ndarray of the provided type that satisfies requirements (flags).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "requirements",
        "type": "List[str]"
      }
    ],
    "variants": {}
  },
  "ResNet": {
    "description": "ResNet model.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "blocks",
        "type": "Sequence[int]"
      }
    ],
    "variants": {}
  },
  "ResNetBlock": {
    "description": "ResNet Block.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "output_dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Rescaling": {
    "description": "Preprocessing layer which rescales input values to a new range.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "scale",
        "type": "float"
      },
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "offset",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Reseed": {
    "description": "Resets the RNG keys for a module or node.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "node",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "seed",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ResetPeakMemory": {
    "description": "Reset the peak memory tracker.",
    "std_args": [],
    "variants": {}
  },
  "Reshape": {
    "description": "Returns a tensor with the same data and number of elements as input, but with the specified shape.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "shape",
        "type": "Tuple[int]"
      }
    ],
    "variants": {}
  },
  "Resize": {
    "description": "Return a new array with the specified shape (may repeat data).",
    "return_type": "Array",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "new_shape",
        "type": "Tuple[int]"
      }
    ],
    "variants": {}
  },
  "ResizeAsSparse_": {
    "description": "Resizes the tensor to match another (sparse).",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ResizeAs_": {
    "description": "Resizes the tensor to match another.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Resizing": {
    "description": "Preprocessing layer which resizes images.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "height",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "width",
        "type": "int"
      },
      {
        "default": "bilinear",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "interpolation",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "ResolveConj": {
    "description": "Returns the tensor with materialized conjugation.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ResolveNeg": {
    "description": "Returns the tensor with materialized negation.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "RestoreIntPaths": {
    "description": "Restores integer keys in a state dictionary (often stringified by JSON).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "pure_dict",
        "type": "dict"
      }
    ],
    "variants": {}
  },
  "RestoreRngs": {
    "description": "Restores RNG states from a backup.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "backups",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "ResultType": {
    "description": "Returns the promotion type of arguments.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tensor1",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tensor2",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ReverseSequence": {
    "description": "Reverse batch of sequences having different lengths specified by `sequence_lens`. For each slice i iterating on batch axis, the operator reverses the first sequence_lens[i] elements on time axis, and copies elements whose index's beyond sequence_lens[i] to the output. So the output slice i contains ...",
    "from": "Operators.md",
    "std_args": [
      [
        "input",
        "Tensor"
      ],
      [
        "sequence_lens",
        "int"
      ],
      [
        "batch_axis",
        "int"
      ],
      [
        "time_axis",
        "int"
      ]
    ]
  },
  "ReversibleEmbedding": {
    "description": "Embedding layer that can project backwards to the input dim.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "output_dim",
        "type": "int"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tie_weights",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "RightShift": {
    "description": "Shift the bits of an integer to the right.",
    "return_type": "Array",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x1",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x2",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "Rint": {
    "description": "Returns element-wise integer closest to x.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "RmsNorm": {
    "description": "Applies Root Mean Square Normalization.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "normalized_shape",
        "type": "Tuple[int]"
      }
    ],
    "variants": {}
  },
  "RmsNormNoScale": {
    "description": "RMS normalization without scale.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Rmsnorm": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "eps",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "RngCount": {
    "description": "The base class for all Variable types. Create custom Variable types by subclassing this class.",
    "std_args": [],
    "variants": {}
  },
  "RngKey": {
    "description": "The base class for all Variable types. Create custom Variable types by subclassing this class.",
    "std_args": [],
    "variants": {}
  },
  "RngState": {
    "description": "The base class for all Variable types. Create custom Variable types by subclassing this class.",
    "std_args": [],
    "variants": {}
  },
  "RngStream": {
    "description": "Base class for all NNX objects.",
    "std_args": [],
    "variants": {}
  },
  "Rngs": {
    "description": "A small abstraction to manage RNG state.",
    "std_args": [
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "seed",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "RnnRelu": {
    "description": "RNN with ReLU activation.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hx",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "params",
        "type": "List[Tensor]"
      }
    ],
    "variants": {}
  },
  "RnnReluCell": {
    "description": "RNN Cell with ReLU activation.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hx",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "w_ih",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "w_hh",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b_ih",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b_hh",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "RnnTanh": {
    "description": "RNN with Tanh activation.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hx",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "params",
        "type": "List[Tensor]"
      }
    ],
    "variants": {}
  },
  "RnnTanhCell": {
    "description": "RNN Cell with Tanh activation.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hx",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "w_ih",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "w_hh",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b_ih",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b_hh",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Rnncellbase": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "variants": {}
  },
  "RoPE": {
    "description": "Rotary Positional Embeddings.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dims",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "RoiAlign": {
    "description": "Region of Interest (RoI) align operation described in the [Mask R-CNN paper](https://arxiv.org/abs/1703.06870). RoiAlign consumes an input tensor X and region of interests (rois) to apply pooling across each RoI; it produces a 4-D tensor of shape (num_rois, C, output_height, output_width). RoiAlign ...",
    "from": "Operators.md",
    "std_args": [
      [
        "X",
        "Any"
      ],
      [
        "rois",
        "Any"
      ],
      [
        "batch_indices",
        "Any"
      ],
      [
        "coordinate_transformation_mode",
        "str"
      ],
      [
        "mode",
        "str"
      ],
      [
        "output_height",
        "int"
      ],
      [
        "output_width",
        "int"
      ],
      [
        "sampling_ratio",
        "int"
      ],
      [
        "spatial_scale",
        "float"
      ]
    ]
  },
  "Roll": {
    "description": "Roll the tensor along the given dimension(s).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "shifts",
        "type": "Union[int, Tuple[int]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dims",
        "type": "Union[int, Tuple[int]]"
      }
    ],
    "variants": {}
  },
  "RollAxis": {
    "description": "Roll the specified axis backwards, until it lies in a given position.",
    "return_type": "Array",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "start",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Rollaxis": {
    "description": "Roll the specified axis to a given position.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "start",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Roots": {
    "description": "Return the roots of a polynomial with coefficients given in p.",
    "return_type": "Array",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "p",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "Rot90": {
    "description": "Rotate a tensor by 90 degrees.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "k",
        "type": "int"
      },
      {
        "default": [
          0,
          1
        ],
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dims",
        "type": "List[int]"
      }
    ],
    "variants": {}
  },
  "RotaryEmbedding": {
    "description": "RotaryEmbedding is the implementation of rotary positional embeddings (RoPE) based on the paper https://arxiv.org/pdf/2104.09864. The key advantage of RoPE is that it allows the model to understand both the absolute position of a token and the relative distances between tokens. This is achieved thro...",
    "from": "Operators.md",
    "std_args": [
      [
        "X",
        "Tensor"
      ],
      [
        "cos_cache",
        "Tensor"
      ],
      [
        "sin_cache",
        "Tensor"
      ],
      [
        "position_ids",
        "Any"
      ],
      [
        "interleaved",
        "int"
      ],
      [
        "num_heads",
        "int"
      ],
      [
        "rotary_embedding_dim",
        "int"
      ]
    ]
  },
  "Round": {
    "description": "Rounds elements to the nearest integer.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "decimals",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Round_": {
    "description": "In-place version of Round.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "decimals",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "RowIndicesCopy": {
    "description": "Copy row indices.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "out",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "RowStack": {
    "description": "Stack arrays in sequence vertically (row wise).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tensors",
        "type": "List[Tensor]"
      }
    ],
    "variants": {}
  },
  "RowWise": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Rrelu": {
    "description": "Randomized ReLU.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 0.125,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "lower",
        "type": "float"
      },
      {
        "default": 0.333,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "upper",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Rrelu_": {
    "description": "In-place version of Rrelu.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Rsqrt": {
    "description": "Returns the reciprocal of the square root of elements.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Rsqrt_": {
    "description": "In-place version of Rsqrt.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Rsub": {
    "description": "Subtracts input from other (other - input) scaling input by alpha.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "alpha",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "SELU": {
    "description": "Applies the Scaled Exponential Linear Unit.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "SGD": {
    "description": "Gradient descent (with momentum) optimizer.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.01,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "learning_rate",
        "type": "float"
      },
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "momentum",
        "type": "float"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "nesterov",
        "type": "boolean"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "weight_decay",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "SSM": {
    "description": "State Space Model layer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SSMGated": {
    "description": "Gated State Space Model.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_dims",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SSMTransformer": {
    "description": "Transformer layer using SSM.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_dims",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "STFT": {
    "description": "Computes the Short-time Fourier Transform of the signal.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "signal",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "frame_step",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "window",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "frame_length",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "onesided",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "STFTSpectrogram": {
    "description": "Computes the Short-Time Fourier Transform (STFT) spectrogram.",
    "op_type": "class",
    "std_args": [
      {
        "default": 256,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "frame_length",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "frame_step",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "fft_length",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "STRING": {
    "description": "Auto-generated from flax_nnx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "SWIZZLE_32_4_4": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Saddmm": {
    "description": "Performs the S-ADDMM operation (Sparse Add Matrix-Matrix). Generally deprecated in favor of explicit sparse operations.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mat1",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mat2",
        "type": "Tensor"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta",
        "type": "float"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "alpha",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "out",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Save": {
    "description": "Saves an object (tensor or model) to a disk file.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "obj",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "f",
        "type": "Union[str, Path]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "pickle_module",
        "type": "Any"
      },
      {
        "default": 2,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "pickle_protocol",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SaveGguf": {
    "description": "Save arrays to GGUF format.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "file",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "arrays",
        "type": "Dict[str, Tensor]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "metadata",
        "type": "Dict[str, Any]"
      }
    ],
    "variants": {}
  },
  "SaveSafetensors": {
    "description": "Save arrays to Safetensors format.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "file",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "arrays",
        "type": "Dict[str, Tensor]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "metadata",
        "type": "Dict[str, str] | None"
      }
    ],
    "variants": {}
  },
  "SaveTxt": {
    "description": "Save an array to a text file.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "fname",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "X",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "SaveZ": {
    "description": "Save several arrays into a single file in uncompressed .npz format.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "file",
        "type": "str"
      },
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SaveZCompressed": {
    "description": "Save several arrays into a single file in compressed .npz format.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "file",
        "type": "str"
      },
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Savez": {
    "description": "Save several arrays to an uncompressed .npz format.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "file",
        "type": "str"
      },
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kwargs",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SavezCompressed": {
    "description": "Save several arrays to a compressed .npz format.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "file",
        "type": "str"
      },
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "ScalarMul": {
    "description": "Multiplies a scalar times a Tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "scalar",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ScalarTensor": {
    "description": "Creates a 0-dimensional tensor containing a single value.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "s",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "DType"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "device",
        "type": "Device"
      }
    ],
    "variants": {}
  },
  "ScalarType": {
    "description": "Tuple of scalar types.",
    "std_args": [],
    "variants": {}
  },
  "ScaleByTrustRatioState": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "ScaleState": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "ScalingType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Scan": {
    "description": "Functional loop operation carrying state across iterations.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "f",
        "type": "Callable"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "init",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "xs",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Scatter": {
    "description": "Writes values into a tensor at indices specified by index.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "index",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "src",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "reduce",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "ScatterAdd": {
    "description": "Adds values into a tensor at indices specified by index.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "index",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "src",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ScatterElements": {
    "description": "ScatterElements takes three inputs `data`, `updates`, and `indices` of the same rank r >= 1 and an optional attribute axis that identifies an axis of `data` (by default, the outer-most axis, that is axis 0). The output of the operation is produced by creating a copy of the input `data`, and then upd...",
    "from": "Operators.md",
    "std_args": [
      [
        "data",
        "Tensor"
      ],
      [
        "indices",
        "Any"
      ],
      [
        "updates",
        "Tensor"
      ],
      [
        "axis",
        "int"
      ],
      [
        "reduction",
        "str"
      ]
    ]
  },
  "ScatterND": {
    "description": "ScatterND takes three inputs `data` tensor of rank r >= 1, `indices` tensor of rank q >= 1, and `updates` tensor of rank q + r - indices.shape[-1] - 1. The output of the operation is produced by creating a copy of the input `data`, and then updating its value to values specified by `updates` at spec...",
    "from": "Operators.md",
    "std_args": [
      [
        "data",
        "Tensor"
      ],
      [
        "indices",
        "int"
      ],
      [
        "updates",
        "Tensor"
      ],
      [
        "reduction",
        "str"
      ]
    ]
  },
  "ScatterReduce": {
    "description": "Reduces values into a tensor at indices specified by index using a reduction operation.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "index",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "src",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "reduce",
        "type": "str"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "include_self",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "ScriptClass": {
    "description": "Internal TorchScript class representation.",
    "std_args": [],
    "variants": {}
  },
  "ScriptClassFunction": {
    "description": "Internal TorchScript function representation.",
    "std_args": [],
    "variants": {}
  },
  "ScriptDict": {
    "description": "Internal TorchScript dictionary representation.",
    "std_args": [],
    "variants": {}
  },
  "ScriptDictIterator": {
    "description": "Internal TorchScript dictionary iterator.",
    "std_args": [],
    "variants": {}
  },
  "ScriptDictKeyIterator": {
    "description": "Internal TorchScript dictionary key iterator.",
    "std_args": [],
    "variants": {}
  },
  "ScriptFunction": {
    "description": "Internal TorchScript function.",
    "std_args": [],
    "variants": {}
  },
  "ScriptList": {
    "description": "Internal TorchScript list.",
    "std_args": [],
    "variants": {}
  },
  "ScriptListIterator": {
    "description": "Internal TorchScript list iterator.",
    "std_args": [],
    "variants": {}
  },
  "ScriptMethod": {
    "description": "Internal TorchScript method.",
    "std_args": [],
    "variants": {}
  },
  "ScriptModule": {
    "description": "Internal TorchScript module.",
    "std_args": [],
    "variants": {}
  },
  "ScriptModuleSerializer": {
    "description": "Internal TorchScript serializer.",
    "std_args": [],
    "variants": {}
  },
  "ScriptObject": {
    "description": "Internal TorchScript object.",
    "std_args": [],
    "variants": {}
  },
  "ScriptObjectProperty": {
    "description": "Internal TorchScript object property.",
    "std_args": [],
    "variants": {}
  },
  "SctypeDict": {
    "description": "Dictionary of scalar types.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "SeLU": {
    "description": "Scaled Exponential Linear Unit activation.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "SeLU_": {
    "description": "In-place SeLU.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "SearchSorted": {
    "description": "Finds indices where elements should be inserted to maintain order.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "sorted_sequence",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "values",
        "type": "Tensor"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "out_int32",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "right",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "side",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "sorter",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Seed": {
    "description": "Sets the seed for generating random numbers.",
    "std_args": [],
    "variants": {}
  },
  "SegmentMask": {
    "description": "Computes (non-causal) segment mask.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "segment_ids",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "SegmentMax": {
    "description": "Computes the maximum along segments of a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "segment_ids",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "SegmentMean": {
    "description": "Computes the mean along segments of a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "segment_ids",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "SegmentMin": {
    "description": "Computes the minimum along segments of a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "segment_ids",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "SegmentProd": {
    "description": "Computes the product along segments of a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "segment_ids",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "SegmentReduce": {
    "description": "Performs a reduction along segments of a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "reduce",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "lengths",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "indices",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "offsets",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SegmentSum": {
    "description": "Computes the sum along segments of a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "segment_ids",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "SegmentedMm": {
    "description": "Segmented matrix multiplication.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "segments",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Select": {
    "description": "Slices the input tensor along the selected dimension at the given index.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "index",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SelectCopy": {
    "description": "Slices the tensor, returning a copy.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "index",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SelectScatter": {
    "description": "Embeds values into the tensor at the given index.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "src",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "index",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SelfAttentionWithNormAndResidual": {
    "description": "Self attention sub-layer.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Selu": {
    "description": "Applies the Scaled Exponential Linear Unit.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "SeparableConv1D": {
    "description": "1D separable convolution layer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "filters",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "strides",
        "type": "int"
      },
      {
        "default": "valid",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "str"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "depth_multiplier",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SeparableConv2D": {
    "description": "2D separable convolution layer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "filters",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "int"
      },
      {
        "default": [
          1,
          1
        ],
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "strides",
        "type": "Tuple[int, int]"
      },
      {
        "default": "valid",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "str"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "depth_multiplier",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SeparableConvolution1D": {
    "description": "Alias for SeparableConv1D.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "filters",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "strides",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SeparableConvolution2D": {
    "description": "Alias for SeparableConv2D.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "filters",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "int"
      },
      {
        "default": [
          1,
          1
        ],
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "strides",
        "type": "Tuple[int, int]"
      }
    ],
    "variants": {}
  },
  "SequenceAt": {
    "description": "Outputs a tensor copy from the tensor at 'position' in 'input_sequence'. Accepted range for 'position' is in `[-n, n - 1]`, where `n` is the number of tensors in 'input_sequence'. Negative value means counting positions from the back.",
    "from": "Operators.md",
    "std_args": [
      [
        "input_sequence",
        "Any"
      ],
      [
        "position",
        "Any"
      ]
    ]
  },
  "SequenceConstruct": {
    "description": "Construct a tensor sequence containing 'inputs' tensors. All tensors in 'inputs' must have the same data type.",
    "from": "Operators.md",
    "std_args": [
      [
        "inputs",
        "Tensor"
      ]
    ]
  },
  "SequenceEmpty": {
    "description": "Construct an empty tensor sequence, with given data type.",
    "from": "Operators.md",
    "std_args": [
      [
        "dtype",
        "int"
      ]
    ]
  },
  "SequenceErase": {
    "description": "Outputs a tensor sequence that removes the tensor at 'position' from 'input_sequence'. Accepted range for 'position' is in `[-n, n - 1]`, where `n` is the number of tensors in 'input_sequence'. Negative value means counting positions from the back. 'position' is optional, by default it erases the la...",
    "from": "Operators.md",
    "std_args": [
      [
        "input_sequence",
        "Any"
      ],
      [
        "position",
        "Any"
      ]
    ]
  },
  "SequenceInsert": {
    "description": "Outputs a tensor sequence that inserts 'tensor' into 'input_sequence' at 'position'. 'tensor' must have the same data type as 'input_sequence'. Accepted range for 'position' is in `[-n, n]`, where `n` is the number of tensors in 'input_sequence'. Negative value means counting positions from the back...",
    "from": "Operators.md",
    "std_args": [
      [
        "input_sequence",
        "Any"
      ],
      [
        "tensor",
        "Tensor"
      ],
      [
        "position",
        "Any"
      ]
    ]
  },
  "SequenceLength": {
    "description": "Produces a scalar(tensor of empty shape) containing the number of tensors in 'input_sequence'.",
    "from": "Operators.md",
    "std_args": [
      [
        "input_sequence",
        "Any"
      ]
    ]
  },
  "SequenceMap": {
    "description": "Applies a sub-graph to each sample in the input sequence(s). Inputs can be either tensors or sequences, with the exception of the first input which must be a sequence. The length of the first input sequence will determine the number of samples in the outputs. Any other sequence inputs should have th...",
    "from": "Operators.md",
    "std_args": [
      [
        "input_sequence",
        "Any"
      ],
      [
        "additional_inputs",
        "Any"
      ],
      [
        "body",
        "Any"
      ]
    ]
  },
  "SequenceModel": {
    "description": "Sequence Model base task.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Sequential": {
    "description": "Applies a linear chain of Modules.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "layers",
        "type": "Sequence"
      }
    ],
    "variants": {}
  },
  "SerializationStorageContext": {
    "description": "Internal serialization context.",
    "std_args": [],
    "variants": {}
  },
  "SerializeLayer": {
    "description": "Returns the layer configuration as a Python dict.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "layer",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SerializeLoss": {
    "description": "Serializes loss function or Loss instance.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "loss",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SerializeOptimizer": {
    "description": "Returns the optimizer configuration as a Python dict.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "optimizer",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SetAnomalyEnabled": {
    "description": "Context-manager/Function to enable or disable anomaly detection (NaN checks).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mode",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "SetAutocastCacheEnabled": {
    "description": "Sets the autocast cache status.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "enabled",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "SetAutocastCpuDtype": {
    "description": "Sets the autocast dtype for CPU.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "DType"
      }
    ],
    "variants": {}
  },
  "SetAutocastCpuEnabled": {
    "description": "Enables autocast for CPU.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "enabled",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "SetAutocastDtype": {
    "description": "Sets the autocast dtype.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "device_type",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "DType"
      }
    ],
    "variants": {}
  },
  "SetAutocastEnabled": {
    "description": "Enables autocast.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "device_type",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "enabled",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "SetAutocastGpuDtype": {
    "description": "Sets autocast dtype for GPU.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "DType"
      }
    ],
    "variants": {}
  },
  "SetAutocastIpUDtype": {
    "description": "Sets autocast dtype for IPU.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "DType"
      }
    ],
    "variants": {}
  },
  "SetAutocastIpUEnabled": {
    "description": "Enables autocast for IPU.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "enabled",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "SetAutocastXlaDtype": {
    "description": "Sets autocast dtype for XLA.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "DType"
      }
    ],
    "variants": {}
  },
  "SetAutocastXlaEnabled": {
    "description": "Enables autocast for XLA.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "enabled",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "SetBufSize": {
    "description": "Set the size of the buffer used in ufuncs.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SetCacheLimit": {
    "description": "Set the free cache limit.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "limit",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SetDefaultDevice": {
    "description": "Sets the default device for tensor allocation.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "device",
        "type": "Union[str, Device]"
      }
    ],
    "variants": {}
  },
  "SetDefaultDtype": {
    "description": "Sets the default floating point dtype.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "d",
        "type": "DType"
      }
    ],
    "variants": {}
  },
  "SetDefaultStream": {
    "description": "Set the default stream.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stream",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SetDefaultTensorType": {
    "description": "Sets the default tensor type (Deprecated).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "t",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SetDeterministicDebugMode": {
    "description": "Sets debug mode for deterministic operations.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "debug_mode",
        "type": "Union[str, int]"
      }
    ],
    "variants": {}
  },
  "SetDiff1d": {
    "description": "Find the set difference of two arrays.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ar1",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ar2",
        "type": "Array"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "assume_unique",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "SetErr": {
    "description": "Set how floating-point errors are handled.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "all",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "divide",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "over",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "under",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "invalid",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "SetErrCall": {
    "description": "Set the floating-point error callback function or log object.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "func",
        "type": "Callable"
      }
    ],
    "variants": {}
  },
  "SetFloat32MatmulPrecision": {
    "description": "Sets internal precision for float32 matrix multiplications.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "precision",
        "options": [
          "highest",
          "high",
          "medium"
        ],
        "type": "str"
      }
    ],
    "variants": {}
  },
  "SetFlushDenormal": {
    "description": "Disables denormal floating numbers on CPU.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mode",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "SetGradEnabled": {
    "description": "Context-manager that sets gradient calculation on or off.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mode",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "SetMemoryLimit": {
    "description": "Set the memory limit.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "limit",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SetMetadata": {
    "description": "Attaches metadata to a graph node.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "node",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SetMode": {
    "description": "Sets the execution mode (train/eval) for a module.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "node",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "training",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "SetModeInfo": {
    "description": "Introspects mode information for a module.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "node",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SetNumInteropThreads": {
    "description": "Sets the number of threads used for interop parallelism.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "int",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SetNumThreads": {
    "description": "Sets the number of threads used for intraop parallelism.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "int",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SetPrintOptions": {
    "description": "Set options for printing.",
    "std_args": [
      {
        "default": 4,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "precision",
        "type": "int"
      },
      {
        "default": 1000,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "threshold",
        "type": "int"
      },
      {
        "default": 3,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "edgeitems",
        "type": "int"
      },
      {
        "default": 80,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "linewidth",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "profile",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "sci_mode",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "SetPrintoptions": {
    "description": "Set printing options.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "var_keyword",
        "name": "kwargs",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SetRngState": {
    "description": "Sets the random number generator state.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "new_state",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "SetVital": {
    "description": "Undocumented utility.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "arg0",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "arg1",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "arg2",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SetWarnAlways": {
    "description": "Forces warnings to always emit.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "SetWiredLimit": {
    "description": "Set the wired memory limit (macOS).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "limit",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SetXor1d": {
    "description": "Find the set exclusive-or of two arrays.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ar1",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ar2",
        "type": "Array"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "assume_unique",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Sgn": {
    "description": "Computes the sign of the input tensor, supporting complex numbers.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Shape": {
    "description": "Constructs a shape tuple equivalent to torch.Size.",
    "std_args": [
      {
        "default": "()",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "iterable",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "ShardMap": {
    "description": "Transformation for sharded parallel execution over a mesh.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "f",
        "type": "Callable"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mesh",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "ShardedToAllLinear": {
    "description": "Distributed linear layer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "in_features",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "out_features",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SharedEmbeddingSoftmax": {
    "description": "Softmax layer with embedding lookups.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_dims",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_classes",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SharesMemory": {
    "description": "Determine if two arrays share memory.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b",
        "type": "Array"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "max_work",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Short": {
    "description": "Casts the input tensor to int16 (short).",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ShortStorage": {
    "description": "Storage for int16 tensors.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "ShouldSkipUpdateFunction": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "ShowConfig": {
    "description": "Show libraries and system information.",
    "std_args": [
      {
        "default": "'stdout'",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mode",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "ShowRuntime": {
    "description": "Print information about various resources in the system.",
    "std_args": [],
    "variants": {}
  },
  "Shrink": {
    "description": "Shrink takes one input data (Tensor<numeric>) and produces one Tensor output, having same datatype and shape with input. It has two attributes, lambd and bias. The formula of this operator is: If x < -lambd, y = x + bias; If x > lambd, y = x - bias; Otherwise, y = 0.",
    "from": "Operators.md",
    "std_args": [
      [
        "input",
        "Tensor"
      ],
      [
        "bias",
        "float"
      ],
      [
        "lambd",
        "float"
      ]
    ]
  },
  "SiLU": {
    "description": "Sigmoid Linear Unit activation layer.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Sigmoid": {
    "description": "Computes the element-wise sigmoid of the input.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "SigmoidCrossEntropy": {
    "description": "Sigmoid cross-entropy loss layer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_classes",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Sigmoid_": {
    "description": "In-place sigmoid.",
    "is_inplace": true,
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Sign": {
    "description": "Returns a new tensor with the signs of the elements.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Signbit": {
    "description": "Tests if each element has its sign bit set.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "SignedInteger": {
    "description": "Abstract base class of all signed integer scalar types.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Silu": {
    "description": "Applies the Sigmoid Linear Unit (SiLU) function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "SimpleCell": {
    "description": "Simple RNN cell.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "in_features",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hidden_features",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SimpleRNN": {
    "description": "Fully-connected RNN where output is fed back as input.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "units",
        "type": "int"
      },
      {
        "default": "tanh",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "activation",
        "type": "str"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "return_sequences",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "return_state",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "SimpleRNNCell": {
    "description": "Cell class for SimpleRNN.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "units",
        "type": "int"
      },
      {
        "default": "tanh",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "activation",
        "type": "str"
      },
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dropout",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Sin": {
    "description": "Computes the element-wise sine.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Sin_": {
    "description": "In-place sine.",
    "is_inplace": true,
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Sinc": {
    "description": "Computes the normalized sinc function.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Sinc_": {
    "description": "In-place sinc.",
    "is_inplace": true,
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Single": {
    "description": "Cast to single-precision floating-point number (float32).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Sinh": {
    "description": "Computes the hyperbolic sine.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Sinh_": {
    "description": "In-place hyperbolic sine.",
    "is_inplace": true,
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "SinusoidalPositionalEncoding": {
    "description": "Injects sinusoidal positional encodings.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dims",
        "type": "int"
      },
      {
        "default": 0.0001,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "min_freq",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Size": {
    "description": "Return the number of elements along a given axis.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Slice": {
    "description": "Extract a sub-array from the input array using start indices and sizes.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "start_indices",
        "type": "Union[List[int], Tensor]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "slice_sizes",
        "type": "Union[List[int], Tensor]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axes",
        "type": "Optional[List[int]]"
      }
    ],
    "variants": {}
  },
  "SliceCopy": {
    "description": "Performs slicing, returning a copy.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "SliceInverse": {
    "description": "Undocumented/Internal.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SliceScatter": {
    "description": "Embeds values into the tensor at a given dimension slice.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "src",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "start",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "end",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "step",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SliceUpdate": {
    "description": "Update a sub-array of the input array.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "update",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "start_indices",
        "type": "Union[List[int], Tensor]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axes",
        "type": "Optional[List[int]]"
      }
    ],
    "variants": {}
  },
  "Slogdet": {
    "description": "Computes the sign and log value of the determinant.",
    "return_type": "Tuple[Tensor, Tensor]",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Smm": {
    "description": "Performs sparse matrix multiplication.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mat",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "SmoothL1Loss": {
    "description": "Creates a criterion that uses a squared term if the absolute",
    "std_args": [
      "self",
      "size_average",
      "reduce",
      "reduction",
      "beta"
    ],
    "type": "class"
  },
  "Smoothl1": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "SnapshotState": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "SobolSample": {
    "description": "Generates points from the Sobol sequence.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_results",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "skip",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SoftMarginLoss": {
    "description": "Creates a criterion that optimizes a two-class classification",
    "std_args": [
      "self",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "class"
  },
  "SoftSign": {
    "description": "SoftSign activation function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Softmax": {
    "description": "Applies the Softmax function.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "Softmax2d": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "SoftmaxCrossEntropyLoss": {
    "description": "Loss function that measures the softmax cross entropy between 'scores' and 'labels'. This operator first computes a loss tensor whose shape is identical to the labels input. If the input is 2-D with shape (N, C), the loss tensor may be a N-element vector L = (l_1, l_2, ..., l_N). If the input is N-D...",
    "from": "Operators.md",
    "std_args": [
      [
        "scores",
        "Tensor"
      ],
      [
        "labels",
        "Any"
      ],
      [
        "weights",
        "Tensor"
      ],
      [
        "ignore_index",
        "int"
      ],
      [
        "reduction",
        "str"
      ]
    ]
  },
  "Softmin": {
    "description": "Applies the Softmin function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Softplus": {
    "description": "Computes elementwise softplus: log(exp(x) + 1).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Softshrink": {
    "description": "Applies the Softshrink activation function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "default": 0.5,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "lambd",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Softsign": {
    "description": "Computes softsign: x / (abs(x) + 1).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Solarization": {
    "description": "Applies max_value - pixel + min_value inversion above a threshold.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "threshold_factor",
        "type": "float"
      },
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "addition_factor",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Solve": {
    "description": "Solves a system of linear equations.",
    "return_type": "Tuple[Tensor, Tensor]",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "A",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Sort": {
    "description": "Sorts the elements of the input tensor.",
    "return_type": "Tuple[Tensor, Tensor]",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "descending",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stable",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "SortComplex": {
    "description": "Sort a complex array using the real part first, then the imaginary part.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "SpaceToDepth": {
    "description": "SpaceToDepth rearranges blocks of spatial data into depth. More specifically, this op outputs a copy of the input tensor where values from the height and width dimensions are moved to the depth dimension.",
    "from": "Operators.md",
    "std_args": [
      [
        "input",
        "Tensor"
      ],
      [
        "blocksize",
        "int"
      ]
    ]
  },
  "Spacing": {
    "description": "Return the distance between x and the nearest adjacent number.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "SparseBsc": {
    "description": "Logic for Sparse Block Compressed Column format.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "arg0",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SparseBscTensor": {
    "description": "Constructs a sparse tensor in BSC format.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ccol_indices",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "row_indices",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "values",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "Optional[Tuple]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Optional[str]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "device",
        "type": "Optional[str]"
      }
    ],
    "variants": {}
  },
  "SparseBsr": {
    "description": "Layout constant for BSR.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "SparseBsrTensor": {
    "description": "Constructs a sparse tensor in BSR (Block Compressed Sparse Row) format.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "crow_indices",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "col_indices",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "values",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "Optional[List[int]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Optional[str]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "device",
        "type": "Optional[Any]"
      }
    ],
    "variants": {}
  },
  "SparseCategoricalCrossentropy": {
    "description": "Computes the sparse categorical crossentropy loss.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_true",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_pred",
        "type": "Tensor"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "from_logits",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ignore_class",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SparseCompressed": {
    "description": "Layout constant",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "SparseCompressedTensor": {
    "description": "Constructs a sparse tensor in a compressed format (CSR, CSC, BSR, BSC).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "compressed_indices",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "plain_indices",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "values",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "Optional[List[int]]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "layout",
        "type": "Optional[Any]"
      }
    ],
    "variants": {}
  },
  "SparseCoo": {
    "description": "Layout constant for COO.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "SparseCooTensor": {
    "description": "Constructs a sparse tensor in COO (Coordinate) format.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "indices",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "values",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "Optional[List[int]]"
      }
    ],
    "variants": {}
  },
  "SparseCsc": {
    "description": "Layout constant for CSC.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "SparseCscTensor": {
    "description": "Constructs a sparse tensor in CSC (Compressed Sparse Column) format.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ccol_indices",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "row_indices",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "values",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "Optional[List[int]]"
      }
    ],
    "variants": {}
  },
  "SparseCsr": {
    "description": "Layout constant for CSR.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "SparseCsrTensor": {
    "description": "Constructs a sparse tensor in CSR (Compressed Sparse Row) format.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "crow_indices",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "col_indices",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "values",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "Optional[List[int]]"
      }
    ],
    "variants": {}
  },
  "Sparsemax": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "labels",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "logits",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SpatialDropout1D": {
    "description": "Spatial 1D version of Dropout (drops entire feature maps).",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "rate",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "seed",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SpatialDropout2D": {
    "description": "Spatial 2D version of Dropout.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "rate",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "seed",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SpatialDropout3D": {
    "description": "Spatial 3D version of Dropout.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "rate",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "seed",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SpectralNorm": {
    "description": "Spectral normalization.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "layer",
        "type": "Any"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "n_steps",
        "type": "int"
      },
      {
        "default": "1e-12",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "epsilon",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "SpectralNormLoadStateDictPreHook": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "fn"
    ],
    "type": "class"
  },
  "SpectralNormStateDictHook": {
    "description": "The class representing a Python class.",
    "std_args": [
      "self",
      "fn"
    ],
    "type": "class"
  },
  "SpectralNormalization": {
    "description": "Performs spectral normalization on the weights of a target layer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "layer",
        "type": "Any"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "power_iterations",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SpectrumAugmenter": {
    "description": "SpecAugment data augmentation.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Split": {
    "description": "Splits a tensor into chunks. Torch uses `split_size`, Numpy uses `indices_or_sections`.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tensor",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "split_size_or_sections",
        "type": "Union[int, List[int]]"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SplitContext": {
    "description": "Splits a context object?",
    "std_args": [],
    "variants": {}
  },
  "SplitCopy": {
    "description": "Splits the tensor into chunks (Copy).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tensor",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "split_size_or_sections",
        "type": "Union[int, List[int]]"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SplitGraph": {
    "description": "Splits a stateful graph node into structure (GraphDef) and state.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "node",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SplitRngs": {
    "description": "Splits RNG keys for stochastic operations.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "key",
        "type": "Any"
      },
      {
        "default": 2,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "count",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "SplitState": {
    "description": "Splits a State object into multiple subsets based on filters.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "state",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SplitToSequence": {
    "description": "Split a tensor into a sequence of tensors, along the specified 'axis'. Lengths of the parts can be specified using the optional argument 'split'. If the argument `split' is not specified, a default scalar value of 1 is used as the value of `split'. 'split' must contain only positive numbers. 'split'...",
    "from": "Operators.md",
    "std_args": [
      [
        "input",
        "Tensor"
      ],
      [
        "split",
        "Any"
      ],
      [
        "axis",
        "int"
      ],
      [
        "keepdims",
        "int"
      ]
    ]
  },
  "SplitWithSizes": {
    "description": "Splits the tensor into chunks chunks with specified sizes.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tensor",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "split_sizes",
        "type": "List[int]"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Spmm": {
    "description": "Sparse matrix multiplication.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mat1",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mat2",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Sqrt": {
    "description": "Computes the square root element-wise.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Sqrt_": {
    "description": "In-place square root.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Square": {
    "description": "Computes the square element-wise.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Square_": {
    "description": "In-place square.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "SquaredDifference": {
    "description": "Returns (x - y)(x - y) element-wise.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "SquaredHinge": {
    "description": "Computes the squared hinge loss.",
    "op_type": "class",
    "std_args": [
      {
        "default": "sum_over_batch_size",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "reduction",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "SquaredHingeLoss": {
    "description": "Computes the squared hinge loss between y_true & y_pred.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_true",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_pred",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "SquaredReLU": {
    "description": "Squared ReLU activation layer.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Squeeze": {
    "description": "Returns a tensor with all the dimensions of input of size 1 removed.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "Optional[Union[int, List[int]]]"
      }
    ],
    "variants": {}
  },
  "SqueezeCopy": {
    "description": "Squeeze variant ensuring copy.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "Optional[Union[int, List[int]]]"
      }
    ],
    "variants": {}
  },
  "Sspaddmm": {
    "description": "Sparse matrix multiply and add: t + beta * m1 @ m2",
    "std_args": [
      {
        "doc": "Sparse matrix to add",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "doc": "Sparse matrix 1",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mat1",
        "type": "Tensor"
      },
      {
        "doc": "Dense matrix 2",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mat2",
        "type": "Tensor"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta",
        "type": "float"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "alpha",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Stack": {
    "description": "Concatenates a sequence of tensors along a new dimension.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tensors",
        "type": "List[Tensor]"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "StackFrnn": {
    "description": "Stacked FRNN layer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_layers",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "StackedRNNCells": {
    "description": "Wrapper allowing a stack of RNN cells to behave as a single cell.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "cells",
        "type": "List[Any]"
      }
    ],
    "variants": {}
  },
  "StackedTransformer": {
    "description": "Stack of Transformer layers.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_layers",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "model_dims",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_heads",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "StackedTransformerRepeated": {
    "description": "Stack of Transformer layers using repeat.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x_times",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "StackingOverTime": {
    "description": "Stacking applied along the time axis.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stride",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Standardize": {
    "description": "Standardizes input (centering and scaling).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "State": {
    "description": "Extracts state dictionary from a node.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "node",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "StateAxes": {
    "description": "Helper class that provides a standard way to create an ABC using inheritance.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "filter_axes",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "StateSharding": {
    "description": "Helper class that provides a standard way to create an ABC using inheritance.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "filter_sharding",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Static": {
    "description": "Marks a value as static (non-traceable) within a Pytree.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "StaticModule": {
    "description": "Internal static module wrapper.",
    "std_args": [],
    "variants": {}
  },
  "Std": {
    "description": "Calculates the standard deviation.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "Optional[Union[int, List[int]]]"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "correction",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "StdMean": {
    "description": "Calculates the standard deviation and mean.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "Optional[Union[int, List[int]]]"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "correction",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Step": {
    "description": "Applies the Step Activation Function (Heaviside).",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "threshold",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "StepActivation": {
    "description": "Applies the Step Activation Function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "threshold",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "StepLR": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Stft": {
    "description": "Short-time Fourier transform.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "n_fft",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hop_length",
        "type": "Optional[int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "win_length",
        "type": "Optional[int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "window",
        "type": "Optional[Tensor]"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "center",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "normalized",
        "type": "bool"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "onesided",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "return_complex",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "StochasticResidual": {
    "description": "Stochastic residual layer that randomly drops the residual branch.",
    "op_type": "class",
    "std_args": [
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "residual_weight",
        "type": "float"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "survival_prob",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "StopGradient": {
    "description": "Stop gradients from being computed.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Storage": {
    "description": "Base storage class access.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "StorageBase": {
    "description": "Abstract base for storage.",
    "std_args": [],
    "variants": {}
  },
  "Str_": {
    "description": "A unicode string type.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Stream": {
    "description": "Context manager for device streams.",
    "op_type": "context",
    "std_args": [
      {
        "default": "None",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "device",
        "type": "Any"
      },
      {
        "default": "0",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "priority",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "StreamContext": {
    "description": "Context manager for setting the current stream.",
    "op_type": "context",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stream",
        "type": "Stream"
      }
    ],
    "variants": {}
  },
  "StreamObjType": {
    "description": "Internal stream type.",
    "std_args": [],
    "variants": {}
  },
  "Strided": {
    "description": "Directs layout to strided (Standard).",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "String": {
    "description": "NumPy string_ type constructor.",
    "op_type": "class",
    "std_args": [
      {
        "default": "",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "StringConcat": {
    "description": "StringConcat concatenates string tensors elementwise (with NumPy-style broadcasting support)",
    "from": "Operators.md",
    "std_args": [
      [
        "X",
        "Tensor"
      ],
      [
        "Y",
        "Tensor"
      ]
    ]
  },
  "StringLookup": {
    "description": "A preprocessing layer that maps strings to (possibly encoded) indices.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "max_tokens",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_oov_indices",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mask_token",
        "type": "str"
      },
      {
        "default": "[UNK]",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "oov_token",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "vocabulary",
        "type": "List[str]"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "invert",
        "type": "bool"
      },
      {
        "default": "int",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "output_mode",
        "options": [
          "int",
          "one_hot",
          "multi_hot",
          "count",
          "tf_idf"
        ],
        "type": "str"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "pad_to_max_tokens",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "sparse",
        "type": "bool"
      },
      {
        "default": "utf-8",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "encoding",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "StringNormalizer": {
    "description": "StringNormalization performs string operations for basic cleaning. This operator has only one input (denoted by X) and only one output (denoted by Y). This operator first examines the elements in the X, and removes elements specified in \"stopwords\" attribute. After removing stop words, the intermedi...",
    "from": "Operators.md",
    "std_args": [
      [
        "X",
        "str"
      ],
      [
        "case_change_action",
        "str"
      ],
      [
        "is_case_sensitive",
        "int"
      ],
      [
        "locale",
        "str"
      ],
      [
        "stopwords",
        "List[str]"
      ]
    ]
  },
  "StringSplit": {
    "description": "StringSplit splits a string tensor's elements into substrings based on a delimiter attribute and a maxsplit attribute. The first output of this operator is a tensor of strings representing the substrings from splitting each input string on the `delimiter` substring. This tensor has one additional ra...",
    "from": "Operators.md",
    "std_args": [
      [
        "X",
        "Any"
      ],
      [
        "delimiter",
        "str"
      ],
      [
        "maxsplit",
        "int"
      ]
    ]
  },
  "StringType": {
    "description": "Internal string type.",
    "std_args": [],
    "variants": {}
  },
  "Sub": {
    "description": "Subtracts other from input.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "alpha",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Subtract": {
    "description": "Alias for Sub.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "other",
        "type": "Tensor"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "alpha",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "SubtractLayer": {
    "description": "Layer that performs elementwise subtraction on a list of two inputs.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Sum": {
    "description": "Returns the sum of all elements in the input tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "Optional[Union[int, List[int]]]"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdim",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Optional[Any]"
      }
    ],
    "variants": {}
  },
  "Svd": {
    "description": "Computes the singular value decomposition.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "some",
        "type": "bool"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "compute_uv",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "SvdLowrank": {
    "description": "Computes a low-rank approximation of the singular value decomposition.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "A",
        "type": "Tensor"
      },
      {
        "default": 6,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "q",
        "type": "int"
      },
      {
        "default": 2,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "niter",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "M",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "SwapAxes": {
    "description": "Interchange two axes of an array.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis1",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis2",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Swapaxes": {
    "description": "Interchange two dimensions of a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis0",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis1",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Swapdims": {
    "description": "Interchange two dimensions of a tensor (Alias for Swapaxes).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim0",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim1",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Swish": {
    "description": "Swish activation layer.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Switch": {
    "description": "Functional branch selection.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "index",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "branches",
        "type": "List[Callable]"
      }
    ],
    "variants": {}
  },
  "SwizzleType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "SymBool": {
    "description": "Symbolic boolean for tracing.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "node",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SymBoolType": {
    "description": "Type hint for symbolic boolean.",
    "std_args": [],
    "variants": {}
  },
  "SymConstrainRange": {
    "description": "Symbolic utility to constrain value range (Traced).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "min",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "max",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SymConstrainRangeForSize": {
    "description": "Symbolic utility to constrain size range (Traced).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SymFloat": {
    "description": "Casts a symbolic integer to a float.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SymFreshSize": {
    "description": "Symbolic utility for creating a fresh size symbol.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "expr",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SymInt": {
    "description": "Casts a symbolic float or object to an int.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SymIntType": {
    "description": "Meta-type for Symbolic Integers.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "SymIte": {
    "description": "Symbolic if-then-else.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "t",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "f",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SymMax": {
    "description": "Symbolic Max operation.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SymMin": {
    "description": "Symbolic Min operation.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SymNot": {
    "description": "Symbolic logic negation.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SymSqrt": {
    "description": "Symbolic square root.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "SymSum": {
    "description": "Symbolic N-ary sum.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "List"
      }
    ],
    "variants": {}
  },
  "Symeig": {
    "description": "Computes eigenvalues and eigenvectors of a real symmetric matrix (Deprecated).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "eigenvectors",
        "type": "bool"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "upper",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "SyncBatchNorm": {
    "description": "Applies Batch Normalization over a N-Dimensional input.",
    "std_args": [
      "self",
      "num_features",
      "eps",
      "momentum",
      "affine",
      "track_running_stats",
      "process_group",
      "device",
      "dtype"
    ],
    "type": "class"
  },
  "Synchronize": {
    "description": "Synchronize with the given stream.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "stream",
        "type": "Optional[Any]"
      }
    ],
    "variants": {}
  },
  "T": {
    "description": "Auto-generated from flax_nnx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "TCopy": {
    "description": "Performs transpose (2D) and returns a fresh copy.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "TFSMLayer": {
    "description": "Reload a Keras model/layer that was saved via SavedModel / ExportArchive.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "filepath",
        "type": "str"
      },
      {
        "default": "serve",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "call_endpoint",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "TUPLE": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "TYPE_CHECKING": {
    "description": "Boolean constant used for static analysis guards.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "T_destination": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "T_module": {
    "description": "Auto-generated from flax_nnx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Tabulate": {
    "description": "Generates a summary table of the model architecture.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "model",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_size",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Tag": {
    "description": "PyTorch internal tags for compiler/dispatcher.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Take": {
    "description": "Returns a new tensor with the elements of input at the given indices (flattened).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "index",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "TakeAlongAxis": {
    "description": "Take values from the input array by matching 1d index and data slices.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "arr",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "indices",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "TakeAlongDim": {
    "description": "Selects values from input at indices along the given dim.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "indices",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Tan": {
    "description": "Computes the tangent of the elements.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Tan_": {
    "description": "In-place version of Tan.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Tanh": {
    "description": "Computes the hyperbolic tangent of the elements.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Tanh_": {
    "description": "In-place version of Tanh.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Tanhshrink": {
    "description": "Auto-discovered via Consensus (Score: 2.0)",
    "std_args": [],
    "variants": {}
  },
  "TemporalShifting": {
    "description": "Shifts audio signals by a random amount during training.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "shift_range_ms",
        "type": "float"
      },
      {
        "default": 16000.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "sample_rate",
        "type": "float"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Tensor": {
    "description": "Constructs a tensor from data.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "device",
        "type": "Any"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "requires_grad",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "TensorScatter": {
    "description": "TensorScatter is a generic tensor update operation, motivated by the requirements for KV cache updates for Attention ops commonly found in LLMs. It is a functional operation that models an in-place update to a KV cache buffer. The past and present cache tensors have the same shape (batch_size, D1, D...",
    "from": "Operators.md",
    "std_args": [
      [
        "past_cache",
        "Tensor"
      ],
      [
        "update",
        "Tensor"
      ],
      [
        "write_indices",
        "int"
      ],
      [
        "axis",
        "int"
      ],
      [
        "mode",
        "str"
      ]
    ]
  },
  "TensorSplit": {
    "description": "Splits a tensor into multiple sub-tensors.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "indices_or_sections",
        "type": "Union[int, List[int]]"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "TensorType": {
    "description": "Type representation of a Tensor.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "TensorWise": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Tensordot": {
    "description": "Returns a contraction of a and b over multiple dimensions.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b",
        "type": "Tensor"
      },
      {
        "default": 2,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dims",
        "type": "Union[int, Tuple]"
      }
    ],
    "variants": {}
  },
  "Test": {
    "description": "Pytest test runner.",
    "std_args": [
      {
        "default": "fast",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "label",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "TestAssignmentOnlyModules": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestDataOnlyMultiModule": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestModuleAndSubroutine": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestModuleDeclaration": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestModuleDocString": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestModuleFilterPublicEntities": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestModuleProcedure": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestModuleWithDerivedType": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestModuleWithoutPublicEntities": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TestUsedModule": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "TextVectorization": {
    "description": "A preprocessing layer which maps text features to integer sequences.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "max_tokens",
        "type": "int"
      },
      {
        "default": "lower_and_strip_punctuation",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "standardize",
        "type": "str"
      },
      {
        "default": "whitespace",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "split",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ngrams",
        "type": "int"
      },
      {
        "default": "int",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "output_mode",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "output_sequence_length",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "pad_to_max_tokens",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "vocabulary",
        "type": "List[str]"
      }
    ],
    "variants": {}
  },
  "TfIdfVectorizer": {
    "description": "This transform extracts n-grams from the input sequence and save them as a vector. Input can be either a 1-D or 2-D tensor. For 1-D input, output is the n-gram representation of that input. For 2-D input, the output is also a  2-D tensor whose i-th row is the n-gram representation of the i-th input ...",
    "from": "Operators.md",
    "std_args": [
      [
        "X",
        "Tensor"
      ],
      [
        "max_gram_length",
        "int"
      ],
      [
        "max_skip_count",
        "int"
      ],
      [
        "min_gram_length",
        "int"
      ],
      [
        "mode",
        "str"
      ],
      [
        "ngram_counts",
        "List[int]"
      ],
      [
        "ngram_indexes",
        "List[int]"
      ],
      [
        "pool_int64s",
        "List[int]"
      ],
      [
        "pool_strings",
        "List[str]"
      ],
      [
        "weights",
        "List[float]"
      ]
    ]
  },
  "Threshold": {
    "description": "Thresholds each element of the input Tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "threshold",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Threshold_": {
    "description": "In-place version of Threshold.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "threshold",
        "type": "float"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "ThresholdedRelu": {
    "description": "ThresholdedRelu takes one input data (Tensor<T>) and produces one output data (Tensor<T>) where the rectified linear function, y = x for x > alpha, y = 0 otherwise, is applied to the tensor elementwise.",
    "from": "Operators.md",
    "std_args": [
      [
        "X",
        "Tensor"
      ],
      [
        "alpha",
        "float"
      ]
    ]
  },
  "ThroughputBenchmark": {
    "description": "PyTorch internal benchmarking utility.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Tile": {
    "description": "Constructs a tensor by repeating the elements of input.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dims",
        "type": "Tuple[int]"
      }
    ],
    "variants": {}
  },
  "TimeDistributed": {
    "description": "This wrapper allows to apply a layer to every temporal slice of an input.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "layer",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Timedelta64": {
    "description": "A timedelta stored as a 64-bit integer.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ToDlpack": {
    "description": "Exports a tensor to a DLPack capsule.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tensor",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ToFlatState": {
    "description": "Flattens a nested state dictionary.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "state",
        "type": "dict"
      }
    ],
    "variants": {}
  },
  "ToPureDict": {
    "description": "Converts a State object to a standard Python dictionary.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "state",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "ToTensor": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "ToTree": {
    "description": "Reconstructs a PyTree from flat state?",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tree",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "TopK": {
    "description": "Returns the k largest elements of the given input tensor along a given dimension.",
    "output_shape_calc": "lambda input, k, dim: (input.shape[:dim] + (k,) + input.shape[dim+1:], input.shape[:dim] + (k,) + input.shape[dim+1:])",
    "return_type": "Tuple[Tensor, Tensor]",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "k",
        "type": "int"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "largest",
        "type": "bool"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "sorted",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "TopKValues": {
    "description": "Returns the k largest elements from the input (Values only).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "k",
        "type": "int"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "TorchFunctional": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "TorchLoad": {
    "description": "Definition for TorchLoad",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "f",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "TorchModuleWrapper": {
    "description": "Torch module wrapper layer for Keras.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "module",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "name",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "TorchSave": {
    "description": "Definition for TorchSave",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "obj",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "f",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Trace": {
    "description": "Returns the sum of the elements of the diagonal of the input 2-D matrix.",
    "return_type": "Tensor",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "rank": 2,
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "TraceState": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "TracingState": {
    "description": "Internal JIT tracing state container.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "TrainMode": {
    "description": "Puts the model or node into training mode (enabling dropout, batch norm updating).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "node",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "TrainState": {
    "description": "TrainState container.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "graphdef",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "params",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "opt_state",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "step",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "TrainablePositionalEmbedding": {
    "description": "Generates trainable position embedding for a given 1-d sequence.",
    "op_type": "class",
    "std_args": [
      {
        "default": 10240,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "max_seq_length",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "embedding_dims",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Transformer": {
    "description": "Transformer layer with multi-headed attention.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_dims",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hidden_dims",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_heads",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim_per_head",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "TransformerDecoderLayer": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "TransformerEncoderDecoder": {
    "description": "Transformer encoder/decoder class.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "model_dims",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "TransformerEncoderLayer": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "TransformerFeedForward": {
    "description": "Transformer feedforward layer with residual connection and dropout.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_dims",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hidden_dims",
        "type": "int"
      },
      {
        "default": 0.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dropout_prob",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "TransformerFeedForwardMoe": {
    "description": "A sharded MoE Layer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_dims",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hidden_dims",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_experts",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_groups",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "TransformerLm": {
    "description": "Packed Transformer LM with position embedding and shared softmax layer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "vocab_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "model_dims",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Transformerdecoder": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Transformerencoder": {
    "description": "Auto-generated from mlx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Transpose": {
    "description": "Returns a tensor that is a transposed version of input. Swaps dimensions dim0 and dim1.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim0",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim1",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Transpose2D": {
    "description": "Transposes dimensions 0 and 1 of a tensor. Expects <= 2D input.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "TransposeCopy": {
    "description": "Alias for Transpose. Returns a fresh copy of transposed tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim0",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim1",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Trapezoid": {
    "description": "Computes the trapezoidal rule along dim.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dx",
        "type": "float"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Trapz": {
    "description": "Alias for Trapezoid.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dx",
        "type": "float"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Tri": {
    "description": "An array with ones at and below the given diagonal and zeros elsewhere.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "N",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "M",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "k",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "dtype"
      }
    ],
    "variants": {}
  },
  "TriangularSolve": {
    "description": "Solves a system of equations with a triangular coefficient matrix.",
    "return_type": "Tuple[Tensor, Tensor]",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "b",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "A",
        "type": "Tensor"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "upper",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "transpose",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "unitriangular",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Tril": {
    "description": "Returns the lower triangular part of the matrix or batch of matrices.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "diagonal",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "TrilIndices": {
    "description": "Returns the indices of the lower triangular part of a row-by-col matrix.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "row",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "col",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "offset",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "TrilIndicesFrom": {
    "description": "Return the indices for the lower-triangle of arr.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "arr",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "k",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Trilu": {
    "description": "Given a 2-D matrix or batches of 2-D matrices, returns the upper or lower triangular part of the tensor(s). The attribute \"upper\" determines whether the upper or lower part is retained. If set to true, the upper triangular matrix is retained. Lower triangular matrix is retained otherwise. Default va...",
    "from": "Operators.md",
    "std_args": [
      [
        "input",
        "Tensor"
      ],
      [
        "k",
        "int"
      ],
      [
        "upper",
        "int"
      ]
    ]
  },
  "TrimZeros": {
    "description": "Remove values along a dimension which are zero along all other.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "filt",
        "type": "Tensor"
      },
      {
        "default": "fb",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "trim",
        "type": "str"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "TripletMarginLoss": {
    "description": "Creates a criterion that measures the triplet loss.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "anchor",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "positive",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "negative",
        "type": "Tensor"
      },
      {
        "default": 1.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "margin",
        "type": "float"
      },
      {
        "default": 2.0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "p",
        "type": "float"
      },
      {
        "default": "1e-06",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "eps",
        "type": "float"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "swap",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "TripletMarginWithDistanceLoss": {
    "description": "Creates a criterion that measures the triplet loss given input",
    "std_args": [
      "self",
      "distance_function",
      "margin",
      "swap",
      "reduction"
    ],
    "type": "class"
  },
  "Triu": {
    "description": "Returns the upper triangular part of a matrix.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "diagonal",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "TriuIndices": {
    "description": "Returns the indices of the upper triangular part of a row-by-col matrix.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "row",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "col",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "offset",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "TriuIndicesFrom": {
    "description": "Return the indices for the upper-triangle of arr.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "arr",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "k",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "TrueDiv": {
    "description": "Divides x / y elementwise (floating point).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "TrueDivide": {
    "description": "Alias for division with float promotion.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dividend",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "divisor",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "True_": {
    "description": "Boolean type (True or False), stored as a byte. Legacy Numpy definition.",
    "std_args": [
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Trunc": {
    "description": "Returns a new tensor with the truncated integer values of the elements of input.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "TruncInplace": {
    "description": "In-place version of trunc.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "TupleType": {
    "description": "Type representation of a tuple.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "TverskyLoss": {
    "description": "Computes the Tversky loss value between y_true and y_pred.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_true",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y_pred",
        "type": "Tensor"
      },
      {
        "default": 0.5,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "alpha",
        "type": "float"
      },
      {
        "default": 0.5,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Type": {
    "description": "Top-level Type class.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "TypeVarA": {
    "description": "Type variable 'A' for static typing.",
    "std_args": [],
    "variants": {}
  },
  "TypeVarM": {
    "description": "Type variable helper.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "name",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "Typecodes": {
    "description": "Dictionary defining character codes for types.",
    "std_args": [],
    "variants": {}
  },
  "TypedStorage": {
    "description": "Legacy storage class for typed data.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Typename": {
    "description": "String representation of the type of an object.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "obj",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "UByte": {
    "description": "Unsigned integer type, compatible with C unsigned char.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "UFunc": {
    "description": "Functions that operate element by element on whole arrays.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "UInt": {
    "description": "Unsigned signed integer type, 64bit on 64bit system.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "UInt16": {
    "description": "16-bit unsigned integer type/constructor.",
    "std_args": [
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "UInt32": {
    "description": "32-bit unsigned integer type/constructor.",
    "std_args": [
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "UInt64": {
    "description": "64-bit unsigned integer type/constructor.",
    "std_args": [
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "UInt8": {
    "description": "8-bit unsigned integer type/constructor.",
    "std_args": [
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "UIntC": {
    "description": "Unsigned integer type, compatible with C ``unsigned int``.",
    "std_args": [
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "UIntP": {
    "description": "Unsigned integer large enough to fit pointer.",
    "std_args": [
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ULong": {
    "description": "Unsigned long integer type.",
    "std_args": [
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ULongLong": {
    "description": "Unsigned long long integer type.",
    "std_args": [
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "UPPER_LEFT": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "USE_TMA": {
    "description": "Whether to use Tensor Memory Accelerator (TMA) on supported hardware.",
    "std_args": [],
    "type": "attribute"
  },
  "UShort": {
    "description": "Unsigned integer type, compatible with C ``unsigned short``.",
    "std_args": [
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Ufunc": {
    "description": "Universal functions which operation element-by-element on arrays.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "func",
        "type": "Callable"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "nin",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "nout",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "identity",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Uint": {
    "description": "A JAX scalar constructor of type uint64.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Uint1": {
    "description": "1-bit unsigned integer type.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Uint16": {
    "description": "16-bit unsigned integer type.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Uint2": {
    "description": "2-bit unsigned integer type.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Uint3": {
    "description": "3-bit unsigned integer type.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Uint32": {
    "description": "32-bit unsigned integer type.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Uint4": {
    "description": "4-bit unsigned integer type.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Uint5": {
    "description": "5-bit unsigned integer type.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Uint6": {
    "description": "6-bit unsigned integer type.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Uint64": {
    "description": "64-bit unsigned integer type.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Uint7": {
    "description": "7-bit unsigned integer type.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Uint8": {
    "description": "8-bit unsigned integer type.",
    "op_type": "attribute",
    "std_args": [],
    "variants": {}
  },
  "Unbind": {
    "description": "Removes a tensor dimension. Returns a tuple of all slices along a given dimension.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "UnbindCopy": {
    "description": "Alias for Unbind. Returns fresh copies.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Unflatten": {
    "description": "Expands a dimension of the input tensor over multiple dimensions.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "sizes",
        "type": "Tuple[int]"
      }
    ],
    "variants": {}
  },
  "Unfold": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "UnfoldCopy": {
    "description": "Extracts sliding local blocks from a batched input tensor. Copy variant.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dimension",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "step",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Unicode": {
    "description": "Unicode string type (NumPy). Unsupported in strict Tensor frameworks.",
    "std_args": [
      {
        "default": "",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Any"
      },
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "args",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "UnifyTypeList": {
    "description": "Internal type unification utility. No-op in transpilation contexts.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "types",
        "type": "List[Any]"
      }
    ],
    "variants": {}
  },
  "UninitializedBuffer": {
    "description": "A buffer that is not initialized.",
    "std_args": [
      "self",
      "data",
      "requires_grad",
      "persistent"
    ],
    "type": "class"
  },
  "UninitializedParameter": {
    "description": "A parameter that is not initialized.",
    "std_args": [
      "self",
      "data",
      "requires_grad"
    ],
    "type": "class"
  },
  "UninitializedTensorMixin": {
    "description": "The class representing a Python class.",
    "std_args": [],
    "type": "class"
  },
  "Union1d": {
    "description": "Find the union of two arrays.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ar1",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ar2",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "UnionType": {
    "description": "Type representation for unions.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Unique": {
    "description": "Returns the unique elements of the input tensor.",
    "return_type": "Tuple[Tensor, ...]",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "default": true,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "sorted",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "return_inverse",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "return_counts",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "UniqueAll": {
    "description": "Find the unique elements of an array, and counts, inverse, and indices.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "UniqueConsecutive": {
    "description": "Eliminates all but the first element from every consecutive group of equivalent elements.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "return_inverse",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "return_counts",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "UniqueCounts": {
    "description": "Find the unique elements and counts of an input array.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "UniqueInverse": {
    "description": "Find the unique elements of x and indices to reconstruct x.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "UniqueValues": {
    "description": "Returns the unique elements of an input array.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "UnitNormalization": {
    "description": "Normalize a batch of inputs so that each input in the batch has a L2 norm equal to 1.",
    "op_type": "class",
    "std_args": [
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "UnpackBits": {
    "description": "Unpacks elements of a uint8 array into a binary-valued output array.",
    "std_args": [
      {
        "dtype": "uint8",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "count",
        "type": "int"
      },
      {
        "default": "big",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "bitorder",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "UnravelIndex": {
    "description": "Converts a flat index or array of flat indices into a tuple of coordinate arrays.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "indices",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "shape",
        "type": "Tuple[int]"
      }
    ],
    "variants": {}
  },
  "UnsafeChunk": {
    "description": "Chunks a tensor into specific number of chunks. Alias for Chunk where unsafe optimization is ignored.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "chunks",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "UnsafeSplit": {
    "description": "Splits a tensor into sections. Alias for Split.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tensor",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "split_size_or_sections",
        "type": "Union[int, List[int]]"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "UnsafeSplitWithSizes": {
    "description": "Splits tensor with explicit sizes.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tensor",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "split_sizes",
        "type": "List[int]"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "UnsignedInteger": {
    "description": "Abstract base class of all unsigned integer scalar types.",
    "std_args": [],
    "variants": {}
  },
  "UnsortedSegmentMax": {
    "description": "Computes the maximum along segments of a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "segment_ids",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_segments",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "UnsortedSegmentMean": {
    "description": "Computes the mean along segments of a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "segment_ids",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_segments",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "UnsortedSegmentMin": {
    "description": "Computes the minimum along segments of a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "segment_ids",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_segments",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "UnsortedSegmentProd": {
    "description": "Computes the product along segments of a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "segment_ids",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_segments",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "UnsortedSegmentSqrtN": {
    "description": "Computes the sum along segments of a tensor divided by the sqrt(N).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "segment_ids",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_segments",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "UnsortedSegmentSum": {
    "description": "Computes the sum along segments of a tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "segment_ids",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_segments",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Unsqueeze": {
    "description": "Returns a new tensor with a dimension of size one inserted at the specified position.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "max": 5.0,
        "min": -5.0,
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "UnsqueezeCopy": {
    "description": "Copy-variant of Unsqueeze.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Unstack": {
    "description": "Split an array into a sequence of arrays along the given axis.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Array"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "UntypedStorage": {
    "description": "Legacy storage class for untyped data.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "Unwrap": {
    "description": "Unwrap by taking the complement of large deltas with respect to the period.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "p",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "discont",
        "type": "float"
      },
      {
        "default": -1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "default": 6.283185307179586,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "period",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "UpSampling1D": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "UpSampling1d": {
    "description": "Upsampling layer for 1D inputs.",
    "op_type": "class",
    "std_args": [
      {
        "default": 2,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "UpSampling2D": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "UpSampling2d": {
    "description": "Upsampling layer for 2D inputs.",
    "op_type": "class",
    "std_args": [
      {
        "default": [
          2,
          2
        ],
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "Tuple[int, int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      },
      {
        "default": "nearest",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "interpolation",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "UpSampling3D": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "UpSampling3d": {
    "description": "Upsampling layer for 3D inputs.",
    "op_type": "class",
    "std_args": [
      {
        "default": [
          2,
          2,
          2
        ],
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "size",
        "type": "Tuple[int, int, int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "data_format",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "UpdateContext": {
    "description": "Context manager/decorator for handling complex state updates with graph mutations.",
    "op_type": "context",
    "std_args": [
      {
        "default": "'default'",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tag",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "UpdateCvState": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "UpdateState": {
    "description": "Updates a graph node with a new state dictionary in-place.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "node",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "state",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Upsample": {
    "description": "Upsample the input signal spatially.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "scale_factor",
        "type": "float | Tuple"
      },
      {
        "default": "nearest",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mode",
        "options": [
          "nearest",
          "linear",
          "cubic",
          "bilinear",
          "bicubic"
        ],
        "type": "str"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "align_corners",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "UpsamplingBilinear2d": {
    "description": "Applies a 2D bilinear upsampling to an input signal composed of several input channels.",
    "std_args": [
      "self",
      "size",
      "scale_factor"
    ],
    "type": "class"
  },
  "UpsamplingNearest2d": {
    "description": "Applies a 2D nearest neighbor upsampling to an input signal composed of several input channels.",
    "std_args": [
      "self",
      "size",
      "scale_factor"
    ],
    "type": "class"
  },
  "Use": {
    "description": "Internal Use class.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "UseDeterministicAlgorithms": {
    "description": "Sets whether operations must use deterministic algorithms.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "mode",
        "type": "bool"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "warn_only",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "UseEagerSharding": {
    "description": "Sets whether Variables should use eager sharding by default.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "UseGlobalDeps": {
    "description": "Configuration flag for global dependencies.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "UseHijax": {
    "description": "Enables or disables Hijax mode.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "UseRtldGlobal": {
    "description": "Configuration flag for RTLD_GLOBAL usage.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "UsingEagerSharding": {
    "description": "Returns True if eager sharding is currently enabled.",
    "std_args": [],
    "variants": {}
  },
  "UsingHijax": {
    "description": "Returns True if Hijax mode is currently enabled.",
    "std_args": [],
    "variants": {}
  },
  "V": {
    "description": "Auto-generated from flax_nnx_code_defs",
    "std_args": [],
    "variants": {}
  },
  "VMap": {
    "description": "Vectorizing map. Creates a function that maps f over array axes.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "f",
        "type": "Callable"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "in_axes",
        "type": "Any"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "out_axes",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "VQNgrammer": {
    "description": "Implements a VQ based ngrammer layer which looks up latent ngram id.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ngram_vocab_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ngram_emb_dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Value": {
    "description": "Internal Value class for IR.",
    "op_type": "class",
    "std_args": [],
    "variants": {}
  },
  "ValueAndGrad": {
    "description": "Computes the value and gradient of a function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "model",
        "type": "Any"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "fn",
        "type": "Callable"
      }
    ],
    "variants": {}
  },
  "ValuesCopy": {
    "description": "Copy-variant of .values() accessor (typically for sparse tensors).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Vander": {
    "description": "Generates a Vandermonde matrix.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "N",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "increasing",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "VanillaBlock": {
    "description": "Vanilla Convolution Block.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "output_dim",
        "type": "int"
      },
      {
        "default": 3,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "kernel_size",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "VanillaNet": {
    "description": "VanillaNet model without skip-connection or batch-norm mirroring ResNets.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "strides",
        "type": "Sequence[int]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "channels",
        "type": "Sequence[int]"
      }
    ],
    "variants": {}
  },
  "Var": {
    "description": "Calculates the variance.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "correction",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "VarMean": {
    "description": "Returns (var, mean).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "correction",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Variable": {
    "description": "The base class for all Variable types.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "VariableMetadata": {
    "description": "Metadata container for variables.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "raw_value",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "VariableNameFromType": {
    "description": "Gets the collection name for a Variable type.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "typ",
        "type": "type"
      }
    ],
    "variants": {}
  },
  "VariableTypeFromName": {
    "description": "Gets the Variable class from a collection name.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "name",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "Variance": {
    "description": "Compute the variance along the specified axis.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "a",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "dtype"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "out",
        "type": "Tensor"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "ddof",
        "type": "int"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "keepdims",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "Vdot": {
    "description": "Computes the dot product of two vectors (conjugating the first if complex).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Vecdot": {
    "description": "Vector dot product of two arrays.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x1",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x2",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "axis",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "Vecmat": {
    "description": "Vector-matrix dot product of two arrays.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x1",
        "type": "Array"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x2",
        "type": "Array"
      }
    ],
    "variants": {}
  },
  "VectorQuantization": {
    "description": "Implements vector quantization (VQ)/online k-means clustering.",
    "op_type": "class",
    "std_args": [
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_clusters",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_heads",
        "type": "int"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dim_per_head",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "VectorQuantizer": {
    "description": "The VQ-VAE sequence vector quantizer.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "num_latent_classes",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "latent_dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "beta",
        "type": "float"
      }
    ],
    "variants": {}
  },
  "Vectorize": {
    "description": "Returns an object that acts like pyfunc, but takes arrays as input.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "pyfunc",
        "type": "Callable"
      }
    ],
    "variants": {}
  },
  "View": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "ViewAsComplex": {
    "description": "Views a real float tensor as a complex tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ViewAsComplexCopy": {
    "description": "Copy-variant of view_as_complex.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ViewAsReal": {
    "description": "Views a complex tensor as a real tensor.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ViewAsRealCopy": {
    "description": "Copy-variant of view_as_real.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ViewCopy": {
    "description": "Copy-variant of View (Reshape).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "name": "shape",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "VisionTransformer": {
    "description": "Vision transformer model.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "entry_layers_tpl",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "VitEntryLayers": {
    "description": "Entry block of ViT (Patch Embed).",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "patch_size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input_dims",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "output_dims",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "VitExitLayers": {
    "description": "Exit block of ViT.",
    "op_type": "class",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "hidden_dim",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "output_dim",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "VitalsEnabled": {
    "description": "Checks if vitals are enabled. Internal.",
    "std_args": [],
    "variants": {}
  },
  "Vjp": {
    "description": "Compute the vector-Jacobian product.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "fun",
        "type": "Callable"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "primals",
        "type": "List[Tensor]"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "cotangents",
        "type": "List[Tensor]"
      }
    ],
    "variants": {}
  },
  "Vmap": {
    "description": "Vectorizing map. Creates a function that maps a computation over a batch axis.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "func",
        "type": "Callable"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "in_axes",
        "type": "Any"
      },
      {
        "default": 0,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "out_axes",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Void": {
    "description": "Create a new structured or unstructured void scalar.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "length_or_data",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Vsplit": {
    "description": "Splits an array into multiple sub-arrays vertically (row-wise).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "indices_or_sections",
        "type": "Union[int, List[int]]"
      }
    ],
    "variants": {}
  },
  "Vstack": {
    "description": "Stacks arrays in sequence vertically (row wise).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tensors",
        "type": "List[Tensor]"
      }
    ],
    "variants": {}
  },
  "WARN_FOR_UNFUSED_KERNELS": {
    "description": "An enum-like class that contains the different backends for scaled dot product attention.",
    "std_args": [],
    "type": "attribute"
  },
  "WRITE_DQ": {
    "description": "Controls whether gradient scatters are done in the DQ iteration loop of the backward pass.",
    "std_args": [],
    "type": "attribute"
  },
  "Wait": {
    "description": "Waits on a future.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "future",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "WeightNorm": {
    "description": "L2 weight normalization.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "layer",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "Wh": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Where": {
    "description": "Selects elements from x or y depending on condition.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "condition",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Whh": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "WhileLoop": {
    "description": "Constructs a loop that executes body_fn while cond_fn is true.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "cond_fn",
        "type": "Callable"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "body_fn",
        "type": "Callable"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "init_val",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "WithMetadata": {
    "description": "Annotates an initializer or variable with metadata hooks.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "initializer",
        "type": "Callable"
      }
    ],
    "variants": {}
  },
  "WithPartitioning": {
    "description": "Annotates an initializer with sharding constraints.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "initializer",
        "type": "Callable"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "sharding",
        "type": "Any"
      }
    ],
    "variants": {}
  },
  "WithTag": {
    "description": "Tags a variable.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "tag",
        "type": "str"
      }
    ],
    "variants": {}
  },
  "WrappedSchedule": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Wrapper": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "Wx": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Wxh": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "Xdivy": {
    "description": "Computes x / y. Returns zero when x = 0.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Xlog1py": {
    "description": "Compute x * log1p(y). Returns zero when x = 0.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Xlogy": {
    "description": "Computes x * log(y).",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Xlogy_": {
    "description": "In-place variant of Xlogy.",
    "is_inplace": true,
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "y",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Xor": {
    "description": "Returns the tensor resulted from performing the `xor` logical operation elementwise on the input tensors `A` and `B` (with Numpy-style broadcasting support). This operator supports **multidirectional (i.e., Numpy-style) broadcasting**; for more details please check [the doc](Broadcasting.md).",
    "from": "Operators.md",
    "std_args": [
      [
        "A",
        "Tensor"
      ],
      [
        "B",
        "Tensor"
      ],
      [
        "decay_factor",
        "float"
      ],
      [
        "epsilon",
        "float"
      ],
      [
        "norm_coefficient",
        "float"
      ]
    ]
  },
  "ZeroFraction": {
    "description": "Returns the fraction of zeros in value.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "value",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "ZeroNansState": {
    "description": "Auto-generated from jax_code_defs",
    "std_args": [],
    "variants": {}
  },
  "ZeroPad1d": {
    "description": "Pads the input tensor boundaries with zero.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ZeroPad2d": {
    "description": "Pads the input tensor boundaries with zero.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ZeroPad3d": {
    "description": "Pads the input tensor boundaries with zero.",
    "std_args": [
      "self",
      "padding"
    ],
    "type": "class"
  },
  "ZeroPadding1D": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "ZeroPadding1d": {
    "description": "Zero-padding layer for 1D input.",
    "op_type": "class",
    "std_args": [
      {
        "default": 1,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "int"
      }
    ],
    "variants": {}
  },
  "ZeroPadding2D": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "ZeroPadding2d": {
    "description": "Zero-padding layer for 2D input.",
    "op_type": "class",
    "std_args": [
      {
        "default": [
          1,
          1
        ],
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "Tuple[int, int]"
      }
    ],
    "variants": {}
  },
  "ZeroPadding3D": {
    "description": "Auto-generated from keras_code_defs",
    "std_args": [],
    "variants": {}
  },
  "ZeroPadding3d": {
    "description": "Zero-padding layer for 3D data.",
    "op_type": "class",
    "std_args": [
      {
        "default": [
          1,
          1,
          1
        ],
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "padding",
        "type": "Tuple[int, int, int]"
      }
    ],
    "variants": {}
  },
  "Zero_": {
    "description": "Fills the input tensor with the scalar value 0 in-place.",
    "is_inplace": true,
    "std_args": [
      {
        "dtype": "float32",
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "rank": 0,
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "Zeros": {
    "description": "Returns a tensor filled with the-scalar value 0, with the shape defined by the variable argument size.",
    "std_args": [
      {
        "is_variadic": true,
        "kind": "positional_or_keyword",
        "min": 0.0,
        "name": "size",
        "type": "int"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "DType"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "device",
        "type": "Device"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "requires_grad",
        "type": "bool"
      }
    ],
    "variants": {}
  },
  "ZerosLike": {
    "description": "Returns a tensor filled with the scalar value 0, with the same size as input.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "input",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "dtype",
        "type": "DType"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "device",
        "type": "Device"
      },
      {
        "default": false,
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "requires_grad",
        "type": "bool"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "layout",
        "type": "Layout"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "memory_format",
        "type": "MemoryFormat"
      }
    ],
    "variants": {}
  },
  "Zeta": {
    "description": "Compute the Hurwitz zeta function.",
    "std_args": [
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "x",
        "type": "Tensor"
      },
      {
        "is_variadic": false,
        "kind": "positional_or_keyword",
        "name": "q",
        "type": "Tensor"
      }
    ],
    "variants": {}
  },
  "activate_flash_attention_impl": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "activation_fn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "adapt": {
    "description": "Computes a vocabulary of string terms from tokens in a dataset.\n\nCalling `adapt()` on a `TextVectorization` layer is an alternative to\npassing in a precomputed vocabulary on construction via the `vocabulary`\nargument. A `TextVectorization` layer should always be either adapted\nover a dataset or supplied with a vocabulary.\n\nDuring `adapt()`, the layer will build a vocabulary of all string tokens\nseen in the dataset, sorted by occurrence count, with ties broken by\nsort order of the tokens (high to low). At the end of `adapt()`, if\n`max_tokens` is set, the vocabulary will be truncated to `max_tokens`\nsize. For example, adapting a layer with `max_tokens=1000` will compute\nthe 1000 most frequent tokens occurring in the input dataset. If\n`output_mode='tf-idf'`, `adapt()` will also learn the document\nfrequencies of each token in the input dataset.\n\nArguments:\n    data: The data to train on. It can be passed either as a\n        batched `tf.data.Dataset`, as a list of strings,\n        or as a NumPy array.\n    steps: Integer or `None`.\n        Total number of steps (batches of samples) to process.\n        If `data` is a `tf.data.Dataset`, and `steps` is `None`,\n        `adapt()` will run until the input dataset is exhausted.\n        When passing an infinitely\n        repeating dataset, you must specify the `steps` argument. This\n        argument is not supported with array inputs or list inputs.",
    "std_args": [
      "self",
      "data",
      "batch_size",
      "steps"
    ],
    "type": "function"
  },
  "adaptive_avg_pool1d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "adaptive_avg_pool2d": {
    "description": "Apply a 2D adaptive average pooling over an input signal composed of several input planes.",
    "std_args": [
      "input",
      "output_size"
    ],
    "type": "function"
  },
  "adaptive_avg_pool3d": {
    "description": "Apply a 3D adaptive average pooling over an input signal composed of several input planes.",
    "std_args": [
      "input",
      "output_size"
    ],
    "type": "function"
  },
  "adaptive_max_pool1d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "adaptive_max_pool1d_with_indices": {
    "description": "adaptive_max_pool1d(input, output_size, return_indices=False)",
    "std_args": [
      "input",
      "output_size",
      "return_indices"
    ],
    "type": "function"
  },
  "adaptive_max_pool2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "adaptive_max_pool2d_with_indices": {
    "description": "adaptive_max_pool2d(input, output_size, return_indices=False)",
    "std_args": [
      "input",
      "output_size",
      "return_indices"
    ],
    "type": "function"
  },
  "adaptive_max_pool3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "adaptive_max_pool3d_with_indices": {
    "description": "adaptive_max_pool3d(input, output_size, return_indices=False)",
    "std_args": [
      "input",
      "output_size",
      "return_indices"
    ],
    "type": "function"
  },
  "add_loss": {
    "description": "Can be called inside of the `call()` method to add a scalar loss.\n\nExample:\n\n```python\nclass MyLayer(Layer):\n    ...\n    def call(self, x):\n        self.add_loss(ops.sum(x))\n        return x\n```",
    "std_args": [
      "self",
      "loss"
    ],
    "type": "function"
  },
  "add_metric": {
    "description": "",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "add_module": {
    "description": "Add a child module to the current module.",
    "std_args": [
      "self",
      "name",
      "module"
    ],
    "type": "function"
  },
  "add_pruning_method": {
    "description": "Add a child pruning ``method`` to the container.",
    "std_args": [
      "self",
      "method"
    ],
    "type": "function"
  },
  "add_variable": {
    "description": "Add a weight variable to the layer.\n\nAlias of `add_weight()`.",
    "std_args": [
      "self",
      "shape",
      "initializer",
      "dtype",
      "trainable",
      "autocast",
      "regularizer",
      "constraint",
      "name"
    ],
    "type": "function"
  },
  "add_weight": {
    "description": "Add a weight variable to the layer.\n\nArgs:\n    shape: Shape tuple for the variable. Must be fully-defined\n        (no `None` entries). Defaults to `()` (scalar) if unspecified.\n    initializer: Initializer object to use to populate the initial\n        variable value, or string name of a built-in initializer\n        (e.g. `\"random_normal\"`). If unspecified, defaults to\n        `\"glorot_uniform\"` for floating-point variables and to `\"zeros\"`\n        for all other types (e.g. int, bool).\n    dtype: Dtype of the variable to create, e.g. `\"float32\"`. If\n        unspecified, defaults to the layer's variable dtype\n        (which itself defaults to `\"float32\"` if unspecified).\n    trainable: Boolean, whether the variable should be trainable via\n        backprop or whether its updates are managed manually. Defaults\n        to `True`.\n    autocast: Boolean, whether to autocast layers variables when\n        accessing them. Defaults to `True`.\n    regularizer: Regularizer object to call to apply penalty on the\n        weight. These penalties are summed into the loss function\n        during optimization. Defaults to `None`.\n    constraint: Contrainst object to call on the variable after any\n        optimizer update, or string name of a built-in constraint.\n        Defaults to `None`.\n    aggregation: Optional string, one of `None`, `\"none\"`, `\"mean\"`,\n        `\"sum\"` or `\"only_first_replica\"`. Annotates the variable with\n        the type of multi-replica aggregation to be used for this\n        variable when writing custom data parallel training loops.\n        Defaults to `\"none\"`.\n    overwrite_with_gradient: Boolean, whether to overwrite the variable\n        with the computed gradient. This is useful for float8 training.\n        Defaults to `False`.\n    name: String name of the variable. Useful for debugging purposes.",
    "std_args": [
      "self",
      "shape",
      "initializer",
      "dtype",
      "trainable",
      "autocast",
      "regularizer",
      "constraint",
      "aggregation",
      "overwrite_with_gradient",
      "name"
    ],
    "type": "function"
  },
  "add_zero_attn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "affine": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "affine_grid": {
    "description": "Generate 2D or 3D flow field (sampling grid), given a batch of affine matrices :attr:`theta`.",
    "std_args": [
      "theta",
      "size",
      "align_corners"
    ],
    "type": "function"
  },
  "all_weights": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "alpha_dropout": {
    "description": "Apply alpha dropout to the input.",
    "std_args": [
      "input",
      "p",
      "training",
      "inplace"
    ],
    "type": "function"
  },
  "amount": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "and_masks": {
    "description": "Returns a mask_mod that's the intersection of provided mask_mods",
    "std_args": [
      "mask_mods"
    ],
    "type": "function"
  },
  "apply_permutation": {
    "description": "The class representing a Python function.",
    "std_args": [
      "tensor",
      "permutation",
      "dim"
    ],
    "type": "function"
  },
  "apply_to_modules": {
    "description": "Apply a function to all the modules in this instance (including this",
    "std_args": [
      "self",
      "apply_fn"
    ],
    "type": "function"
  },
  "as_linear": {
    "description": "Call the embedding layer as a linear layer.",
    "std_args": [
      "self",
      "x"
    ],
    "type": "function"
  },
  "as_tuple": {
    "description": "Returns a tuple of the attributes of the BlockMask.",
    "std_args": [
      "self",
      "flatten"
    ],
    "type": "function"
  },
  "assert_int_or_pair": {
    "description": "The class representing a Python function.",
    "std_args": [
      "arg",
      "arg_name",
      "message"
    ],
    "type": "function"
  },
  "attend": {
    "description": "Attend over the embedding using a query array.",
    "std_args": [
      "self",
      "query"
    ],
    "type": "function"
  },
  "attention_fn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "average_gradients": {
    "description": "Average the gradients across the distributed processes in the passed group.",
    "std_args": [
      "gradients",
      "group",
      "all_reduce_size",
      "communication_type",
      "communication_stream"
    ],
    "type": "function"
  },
  "avg_pool1d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "avg_pool2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "avg_pool3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "axis_index_groups": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "axis_name": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "backward_rnn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "base_module": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "batch_axis": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "batch_first": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "batch_norm": {
    "description": "Apply Batch Normalization for each channel across a batch of data.",
    "std_args": [
      "input",
      "running_mean",
      "running_var",
      "weight",
      "bias",
      "training",
      "momentum",
      "eps"
    ],
    "type": "function"
  },
  "batch_sizes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "batch_stats": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bhn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bias_shape": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "biases": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "binary_cross_entropy_with_logits": {
    "description": "Compute Binary Cross Entropy between target and input logits.",
    "std_args": [
      "input",
      "target",
      "weight",
      "size_average",
      "reduce",
      "reduction",
      "pos_weight"
    ],
    "type": "function"
  },
  "bind": {
    "description": "The class representing a Python function.",
    "std_args": [
      "optional",
      "fn"
    ],
    "type": "function"
  },
  "blank": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "broadcast_bucket_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "broadcast_buffers": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "broadcast_coalesced": {
    "description": "Broadcast a sequence of tensors to the specified GPUs.",
    "std_args": [
      "tensors",
      "devices",
      "buffer_size"
    ],
    "type": "function"
  },
  "broadcast_dims": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "broadcast_dropout": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "broadcast_rngs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bucket_bytes_cap": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "bucket_bytes_cap_default": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "buffers": {
    "description": "Return an iterator over module buffers.",
    "std_args": [
      "self",
      "recurse"
    ],
    "type": "function"
  },
  "build": {
    "description": "",
    "std_args": [
      "self",
      "input_shape"
    ],
    "type": "function"
  },
  "build_from_config": {
    "description": "Builds the layer's states with the supplied config dict.\n\nBy default, this method calls the `build(config[\"input_shape\"])` method,\nwhich creates weights based on the layer's input shape in the supplied\nconfig. If your config contains other information needed to load the\nlayer's state, you should override this method.\n\nArgs:\n    config: Dict containing the input shape associated with this layer.",
    "std_args": [
      "self",
      "config"
    ],
    "type": "function"
  },
  "build_module": {
    "description": "Compile and import a f2py module, built from the given files.",
    "std_args": [
      "source_files",
      "options",
      "skip",
      "only",
      "module_name"
    ],
    "type": "function"
  },
  "buildmodule": {
    "description": "Return",
    "std_args": [
      "m",
      "um"
    ],
    "type": "function"
  },
  "cache_index": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cached_key": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cached_value": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "calculate_gain": {
    "description": "Return the recommended gain value for the given nonlinearity function.",
    "std_args": [
      "nonlinearity",
      "param"
    ],
    "type": "function"
  },
  "call_super_init": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "canonicalize_dtype": {
    "description": "Canonicalize an optional dtype to the definitive dtype.",
    "std_args": [
      "args",
      "dtype",
      "inexact"
    ],
    "type": "function"
  },
  "canonicalize_padding": {
    "description": "\"Canonicalizes conv padding to a jax.lax supported format.",
    "std_args": [
      "padding",
      "rank"
    ],
    "type": "function"
  },
  "carry_init": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "causal_lower_right": {
    "description": "Creates a lower-right triangular causal bias.",
    "std_args": [
      "size"
    ],
    "type": "function"
  },
  "causal_upper_left": {
    "description": "Creates an upper-left triangular causal bias.",
    "std_args": [
      "size"
    ],
    "type": "function"
  },
  "cell": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "celu_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "channel_shuffle": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "check_forward_args": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "input",
      "hidden",
      "batch_sizes"
    ],
    "type": "function"
  },
  "check_hidden_size": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "hx",
      "expected_hidden_size",
      "msg"
    ],
    "type": "function"
  },
  "check_input": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "input",
      "batch_sizes"
    ],
    "type": "function"
  },
  "clip_grad_value_": {
    "description": "Clip the gradients of an iterable of parameters at specified value.",
    "std_args": [
      "parameters",
      "clip_value",
      "foreach"
    ],
    "type": "function"
  },
  "cls_to_become": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "combine_masks": {
    "description": "Combine attention masks.",
    "std_args": [
      "masks",
      "dtype"
    ],
    "type": "function"
  },
  "compute_output_shape": {
    "description": "",
    "std_args": [
      "self",
      "input_shape"
    ],
    "type": "function"
  },
  "compute_output_spec": {
    "description": "",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "compute_weight": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "module"
    ],
    "type": "function"
  },
  "consume_prefix_in_state_dict_if_present": {
    "description": "Strip the prefix in state_dict in place, if any.",
    "std_args": [
      "state_dict",
      "prefix"
    ],
    "type": "function"
  },
  "containsmodule": {
    "description": "The class representing a Python function.",
    "std_args": [
      "block"
    ],
    "type": "function"
  },
  "conv_general_dilated": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "conv_tbc": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "convert_conv2d_weight_memory_format": {
    "description": "Convert ``memory_format`` of ``nn.Conv2d.weight`` to ``memory_format``.",
    "std_args": [
      "module",
      "memory_format"
    ],
    "type": "function"
  },
  "convert_conv3d_weight_memory_format": {
    "description": "Convert ``memory_format`` of ``nn.Conv3d.weight`` to ``memory_format``",
    "std_args": [
      "module",
      "memory_format"
    ],
    "type": "function"
  },
  "convert_sync_batchnorm": {
    "description": "Converts all :attr:`BatchNorm*D` layers in the model to :class:`torch.nn.SyncBatchNorm` layers.",
    "std_args": [
      "cls",
      "module",
      "process_group"
    ],
    "type": "function"
  },
  "convert_weight": {
    "description": "Convert the weight if it is from the a different backend.",
    "std_args": [
      "self",
      "weight"
    ],
    "type": "function"
  },
  "convolution_notes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "convolution_op": {
    "description": "",
    "std_args": [
      "self",
      "inputs",
      "kernel"
    ],
    "type": "function"
  },
  "cos_first": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cosine_embedding_loss": {
    "description": "Compute the cosine embedding loss.",
    "std_args": [
      "input1",
      "input2",
      "target",
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "cosine_similarity_loss": {
    "description": "Computes the cosine similarity between the two inputs.",
    "std_args": [
      "x1",
      "x2",
      "axis",
      "eps",
      "reduction"
    ],
    "type": "function"
  },
  "count_include_pad": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "count_params": {
    "description": "Count the total number of scalars composing the weights.\n\nReturns:\n    An integer count.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "cpp_dict": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cpp_module": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "create_additive_causal_mask": {
    "description": "The class representing a Python function.",
    "std_args": [
      "N",
      "dtype"
    ],
    "type": "function"
  },
  "create_alibi_matrix": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "q_sequence_length",
      "k_sequence_length",
      "num_heads",
      "offset",
      "dtype"
    ],
    "type": "function"
  },
  "create_alibi_slope": {
    "description": "The class representing a Python function.",
    "std_args": [
      "num_heads"
    ],
    "type": "function"
  },
  "create_block_mask": {
    "description": "This function creates a block mask tuple from a mask_mod function.",
    "std_args": [
      "mask_mod",
      "B",
      "H",
      "Q_LEN",
      "KV_LEN",
      "device",
      "BLOCK_SIZE",
      "_compile"
    ],
    "type": "function"
  },
  "cross_attention": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "cuda": {
    "description": "Move all model parameters and buffers to the GPU.",
    "std_args": [
      "self",
      "device"
    ],
    "type": "function"
  },
  "current_flash_attention_impl": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "current_linen_module": {
    "description": "Get the current Linen module from the Linen context.",
    "std_args": [],
    "type": "function"
  },
  "current_module": {
    "description": "A quick util to get the current bridge module.",
    "std_args": [],
    "type": "function"
  },
  "custom_from_mask": {
    "description": "Prune tensor corresponding to parameter called ``name`` in ``module`` by applying the pre-computed mask in ``mask``.",
    "std_args": [
      "module",
      "name",
      "mask"
    ],
    "type": "function"
  },
  "cutoffs": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "data_parallel": {
    "description": "Evaluate module(input) in parallel across the GPUs given in device_ids.",
    "std_args": [
      "module",
      "inputs",
      "device_ids",
      "output_device",
      "dim",
      "module_kwargs"
    ],
    "type": "function"
  },
  "decode": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_a_initializer": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_b_initializer": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_bias_init": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_embed_init": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "default_kernel_init": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "delta": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dense_h": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dense_i": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "deterministic": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dirac": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dirac_": {
    "description": "Fill the {3, 4, 5}-dimensional input `Tensor` with the Dirac delta function.",
    "std_args": [
      "tensor",
      "groups"
    ],
    "type": "function"
  },
  "distance_function": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "divisor_override": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dot_general": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dot_general_cls": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dot_product_attention_weights": {
    "description": "Computes dot-product attention weights given query and key.",
    "std_args": [
      "query",
      "key",
      "bias",
      "mask",
      "broadcast_dropout",
      "dropout_rng",
      "dropout_rate",
      "deterministic",
      "dtype",
      "precision",
      "module",
      "promote_dtype",
      "is_causal"
    ],
    "type": "function"
  },
  "dropout1d": {
    "description": "Randomly zero out entire channels (a channel is a 1D feature map).",
    "std_args": [
      "input",
      "p",
      "training",
      "inplace"
    ],
    "type": "function"
  },
  "dropout_rate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "dump_patches": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "einsum_op": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "einsum_str": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "elementwise_affine": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "elu_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "embed_dim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "embedding_bag": {
    "description": "Compute sums, means or maxes of `bags` of embeddings.",
    "std_args": [
      "input",
      "weight",
      "offsets",
      "max_norm",
      "norm_type",
      "scale_grad_by_freq",
      "mode",
      "sparse",
      "per_sample_weights",
      "include_last_offset",
      "padding_idx"
    ],
    "type": "function"
  },
  "enable_lora": {
    "description": "",
    "std_args": [
      "self",
      "rank",
      "lora_alpha",
      "a_initializer",
      "b_initializer"
    ],
    "type": "function"
  },
  "enable_nested_tensor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "epsilon": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "error_on_non_matrix": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "extra_repr": {
    "description": "Return the extra representation of the module.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "factory_kwargs": {
    "description": "Return a canonicalized dict of factory kwargs.",
    "std_args": [
      "kwargs"
    ],
    "type": "function"
  },
  "feature_alpha_dropout": {
    "description": "Randomly masks out entire channels (a channel is a feature map).",
    "std_args": [
      "input",
      "p",
      "training",
      "inplace"
    ],
    "type": "function"
  },
  "feature_axes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "feature_axis": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "feature_group_count": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "features": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "filter_and_map": {
    "description": "Recursively filter the contents of the module using ``filter_fn``,",
    "std_args": [
      "self",
      "filter_fn",
      "map_fn",
      "is_leaf_fn"
    ],
    "type": "function"
  },
  "finalize_state": {
    "description": "",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "find_unused_parameters": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "flex_attention": {
    "description": "This function implements scaled dot product attention with an arbitrary attention score modification function.",
    "std_args": [
      "query",
      "key",
      "value",
      "score_mod",
      "block_mask",
      "scale",
      "enable_gqa",
      "return_lse",
      "kernel_options",
      "return_aux"
    ],
    "type": "function"
  },
  "flip_sequences": {
    "description": "Flips a sequence of inputs along the time axis.",
    "std_args": [
      "inputs",
      "seq_lengths",
      "num_batch_dims",
      "time_major"
    ],
    "type": "function"
  },
  "fold": {
    "description": "Combine an array of sliding local blocks into a large containing tensor.",
    "std_args": [
      "input",
      "output_size",
      "kernel_size",
      "dilation",
      "padding",
      "stride"
    ],
    "type": "function"
  },
  "forward_rnn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fractional_max_pool2d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fractional_max_pool2d_with_indices": {
    "description": "fractional_max_pool2d(input, kernel_size, output_size=None, output_ratio=None, return_indices=False, _random_samples=None)",
    "std_args": [
      "input",
      "kernel_size",
      "output_size",
      "output_ratio",
      "return_indices",
      "_random_samples"
    ],
    "type": "function"
  },
  "fractional_max_pool3d": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "fractional_max_pool3d_with_indices": {
    "description": "fractional_max_pool3d(input, kernel_size, output_size=None, output_ratio=None, return_indices=False, _random_samples=None)",
    "std_args": [
      "input",
      "kernel_size",
      "output_size",
      "output_ratio",
      "return_indices",
      "_random_samples"
    ],
    "type": "function"
  },
  "from_config": {
    "description": "Creates an operation from its config.\n\nThis method is the reverse of `get_config`, capable of instantiating the\nsame operation from the config dictionary.\n\nNote: If you override this method, you might receive a serialized dtype\nconfig, which is a `dict`. You can deserialize it as follows:\n\n```python\nif \"dtype\" in config and isinstance(config[\"dtype\"], dict):\n    policy = dtype_policies.deserialize(config[\"dtype\"])\n```\n\nArgs:\n    config: A Python dictionary, typically the output of `get_config`.\n\nReturns:\n    An operation instance.",
    "std_args": [
      "config"
    ],
    "type": "function"
  },
  "from_embedding": {
    "description": "Create a :obj:`QuantizedEmbedding` layer from an :obj:`Embedding` layer.",
    "std_args": [
      "cls",
      "embedding_layer",
      "group_size",
      "bits",
      "mode"
    ],
    "type": "function"
  },
  "from_kv_blocks": {
    "description": "Creates a BlockMask instance from key-value block information.",
    "std_args": [
      "cls",
      "kv_num_blocks",
      "kv_indices",
      "full_kv_num_blocks",
      "full_kv_indices",
      "BLOCK_SIZE",
      "mask_mod",
      "seq_lengths",
      "compute_q_blocks"
    ],
    "type": "function"
  },
  "from_linear": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "linear_layer",
      "segments",
      "group"
    ],
    "type": "function"
  },
  "from_pretrained": {
    "description": "Create EmbeddingBag instance from given 2-dimensional FloatTensor.",
    "std_args": [
      "cls",
      "embeddings",
      "freeze",
      "max_norm",
      "norm_type",
      "scale_grad_by_freq",
      "mode",
      "sparse",
      "include_last_offset",
      "padding_idx"
    ],
    "type": "function"
  },
  "from_quantized_linear": {
    "description": "The class representing a Python function.",
    "std_args": [
      "cls",
      "quantized_linear_layer",
      "segments",
      "group"
    ],
    "type": "function"
  },
  "fromkeys": {
    "description": "Return a new ParameterDict with the keys provided.",
    "std_args": [
      "self",
      "keys",
      "default"
    ],
    "type": "function"
  },
  "full_kv_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "full_kv_num_blocks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "full_q_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "full_q_num_blocks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "functional_call": {
    "description": "Perform a functional call on the module by replacing the module parameters and buffers with the provided ones.",
    "std_args": [
      "module",
      "parameters_and_buffers",
      "args",
      "kwargs",
      "tie_weights",
      "strict"
    ],
    "type": "function"
  },
  "fuse_conv_bn_eval": {
    "description": "Fuse a convolutional module and a BatchNorm module into a single, new convolutional module.",
    "std_args": [
      "conv",
      "bn",
      "transpose"
    ],
    "type": "function"
  },
  "fuse_conv_bn_weights": {
    "description": "Fuse convolutional module parameters and BatchNorm module parameters into new convolutional module parameters.",
    "std_args": [
      "conv_w",
      "conv_b",
      "bn_rm",
      "bn_rv",
      "bn_eps",
      "bn_w",
      "bn_b",
      "transpose"
    ],
    "type": "function"
  },
  "fuse_linear_bn_eval": {
    "description": "Fuse a linear module and a BatchNorm module into a single, new linear module.",
    "std_args": [
      "linear",
      "bn"
    ],
    "type": "function"
  },
  "fuse_linear_bn_weights": {
    "description": "Fuse linear module parameters and BatchNorm module parameters into new linear module parameters.",
    "std_args": [
      "linear_w",
      "linear_b",
      "bn_rm",
      "bn_rv",
      "bn_eps",
      "bn_w",
      "bn_b"
    ],
    "type": "function"
  },
  "gate_fn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "gelu_approx": {
    "description": "An approximation to Gaussian Error Linear Unit.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "gelu_fast_approx": {
    "description": "A fast approximation to Gaussian Error Linear Unit.",
    "std_args": [
      "x"
    ],
    "type": "function"
  },
  "generate_square_subsequent_mask": {
    "description": "Generate a square causal mask for the sequence.",
    "std_args": [
      "sz",
      "device",
      "dtype"
    ],
    "type": "function"
  },
  "get_a_var": {
    "description": "The class representing a Python function.",
    "std_args": [
      "obj"
    ],
    "type": "function"
  },
  "get_abstract_model": {
    "description": "The class representing a Python function.",
    "std_args": [
      "init_fn",
      "mesh"
    ],
    "type": "function"
  },
  "get_buffer": {
    "description": "Return the buffer given by ``target`` if it exists, otherwise throw an error.",
    "std_args": [
      "self",
      "target"
    ],
    "type": "function"
  },
  "get_build_config": {
    "description": "Returns a dictionary with the layer's input shape.\n\nThis method returns a config dict that can be used by\n`build_from_config(config)` to create all states (e.g. Variables and\nLookup tables) needed by the layer.\n\nBy default, the config only contains the input shape that the layer\nwas built with. If you're writing a custom layer that creates state in\nan unusual way, you should override this method to make sure this state\nis already created when Keras attempts to load its value upon model\nloading.\n\nReturns:\n    A dict containing the input shape associated with the layer.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_clipped_bbox": {
    "description": "",
    "std_args": [
      "self",
      "bounding_boxes",
      "h_end",
      "h_start",
      "w_end",
      "w_start"
    ],
    "type": "function"
  },
  "get_config": {
    "description": "Returns the config of the object.\n\nAn object config is a Python dictionary (serializable)\ncontaining the information needed to re-instantiate it.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_dropout_mask": {
    "description": "",
    "std_args": [
      "self",
      "step_input"
    ],
    "type": "function"
  },
  "get_elastic_transform_params": {
    "description": "",
    "std_args": [
      "self",
      "height",
      "width",
      "factor"
    ],
    "type": "function"
  },
  "get_expected_cell_size": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "input",
      "batch_sizes"
    ],
    "type": "function"
  },
  "get_expected_hidden_size": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "input",
      "batch_sizes"
    ],
    "type": "function"
  },
  "get_extra_state": {
    "description": "Return any extra state to include in the module's state_dict.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "get_initial_state": {
    "description": "",
    "std_args": [
      "self",
      "batch_size"
    ],
    "type": "function"
  },
  "get_random_transformation": {
    "description": "",
    "std_args": [
      "self",
      "data",
      "training",
      "seed"
    ],
    "type": "function"
  },
  "get_recurrent_dropout_mask": {
    "description": "",
    "std_args": [
      "self",
      "step_input"
    ],
    "type": "function"
  },
  "get_shifted_bbox": {
    "description": "",
    "std_args": [
      "self",
      "bounding_boxes",
      "w_shift_factor",
      "h_shift_factor"
    ],
    "type": "function"
  },
  "get_submodule": {
    "description": "Return the submodule given by ``target`` if it exists, otherwise throw an error.",
    "std_args": [
      "self",
      "target"
    ],
    "type": "function"
  },
  "get_transformed_x_y": {
    "description": "",
    "std_args": [
      "self",
      "x",
      "y",
      "transform"
    ],
    "type": "function"
  },
  "get_vocabulary": {
    "description": "Returns the current vocabulary of the layer.\n\nArgs:\n    include_special_tokens: If `True`, the returned vocabulary\n        will include the padding and OOV tokens,\n        and a term's index in the vocabulary will equal\n        the term's index when calling the layer. If `False`, the\n        returned vocabulary will not include any padding\n        or OOV tokens.",
    "std_args": [
      "self",
      "include_special_tokens"
    ],
    "type": "function"
  },
  "get_weights": {
    "description": "Return the values of `layer.weights` as a list of NumPy arrays.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "global_unstructured": {
    "description": "Globally prunes tensors corresponding to all parameters in ``parameters`` by applying the specified ``pruning_method``.",
    "std_args": [
      "parameters",
      "pruning_method",
      "importance_scores",
      "kwargs"
    ],
    "type": "function"
  },
  "gradient_as_bucket_view": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "grid_sample": {
    "description": "Compute grid sample.",
    "std_args": [
      "input",
      "grid",
      "mode",
      "padding_mode",
      "align_corners"
    ],
    "type": "function"
  },
  "group_norm": {
    "description": "Apply Group Normalization for last certain number of dimensions.",
    "std_args": [
      "input",
      "num_groups",
      "weight",
      "bias",
      "eps"
    ],
    "type": "function"
  },
  "grouped_mm": {
    "description": "grouped_mm(mat_a, mat_b, *, offs=None, bias=None, out_dtype=None)",
    "std_args": [
      "mat_a",
      "mat_b",
      "offs",
      "bias",
      "out_dtype"
    ],
    "type": "function"
  },
  "gumbel_softmax": {
    "description": "Sample from the Gumbel-Softmax distribution (`Link 1`_  `Link 2`_) and optionally discretize.",
    "std_args": [
      "logits",
      "tau",
      "hard",
      "eps",
      "dim"
    ],
    "type": "function"
  },
  "hardtanh_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "has_uninitialized_params": {
    "description": "Check if a module has parameters that are not initialized.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "head_bias": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "head_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hf": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hg": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hi": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hidden_features": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "hinge_embedding_loss": {
    "description": "Compute the hinge embedding loss.",
    "std_args": [
      "input",
      "target",
      "margin",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "ho": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "if_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ig": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ignore_index": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ii": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in_kv_features": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in_proj_bias": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "in_proj_weight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "include_last_offset": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "init_cache": {
    "description": "Initializes cache for fast autoregressive decoding. When",
    "std_args": [
      "self",
      "input_shape",
      "dtype"
    ],
    "type": "function"
  },
  "initialize_carry": {
    "description": "Initialize the RNN cell carry.",
    "std_args": [
      "self",
      "input_shape",
      "rngs",
      "carry_init"
    ],
    "type": "function"
  },
  "initialize_parameters": {
    "description": "Initialize parameters according to the input batch properties.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "inner_loop": {
    "description": "",
    "std_args": [
      "self",
      "sequences",
      "initial_state",
      "mask",
      "training"
    ],
    "type": "function"
  },
  "input_dilation": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "input_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "instance_norm": {
    "description": "Apply Instance Normalization independently for each channel in every data sample within a batch.",
    "std_args": [
      "input",
      "running_mean",
      "running_var",
      "weight",
      "bias",
      "use_input_stats",
      "momentum",
      "eps"
    ],
    "type": "function"
  },
  "io": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ipu": {
    "description": "Move all model parameters and buffers to the IPU.",
    "std_args": [
      "self",
      "device"
    ],
    "type": "function"
  },
  "is_cuda": {
    "description": "Return true if `self.data` stored on a gpu.",
    "std_args": [],
    "type": "attribute"
  },
  "is_lazy": {
    "description": "Returns whether ``param`` is an ``UninitializedParameter`` or ``UninitializedBuffer``.",
    "std_args": [
      "param"
    ],
    "type": "function"
  },
  "is_module": {
    "description": "The class representing a Python function.",
    "std_args": [
      "value"
    ],
    "type": "function"
  },
  "is_multi_device_module": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "is_namedtuple": {
    "description": "The class representing a Python function.",
    "std_args": [
      "obj"
    ],
    "type": "function"
  },
  "is_parametrized": {
    "description": "Determine if a module has a parametrization.",
    "std_args": [
      "module",
      "tensor_name"
    ],
    "type": "function"
  },
  "is_pinned": {
    "description": "Return true if `self.data` stored on in pinned memory.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "is_pruned": {
    "description": "Check if a module is pruned by looking for pruning pre-hooks.",
    "std_args": [
      "module"
    ],
    "type": "function"
  },
  "ismodule": {
    "description": "The class representing a Python function.",
    "std_args": [
      "rout"
    ],
    "type": "function"
  },
  "join_device": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "join_hook": {
    "description": "DDP join hook enables training on uneven inputs by mirroring communications in forward and backward passes.",
    "std_args": [
      "self",
      "kwargs"
    ],
    "type": "function"
  },
  "join_process_group": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "k_proj_weight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kdim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "keep_order": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "keepdim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kernel": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kernel_dilation": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kernel_shape": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "key_ln": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "key_proj": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kl_div": {
    "description": "Compute the KL Divergence loss.",
    "std_args": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction",
      "log_target"
    ],
    "type": "function"
  },
  "kl_div_loss": {
    "description": "Computes the Kullback-Leibler divergence loss.",
    "std_args": [
      "inputs",
      "targets",
      "axis",
      "reduction"
    ],
    "type": "function"
  },
  "kpack": {
    "description": "ROCm-specific kernel packing parameter.",
    "std_args": [],
    "type": "attribute"
  },
  "kv_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "kv_num_blocks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "l1_unstructured": {
    "description": "Prune tensor by removing units with the lowest L1-norm.",
    "std_args": [
      "module",
      "name",
      "amount",
      "importance_scores"
    ],
    "type": "function"
  },
  "layer_instance": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "layer_normalization": {
    "description": "Layer normalization layer (Ba et al., 2016).\n\nNormalize the activations of the previous layer for each given example in a\nbatch independently, rather than across a batch like Batch Normalization.\ni.e. applies a transformation that maintains the mean activation within each\nexample close to 0 and the activation standard deviation close to 1.\n\nArgs:\n    x: Input tensor.\n    gamma: Optional scaling factor for the normalization.\n    beta: Optional add offset for the normalized tensor.\n    axis: The axis or axes along which to perform normalization. Default to\n        `-1`.\n    epsilon: A lower bound value for the norm.\n        Defaults to `backend.epsilon()`.\n\nReturns:\n    The normalized array.\n\nExample:\n\n>>> x = keras.ops.arange(5, dtype=\"float32\")\n>>> keras.ops.layer_normalization(x)\narray([-1.4142135, -0.70710677, 0.0, 0.7071067, 1.4142135])",
    "std_args": [
      "x",
      "gamma",
      "beta",
      "axis",
      "epsilon",
      "kwargs"
    ],
    "type": "function"
  },
  "leaf_modules": {
    "description": "Return the submodules that do not contain other modules.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "list_flash_attention_impls": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ln": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ln1": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ln2": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ln3": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ln_promote_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "ln_structured": {
    "description": "Prune tensor by removing channels with the lowest L\\ ``n``-norm along the specified dimension.",
    "std_args": [
      "module",
      "name",
      "amount",
      "n",
      "dim",
      "importance_scores"
    ],
    "type": "function"
  },
  "load_assets": {
    "description": "",
    "std_args": [
      "self",
      "dir_path"
    ],
    "type": "function"
  },
  "load_own_variables": {
    "description": "Loads the state of the layer.\n\nYou can override this method to take full control of how the state of\nthe layer is loaded upon calling `keras.models.load_model()`.\n\nArgs:\n    store: Dict from which the state of the model will be loaded.",
    "std_args": [
      "self",
      "store"
    ],
    "type": "function"
  },
  "load_weights": {
    "description": "Update the model's weights from a ``.npz``, a ``.safetensors`` file, or a list.",
    "std_args": [
      "self",
      "file_or_weights",
      "strict"
    ],
    "type": "function"
  },
  "local_response_norm": {
    "description": "Apply local response normalization over an input signal.",
    "std_args": [
      "input",
      "size",
      "alpha",
      "beta",
      "k"
    ],
    "type": "function"
  },
  "log_cosh_loss": {
    "description": "Computes the log cosh loss between inputs and targets.",
    "std_args": [
      "inputs",
      "targets",
      "reduction"
    ],
    "type": "function"
  },
  "log_input": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "log_target": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lora_a": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lora_b": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lora_param_type": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "lp_pool1d": {
    "description": "Apply a 1D power-average pooling over an input signal composed of several input planes.",
    "std_args": [
      "input",
      "norm_type",
      "kernel_size",
      "stride",
      "ceil_mode"
    ],
    "type": "function"
  },
  "lp_pool2d": {
    "description": "Apply a 2D power-average pooling over an input signal composed of several input planes.",
    "std_args": [
      "input",
      "norm_type",
      "kernel_size",
      "stride",
      "ceil_mode"
    ],
    "type": "function"
  },
  "lp_pool3d": {
    "description": "Apply a 3D power-average pooling over an input signal composed of several input planes.",
    "std_args": [
      "input",
      "norm_type",
      "kernel_size",
      "stride",
      "ceil_mode"
    ],
    "type": "function"
  },
  "lse": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "make_attention_mask": {
    "description": "Mask-making helper for attention weights.",
    "std_args": [
      "query_input",
      "key_input",
      "pairwise_fn",
      "extra_batch_dims",
      "dtype"
    ],
    "type": "function"
  },
  "make_causal_mask": {
    "description": "Make a causal mask for self-attention.",
    "std_args": [
      "x",
      "extra_batch_dims",
      "dtype"
    ],
    "type": "function"
  },
  "materialize": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "shape",
      "device",
      "dtype"
    ],
    "type": "function"
  },
  "matrix_instr_nonkdim": {
    "description": "ROCm-specific matrix instruction non-K dimension.",
    "std_args": [],
    "type": "attribute"
  },
  "max_pool1d_with_indices": {
    "description": "max_pool1d(input, kernel_size, stride=None, padding=0, dilation=1, ceil_mode=False, return_indices=False)",
    "std_args": [
      "input",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "ceil_mode",
      "return_indices"
    ],
    "type": "function"
  },
  "max_pool2d_with_indices": {
    "description": "max_pool2d(input, kernel_size, stride=None, padding=0, dilation=1, ceil_mode=False, return_indices=False)",
    "std_args": [
      "input",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "ceil_mode",
      "return_indices"
    ],
    "type": "function"
  },
  "max_pool3d_with_indices": {
    "description": "max_pool3d(input, kernel_size, stride=None, padding=0, dilation=1, ceil_mode=False, return_indices=False)",
    "std_args": [
      "input",
      "kernel_size",
      "stride",
      "padding",
      "dilation",
      "ceil_mode",
      "return_indices"
    ],
    "type": "function"
  },
  "max_scores": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "max_unpool1d": {
    "description": "Compute a partial inverse of :class:`MaxPool1d`.",
    "std_args": [
      "input",
      "indices",
      "kernel_size",
      "stride",
      "padding",
      "output_size"
    ],
    "type": "function"
  },
  "max_unpool2d": {
    "description": "Compute a partial inverse of :class:`MaxPool2d`.",
    "std_args": [
      "input",
      "indices",
      "kernel_size",
      "stride",
      "padding",
      "output_size"
    ],
    "type": "function"
  },
  "max_unpool3d": {
    "description": "Compute a partial inverse of :class:`MaxPool3d`.",
    "std_args": [
      "input",
      "indices",
      "kernel_size",
      "stride",
      "padding",
      "output_size"
    ],
    "type": "function"
  },
  "merge_fn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "mixed_precision": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "model": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "modified_orthogonal": {
    "description": "Modified orthogonal initializer for compatibility with half precision.",
    "std_args": [
      "key",
      "shape",
      "dtype"
    ],
    "type": "function"
  },
  "mtia": {
    "description": "Move all model parameters and buffers to the MTIA.",
    "std_args": [
      "self",
      "device"
    ],
    "type": "function"
  },
  "multi_head_attention_forward": {
    "description": "Forward method for MultiHeadAttention.",
    "std_args": [
      "query",
      "key",
      "value",
      "embed_dim_to_check",
      "num_heads",
      "in_proj_weight",
      "in_proj_bias",
      "bias_k",
      "bias_v",
      "add_zero_attn",
      "dropout_p",
      "out_proj_weight",
      "out_proj_bias",
      "training",
      "key_padding_mask",
      "need_weights",
      "attn_mask",
      "use_separate_proj_weight",
      "q_proj_weight",
      "k_proj_weight",
      "v_proj_weight",
      "static_k",
      "static_v",
      "average_attn_weights",
      "is_causal"
    ],
    "type": "function"
  },
  "multi_hot": {
    "description": "Encodes integer labels as multi-hot vectors.\n\nThis function encodes integer labels as multi-hot vectors, where each label\nis mapped to a binary value in the resulting vector.\n\nArgs:\n    inputs: Tensor of integer labels to be converted to multi-hot vectors.\n    num_classes: Integer, the total number of unique classes.\n    axis: (optional) Axis along which the multi-hot encoding should be\n        added. Defaults to `-1`, which corresponds to the last dimension.\n    dtype: (optional) The data type of the resulting tensor. Default\n        is backend's float type.\n    sparse: Whether to return a sparse tensor; for backends that support\n        sparse tensors.\n\nReturns:\n    Tensor: The multi-hot encoded tensor.\n\nExample:\n\n>>> data = keras.ops.convert_to_tensor([0, 4])\n>>> keras.ops.multi_hot(data, num_classes=5)\narray([1.0, 0.0, 0.0, 0.0, 1.0], dtype=float32)",
    "std_args": [
      "inputs",
      "num_classes",
      "axis",
      "dtype",
      "sparse",
      "kwargs"
    ],
    "type": "function"
  },
  "multi_margin_loss": {
    "description": "Compute the multi margin loss, with optional weighting.",
    "std_args": [
      "input",
      "target",
      "p",
      "margin",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "multihead_attn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "multilabel_margin_loss": {
    "description": "Compute the multilabel margin loss.",
    "std_args": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "multilabel_soft_margin_loss": {
    "description": "Compute the multilabel soft margin loss.",
    "std_args": [
      "input",
      "target",
      "weight",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "n_classes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "n_clusters": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "n_power_iterations": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "n_steps": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "named_buffers": {
    "description": "Return an iterator over module buffers, yielding both the name of the buffer as well as the buffer itself.",
    "std_args": [
      "self",
      "prefix",
      "recurse",
      "remove_duplicate"
    ],
    "type": "function"
  },
  "named_children": {
    "description": "Return an iterator over immediate children modules, yielding both the name of the module as well as the module itself.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "native_channel_shuffle": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "neededmodule": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "nhead": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "no_sync": {
    "description": "Context manager to disable gradient synchronizations across DDP processes.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "noop_mask": {
    "description": "Returns a noop mask_mod",
    "std_args": [
      "batch",
      "head",
      "token_q",
      "token_kv"
    ],
    "type": "function"
  },
  "normal_": {
    "description": "Fill the input Tensor with values drawn from the normal distribution.",
    "std_args": [
      "tensor",
      "mean",
      "std",
      "generator"
    ],
    "type": "function"
  },
  "normalize_qk": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "normalized_shape": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "normalized_weights": {
    "description": "Generate spectral normalized weights.\n\nThis method returns the updated value for `self.kernel` with the\nspectral normalized value, so that the layer is ready for `call()`.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "ntensors": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_channels": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_feature_axes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_parameters": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "num_stages": {
    "description": "Number of pipeline stages in the CUDA kernel. Higher values may improve performance",
    "std_args": [],
    "type": "attribute"
  },
  "num_warps": {
    "description": "Number of warps to use in the CUDA kernel. Higher values may improve performance",
    "std_args": [],
    "type": "attribute"
  },
  "numel": {
    "description": "Returns the number of elements (not accounting for sparsity) in the mask.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "ones_init": {
    "description": "Builds an initializer that returns a constant array full of ones.",
    "std_args": [],
    "type": "function"
  },
  "or_masks": {
    "description": "Returns a mask_mod that's the union of provided mask_mods",
    "std_args": [
      "mask_mods"
    ],
    "type": "function"
  },
  "original": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "out": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "out_channels": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "out_dot_general": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "out_dot_general_cls": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "out_promote_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "output_padding": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pack_padded_sequence": {
    "description": "Packs a Tensor containing padded sequences of variable length.",
    "std_args": [
      "input",
      "lengths",
      "batch_first",
      "enforce_sorted"
    ],
    "type": "function"
  },
  "pack_sequence": {
    "description": "Packs a list of variable length Tensors.",
    "std_args": [
      "sequences",
      "enforce_sorted"
    ],
    "type": "function"
  },
  "pad_packed_sequence": {
    "description": "Pad a packed batch of variable length sequences.",
    "std_args": [
      "sequence",
      "batch_first",
      "padding_value",
      "total_length"
    ],
    "type": "function"
  },
  "pad_sequence": {
    "description": "Pad a list of variable length Tensors with :attr:`padding_value`.",
    "std_args": [
      "sequences",
      "batch_first",
      "padding_value",
      "padding_side"
    ],
    "type": "function"
  },
  "pairwise_distance": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "parallel_apply": {
    "description": "Apply each `module` in :attr:`modules` in parallel on each of :attr:`devices`.",
    "std_args": [
      "modules",
      "inputs",
      "kwargs_tup",
      "devices"
    ],
    "type": "function"
  },
  "param_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "parameters_to_ignore": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pdist": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "permute_hidden": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "hx",
      "permutation"
    ],
    "type": "function"
  },
  "persistent": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pin_memory": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "pixel_shuffle": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "pixel_unshuffle": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "poisson_nll_loss": {
    "description": "Compute the Poisson negative log likelihood loss.",
    "std_args": [
      "input",
      "target",
      "log_input",
      "full",
      "size_average",
      "eps",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "pos_weight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "precision": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "preferred_element_type": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "process_group": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "proj_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "promote_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "prune": {
    "description": "Compute and returns a pruned version of input tensor ``t``.",
    "std_args": [
      "self",
      "t",
      "default_mask",
      "importance_scores"
    ],
    "type": "function"
  },
  "pytorch_compatible": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "q_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "q_num_blocks": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "q_proj_weight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "qkv_dot_general": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "qkv_dot_general_cls": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "qkv_features": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "qkv_promote_dtype": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "quantized_build": {
    "description": "",
    "std_args": [
      "self",
      "input_shape",
      "mode"
    ],
    "type": "function"
  },
  "quantized_call": {
    "description": "",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "query": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "query_ln": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "query_proj": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "random_structured": {
    "description": "Prune tensor by removing random channels along the specified dimension.",
    "std_args": [
      "module",
      "name",
      "amount",
      "dim"
    ],
    "type": "function"
  },
  "random_unstructured": {
    "description": "Prune tensor by removing random (currently unpruned) units.",
    "std_args": [
      "module",
      "name",
      "amount"
    ],
    "type": "function"
  },
  "rate": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "recompute_scale_factor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "reduce_add": {
    "description": "Sum tensors from multiple GPUs.",
    "std_args": [
      "inputs",
      "destination"
    ],
    "type": "function"
  },
  "reduce_add_coalesced": {
    "description": "Sum tensors from multiple GPUs.",
    "std_args": [
      "inputs",
      "destination",
      "buffer_size"
    ],
    "type": "function"
  },
  "reduction_axes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "register_backward_hook": {
    "description": "Register a backward hook on the module.",
    "std_args": [
      "self",
      "hook"
    ],
    "type": "function"
  },
  "register_comm_hook": {
    "description": "Register communication hook for user-defined DDP aggregation of gradients across multiple workers.",
    "std_args": [
      "self",
      "state",
      "hook"
    ],
    "type": "function"
  },
  "register_flash_attention_impl": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "register_forward_hook": {
    "description": "Register a forward hook on the module.",
    "std_args": [
      "self",
      "hook",
      "prepend",
      "with_kwargs",
      "always_call"
    ],
    "type": "function"
  },
  "register_forward_pre_hook": {
    "description": "Register a forward pre-hook on the module.",
    "std_args": [
      "self",
      "hook",
      "prepend",
      "with_kwargs"
    ],
    "type": "function"
  },
  "register_full_backward_hook": {
    "description": "Register a backward hook on the module.",
    "std_args": [
      "self",
      "hook",
      "prepend"
    ],
    "type": "function"
  },
  "register_full_backward_pre_hook": {
    "description": "Register a backward pre-hook on the module.",
    "std_args": [
      "self",
      "hook",
      "prepend"
    ],
    "type": "function"
  },
  "register_load_state_dict_post_hook": {
    "description": "Register a post-hook to be run after module's :meth:`~nn.Module.load_state_dict` is called.",
    "std_args": [
      "self",
      "hook"
    ],
    "type": "function"
  },
  "register_load_state_dict_pre_hook": {
    "description": "Register a pre-hook to be run before module's :meth:`~nn.Module.load_state_dict` is called.",
    "std_args": [
      "self",
      "hook"
    ],
    "type": "function"
  },
  "register_module": {
    "description": "Alias for :func:`add_module`.",
    "std_args": [
      "self",
      "name",
      "module"
    ],
    "type": "function"
  },
  "register_module_backward_hook": {
    "description": "Register a backward hook common to all the modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_module_buffer_registration_hook": {
    "description": "Register a buffer registration hook common to all modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_module_forward_hook": {
    "description": "Register a global forward hook for all the modules.",
    "std_args": [
      "hook",
      "with_kwargs",
      "always_call"
    ],
    "type": "function"
  },
  "register_module_forward_pre_hook": {
    "description": "Register a forward pre-hook common to all modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_module_full_backward_hook": {
    "description": "Register a backward hook common to all the modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_module_full_backward_pre_hook": {
    "description": "Register a backward pre-hook common to all the modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_module_module_registration_hook": {
    "description": "Register a module registration hook common to all modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_module_parameter_registration_hook": {
    "description": "Register a parameter registration hook common to all modules.",
    "std_args": [
      "hook"
    ],
    "type": "function"
  },
  "register_parametrization": {
    "description": "Register a parametrization to a tensor in a module.",
    "std_args": [
      "module",
      "tensor_name",
      "parametrization",
      "unsafe"
    ],
    "type": "function"
  },
  "register_state_dict_post_hook": {
    "description": "Register a post-hook for the :meth:`~torch.nn.Module.state_dict` method.",
    "std_args": [
      "self",
      "hook"
    ],
    "type": "function"
  },
  "register_state_dict_pre_hook": {
    "description": "Register a pre-hook for the :meth:`~torch.nn.Module.state_dict` method.",
    "std_args": [
      "self",
      "hook"
    ],
    "type": "function"
  },
  "relu_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rematerialized_call": {
    "description": "Enable rematerialization dynamically for layer's call method.\n\nArgs:\n    layer_call: The original `call` method of a layer.\n\nReturns:\n    Rematerialized layer's `call` method.",
    "std_args": [
      "self",
      "layer_call",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "remove_parametrizations": {
    "description": "Remove the parametrizations on a tensor in a module.",
    "std_args": [
      "module",
      "tensor_name",
      "leave_parametrized"
    ],
    "type": "function"
  },
  "remove_spectral_norm": {
    "description": "Remove the spectral normalization reparameterization from a module.",
    "std_args": [
      "module",
      "name"
    ],
    "type": "function"
  },
  "remove_weight_norm": {
    "description": "Remove the weight normalization reparameterization from a module.",
    "std_args": [
      "module",
      "name"
    ],
    "type": "function"
  },
  "replicate": {
    "description": "The class representing a Python function.",
    "std_args": [
      "network",
      "devices",
      "detach"
    ],
    "type": "function"
  },
  "require_backward_grad_sync": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "require_forward_param_sync": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "requires_grad_": {
    "description": "Change if autograd should record operations on parameters in this module.",
    "std_args": [
      "self",
      "requires_grad"
    ],
    "type": "function"
  },
  "reset_dropout_mask": {
    "description": "Reset the cached dropout mask if any.\n\nThe RNN layer invokes this in the `call()` method\nso that the cached mask is cleared after calling `cell.call()`. The\nmask should be cached across all timestep within the same batch, but\nshouldn't be cached between batches.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "reset_parameters": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "reset_recurrent_dropout_mask": {
    "description": "",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "reset_state": {
    "description": "",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "reset_states": {
    "description": "",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "residual": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "return_carry": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "return_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "reverse": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "right_inverse": {
    "description": "Call the ``right_inverse`` methods of the parametrizations in the inverse registration order.",
    "std_args": [
      "self",
      "value"
    ],
    "type": "function"
  },
  "rng_collection": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "rrelu": {
    "description": "rrelu(input, lower=1./8, upper=1./3, training=False, inplace=False) -> Tensor",
    "std_args": [
      "input",
      "lower",
      "upper",
      "training",
      "inplace"
    ],
    "type": "function"
  },
  "rrelu_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "running_mean": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "running_var": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "save_assets": {
    "description": "",
    "std_args": [
      "self",
      "dir_path"
    ],
    "type": "function"
  },
  "save_own_variables": {
    "description": "Saves the state of the layer.\n\nYou can override this method to take full control of how the state of\nthe layer is saved upon calling `model.save()`.\n\nArgs:\n    store: Dict where the state of the model will be saved.",
    "std_args": [
      "self",
      "store"
    ],
    "type": "function"
  },
  "save_weights": {
    "description": "Save the model's weights to a file. The saving method is determined by the file extension:",
    "std_args": [
      "self",
      "file"
    ],
    "type": "function"
  },
  "scale_init": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scaled_grouped_mm": {
    "description": "scaled_grouped_mm(mat_a, mat_b, scale_a, scale_recipe_a, scale_b, scale_recipe_b, swizzle_a, swizzle_b, bias, offs,",
    "std_args": [
      "mat_a",
      "mat_b",
      "scale_a",
      "scale_recipe_a",
      "scale_b",
      "scale_recipe_b",
      "swizzle_a",
      "swizzle_b",
      "bias",
      "offs",
      "output_dtype",
      "contraction_dim",
      "use_fast_accum"
    ],
    "type": "function"
  },
  "scaled_mm": {
    "description": "scaled_mm(mat_a, mat_b, scale_a, scale_recipe_a, scale_b, scale_recipe_b, swizzle_a, swizzle_b, bias, output_dtype,",
    "std_args": [
      "mat_a",
      "mat_b",
      "scale_a",
      "scale_recipe_a",
      "scale_b",
      "scale_recipe_b",
      "swizzle_a",
      "swizzle_b",
      "bias",
      "output_dtype",
      "contraction_dim",
      "use_fast_accum"
    ],
    "type": "function"
  },
  "scales": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "scatter_kwargs": {
    "description": "Scatter with support for kwargs dictionary.",
    "std_args": [
      "inputs",
      "kwargs",
      "target_gpus",
      "dim"
    ],
    "type": "function"
  },
  "sdpa_kernel": {
    "description": "Context manager to select which backend to use for scaled dot product attention.",
    "std_args": [
      "backends",
      "set_priority"
    ],
    "type": "function"
  },
  "self_attention": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "self_attn": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "selu_": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "seq_len_kv": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "seq_len_q": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "seq_lengths": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "set_dtype": {
    "description": "Set the dtype of the module's parameters.",
    "std_args": [
      "self",
      "dtype",
      "predicate"
    ],
    "type": "function"
  },
  "set_extra_state": {
    "description": "Set extra state contained in the loaded `state_dict`.",
    "std_args": [
      "self",
      "state"
    ],
    "type": "function"
  },
  "set_mode": {
    "description": "Class method used by ``nnx.set_mode``.",
    "std_args": [
      "self",
      "use_running_average",
      "kwargs"
    ],
    "type": "function"
  },
  "set_submodule": {
    "description": "Set the submodule given by ``target`` if it exists, otherwise throw an error.",
    "std_args": [
      "self",
      "target",
      "module",
      "strict"
    ],
    "type": "function"
  },
  "set_vocabulary": {
    "description": "Sets vocabulary (and optionally document frequency) for this layer.\n\nThis method sets the vocabulary and IDF weights for this layer directly,\ninstead of analyzing a dataset through `adapt()`. It should be used\nwhenever the vocab (and optionally document frequency) information is\nalready known. If vocabulary data is already present in the layer, this\nmethod will replace it.\n\nArgs:\n    vocabulary: Either an array or a string path to a text file.\n        If passing an array, can pass a tuple, list, 1D NumPy array,\n        or 1D tensor containing the vocabulary terms.\n        If passing a file path, the file should contain one line\n        per term in the vocabulary.\n    idf_weights: A tuple, list, 1D NumPy array, or 1D tensor of inverse\n        document frequency weights with equal length to vocabulary.\n        Must be set if `output_mode` is `\"tf_idf\"`.\n        Should not be set otherwise.",
    "std_args": [
      "self",
      "vocabulary",
      "idf_weights"
    ],
    "type": "function"
  },
  "set_weights": {
    "description": "Sets the values of `layer.weights` from a list of NumPy arrays.",
    "std_args": [
      "self",
      "weights"
    ],
    "type": "function"
  },
  "setdefault": {
    "description": "Set the default for a key in the Parameterdict.",
    "std_args": [
      "self",
      "key",
      "default"
    ],
    "type": "function"
  },
  "setup_module": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "shard_inplace": {
    "description": "Shard a module in-place by updating its parameter dictionary with the",
    "std_args": [
      "module",
      "sharding",
      "segments",
      "group"
    ],
    "type": "function"
  },
  "shard_linear": {
    "description": "Create a new linear layer that has its parameters sharded and also",
    "std_args": [
      "module",
      "sharding",
      "segments",
      "group"
    ],
    "type": "function"
  },
  "share_memory": {
    "description": "See :meth:`torch.Tensor.share_memory_`.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "share_memory_": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "shortlist_size": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "skip_all_reduce_unused_params": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "skip_init": {
    "description": "Given a module class object and args / kwargs, instantiate the module without initializing parameters / buffers.",
    "std_args": [
      "module_cls",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "soft_margin_loss": {
    "description": "Compute the soft margin loss.",
    "std_args": [
      "input",
      "target",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "sorted_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "sparsity": {
    "description": "Computes the percentage of blocks that are sparse (i.e. not computed)",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "spectral_norm": {
    "description": "Apply spectral normalization to a parameter in the given module.",
    "std_args": [
      "module",
      "name",
      "n_power_iterations",
      "eps",
      "dim"
    ],
    "type": "function"
  },
  "src_device_obj": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "state_axes": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "stateless_call": {
    "description": "Call the layer without any side effects.\n\nArgs:\n    trainable_variables: List of trainable variables of the model.\n    non_trainable_variables: List of non-trainable variables of the\n        model.\n    *args: Positional arguments to be passed to `call()`.\n    return_losses: If `True`, `stateless_call()` will return the list of\n        losses created during `call()` as part of its return values.\n    **kwargs: Keyword arguments to be passed to `call()`.\n\nReturns:\n    A tuple. By default, returns `(outputs, non_trainable_variables)`.\n        If `return_losses = True`, then returns\n        `(outputs, non_trainable_variables, losses)`.\n\nNote: `non_trainable_variables` include not only non-trainable weights\nsuch as `BatchNormalization` statistics, but also RNG seed state\n(if there are any random operations part of the layer, such as dropout),\nand `Metric` state (if there are any metrics attached to the layer).\nThese are all elements of state of the layer.\n\nExample:\n\n```python\nmodel = ...\ndata = ...\ntrainable_variables = model.trainable_variables\nnon_trainable_variables = model.non_trainable_variables\n# Call the model with zero side effects\noutputs, non_trainable_variables = model.stateless_call(\n    trainable_variables,\n    non_trainable_variables,\n    data,\n)\n# Attach the updated state to the model\n# (until you do this, the model is still in its pre-call state).\nfor ref_var, value in zip(\n    model.non_trainable_variables, non_trainable_variables\n):\n    ref_var.assign(value)\n```",
    "std_args": [
      "self",
      "trainable_variables",
      "non_trainable_variables",
      "args",
      "return_losses",
      "kwargs"
    ],
    "type": "function"
  },
  "sum_gradients": {
    "description": "The class representing a Python function.",
    "std_args": [
      "group"
    ],
    "type": "function"
  },
  "symbolic_call": {
    "description": "",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "tail": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "teardown_module": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_module": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "test_suppress_warnings_module": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "test_version_module": {
    "description": "The class representing a Python function.",
    "std_args": [],
    "type": "function"
  },
  "time_major": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "to": {
    "description": "Move and/or cast the parameters and buffers.",
    "std_args": [
      "self",
      "args",
      "kwargs"
    ],
    "type": "function"
  },
  "to_empty": {
    "description": "Move the parameters and buffers to the specified device without copying storage.",
    "std_args": [
      "self",
      "device",
      "recurse"
    ],
    "type": "function"
  },
  "to_kwargs": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self",
      "inputs",
      "kwargs",
      "device_id"
    ],
    "type": "function"
  },
  "to_nnx__module": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "to_quantized": {
    "description": "Return a :obj:`QuantizedLinear` layer that approximates this layer.",
    "std_args": [
      "self",
      "group_size",
      "bits",
      "mode"
    ],
    "type": "function"
  },
  "to_string": {
    "description": "Returns a string representation of the block mask. Quite nifty.",
    "std_args": [
      "self",
      "grid_size",
      "limit"
    ],
    "type": "function"
  },
  "track_running_stats": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "traditional": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "trainable_parameter_filter": {
    "description": "The class representing a Python function.",
    "std_args": [
      "module",
      "key",
      "value"
    ],
    "type": "function"
  },
  "trainable_parameters": {
    "description": "Recursively return all the non frozen :class:`mlx.core.array` members of",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "transfer_parametrizations_and_params": {
    "description": "Transfer parametrizations and the parameters they parametrize from :attr:`from_module` to :attr:`to_module`.",
    "std_args": [
      "from_module",
      "to_module",
      "tensor_name"
    ],
    "type": "function"
  },
  "transform_bounding_boxes": {
    "description": "",
    "std_args": [
      "self",
      "bounding_boxes",
      "transformation",
      "training"
    ],
    "type": "function"
  },
  "transform_images": {
    "description": "",
    "std_args": [
      "self",
      "images",
      "transformation",
      "training"
    ],
    "type": "function"
  },
  "transform_labels": {
    "description": "",
    "std_args": [
      "self",
      "labels",
      "transformation",
      "training"
    ],
    "type": "function"
  },
  "transform_segmentation_masks": {
    "description": "",
    "std_args": [
      "self",
      "segmentation_masks",
      "transformation",
      "training"
    ],
    "type": "function"
  },
  "transform_single_bounding_box": {
    "description": "",
    "std_args": [
      "self",
      "bounding_box",
      "transformation",
      "training"
    ],
    "type": "function"
  },
  "transform_single_image": {
    "description": "",
    "std_args": [
      "self",
      "image",
      "transformation",
      "training"
    ],
    "type": "function"
  },
  "transform_single_label": {
    "description": "",
    "std_args": [
      "self",
      "label",
      "transformation",
      "training"
    ],
    "type": "function"
  },
  "transform_single_segmentation_mask": {
    "description": "",
    "std_args": [
      "self",
      "segmentation_mask",
      "transformation",
      "training"
    ],
    "type": "function"
  },
  "transpose_kernel": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "triplet_loss": {
    "description": "Computes the triplet loss for a set of anchor, positive, and negative samples.",
    "std_args": [
      "anchors",
      "positives",
      "negatives",
      "axis",
      "p",
      "margin",
      "eps",
      "reduction"
    ],
    "type": "function"
  },
  "triplet_margin_loss": {
    "description": "Compute the triplet loss between given input tensors and a margin greater than 0.",
    "std_args": [
      "anchor",
      "positive",
      "negative",
      "margin",
      "p",
      "eps",
      "swap",
      "size_average",
      "reduce",
      "reduction"
    ],
    "type": "function"
  },
  "triplet_margin_with_distance_loss": {
    "description": "Compute the triplet margin loss for input tensors using a custom distance function.",
    "std_args": [
      "anchor",
      "positive",
      "negative",
      "distance_function",
      "margin",
      "swap",
      "reduction"
    ],
    "type": "function"
  },
  "type_before_parametrizations": {
    "description": "Return the module type before parametrizations were applied and if not, then it returns the module type.",
    "std_args": [
      "module"
    ],
    "type": "function"
  },
  "unfreeze": {
    "description": "Unfreeze the Module's parameters or some of them.",
    "std_args": [
      "self",
      "recurse",
      "keys",
      "strict"
    ],
    "type": "function"
  },
  "uniform_": {
    "description": "Fill the input Tensor with values drawn from the uniform distribution.",
    "std_args": [
      "tensor",
      "a",
      "b",
      "generator"
    ],
    "type": "function"
  },
  "unpack_sequence": {
    "description": "Unpack PackedSequence into a list of variable length Tensors.",
    "std_args": [
      "packed_sequences"
    ],
    "type": "function"
  },
  "unpad_sequence": {
    "description": "Unpad padded Tensor into a list of variable length Tensors.",
    "std_args": [
      "padded_sequences",
      "lengths",
      "batch_first"
    ],
    "type": "function"
  },
  "unroll": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "unsafe": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "unsorted_indices": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "update_modules": {
    "description": "Replace the child modules of this :class:`Module` instance with the",
    "std_args": [
      "self",
      "modules",
      "strict"
    ],
    "type": "function"
  },
  "update_state": {
    "description": "",
    "std_args": [
      "self",
      "data"
    ],
    "type": "function"
  },
  "upsample_cubic": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x",
      "scale_factor",
      "align_corners"
    ],
    "type": "function"
  },
  "upsample_linear": {
    "description": "The class representing a Python function.",
    "std_args": [
      "x",
      "scale_factor",
      "align_corners"
    ],
    "type": "function"
  },
  "use_bias": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_fast_variance": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_nested_tensor": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_running_average": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_scale": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "use_side_stream_for_tensor_copies": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "v_proj_weight": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "valid_child_filter": {
    "description": "The class representing a Python function.",
    "std_args": [
      "module",
      "key",
      "value"
    ],
    "type": "function"
  },
  "valid_parameter_filter": {
    "description": "The class representing a Python function.",
    "std_args": [
      "module",
      "key",
      "value"
    ],
    "type": "function"
  },
  "value_proj": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "variable_filter": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "varlen_attn": {
    "description": "Compute variable-length attention using Flash Attention.",
    "std_args": [
      "query",
      "key",
      "value",
      "cu_seq_q",
      "cu_seq_k",
      "max_q",
      "max_k",
      "is_causal",
      "return_aux"
    ],
    "type": "function"
  },
  "vdim": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "vector_to_parameters": {
    "description": "Copy slices of a vector into an iterable of parameters.",
    "std_args": [
      "vec",
      "parameters"
    ],
    "type": "function"
  },
  "vocabulary_size": {
    "description": "Gets the current size of the layer's vocabulary.\n\nReturns:\n    The integer size of the vocabulary, including optional\n    mask and OOV indices.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "waves_per_eu": {
    "description": "ROCm-specific waves per execution unit.",
    "std_args": [],
    "type": "attribute"
  },
  "weight_norm": {
    "description": "Apply weight normalization to a parameter in the given module.",
    "std_args": [
      "module",
      "name",
      "dim"
    ],
    "type": "function"
  },
  "will_sync_module_buffers": {
    "description": "The class representing a Python function.",
    "std_args": [
      "self"
    ],
    "type": "function"
  },
  "xpu": {
    "description": "Move all model parameters and buffers to the XPU.",
    "std_args": [
      "self",
      "device"
    ],
    "type": "function"
  },
  "zero_infinity": {
    "description": "The class representing a Python module/class/instance attribute.",
    "std_args": [],
    "type": "attribute"
  },
  "zeros_init": {
    "description": "Builds an initializer that returns a constant array full of zeros.",
    "std_args": [],
    "type": "function"
  }
}