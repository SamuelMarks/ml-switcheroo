"""
HTML/SVG DSL Framework Adapter.

This module registers `html` as a valid framework in the `ml-switcheroo` ecosystem.
It enables the conversion of Python code to the Visual HTML Grid DSL and vice versa.

Features:

-   **Target (Output)**: Uses `HtmlEmitter` to generate the HTML grid from Python AST.
-   **Source (Input)**: Uses `HtmlParser` to scrape HTML grids back into Python AST.
-   **Semantic Mappings**: Defines the virtual `html_dsl` namespace to map grid components
    (Red boxes, Blue boxes) to Abstract Operations defined in the Knowledge Base.
"""

from typing import Dict, List, Tuple, Any, Set, Optional

from ml_switcheroo.frameworks.base import (
  register_framework,
  FrameworkAdapter,
  StandardMap,
  StandardCategory,
  GhostRef,
  ImportConfig,
  InitMode,
)
from ml_switcheroo.semantics.schema import StructuralTraits, PluginTraits, OpDefinition
from ml_switcheroo.enums import SemanticTier
from ml_switcheroo.core.html.parser import HtmlParser
from ml_switcheroo.core.html.emitter import HtmlEmitter


@register_framework("html")
class HtmlDSLAdapter(FrameworkAdapter):
  """
  Adapter for the HTML/SVG Visual DSL.

  Registers as 'html'. Utilizes the `HtmlEmitter` for generation and `HtmlParser` for ingestion.
  """

  display_name: str = "HTML Grid DSL"
  ui_priority: int = 980
  inherits_from: Optional[str] = None

  def __init__(self) -> None:
    """Initialize in Ghost Mode (no live python module dependency)."""
    self._mode = InitMode.GHOST
    self._snapshot_data: Dict[str, Any] = {}

  @property
  def search_modules(self) -> List[str]:
    """No Python modules to scan."""
    return []

  @property
  def unsafe_submodules(self) -> Set[str]:
    """No submodules."""
    return set()

  @property
  def import_alias(self) -> Tuple[str, str]:
    """
    Virtual import alias matching the parser output.
    The HtmlParser emits `import html_dsl as dsl`.
    """
    return ("html_dsl", "dsl")

  @property
  def import_namespaces(self) -> Dict[str, ImportConfig]:
    """
    Declare the virtual 'html_dsl' namespace.
    """
    return {"html_dsl": ImportConfig(tier=SemanticTier.NEURAL, recommended_alias="dsl")}

  @property
  def discovery_heuristics(self) -> Dict[str, List[str]]:
    """No heuristics."""
    return {}

  @property
  def supported_tiers(self) -> List[SemanticTier]:
    """Supports Neural layer definitions primarily."""
    return [SemanticTier.NEURAL]

  @property
  def structural_traits(self) -> StructuralTraits:
    """
    Defines behavior when converting TO Python FROM HTML.
    We map the `html_dsl.Module` base class generated by the Parser resolving alias `dsl`.
    """
    return StructuralTraits(
      module_base="html_dsl.Module",
      forward_method="forward",
      init_method_name="__init__",
      requires_super_init=True,
    )

  @property
  def plugin_traits(self) -> PluginTraits:
    """Default capabilities."""
    return PluginTraits()

  @property
  def test_config(self) -> Dict[str, str]:
    """No unit tests can be generated for HTML output."""
    return {}

  @property
  def harness_imports(self) -> List[str]:
    """No harness imports."""
    return []

  def get_harness_init_code(self) -> str:
    """No init code."""
    return ""

  @property
  def declared_magic_args(self) -> List[str]:
    """No magic args."""
    return []

  @property
  def rng_seed_methods(self) -> List[str]:
    """No RNG."""
    return []

  @property
  def definitions(self) -> Dict[str, StandardMap]:
    """
    Semantic mappings for the virtual `html_dsl` namespace.

    These map the operations found in the Blue boxes (e.g. `dsl.Flatten`) which resolve
    to `html_dsl.Flatten`, and attributes in Red boxes (e.g. `dsl.Conv2d`) to Abstract Standards.

    NOTE: Arguments are mapped to 'i' and 'o' instead of 'in' and 'out' because 'in'
    is a reserved Python keyword. The Parser generates `Conv2d(i=1)` which is valid.
    """
    return {
      "Module": StandardMap(api="html_dsl.Module"),
      # Layers (Red Boxes)
      "Conv2d": StandardMap(
        api="html_dsl.Conv2d",
        args={
          "in_channels": "i",
          "out_channels": "o",
          "kernel_size": "k",
        },
      ),
      "Linear": StandardMap(
        api="html_dsl.Linear",
        args={
          "in_features": "i",
          "out_features": "o",
        },
      ),
      # Operations (Blue Boxes)
      "Flatten": StandardMap(
        api="html_dsl.Flatten",
        args={"start_dim": "start"},
      ),
      "ReLU": StandardMap(api="html_dsl.ReLU"),
      "relu": StandardMap(api="html_dsl.relu"),
    }

  @property
  def specifications(self) -> Dict[str, OpDefinition]:
    """No spec definitions."""
    return {}

  def collect_api(self, category: StandardCategory) -> List[GhostRef]:
    """No API to collect."""
    return []

  def convert(self, data: Any) -> Any:
    """Identity conversion."""
    return str(data)

  def get_device_syntax(self, device_type: str, device_index: Optional[str] = None) -> str:
    """No device logic."""
    return ""

  def get_device_check_syntax(self) -> str:
    """No device checks."""
    return "False"

  def get_rng_split_syntax(self, rng_var: str, key_var: str) -> str:
    """No RNG."""
    return ""

  def get_serialization_imports(self) -> List[str]:
    """No serialization."""
    return []

  def get_serialization_syntax(self, op: str, file_arg: str, object_arg: Optional[str] = None) -> str:
    """No serialization."""
    return ""

  def apply_wiring(self, snapshot: Dict[str, Any]) -> None:
    """No manual wiring."""
    pass

  @classmethod
  def get_example_code(cls) -> str:
    """Returns a valid HTML Snippet."""
    return """ 
<div class="grid">
  <div class="box r">
    <span class="header-txt">conv: Conv2d</span>
    <code>i=1, o=32</code>
  </div>
</div>
"""

  def get_tiered_examples(self) -> Dict[str, str]:
    """Returns tiered examples."""
    code = self.get_example_code()
    return {
      "tier2_neural": code,
    }

  # --- Custom Engine Hooks ---
  # Detected by ASTEngine to swap pipeline components

  def create_parser(self, code: str) -> HtmlParser:
    """Factory for the ingest parser."""
    return HtmlParser(code)

  def create_emitter(self) -> HtmlEmitter:
    """Factory for the output generator."""
    return HtmlEmitter()
