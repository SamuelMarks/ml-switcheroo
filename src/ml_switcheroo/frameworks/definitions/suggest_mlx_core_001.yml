operation: "Abs"
description: "Calculates the absolute value element-wise."
std_args:
  - name: "x"
    type: "Tensor"
variants:
  torch:
    api: "torch.abs"
  jax:
    api: "jax.numpy.abs"
  flax_nnx:
    api: "jax.numpy.abs"
  paxml:
    api: "jax.numpy.abs"
  keras:
    api: "keras.ops.abs"
  tensorflow:
    api: "tf.abs"
  numpy:
    api: "numpy.abs"
  mlx:
    api: "mlx.core.abs"

---
operation: "Add"
description: "Element-wise addition of two arrays."
std_args:
  - name: "x"
    type: "Tensor"
  - name: "y"
    type: "Tensor"
variants:
  torch:
    api: "torch.add"
  jax:
    api: "jax.numpy.add"
  flax_nnx:
    api: "jax.numpy.add"
  paxml:
    api: "jax.numpy.add"
  keras:
    api: "keras.ops.add"
  tensorflow:
    api: "tf.math.add"
  numpy:
    api: "numpy.add"
  mlx:
    api: "mlx.core.add"
    args:
      x: "a"
      y: "b"

---
operation: "Addmm"
description: "Performs matrix multiplication of mat1 and mat2, adding input scaled by beta to the result scaled by alpha."
std_args:
  - name: "input"
    type: "Tensor"
    doc: "Matrix to be added (the bias)."
  - name: "mat1"
    type: "Tensor"
    doc: "First matrix for multiplication."
  - name: "mat2"
    type: "Tensor"
    doc: "Second matrix for multiplication."
  - name: "alpha"
    type: "float"
    default: 1.0
  - name: "beta"
    type: "float"
    default: 1.0
variants:
  torch:
    api: "torch.addmm"
  jax:
    macro_template: "{alpha} * jax.numpy.dot({mat1}, {mat2}) + {beta} * {input}"
  keras:
    macro_template: "{alpha} * keras.ops.matmul({mat1}, {mat2}) + {beta} * {input}"
  numpy:
    macro_template: "{alpha} * np.dot({mat1}, {mat2}) + {beta} * {input}"
  mlx:
    api: "mlx.core.addmm"
    args:
      input: "c"
      mat1: "a"
      mat2: "b"

---
operation: "All"
description: "Tests if all elements evaluate to True along a given axis."
std_args:
  - name: "x"
    type: "Tensor"
  - name: "axis"
    type: "int"
    default: null
  - name: "keepdims"
    type: "bool"
    default: false
variants:
  torch:
    api: "torch.all"
    args:
      axis: "dim"
  jax:
    api: "jax.numpy.all"
  keras:
    api: "keras.ops.all"
  tensorflow:
    api: "tf.reduce_all"
  numpy:
    api: "numpy.all"
  mlx:
    api: "mlx.core.all"
    args:
      x: "a"

---
operation: "AllClose"
description: "Checks if two arrays are element-wise equal within a tolerance."
std_args:
  - name: "x"
    type: "Tensor"
  - name: "y"
    type: "Tensor"
  - name: "rtol"
    type: "float"
    default: 1e-05
  - name: "atol"
    type: "float"
    default: 1e-08
  - name: "equal_nan"
    type: "bool"
    default: false
variants:
  torch:
    api: "torch.allclose"
    args:
      x: "input"
      y: "other"
  jax:
    api: "jax.numpy.allclose"
    args:
      x: "a"
      y: "b"
  numpy:
    api: "numpy.allclose"
    args:
      x: "a"
      y: "b"
  mlx:
    api: "mlx.core.allclose"
    args:
      x: "a"
      y: "b"

---
operation: "Any"
description: "Tests if any element evaluates to True along a given axis."
std_args:
  - name: "x"
    type: "Tensor"
  - name: "axis"
    type: "int"
    default: null
  - name: "keepdims"
    type: "bool"
    default: false
variants:
  torch:
    api: "torch.any"
    args:
      axis: "dim"
  jax:
    api: "jax.numpy.any"
  keras:
    api: "keras.ops.any"
  tensorflow:
    api: "tf.reduce_any"
    args:
      keepdims: "keep_dims"
  numpy:
    api: "numpy.any"
  mlx:
    api: "mlx.core.any"
    args:
      x: "a"

---
operation: "Arange"
description: "Returns evenly spaced values within a given interval."
std_args:
  - name: "start"
    type: "float"
  - name: "stop"
    type: "float"
    default: null
  - name: "step"
    type: "float"
    default: 1
  - name: "dtype"
    type: "Dtype"
    default: null
variants:
  torch:
    api: "torch.arange"
    args:
      stop: "end"
  jax:
    api: "jax.numpy.arange"
  keras:
    api: "keras.ops.arange"
  tensorflow:
    api: "tf.range"
    args:
      stop: "limit"
      step: "delta"
  numpy:
    api: "numpy.arange"
  mlx:
    api: "mlx.core.arange"

---
operation: "Array"
description: "Constructs an array from data."
std_args:
  - name: "data"
    type: "List"
  - name: "dtype"
    type: "Dtype"
    default: null
variants:
  torch:
    api: "torch.tensor"
  jax:
    api: "jax.numpy.array"
    args:
      data: "object"
  keras:
    api: "keras.ops.convert_to_tensor"
    args:
      data: "x"
  tensorflow:
    api: "tf.constant"
    args:
      data: "value"
  numpy:
    api: "numpy.array"
    args:
      data: "object"
  mlx:
    api: "mlx.core.array"
    args:
      data: "a"

---
operation: "ArrayAt"
description: "Interface for indexed updates (JAX style)."
std_args:
  - name: "x"
    type: "Tensor"
variants:
  jax:
    api: "x.at"
    transformation_type: "infix"
  mlx:
    api: "mlx.core.ArrayAt"

---
operation: "ArrayEqual"
description: "True if two arrays have the same shape and elements."
std_args:
  - name: "x"
    type: "Tensor"
  - name: "y"
    type: "Tensor"
  - name: "equal_nan"
    type: "bool"
    default: false
variants:
  torch:
    api: "torch.equal"
    args:
      x: "input"
      y: "other"
      equal_nan: null # Torch.equal (prior to recent versions) didn't support equal_nan
  jax:
    api: "jax.numpy.array_equal"
    args:
      x: "a1"
      y: "a2"
  numpy:
    api: "numpy.array_equal"
    args:
      x: "a1"
      y: "a2"
  mlx:
    api: "mlx.core.array_equal"
    args:
      x: "a"
      y: "b"

---
operation: "Acos"
description: "Inverse cosine element-wise."
std_args:
  - name: "x"
    type: "Tensor"
variants:
  torch:
    api: "torch.acos"
  jax:
    api: "jax.numpy.arccos"
  keras:
    api: "keras.ops.arccos"
  tensorflow:
    api: "tf.math.acos"
  numpy:
    api: "numpy.arccos"
  mlx:
    api: "mlx.core.arccos"
    args:
      x: "a"

---
operation: "Acosh"
description: "Inverse hyperbolic cosine element-wise."
std_args:
  - name: "x"
    type: "Tensor"
variants:
  torch:
    api: "torch.acosh"
  jax:
    api: "jax.numpy.arccosh"
  keras:
    api: "keras.ops.arccosh"
  tensorflow:
    api: "tf.math.acosh"
  numpy:
    api: "numpy.arccosh"
  mlx:
    api: "mlx.core.arccosh"
    args:
      x: "a"

---
operation: "Asin"
description: "Inverse sine element-wise."
std_args:
  - name: "x"
    type: "Tensor"
variants:
  torch:
    api: "torch.asin"
  jax:
    api: "jax.numpy.arcsin"
  keras:
    api: "keras.ops.arcsin"
  tensorflow:
    api: "tf.math.asin"
  numpy:
    api: "numpy.arcsin"
  mlx:
    api: "mlx.core.arcsin"
    args:
      x: "a"

---
operation: "Asinh"
description: "Inverse hyperbolic sine element-wise."
std_args:
  - name: "x"
    type: "Tensor"
variants:
  torch:
    api: "torch.asinh"
  jax:
    api: "jax.numpy.arcsinh"
  keras:
    api: "keras.ops.arcsinh"
  tensorflow:
    api: "tf.math.asinh"
  numpy:
    api: "numpy.arcsinh"
  mlx:
    api: "mlx.core.arcsinh"
    args:
      x: "a"

---
operation: "Atan"
description: "Inverse tangent element-wise."
std_args:
  - name: "x"
    type: "Tensor"
variants:
  torch:
    api: "torch.atan"
  jax:
    api: "jax.numpy.arctan"
  keras:
    api: "keras.ops.arctan"
  tensorflow:
    api: "tf.math.atan"
  numpy:
    api: "numpy.arctan"
  mlx:
    api: "mlx.core.arctan"
    args:
      x: "a"

---
operation: "Atan2"
description: "Element-wise arc tangent of y/x with correct quadrant."
std_args:
  - name: "y"
    type: "Tensor"
  - name: "x"
    type: "Tensor"
variants:
  torch:
    api: "torch.atan2"
    args:
      y: "input"
      x: "other"
  jax:
    api: "jax.numpy.arctan2"
    args:
      y: "x1"
      x: "x2"
  keras:
    api: "keras.ops.arctan2"
    args:
      y: "x1"
      x: "x2"
  tensorflow:
    api: "tf.math.atan2"
  numpy:
    api: "numpy.arctan2"
    args:
      y: "x1"
      x: "x2"
  mlx:
    api: "mlx.core.arctan2"
    args:
      y: "a"
      x: "b"

---
operation: "Atanh"
description: "Inverse hyperbolic tangent element-wise."
std_args:
  - name: "x"
    type: "Tensor"
variants:
  torch:
    api: "torch.atanh"
  jax:
    api: "jax.numpy.arctanh"
  keras:
    api: "keras.ops.arctanh"
  tensorflow:
    api: "tf.math.atanh"
  numpy:
    api: "numpy.arctanh"
  mlx:
    api: "mlx.core.arctanh"
    args:
      x: "a"

---
operation: "ArgMax"
description: "Indices of the maximum values along an axis."
std_args:
  - name: "x"
    type: "Tensor"
  - name: "axis"
    type: "int"
    default: null
  - name: "keepdims"
    type: "bool"
    default: false
variants:
  torch:
    api: "torch.argmax"
    args:
      axis: "dim"
  jax:
    api: "jax.numpy.argmax"
    args:
      x: "a"
  keras:
    api: "keras.ops.argmax"
  tensorflow:
    api: "tf.math.argmax"
    args:
      keepdims: null # Not supported directly
  numpy:
    api: "numpy.argmax"
    args:
      x: "a"
  mlx:
    api: "mlx.core.argmax"
    args:
      x: "a"

---
operation: "ArgMin"
description: "Indices of the minimum values along an axis."
std_args:
  - name: "x"
    type: "Tensor"
  - name: "axis"
    type: "int"
    default: null
  - name: "keepdims"
    type: "bool"
    default: false
variants:
  torch:
    api: "torch.argmin"
    args:
      axis: "dim"
  jax:
    api: "jax.numpy.argmin"
    args:
      x: "a"
  keras:
    api: "keras.ops.argmin"
  tensorflow:
    api: "tf.math.argmin"
    args:
      keepdims: null
  numpy:
    api: "numpy.argmin"
    args:
      x: "a"
  mlx:
    api: "mlx.core.argmin"
    args:
      x: "a"

---
operation: "ArgPartition"
description: "Indices that partition the array."
std_args:
  - name: "x"
    type: "Tensor"
  - name: "kth"
    type: "int"
  - name: "axis"
    type: "int"
    default: -1
variants:
  torch:
    # Torch doesn't have exact argpartition, topk behaves similarly for k
    api: "torch.topk"
    args:
      x: "input"
      kth: "k"
      axis: "dim"
  jax:
    api: "jax.numpy.argpartition"
    args:
      x: "a"
  numpy:
    api: "numpy.argpartition"
    args:
      x: "a"
  mlx:
    api: "mlx.core.argpartition"
    args:
      x: "a"

---
operation: "ArgSort"
description: "Returns indices that sort the array."
std_args:
  - name: "x"
    type: "Tensor"
  - name: "axis"
    type: "int"
    default: -1
variants:
  torch:
    api: "torch.argsort"
    args:
      axis: "dim"
  jax:
    api: "jax.numpy.argsort"
    args:
      x: "a"
  keras:
    api: "keras.ops.argsort"
  tensorflow:
    api: "tf.argsort"
  numpy:
    api: "numpy.argsort"
    args:
      x: "a"
  mlx:
    api: "mlx.core.argsort"
    args:
      x: "a"

---
operation: "Device"
description: "Constructor/Type for device objects."
std_args:
  - name: "type"
    type: "str"
  - name: "index"
    type: "int"
    default: null
variants:
  torch:
    api: "torch.device"
  mlx:
    api: "mlx.core.Device"

---
operation: "Dtype"
description: "Data type object."
std_args:
  - name: "name"
    type: "str"
variants:
  torch:
    api: "torch.dtype"
  numpy:
    api: "numpy.dtype"
  mlx:
    api: "mlx.core.Dtype"

---
operation: "Stream"
description: "Asynchronous execution stream."
std_args:
  - name: "device"
    type: "Device"
    default: null
variants:
  torch:
    api: "torch.cuda.Stream"
  mlx:
    api: "mlx.core.Stream"

---
operation: "StreamContext"
description: "Context manager for setting the current stream."
std_args:
  - name: "stream"
    type: "Stream"
op_type: "context"
variants:
  torch:
    api: "torch.cuda.stream"
  mlx:
    api: "mlx.core.StreamContext"
    args:
      stream: "s"

---
operation: "FunctionExporter"
description: "Context for exporting function traces."
std_args: []
variants:
  mlx:
    api: "mlx.core.FunctionExporter"

---
operation: "ArrayIterator"
description: "Iterator over an array's first dimension."
std_args:
  - name: "x"
    type: "Tensor"
variants:
  torch:
    api: "iter"
  python:
    api: "iter"
  mlx:
    api: "mlx.core.ArrayIterator"

---
operation: "DtypeCategory"
description: "Category of data types."
std_args:
  - name: "values"
    is_variadic: true
variants:
  mlx:
    api: "mlx.core.DtypeCategory"

---
operation: "DeviceType"
description: "Enumeration of device types."
std_args:
  - name: "values"
    is_variadic: true
variants:
  mlx:
    api: "mlx.core.DeviceType"

---
operation: "ArrayLike"
description: "Type hint for array-compatible objects."
std_args: []
variants:
  jax:
    api: "jax.typing.ArrayLike"
  numpy:
    api: "numpy.typing.ArrayLike"
  mlx:
    api: "mlx.core.ArrayLike"