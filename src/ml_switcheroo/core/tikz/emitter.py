"""
TikZ Emitter Module.

This module converts a language-agnostic ``LogicalGraph`` into renderable TikZ code.
It acts as the backend of the visualization subsystem.

Responsibilities:
1.  **Layout**: Assigns (x, y) coordinates to nodes using a rank-based topological sort.
    Vertical layout is standard for neural networks (Input at top, Output at bottom).
2.  **Conversion**: transforms abstract Logical components into Concrete Syntax Tree (CST)
    objects defined in ``ml_switcheroo.core.tikz.nodes``.
3.  **Rendering**: Generates the final LaTeX string including ``\\node`` tables
    for layer configuration.
"""

from typing import Dict, List, Tuple
from collections import defaultdict, deque

from ml_switcheroo.core.tikz.analyser import LogicalGraph, LogicalNode, LogicalEdge
from ml_switcheroo.core.tikz.nodes import (
  TikzGraph,
  TikzNode,
  TikzEdge,
  TikzOption,
  TikzTable,
  TikzComment,
  TriviaNode,
)


class TikzEmitter:
  """
  Orchestrates the conversion of a LogicalGraph to TikZ source code.

  Attributes:
      y_spacing (float): Vertical distance between ranks.
      x_spacing (float): Horizontal distance between sibling nodes.
  """

  def __init__(self, y_spacing: float = 2.5, x_spacing: float = 3.0):
    self.y_spacing = y_spacing
    self.x_spacing = x_spacing

  def _sanitize(self, text: str) -> str:
    """
    Escapes LaTeX special characters (specifically underscores) in strings.

    Args:
        text (str): The raw string.

    Returns:
        str: The sanitized string safe for TikZ labels.
    """
    return str(text).replace("_", r"\_")

  def emit(self, graph: LogicalGraph) -> str:
    """
    Generates the TikZ source code string for the provided graph.

    Args:
        graph: The logical graph (nodes and edges) extracted from analysis.

    Returns:
        str: A complete ``\\begin{tikzpicture}...\\end{tikzpicture}`` block.
    """
    # 1. Calculate Layout
    positions = self._calculate_layout(graph)

    # 2. Build CST
    cst_nodes = []
    cst_nodes.append(TikzComment("Generated by ml-switcheroo"))
    cst_nodes.append(TriviaNode("\n"))

    # Add nodes
    for node in graph.nodes:
      pos = positions.get(node.id, (0, 0))
      tikz_node = self._create_tikz_node(node, pos[0], pos[1])
      cst_nodes.append(tikz_node)

    cst_nodes.append(TriviaNode("\n"))

    # Add edges
    for edge in graph.edges:
      tikz_edge = self._create_tikz_edge(edge)
      cst_nodes.append(tikz_edge)

    # 3. Create Root Graph
    # Global options ensure arrow styles are consistent and avoid syntax errors
    options = [
      TikzOption("node distance", "2cm"),
      TikzOption("auto"),
      TikzOption(">=stealth"),  # Global arrow tip style
    ]
    root = TikzGraph(children=cst_nodes, options=options)

    return root.to_text()

  def _calculate_layout(self, graph: LogicalGraph) -> Dict[str, Tuple[float, float]]:
    """
    Computes (x, y) coordinates for each node.

    Algorithm:
    1.  Build adjacency list.
    2.  Compute In-Degree to find roots.
    3.  BFS traversal to assign 'Rank' (depth).
    4.  Group nodes by Rank.
    5.  Assign X coordinates: Center nodes at each rank around x=0.
    6.  Assign Y coordinates: ``-rank * y_spacing``.

    Returns:
        Dict[node_id, (x, y)]
    """
    if not graph.nodes:
      return {}

    # Build adjacency
    adj = defaultdict(list)
    in_degree = defaultdict(int)
    # Ensure all nodes exist in keys
    for n in graph.nodes:
      in_degree[n.id] = 0

    for edge in graph.edges:
      adj[edge.source].append(edge.target)
      in_degree[edge.target] += 1

    # Roots
    queue = deque([n.id for n in graph.nodes if in_degree[n.id] == 0])

    # BFS for Depth (Rank)
    ranks = {}
    processed = set()

    # If circular dependency or no roots, pick first node as root fallback
    if not queue and graph.nodes:
      first = graph.nodes[0].id
      queue.append(first)
      ranks[first] = 0
    else:
      for root_id in queue:
        ranks[root_id] = 0

    max_rank = 0

    while queue:
      curr = queue.popleft()
      if curr in processed:
        continue
      processed.add(curr)

      curr_rank = ranks.get(curr, 0)
      max_rank = max(max_rank, curr_rank)

      for neighbor in adj[curr]:
        # In standard topo sort we decrement in-degree,
        # but for visual layout 'max' depth usually looks better.
        # Here simple BFS is sufficient for trees/DAGs.
        if neighbor not in ranks or ranks[neighbor] < curr_rank + 1:
          ranks[neighbor] = curr_rank + 1
          queue.append(neighbor)

    # Handle nodes not reachable from roots (islands)
    # Assign them to next available rank
    for n in graph.nodes:
      if n.id not in ranks:
        max_rank += 1
        ranks[n.id] = max_rank

    # Group by Rank
    rank_groups = defaultdict(list)
    for node_id, r in ranks.items():
      rank_groups[r].append(node_id)

    # Assign Coordinates
    positions = {}
    for r, nodes in rank_groups.items():
      y = -r * self.y_spacing

      # Center alignment logic
      count = len(nodes)
      # e.g., count=2 -> offsets -0.5, 0.5 -> x = -1.5, 1.5 (times spacing)
      # count=1 -> offset 0

      start_x = -((count - 1) * self.x_spacing) / 2

      for i, node_id in enumerate(nodes):
        x = start_x + (i * self.x_spacing)
        positions[node_id] = (x, y)

    return positions

  def _create_tikz_node(self, node: LogicalNode, x: float, y: float) -> TikzNode:
    """
    Converts a LogicalNode to a TikzNode with HTML-like label table.
    Applies sanitization to strings to safely render LaTeX.
    """
    # Node style specs
    options = [
      TikzOption("draw"),
      TikzOption("rectangle"),
      TikzOption("rounded corners"),
      TikzOption("align", "center"),
    ]

    # Different styling for special node kinds
    if node.kind == "Input":
      options.append(TikzOption("fill", "green!10"))
    elif node.kind == "Output":
      options.append(TikzOption("fill", "red!10"))
    else:
      options.append(TikzOption("fill", "blue!5"))

    # Build Table Content
    # Header: Class Name (Bold)
    sanitized_kind = self._sanitize(node.kind)
    rows = [[rf"\textbf{{{sanitized_kind}}}"]]

    # Body: ID
    sanitized_id = self._sanitize(node.id)
    rows.append([rf"\textit{{{sanitized_id}}}"])

    # Body: Metadata
    for k, v in node.metadata.items():
      # Clean string key
      clean_k = self._sanitize(k)
      # Truncate value if too long then sanitize
      clean_v = self._sanitize(str(v)[:20])
      rows.append([f"{clean_k}: {clean_v}"])

    content_table = TikzTable(rows=rows, align="c")

    return TikzNode(
      node_id=node.id,
      x=x,
      y=y,
      content=content_table,
      options=options,
    )

  def _create_tikz_edge(self, edge: LogicalEdge) -> TikzEdge:
    """
    Converts a LogicalEdge to a TikzEdge using standardized arrows.
    """
    return TikzEdge(
      source_id=edge.source,
      target_id=edge.target,
      connector="--",  # Connector line style
      options=[TikzOption("->"), TikzOption("thick")],  # Arrowhead via option
    )
