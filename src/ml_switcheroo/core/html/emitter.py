"""
HTML Emitter.

Converts Python Source Code into the HTML/SVG representation layout.
Utilizes the shared `LogicalGraph` intermediate representation.
"""

from typing import Dict, List, Optional
import libcst as cst

from ml_switcheroo.core.graph import (
  GraphExtractor,
  LogicalGraph,
  LogicalNode,
  topological_sort,
)
from ml_switcheroo.core.html.nodes import HtmlDocument, GridBox, SvgArrow


class HtmlEmitter:
  """
  Orchestrates the conversion of Python code to the HTML visual DSL.

  Layout Strategy:
  - Input Node: Row 1-2 implicit styling or explicit green box.
  - Stateful Nodes (Layers): Occupy a Red Box (Definition) in Column 1,
    followed by a Blue Box (Execution) in Column 2.
  - Functional Nodes (Ops): Occupy a Blue Box in Column 2 directly.
  - Data Flow: Green Boxes in Column 3 represent intermediate states/shapes.
  """

  # Layout Constants
  ROW_HEIGHT = 80
  GAP_HEIGHT = 0  # Gap is handled by grid-gap but logic might need adjustment if absolute

  def emit(self, code: str, model_name: str = "ConvNet") -> str:
    """
    Generates HTML document string from source code.

    Args:
        code (str): Python source code for the model.
        model_name (str): Label for the diagram header.

    Returns:
        str: Full HTML document string.
    """
    try:
      tree = cst.parse_module(code)
    except cst.ParserSyntaxError as e:
      return f"<!-- Error parsing Python source: {e} -->"

    extractor = GraphExtractor()
    tree.visit(extractor)
    graph = extractor.graph

    # Validate graph content
    if not graph.nodes:
      return "<!-- No model definition found in source. -->"

    # Use extracted name if valid
    if extractor.model_name and extractor.model_name != "GeneratedNet":
      final_name = extractor.model_name
    else:
      final_name = model_name

    children = self._layout_graph(graph)
    doc = HtmlDocument(model_name=final_name, children=children)
    return doc.to_html()

  def _format_args(self, metadata: Dict[str, str]) -> str:
    """
    Formats metadata dictionary into a shorthand string.
    e.g., {'k': 3, 'in': 1} -> "k=3, in=1"
    """
    parts = []
    for k, v in metadata.items():
      if k.startswith("arg_"):
        # Positional arg, just value
        parts.append(v)
      else:
        parts.append(f"{k}={v}")
    return ", ".join(parts)

  def _is_stateful(self, node: LogicalNode) -> bool:
    """
    Determines if a node represents a stateful layer definition.

    Heuristic:
    1. 'Input' and 'Output' are structural markers, not layers.
    2. Nodes with ID starting with 'func_' are purely functional ops extracted by
       GraphExtractor from standard library calls.
    3. Nodes with kind starting with 'func_' catch manual functional nodes.
    """
    if node.kind in ["Input", "Output"]:
      return False

    # Critical Fix: Check ID for functional prefix generated by GraphExtractor
    if node.id.startswith("func_"):
      return False

    if node.kind.startswith("func_"):
      return False

    return True

  def _clean_kind(self, kind: str) -> str:
    """
    Normalizes function/class names for display.
    e.g. 'func_relu' -> 'Relu', 'torch.flatten' -> 'Flatten'.
    """
    if kind.startswith("func_"):
      kind = kind[5:]

    if "." in kind:
      kind = kind.split(".")[-1]

    return kind.capitalize()

  def _create_arrow(self, start_row: int, end_row: int, arrow_type: str = "seq") -> SvgArrow:
    """
    Factory for SvgArrows based on row distance.

    Args:
        start_row: Grid row of source box.
        end_row: Grid row of destination box.
        arrow_type: 'seq' (Blue->Blue down), 'def' (Red->Blue right), 'data' (Blue->Green right).
    """
    # Visual Constants matching the DSL CSS logic
    # row-gap is 40px, row-height is 80px.
    # Calculation Base: Top of Row N vs Top of Row N+1 is 120px.

    if arrow_type == "def":
      # Red -> Blue (Right and Down)
      # Logic:
      # Start: Right edge of Red Box (Column 1).
      # End: Top/Center of Blue Box (Column 2).
      # Vertical Gap Analysis:
      #   Red Box height: 80px.
      #   Gap: 40px.
      #   Blue Box start relative to Red Top: 120px.
      #   Anchor: We use 'top: 60px' (3/4 down the Red Box) to anchor the arrow.
      #   Target: 10px into the Blue Box (130px from Red Top).
      #   Vector Y2 length: 130 - 60 = 70px.
      #   Horizontal X2 length: 50-60px to bridge the gap and margin.

      # FIX: Use 'top' instead of 'bottom' to ensure stability regardless of box-sizing/padding issues
      # in different environments (like the WASM iframe).
      return SvgArrow(
        x1=0,
        y1=0,
        x2=60,
        y2=80,  # 80px down from 'top: 60px' -> 140px total. 20px overlap into next row.
        style_class="s-red",
        marker_end="url(#mr)",
        parent_style="left:100%; top:60px;",
      )

    if arrow_type == "data":
      # Blue -> Green (Straight Right)
      # Anchored at 'top: 40px' (Middle of 80px box)
      return SvgArrow(
        x1=0,
        y1=0,
        x2=60,
        y2=0,
        style_class="s-green",
        marker_end="url(#mg)",
        parent_style="left:100%; top:40px;",
      )

    if arrow_type == "seq":
      # Blue -> Blue (Down, potentially skipping rows)
      # Anchor: Bottom of box (80px down)

      row_delta = end_row - start_row
      # Base distance (1 row jump) is 40px (gap).
      # We want to overlap 10px into the next box.
      # Y length = 50px.

      # Formula: 50 + (delta-1)*(box+gap) = 50 + (d-1)*120
      y_len = 50 + (row_delta - 1) * 120

      return SvgArrow(
        x1=0,
        y1=0,
        x2=0,
        y2=y_len,
        style_class="s-blue",
        marker_end="url(#mb)",
        parent_style="top:80px; left:50%;",  # Use explicit pixel top anchor
      )

    # Fallback empty arrow
    return SvgArrow(0, 0, 0, 0, "", "", "")

  def _layout_graph(self, graph: LogicalGraph) -> List[GridBox]:
    """
    Generates list of GridBoxes with layout coordinates.
    """
    boxes = []
    ordered = topological_sort(graph)
    current_row = 2  # Row 1 is Headers
    last_blue_row = -1  # Track last operation box to link sequential arrows

    # Filter nodes visible in flow
    flow_nodes = [n for n in ordered if n.kind != "Input" and n.kind != "Output"]

    if not flow_nodes:
      # Handle empty/passthrough modules
      return []

    # Stacking Context: Decrement Z-Index to ensure top rows paint *over* bottom rows.
    # This ensures red diagonal arrows don't get hidden behind the blue box of the next row.
    current_z = 1000

    for i, node in enumerate(flow_nodes):
      is_stateful = self._is_stateful(node)

      op_row = current_row
      # If stateful, Op Box is shifted down (N+1) after Definition Box (N)
      # If functional, Op Box stays at current row (N)

      if is_stateful:
        # 1. Attribute Box (Red)
        disp_kind = self._clean_kind(node.kind)

        mem_box = GridBox(
          row=current_row,
          col=1,
          css_class="box r",
          header_text=f"{node.id}: {disp_kind}",
          code_text=self._format_args(node.metadata),
          z_index=current_z,
        )
        current_z -= 1
        mem_box.arrows.append(self._create_arrow(0, 0, "def"))
        boxes.append(mem_box)

        # Move Op to next row
        op_row = current_row + 1

      # 2. Operation Box (Blue)
      if is_stateful:
        op_label = f"Call ({node.id})"
        op_args = "args: x"
      else:
        op_label = self._clean_kind(node.kind)
        fmt_args = self._format_args(node.metadata)
        op_args = f"args: {fmt_args}" if fmt_args else "args: x"

      op_box = GridBox(
        row=op_row,
        col=2,
        css_class="box b",
        header_text=op_label,
        code_text=op_args,
        z_index=current_z,
      )
      current_z -= 1

      # Sequential Arrow (Blue)
      if i == 0:
        # First box gets Entrance Arrow from top
        op_box.arrows.append(
          SvgArrow(
            x1=0,
            y1=0,
            x2=0,
            y2=50,  # Increased overlap
            style_class="s-blue",
            marker_end="url(#mb)",
            parent_style="top:-52px; left:50%;",
          )
        )
      else:
        # Link from previous box
        if last_blue_row != -1:
          arrow = self._create_arrow(last_blue_row, op_row, "seq")
          # Append this arrow to the PREVIOUS computational box
          # We search backwards to find it
          for b in boxes:
            if b.row == last_blue_row and "box b" in b.css_class:
              b.arrows.append(arrow)
              break

      # Data Arrow (Right)
      op_box.arrows.append(self._create_arrow(0, 0, "data"))

      boxes.append(op_box)
      last_blue_row = op_row

      # 3. Data Box (Green)
      data_box = GridBox(
        row=op_row,
        col=3,
        css_class="box g",
        header_text=f"out_{node.id}",
        body_text="[_]",
        z_index=current_z,
      )
      current_z -= 1
      boxes.append(data_box)

      # Advance Row Pointer
      step = 2 if is_stateful else 1
      current_row += step

    # 4. Return Bubble
    return_row = current_row
    arrow = self._create_arrow(last_blue_row, return_row, "seq")

    if last_blue_row != -1:
      for b in boxes:
        if b.row == last_blue_row and "box b" in b.css_class:
          b.arrows.append(arrow)
          break

    return_circle = GridBox(
      row=return_row,
      col=2,
      css_class="circ",
      header_text="Return",
      z_index=current_z,
    )
    boxes.append(return_circle)

    return boxes
