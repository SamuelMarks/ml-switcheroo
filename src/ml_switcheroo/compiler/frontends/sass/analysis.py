"""
SASS Instruction Analyzer.

This module implements heuristics to extract high-level semantic parameters
(like Loop Bounds, Kernel Sizes, etc.) by analyzing the raw SASS instructions
AST generated by the parser.
"""

from typing import Any, Dict, List

from ml_switcheroo.compiler.frontends.sass.nodes import Immediate, Instruction


class SassAnalyzer:
  """
  Analyzes sequences of SASS instructions to reverse-engineer high-level parameters.
  """

  @staticmethod
  def analyze_block(kind: str, instructions: List[Instruction]) -> Dict[str, Any]:
    """
    Extracts metadata from a block of instructions based on the operation kind.

    Args:
        kind (str): The operation type (e.g. "Conv2d", "Linear").
        instructions (List[Instruction]): The assembly lines inside the block.

    Returns:
        Dict[str, Any]: Extracted parameters (e.g., {"kernel_size": 3}).
    """
    metadata = {}

    # Heuristic 1: Loop Bounds
    # Look for ISETP.LT.AND (Integer Set Predicate Less-Than)
    # Usage: ISETP.LT.AND P0, PT, Reg, Immediate, PT;
    loop_limits = []
    for inst in instructions:
      if inst.opcode == "ISETP.LT.AND":
        for op in inst.operands:
          if isinstance(op, Immediate):
            loop_limits.append(op.value)

    if not loop_limits:
      return metadata

    if kind == "Conv2d":
      # Conv2d usually has 2 spatial loops (Ky, Kx).
      # We take the max found limit as the kernel_size estimate.
      k_size = max(loop_limits)
      metadata["kernel_size"] = k_size
      metadata["arg_2"] = k_size

    elif kind == "Linear":
      # Linear usually has 1 inner dot-product loop over input features.
      if loop_limits:
        feat_dim = max(loop_limits)
        metadata["in_features"] = feat_dim
        metadata["arg_0"] = feat_dim

    return metadata
