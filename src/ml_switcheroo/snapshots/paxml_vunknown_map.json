{
  "__framework__": "paxml",
  "mappings": {
    "Abs": {
      "api": "jnp.abs"
    },
    "AdaBelief": {
      "api": "optax.adabelief",
      "requires_plugin": "optimizer_constructor"
    },
    "Adagrad": {
      "api": "optax.adagrad",
      "requires_plugin": "optimizer_constructor"
    },
    "Adam": {
      "api": "optax.adam",
      "requires_plugin": "optimizer_constructor"
    },
    "AdamW": {
      "api": "optax.adamw",
      "requires_plugin": "optimizer_constructor"
    },
    "Dropout": {
      "api": "praxis.layers.Dropout",
      "args": {
        "p": "keep_prob"
      }
    },
    "Einsum": {
      "api": "jnp.einsum",
      "requires_plugin": "einsum_normalizer"
    },
    "Embedding": {
      "api": "praxis.layers.Embedding"
    },
    "LBFGS": {
      "api": "optax.lbfgs",
      "requires_plugin": "optimizer_constructor"
    },
    "Linear": {
      "api": "praxis.layers.Linear",
      "args": {
        "bias": "use_bias",
        "in_features": "input_dims",
        "out_features": "output_dims"
      }
    },
    "RMSprop": {
      "api": "optax.rmsprop",
      "requires_plugin": "optimizer_constructor"
    },
    "SGD": {
      "api": "optax.sgd",
      "requires_plugin": "optimizer_constructor"
    },
    "Sequential": {
      "api": "praxis.layers.Sequential"
    },
    "Yogi": {
      "api": "optax.yogi",
      "requires_plugin": "optimizer_constructor"
    },
    "abs": {
      "api": "jnp.abs"
    },
    "data_ptr": {
      "api": "data",
      "requires_plugin": "method_to_property"
    },
    "permute_dims": {
      "api": "jnp.transpose",
      "pack_to_tuple": "axes"
    },
    "size": {
      "api": "shape",
      "requires_plugin": "method_to_property"
    },
    "step": {
      "requires_plugin": "optimizer_step"
    },
    "trace": {
      "api": "optax.trace"
    },
    "zero_grad": {
      "requires_plugin": "optimizer_zero_grad"
    }
  },
  "templates": {
    "convert_input": "jnp.array({np_var})",
    "fori_loop": "val = jax.lax.fori_loop({start}, {stop}, lambda i, val: {body}, {init_val})",
    "import": "import jax\nimport jax.numpy as jnp\nimport praxis.layers as pl",
    "jit_wrap": "True",
    "scan": "carry, stacked = jax.lax.scan(lambda c, x: {body}, {init}, {xs})",
    "to_numpy": "np.array({res_var})"
  }
}