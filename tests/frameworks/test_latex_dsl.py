"""
Tests for the LaTeX DSL Framework Adapter.

Verifies:
1. Registration in `_ADAPTER_REGISTRY`.
2. Protocol compliance (all methods return safe defaults).
3. Factory methods for parser/emitter exist (used by Engine).
4. Semantic Definitions (`midl` namespace) are populated correctly.
"""

from ml_switcheroo.frameworks.latex_dsl import LatexDSLAdapter
from ml_switcheroo.frameworks.base import (
  _ADAPTER_REGISTRY,
  get_adapter,
  InitMode,
  StandardCategory,
)
from ml_switcheroo.core.latex.parser import LatexParser
from ml_switcheroo.core.latex.emitter import LatexEmitter
from ml_switcheroo.enums import SemanticTier


def test_registry_integration():
  """Verify adapter is registered."""
  assert "latex_dsl" in _ADAPTER_REGISTRY
  adapter = get_adapter("latex_dsl")
  assert isinstance(adapter, LatexDSLAdapter)
  assert adapter.display_name == "LaTeX DSL (MIDL)"


def test_initialization_defaults():
  """Verify Ghost mode init."""
  adapter = LatexDSLAdapter()
  assert adapter._mode == InitMode.GHOST
  assert adapter.search_modules == []
  assert adapter.import_alias == ("midl", "midl")


def test_factories_exist():
  """
  Verify the adapter exposes the hook points for the ASTEngine.
  """
  adapter = LatexDSLAdapter()

  # Parser Hook
  parser = adapter.create_parser(r"\begin{DefModel}{T} \end{DefModel}")
  assert isinstance(parser, LatexParser)

  # Emitter Hook
  emitter = adapter.create_emitter()
  assert isinstance(emitter, LatexEmitter)


def test_definitions_exist():
  """
  Verify that definitions are populated for crucial ops.
  This ensures that when used as a SOURCE, we can pivot to the abstract standard.
  """
  adapter = LatexDSLAdapter()
  defs = adapter.definitions

  assert "Conv2d" in defs
  conv = defs["Conv2d"]
  assert conv.api == "midl.Conv2d"
  # Check argument mapping (Standard -> Framework)
  # The LatexParser generates arg_0, arg_1, etc. for positional CSV args.
  assert conv.args["in_channels"] == "arg_0"
  assert conv.args["out_channels"] == "arg_1"
  assert conv.args["kernel_size"] == "arg_2"

  assert "Linear" in defs
  lin = defs["Linear"]
  assert lin.api == "midl.Linear"
  assert lin.args["in_features"] == "arg_0"
  assert lin.args["out_features"] == "arg_1"

  assert "Flatten" in defs
  flat = defs["Flatten"]
  assert flat.api == "midl.Flatten"
  assert flat.args["start_dim"] == "arg_0"

  assert "ReLU" in defs
  assert "relu" in defs


def test_import_namespaces():
  """
  Verify that the 'midl' namespace is declared as Neural Tier.
  This ensures the ImportFixer doesn't aggressively strip it
  before we're ready, and that discovery works correctly.
  """
  adapter = LatexDSLAdapter()
  ns = adapter.import_namespaces
  assert "midl" in ns
  assert ns["midl"].tier == SemanticTier.NEURAL
  assert ns["midl"].recommended_alias == "midl"


def test_example_code_validity():
  """
  Verify the example code is valid LaTeX structure.
  """
  code = LatexDSLAdapter.get_example_code()
  assert r"\begin{DefModel}" in code
  assert r"\Attribute" in code


def test_helper_method_safety():
  """
  Verify protocol methods return safe empty values instead of raising.
  """
  adapter = LatexDSLAdapter()

  assert adapter.get_device_syntax("cuda") == ""
  assert adapter.get_rng_split_syntax("r", "k") == ""
  assert adapter.get_serialization_syntax("save", "f") == ""
  assert adapter.collect_api(StandardCategory.LAYER) == []

  snap = {}
  adapter.apply_wiring(snap)
  assert snap == {}


def test_structural_traits_for_source():
  """
  Verify traits are defined for when LaTeX is used as SOURCE.
  The rewriter needs to know what 'Module' base class generated by the Parser looks like.
  """
  adapter = LatexDSLAdapter()
  traits = adapter.structural_traits

  # Parser generates class(midl.Module). Adapter traits maps this abstract base.
  assert traits.module_base == "midl.Module"
  assert traits.forward_method == "forward"
