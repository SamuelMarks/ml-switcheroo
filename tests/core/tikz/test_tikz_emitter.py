"""
Tests for TikZ Backend (Emitter).

Verifies:
1.  **Layout Logic**: Ranks are assigned correctly, X-centering works.
2.  **CST Construction**: Metadata is correctly converted to tables.
3.  **Rendering**: Full string generation produces valid TikZ code.
4.  **Sanitization**: Underscores are escaped properly.
"""

import pytest
from ml_switcheroo.compiler.ir import LogicalGraph, LogicalNode, LogicalEdge
from ml_switcheroo.compiler.backends.extras import TikzBackend as TikzEmitter


@pytest.fixture
def simple_graph():
  """Creates A -> B -> C chain."""
  g = LogicalGraph()
  g.nodes = [
    LogicalNode("input", "Input"),
    LogicalNode("conv1", "Conv2d", {"k": "3"}),
    LogicalNode("output", "Output"),
  ]
  g.edges = [
    LogicalEdge("input", "conv1"),
    LogicalEdge("conv1", "output"),
  ]
  return g


@pytest.fixture
def branch_graph():
  """
  Creates branching graph:
      Input -> A
      Input -> B
  """
  g = LogicalGraph()
  g.nodes = [
    LogicalNode("input", "Input"),
    LogicalNode("A", "Op"),
    LogicalNode("B", "Op"),
  ]
  g.edges = [
    LogicalEdge("input", "A"),
    LogicalEdge("input", "B"),
  ]
  return g


def test_layout_linear_coords(simple_graph):
  """
  Scenario: A -> B -> C
  Expectation:
      - input at x=0, y=0.
      - conv1 at x=0, y=negative.
      - output at x=0, y=more_negative.
  """
  emitter = TikzEmitter(y_spacing=2.0)
  pos = emitter._calculate_layout(simple_graph)

  assert len(pos) == 3
  # Input is root -> Rank 0 -> Y = 0
  assert pos["input"] == (0.0, 0.0)

  # Conv1 is child -> Rank 1 -> Y = -2.0
  assert pos["conv1"] == (0.0, -2.0)

  # Output is grandchild -> Rank 2 -> Y = -4.0
  assert pos["output"] == (0.0, -4.0)


def test_layout_branch_coords(branch_graph):
  """
  Scenario: Input -> (A, B)
  Expectation:
      - Input at y=0.
      - A and B at same y (Rank 1).
      - A and B centered around x=0 (e.g., -1.5, 1.5).
  """
  emitter = TikzEmitter(x_spacing=3.0)
  pos = emitter._calculate_layout(branch_graph)

  # Input centered
  assert pos["input"][0] == 0.0
  assert pos["input"][1] == 0.0

  # A and B at Rank 1 (y negative)
  ay = pos["A"][1]
  by = pos["B"][1]
  assert ay == by
  assert ay < 0

  # A and B spread on X
  ax = pos["A"][0]
  bx = pos["B"][0]
  assert ax != bx
  # One should be -1.5, one 1.5 (order depends on dict iter, simplified here)
  assert abs(abs(ax) - 1.5) < 1e-5
  assert abs(abs(bx) - 1.5) < 1e-5


def test_tikz_node_content_generation():
  """
  Verify metadata conversion to Latex table logic and Sanitization.
  """
  emitter = TikzEmitter()
  # Use underscores in keys/values/kinds to test sanitization
  node = LogicalNode("layer_1", "Conv_2d", {"kernel_size": "3_3", "stride": "1"})

  tikz_node = emitter._create_tikz_node(node, 0, 0)
  rendered = tikz_node.to_text()

  assert r"\node" in rendered
  # Check Styling
  assert "fill=blue!5" in rendered

  # Check Table Content with escaped underscores
  assert r"\textbf{Conv\_2d}" in rendered
  assert r"\textit{layer\_1}" in rendered
  assert r"kernel\_size: 3\_3" in rendered
  assert r"stride: 1" in rendered


def test_tikz_edge_generation():
  """Verify arrow style uses standard options (-> vs --)."""
  emitter = TikzEmitter()
  edge = LogicalEdge("a", "b")
  tikz_edge = emitter._create_tikz_edge(edge)
  rendered = tikz_edge.to_text()

  assert r"\draw" in rendered
  assert "(a) -- (b);" in rendered
  assert "->" in rendered  # Arrow option


def test_full_emission_is_valid_latex(simple_graph):
  """
  Integration: Check full wrapper block generation including global options.
  """
  emitter = TikzEmitter()
  # Updated: call compile instead of emit
  latex = emitter.compile(simple_graph)

  assert r"\begin{tikzpicture}" in latex
  assert ">=stealth" in latex
  assert r"\end{tikzpicture}" in latex
  assert "% Generated by ml-switcheroo" in latex

  # Verify content presence
  assert "(input)" in latex
  assert "(conv1)" in latex
  assert "(output)" in latex


def test_handle_island_nodes():
  """
  Scenario: Disconnected node (No edges).
  Expectation: Placed at rank below main graph (fallback logic).
  """
  g = LogicalGraph()
  g.nodes = [LogicalNode("root", "A"), LogicalNode("island", "B")]
  # No edges

  emitter = TikzEmitter(x_spacing=3.0)
  pos = emitter._calculate_layout(g)

  assert pos["root"][1] == 0.0
  assert pos["island"][1] == 0.0
  assert abs(pos["root"][0] - pos["island"][0]) == 3.0
